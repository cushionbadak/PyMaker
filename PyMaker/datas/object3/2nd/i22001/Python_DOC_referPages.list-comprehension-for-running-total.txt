Natural Text
I want to get a running total from a list of numbers.For demo purposes, I start with a sequential list of numbers using yieldsAs you can see, I initialize an empty list , then  in each loop iteration. Is there a more elegant way to this, like a list comprehension?
A list comprehension has no good (clean, portable) way to refer to the very list it's building. One good and elegant approach might be to do the job in a generator:to get this as a list instead, of course, use .
If you can use numpy, it has a built-in function named  that does this.
This can be implemented in 2 lines in Python.Using a default parameter eliminates the need to maintain an aux variable outside, and then we just do a  to the list.
I'm not sure about 'elegant', but I think the following is much simpler and more intuitive (at the cost of an extra variable):The functional way to do the same thing is:...but that's much less readable/maintainable, etc.@Omnifarous suggests this should be improved to:...but I still find that less immediately comprehensible than my initial suggestion.Remember the words of Kernighan: "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."
When we take the sum of a list, we designate an accumulator () and then walk through the list, applying the binary function "x+y" to each element and the accumulator. Procedurally, this looks like:This is a common pattern, and useful for things other than taking sums — we can generalize it to any binary function, which we'll supply as a parameter, and also let the caller specify an initial value. This gives us a function known as , , or [1]:In Python 2,  was a built-in function, but in Python 3 it's been moved to the  module:We can do all kinds of cool stuff with  depending on the function we supply as its the first argument. If we replace "sum" with "list concatenation", and "zero" with "empty list", we get the (shallow)  function:If we add a  function as another parameter to , and apply it before concatenating, we get :If we add a  function that takes  as a parameter and returns a boolean, and use it to decide whether or not to concatenate, we get : and  are sort of unfancy ways of writing list comprehensions — we could also have said  or . There's no corresponding list comprehension syntax for , because  isn't required to return a list at all (as we saw with , earlier, which Python also happens to offer as a built-in function).It turns out that for computing a running sum, the list-building abilities of  are exactly what we want, and probably the most elegant way to solve this problem, despite its reputation (along with ) as something of an un-pythonic shibboleth. The version of  that leaves behind copies of its old values as it runs is called  or [1], and it looks like this:So equipped, we can now define:While conceptually elegant, this precise approach fares poorly in practice with Python. Because Python's  mutates a list in place but doesn't return it, we can't use it effectively in a lambda, and have to use the  operator instead. This constructs a whole new list, which takes time proportional to the length of the accumulated list so far (that is, an O(n) operation). Since we're already inside the O(n)  loop of  when we do this, the overall time complexity compounds to O(n2).In a language like Ruby[2], where  returns the mutated , the equivalent runs in O(n) time:same in JavaScript[2], whose  returns  (not ), but whose anonymous functions allow us to include multiple statements, which we can use to separately specify a return value:So, how can we solve this while retaining the conceptual simplicity of a  function that we just pass  to in order to create the running sum function? Let's rewrite  procedurally. We can fix the accidentally quadratic problem, and while we're at it, pre-allocate the result list to avoid heap thrashing[3]:This is the sweet spot for me: O(n) performance, and the optimized procedural code is tucked away under a meaningful name where it can be re-used the next time you need to write a function that accumulates intermediate values into a list.The names / come from the LISP tradition, / from the ML tradition, and  from the Smalltalk tradition.
Use . Here is an example:This only works on Python 3. On Python 2 you can use the backport in the more-itertools package.
I wanted to do the same thing to generate cumulative frequencies that I could use bisect_left over - this is the way I've generated the list;
Here's a linear time solution one liner:Example:In short, the reduce goes over the list accumulating sum and constructing an list. The final  returns the list,  would be the running total value.
Another one-liner, in linear time and space.I'm stressing linear space here, because most of the one-liners I saw in the other proposed answers --- those based on the pattern  or using  iterators --- generate O(n) lists or generators and stress the garbage collector so much that they perform very poorly, in comparison to this.
I would use a coroutine for this:
You are looking for two things: fold (reduce) and a funny function that keeps a list of the results of another function, which I have called running. I made versions both with and without an initial parameter; either way these need to go to reduce with an initial [].These will take a long time on really large lists due to the + operator. In a functional language, if done correctly, this list construction would be O(n).Here are the first few lines of output:
This is inefficient as it does it every time from beginning but possible it is:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.accumulate
