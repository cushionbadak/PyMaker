Natural Text
In Python, consider I have the following code:How do I initialize the  in the subclass? I am following the Python tutorial and it doesn't cover that. When I searched on Google, I found more than one way of doing. What is the standard way of handling this?
Python (until version 3) supports "old-style" and new-style classes. New-style classes are derived from  and are what you are using, and invoke their base class through , e.g.Because python knows about old- and new-style classes, there are different ways to invoke a base method, which is why you've found multiple ways of doing so.For completeness sake, old-style classes call base methods explicitly using the base class, i.e.But since you shouldn't be using old-style anymore, I wouldn't care about this too much.Python 3 only knows about new-style classes (no matter if you derive from  or not).
Bothorwill work (I prefer the 2nd one, as it adheres more to the DRY principle).See here: http://docs.python.org/reference/datamodel.html#basic-customization
As of python 3.5.2, you can use:https://docs.python.org/3/library/functions.html#super
How do I initialize the base (super) class?Use a  object to ensure you get the next method (as a bound method) in the method resolution order. In Python 2, you need to pass the class name and  to super to lookup the bound  method:In Python 3, there's a little magic that makes the arguments to  unnecessary - and as a side benefit it works a little faster:Hardcoding the parent like this below prevents you from using cooperative multiple inheritance:Note that  may only return  - it is intended to modify the object in-place.Something There's another way to initialize instances - and it's the only way for subclasses of immutable types in Python. So it's required if you want to subclass  or  or another immutable object.You might think it's a classmethod because it gets an implicit class argument. But it's actually a staticmethod. So you need to call  with  explicitly.We usually return the instance from , so if you do, you also need to call your base's  via  as well in your base class. So if you use both methods:Python 3 sidesteps a little of the weirdness of the super calls caused by  being a static method, but you still need to pass  to the non-bound  method:


Answer URL
https://docs.python.org/3/library/functions.html#super
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/reference/datamodel.html#object.__new__
