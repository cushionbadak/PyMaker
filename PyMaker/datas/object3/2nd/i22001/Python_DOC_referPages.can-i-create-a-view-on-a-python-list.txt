Natural Text
I have a large list . I want to create a view from element 4 to 6. I can do it with sequence slice.However lv is copy of a slice of l. If I change the underlying list, lv does not reflect the change.Vice versa I want modification on lv reflect in l as well. Other than that the list size are not going to be changed.I'm not look forward to build a big class to do this. I'm just hoping other Python gurus may know some hidden language trick. Ideally I hope it can like pointer arithmetic in C.
There is no "list slice" class in the Python standard library (nor is one built-in).  So, you do need a class, though it need not be big -- especially if you're content with a "readonly" and "compact" slice.  E.g.:This has some limitations (doesn't support "slicing a slice") but for most purposes might be OK.To make this sequence r/w you need to add , , and :
Perhaps just use a numpy array:Basic slicing numpy arrays returns a view, not a copy:Altering  affects :And altering  affects :
You can do that by creating your own generator using the original list reference.However this being a generator, you can only go through the list once, forwards and it will explode if you remove more elements than you requested with .
https://gist.github.com/mathieucaroff/0cf094325fb5294fb54c6a577f05a2c1Above link is a solution based on python 3 range ability to be sliced andindexed in constant time.It supports slicing, equality comparsion, string casting (), andreproducers (), but doesn't support assigment.Creating a SliceableSequenceView of a SliceableSequenceView won't slow downaccess times as this case is detected.sequenceView.py
Edit:  - so no, sadly.I think buffer type is what you are looking for.Pasting example from linked page:
As soon as you will take a slice from a list, you will be creating a new list. Ok, it will contain same objects so as long as objects of the list are concerned it would be the same, but if you modify a slice the original list is unchanged.If you really want to create a modifiable view, you could imagine a new class based on This could be a starting point for a full featured sub list - it correctly processes slice indexes, but at least is lacking specification for negative indexes processing:Example:
If you are going to be accessing the "view" sequentially then you can just use itertools.islice(..)You can see the documentation for more info.You can't access individual elements to change them in the slice and if you do change the list you have to re-call isclice(..).
Subclass the  to affect views by mutating sequences and vice versa.CodeDemo is a third-party library.  Install via .
You could edit: not do something likeBeing essentially a one-liner, it's not very Pythonic, but that's the basic gist.edit: I've belatedly realized that this doesn't work because  will essentially do a shallow copy of the list it's passed.  So this will end up being more or less the same as just slicing the list.  Actually less, due to a missing override of .  You'll need to use a proxy class; see Mr. Martelli's answer for the details.


Answer URL
https://docs.python.org/3/c-api/buffer.html
