Natural Text
Say I want to make a decorator for methods defined in a class. I want that decorator, when invoked, to be able to set an attribute on the class defining the method (in order to register it in a list of methods that serve a particular purpose).In Python 2, the  method accomplishes this nicely:However, in Python 3, no such attribute (or a  replacement for it) seems to exist. I suppose the idea was that you could call  to get the class, but this does not work for unbound methods, since  in that case.NOTE: This question is actually a bit irrelevant for my case, since I've chosen instead to set an attribute on the method itself and then have the instance scan through all of its methods looking for that attribute at the appropriate time. I am also (currently) using Python 2.6. However, I am curious if there is any replacement for the version 2 functionality, and if not, what the rationale was for removing it completely.EDIT: I just found this question. This makes it seem like the best solution is just to avoid it like I have. I'm still wondering why it was removed though.
The point you appear to be missing is, in Python 3 the "unbound method" type has entirely disappeared -- a method, until and unless it's bound, is just a function, without the weird "type-checking" unbound methods used to perform.  This makes the language simpler!To wit...:and voila -- one less subtle concept and distinction to worry about.  Such simplifications are the core advantage of Python 3 wrt Python 2, which (over the years) had been accumulating so many subtleties that it was in danger (if features kept being added to it) of really losing its status as a simple language.  With Python 3, simplicity is back!-)
I thought it would be worthwhile writing something that does it best at guessing the defining class. For completeness' sake this answer also addresses bound methods.At worst, guessing should fail altogether, with the function returning . However, under any circumstances, it shouldn't raise an exception or return an incorrect class.TL;DRThe final version of our function successfully overcomes most simple cases, and a few pitfalls as well.In a nutshell, its implementation differentiates between bound methods and “unbound methods“ (functions) since in  there is no reliable way to extract the enclosing class from an “unbound method".For a bound method, it simply traverses the , in a similar manner to that done in the accepted answer to an equivalent question for .For an “unbound method“, it relies on parsing its qualified name, which is available only from  and is quite reckless (if this feature is unnecessary it's probably best to remove this block of code and just return  instead).There is also partial handling for methods defined via descriptors, that aren't classified as ordinary methods or functions (for example, ,  and  but not ).The resulting function is:A small requestIf you decide to use this implementation, and encounter any caveats, please comment and describe what happened.The Full Version“Unbound methods” are regular functionsFirst of all, it's worth noting the following change made in  (see Guido's motivation here):The concept of “unbound methods” has been removed from the language. When referencing a method as a class attribute, you now get a plain function object.This makes it practically impossible to reliably extract the class in which a certain “unbound method“ was defined unless it's bound to an object of that class (or of one of its subclasses).Handling bound methodsSo, let us first handle the “easier case“ in which we have a bound method. Note that the bound method must be written in , as described in 's documentation.However, this solution is not perfect and has its perils, as methods can be assigned in runtime, rendering their name possibly different than that of the attribute that they are assigned to (see example below). This problem exists also in . A possible workaround would be to iterate over all of the class's attributes, looking for one whose identity is that of the specified method.Handling “unbound methods“Now that we got that out of the way, we can suggest a hack that tries to handle “unbound methods”. The hack, its rationale, and some discouragement words can be found in this answer. It relies on manually parsing the  attribute, available only from , is highly unrecommended, but should work for simple cases:Combining both approachesSince  and  are mutually exclusive, combining both approaches into a single solution gives us the following (with added logging facilities for the upcoming examples):Execution exampleSo far, so good, but...Final touchesThe outcome generated by  can be partially fixed (to return ) by verifying that the returned value is a class, before actually returning it.The outcome generated by  can be fixed by falling back to parsing the function's  attribute (the function can be extracted via ).The outcome generated by  and  is incorrect because accessing a class method always returns a bound method, whose  attribute is the class itself, rather than its object. Thus, further accessing the  attribute on top of that  attribute doesn't work as expected:This can be fixed by checking whether the method's  attribute returns an instance of . However, this might be confusing when our function is invoked against methods of a metaclass, so we'll leave it as is for now.Here is the final version:Surprisingly, this also fixes the outcome of  and  which now correctly return . This is because the  attribute of a class method returns a regular function whose  attribute may be parsed:EDIT:As per the issue raised by Bryce, it's possible to handle  objects, like , and  objects, like , merely by returning their  attribute (introduced by PEP-252), if such exists:However,  returns  for the respective instance method objects, i.e. for  and for :Since  returns , the above if clause may be relinquished in order to solve the problem for . Unfortunately, this doesn't address the matter of , for which no  attribute is defined. In order to avoid an  exception in such a case, the  attribute isn't accessed directly, but rather via the  function.
Since python 3.6 you could accomplish what you are describing using a decorator that defines a  method. The documentation states that  is called when the class is being created.Here is an example that decorates a method "in order to register it in a list of methods that serve a particular purpose":Note that this question is very similar to Can a Python decorator of an instance method access the class? and therefore my answer as well to the answer I provided there.
A small extension for python 3.6 (python 2.7 worked fine) to the great answer of https://stackoverflow.com/a/25959545/4013571I found the following adjustment was required for As for some reason, when using  the  didn't contain the defining class


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.ismethod
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/reference/datamodel.html#object.__set_name__
