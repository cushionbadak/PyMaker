Natural Text
I like to write a template system in Python, which allows to include files.e.g.As you know, including files might be dangerous. For example, if I use the template system in a web application which allows users to create their own templates, they might do something likeSo therefore, I have to restrict the inclusion of files to files which are for example in a certain subdirectory (e.g. )The question is now: How can I check, whether  is in a subdirectory of ?Would the following code work and be secure?As long, as  is False, it should be secure, I think. Allowing symlinks of course would make it insecure if the user is able to create such links.UPDATE - SolutionThe code above does not work, if intermediate directories are symbolic links.To prevent this, you have to use  instead of .UPDATE: adding a trailing / to directory to solve the problem with commonprefix() Reorx pointed out.This also makes  unnecessary as symlinks are expanded to their real destination   
os.path.realpath(path): Return the canonical path of the specified filename, eliminating any symbolic links encountered in the path (if they are supported by the operating system).Use it on directory and subdirectory name, then check latter starts with former.
Python 3's  module makes this straightforward with its Path.parents attribute. For example:Then:

Problems with many of the suggested methodsIf you're going to test for directory parentage with string comparison or  methods, these are prone to errors with similarly-named paths or relative paths. For example: would be shown as a child path of  using many of the methods. would not be shown as a parent of  by many of the methods. In fact, it is.The previous answer by Rob Dennis provides a good way to compare path parentage without encountering these problems. Python 3.4 added the  module which can perform these kind of path operations in a more sophisticated way, optionally without referencing the underlying OS. jme has described in another previous answer how to use  for the purpose of accurately determining if one path is a child of another. If you prefer not to use  (not sure why, it's pretty great) then Python 3.5 introduced a new OS-based method in  that allows you to do perform path parent-child checks in a similarly accurate and error-free manner with a lot less code.New for Python 3.5Python 3.5 introduced the function . This is a method that is specific to the OS that the code is running on. You can use  in the following way to accurately determine path parentage:Accurate one-linerYou can combine the whole lot into a one-line if statement in Python 3.5. It's ugly, it includes unnecessary duplicate calls to  and it definitely won't fit in the PEP 8 79-character line-length guidelines, but if you like that kind of thing, here goes:
so, I needed this, and due to the criticisms about commonprefx, I went a different way:

I like the "path in other_path.parents" approached mentioned in another answer because I'm a big fan of pathlib, BUT I feel that approach is a bit heavy (it creates one Path instance for each parent to root of path). Also the case where path == other_path will fail with that approach, whereas os.commonpath would succeed on that case. The following is a different approach, with its own set of pros and cons compared to other methods identified in the various answers:which is a little more verbose but can easily be added as a function in your application's common utilities module or even add the method to Path at startup time. 
I would test the result from commonprefix against the filename to get a better answer, something like this:
Based on another answer here, with correction, and with a user-friendlier name:


Answer URL
https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parents
