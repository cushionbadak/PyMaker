Natural Text
This question already has an answer here:How to get Python to gracefully format None and non-existing fields [duplicate]                    3 answers                Is there a way to use python string.format such that no exception is thrown when an index is missing, instead an empty string is inserted.here,result should be :Right now, python throws a keyerror and stops formatting. Is it possible to change this behavior ?ThanksEdit: There exists Template.safe_substitute (even that leaves the pattern intact instead of inserting an empty string) , but couldn't something similar for string.formatThe desired behavior would be similar to string substitution in php.This seems to provide the desired behavior.
 doesn't expect a mapping object. Try this:You make a defaultdict with a  factory that returns "". Then you make one key for the defaultdict. In the format string, you access keys of the first object passed. This has the advantage of allowing you to pass other keys and values, as long as your defaultdict is the first argument to .Also, see http://bugs.python.org/issue6081
The official solution (Python 3 Docs) for strings in format mappings is to subclass the  class and to define the magic-method . This method is called whenever a key is missing, and what it returns is used for the string formatting instead:Edit: the second print() works in Python 3.5.3, but it does not in e.g. 3.7.2:  is raised and I couldn't find a way to catch it.After some experiments, I found a difference in Python's behavior. In v3.5.3, the calls are  which succeeds and  which can not find the key , therefore it calls  to handle the missing key without throwing a KeyError. In v3.7.2,  is called internally. The built-in  method is used to return an iterator over the keys, which yields "foo",  succeeds, then the iterator is exhausted. For  from the format string there is no key .  and hence  are not called to handle the situation. Instead, the KeyError is thrown. I don't know how one could catch it, if at all.In Python 3.2+ you should use  instead (also see Python Bug Tracker - Issue 6081):If you want to keep the placeholders, you can do:As you can see,  does call .The following appears to be the most compatible solution as it also works in older Python versions including 2.x (I tested v2.7.15):
Unfortunately, no, there is no such way to do by default. However you can provide it defaultdict or object with overridden , and use like this:
I made a version that does work similarly to Daniel's method but without the {0.x} attribute access.prints out


Answer URL
