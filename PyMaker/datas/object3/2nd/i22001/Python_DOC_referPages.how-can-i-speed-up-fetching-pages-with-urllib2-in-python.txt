Natural Text
I have a script that fetches several web pages and parses the info.(An example can be seen at http://bluedevilbooks.com/search/?DEPT=MATH&CLASS=103&SEC=01 )I ran cProfile on it, and as I assumed, urlopen takes up a lot of time. Is there a way to fetch the pages faster? Or a way to fetch several pages at once? I'll do whatever is simplest, as I'm new to python and web developing.Thanks in advance! :)UPDATE: I have a function called , which I use to make an array of the URLs I needso something like .The URLS are all XML files from Amazon and eBay APIs (which confuses me as to why it takes so long to load, maybe my webhost is slow?)What I need to do is load each URL, read each page, and send that data to another part of the script which will parse and display the data.Note that I can't do the latter part until ALL of the pages have been fetched, that's what my issue is.Also, my host limits me to 25 processes at a time, I believe, so whatever is easiest on the server would be nice :)Here it is for time:
EDIT: I'm expanding the answer to include a more polished example. I have found a lot hostility and misinformation in this post regarding threading v.s. async I/O. Therefore I also adding more argument to refute certain invalid claim. I hope this will help people to choose the right tool for the right job.This is a dup to a question 3 days ago.Python urllib2.open is slow, need a better way to read several urls - Stack Overflow  Python urllib2.urlopen() is slow, need a better way to read several urlsI'm polishing the code to show how to fetch multiple webpage in parallel using threads.As you can see, the application specific code has only 3 lines, which can be collapsed into 1 line if you are aggressive. I don't think anyone can justify their claim that this is complex and unmaintainable. Unfortunately most other threading code posted here has some flaws. Many of them do active polling to wait for the code to finish.  is a better way to synchronize the code. I think this code has improved upon all the threading examples so far.keep-alive connectionWoLpH's suggestion about using keep-alive connection could be very useful if all you URLs are pointing to the same server.twistedAaron Gallagher is a fans of  framework and he is hostile any people who suggest thread. Unfortunately a lot of his claims are misinformation. For example he said "-1 for suggesting threads. This is IO-bound; threads are useless here." This contrary to evidence as both Nick T and I have demonstrated speed gain from the using thread. In fact I/O bound application has the most to gain from using Python's thread (v.s. no gain in CPU bound application). Aaron's misguided criticism on thread shows he is rather confused about parallel programming in general.Right tool for the right jobI'm well aware of the issues pertain to parallel programming using threads, python, async I/O and so on. Each tool has their pros and cons. For each situation there is an appropriate tool. I'm not against twisted (though I have not deployed one myself). But I don't believe we can flat out say that thread is BAD and twisted is GOOD in all situations.For example, if the OP's requirement is to fetch 10,000 website in parallel, async I/O will be prefereable. Threading won't be appropriable (unless maybe with stackless Python).Aaron's opposition to threads are mostly generalizations. He fail to recognize that this is a trivial parallelization task. Each task is independent and do not share resources. So most of his attack do not apply.Given my code has no external dependency, I'll call it right tool for the right job.PerformanceI think most people would agree that performance of this task is largely depend on the networking code and the external server, where the performance of platform code should have negligible effect. However Aaron's benchmark show an 50% speed gain over the threaded code. I think it is necessary to response to this apparent speed gain.In Nick's code, there is an obvious flaw that caused the inefficiency. But how do you explain the 233ms speed gain over my code? I think even twisted fans will refrain from jumping into conclusion to attribute this to the efficiency of twisted. There are, after all, a huge amount of variable outside of the system code, like the remote server's performance, network, caching, and difference implementation between urllib2 and twisted web client and so on.Just to make sure Python's threading will not incur a huge amount of inefficiency, I do a quick benchmark to spawn 5 threads and then 500 threads. I am quite comfortable to say the overhead of spawning 5 thread is negligible and cannot explain the 233ms speed difference.Further testing on my parallel fetching shows a huge variability in the response time in 17 runs. (Unfortunately I don't have twisted to verify Aaron's code).My testing does not support Aaron's conclusion that threading is consistently slower than async I/O by a measurable margin. Given the number of variables involved, I have to say this is not a valid test to measure the systematic performance difference between async I/O and threading.
Use twisted! It makes this kind of thing absurdly easy compared to, say, using threads.This code also performs better than any of the other solutions posted (edited after I closed some things that were using a lot of bandwidth):And using Nick T's code, rigged up to also give the average of five and show the output better: And using Wai Yip Tung's code:I've gotta say, I do like that the sequential fetches performed better for me.
Here is an example using python . The other threaded examples here launch a thread per url, which is not very friendly behaviour if it causes too many hits for the server to handle (for example it is common for spiders to have many urls on the same host)Note: The times given here are for 40 urls and will depend a lot on the speed of your internet connection and the latency to the server. Being in Australia, my ping is > 300msWith  it took 86 seconds to runWith  it took 23 seconds to runwith  it took 10 seconds to run  so having 10 threads downloading is 8.6 times as fast as a single thread.Here is an upgraded version that uses a Queue. There are at least a couple of advantages.1. The urls are requested in the order that they appear in the list2. Can use  to detect when the requests have all completed3. The results are kept in the same order as the url list
The actual wait is probably not in  but in the server and/or your network connection to the server.There are 2 ways of speeding this up.Keep the connection alive (see this question on how to do that: Python urllib2 with keep alive)Use multiplle connections, you can use threads or an async approach as Aaron Gallagher suggested. For that, simply use any threading example and you should do fine :) You can also use the  lib to make things pretty easy.
Most of the answers focused on fetching multiple pages from different servers at the same time(threading) but not on reusing already open HTTP connection. If OP is making multiple request to the same server/site. In urlib2 a separate connection is created with each request which impacts performance and and as a result  slower rate of fetching pages. urllib3 solves this problem by using a connection pool. Can read more here urllib3  [Also thread-safe]There is also Requests an HTTP library that uses urllib3 This combined with threading should increase the speed of fetching pages 
Nowadays there is excellent Python lib that do this for you called requests.Use standard api of requests if you want solution based on threads or async api (using gevent under the hood) if you want solution based on non-blocking IO.
Since this question was posted it looks like there's a higher level abstraction available, :https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-exampleThe example from there pasted here for convenience:There's also  which I think makes the code easier: https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
Ray offers an elegant way to do this (in both Python 2 and Python 3). Ray is a library for writing parallel and distributed Python.Simply define the  function with the  decorator. Then you can fetch a URL in the background by calling .If you also want to process the webpages in parallel, you can either put the processing code directly into , or you can define a new remote function and compose them together.If you have a very long list of URLs that you want to fetch, you may wish to issue some tasks and then process them in the order that they complete. You can do this using .View the Ray documentation.
Fetching webpages obviously will take a while as you're not accessing anything local.  If you have several to access, you could use the  module to run a couple at once.Here's a very crude exampleThis was the output when I ran it:Grabbing the data from the thread by appending to a list is probably ill-advised (Queue would be better) but it illustrates that there is a difference.
Here's a standard library solution. It's not quite as fast, but it uses less memory than the threaded solutions.Also, if most of your requests are to the same host, then reusing the same http connection would probably help more than doing things in parallel.
Please find Python network benchmark script for single connection slowness identification:And example of results with Python 3.6:Python 2.7.13 has very similar results.In this case, DNS and urlopen slowness are easily identified.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
