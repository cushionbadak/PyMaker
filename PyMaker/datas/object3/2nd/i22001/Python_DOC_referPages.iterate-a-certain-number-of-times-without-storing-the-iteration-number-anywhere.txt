Natural Text
This question already has an answer here:Is it possible to implement a Python for range loop without an iterator variable?                    15 answers                I was wondering if it is possible to perform a certain number of operations without storing the loop iteration number anywhere.For instance, let's say I want to print two  messages to the console. Right now I know I can do:but then the  variable is going to take the values  and  (which I don't really need). Is there a way to achieve the same thing without storing those unwanted values anywhere?
The idiom (shared by quite a few other languages) for an unused variable is a single underscore . Code analysers typically won't complain about  being unused, and programmers will instantly know it's a shortcut for . There is no way to iterate without having an item variable - as the Zen of Python puts it, "special cases aren't special enough to break the rules".
should work, but I'm kind of ashamed that I thought of it.Update:  Just thought of another one:
Well I think the forloop you've provided in the question is about as good as it gets, but I want to point out that unused variables that have to be assigned can be assigned to the variable named , a convention for "discarding" the value assigned. Though the  reference will hold the value you gave it, code linters and other developers will understand you aren't using that reference. So here's an example:
Others have addressed the inability to completely avoid an iteration variable in a  loop, but there are options to reduce the work a tiny amount.  has to generate a whole bunch of numbers after all, which involves a tiny amount of work; if you want to avoid even that, you can use  to just get the same (ignored) value back over and over, which involves no creation/retrieval of different objects:This will run faster in microbenchmarks than , but if the loop body does meaningful work, it's a drop in the bucket. And unlike multiplying some anonymous sequence for your loop iterable,  has only a trivial setup cost, with no memory overhead dependent on length.
Although I agree completely with delnan's answer, it's not impossible:Note, however, that this will not work for an arbitrary list: If the first value in the list (the last one popped) does not evaluate to , you will get another iteration and an exception on the next pass: . Also, your list () will be empty after the loop.Just for curiosity's sake. ;)
This will print 'hello' 3 times without storing ...
You can simply do print 2*'hello'
It's not idiomatic Python, but neither is what you're trying to do.
Sorry, but in order to iterate over anything in any language, Python and English included, an index must be stored. Be it in a variable or not. Finding a way to obscure the fact that python is internally tracking the for loop won't change the fact that it is. I'd recommend just leaving it as is.
It turns out that using dummy* (starting word is dummy) as a variable do the same trick as _. But you don't mess with already defined and sometimes used variable or a function. 


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.repeat
