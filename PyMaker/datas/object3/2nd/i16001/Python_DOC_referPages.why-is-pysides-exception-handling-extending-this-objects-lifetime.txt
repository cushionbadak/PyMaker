Natural Text
tl;dr -- In a PySide application, an object whose method throws an exception will remain alive even when all other references have been deleted. Why? And what, if anything, should one do about this?In the course of building a simple CRUDish app using a Model-View-Presenter architecture with a PySide GUI, I discovered some curious behavior. In my case:The interface is divided into multiple Views -- i.e., each tab page displaying a different aspect of data might be its own class of ViewViews are instantiated first, and in their initialization, they instantiate their own Presenter, keeping a normal reference to itA Presenter receives a reference to the View it drives, but stores this as a weak reference () to avoid circularityNo other strong references to a Presenter exist. (Presenters can communicate indirectly with the  messaging library, but this also stores only weak references to listeners, and is not a factor in the MCVE below.)Thus, in normal operation, when a View is deleted (e.g., when a tab is closed), its Presenter is subsequently deleted as its reference count becomes 0However, a Presenter of which a method has thrown an exception does not get deleted as expected. The application continues to function, because PySide employs some magic to catch exceptions. The Presenter in question continues to receive and respond to any View events bound to it. But when the View is deleted, the exception-throwing Presenter remains alive until the whole application is closed. An MCVE (link for readability):Open and close the inner view, and you'll see both view and presenter are deleted as expected. Open the inner view, click the button to trigger an exception on the presenter, then close the inner view. The view will be deleted, but the presenter won't until the application exits.Why? Presumably whatever it is that catches all exceptions on behalf of PySide is storing a reference to the object that threw it. Why would it need to do that?How should I proceed (aside from writing code that never causes exceptions, of course)? I have enough sense not to rely on  for resource management. I get that I have no right to expect anything subsequent to a caught-but-not-really-handled exception to go ideally but this just strikes me as unnecessarily ugly. How should I approach this in general?
The problem is  and .When a traceback is raised interactively, and this seems to be what is emulated, the last exception and its traceback are stores in  and  respectively.Doingwill free the memory.It's worth noting that at most one exception and traceback pair can get cached. This means that, because you're sane and don't rely on , there isn't a massive amount of damage to be done.But if you want to reclaim the memory, just delete those values.  


Answer URL
