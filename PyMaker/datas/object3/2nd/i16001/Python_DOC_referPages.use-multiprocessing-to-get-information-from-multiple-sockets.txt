Natural Text
I'm working on developing a little irc client in python (ver 2.7).  I had hoped to use multiprocessing to read from all servers I'm currently connected to, but I'm running into an issueWhenever it hits the line  I get the errorFrom what I've read this is what happens when I try to pickle something that isn't picklable.  To resolve this I first made the  and  as described here.  Then I realized that I was (originally) trying to pass  a list of sockets (very not picklable) so I changed it to the list of hostnames, as strings can be pickled.  I still get this error, however.I then tried calling  directly on , , and .  As expected it worked fine for the latter two, but from the first I getSome more research lead me to this question, which seems to indicate that the issue is with the use of sockets (and gnibbler's answer to that question would seem to confirm it).Is there a way that I can actually use multiprocessing for this?  From what I've (very briefly) read  might be what I need, but I'd really like to stick to the standard library if at all possible.I'm also not set on using multiprocessing - if multithreading would work better and avoid this issue then I'm more than open to those solutions.
Your root problem is that you can't pass sockets to child processes. The easy solution is to use threads instead.In more detail:Pickling a bound method requires pickling three things: the function name, the object, and the class. (I think  does this for you automatically, but you're doing it manually; that's fine.) To pickle the object, you have to pickle its members, which in your case includes a dict whose values are sockets.You can't pickle sockets with the default pickling protocol in Python 2.x. The answer to the question you linked explains why, and provides the simple workaround: don't use the default pickling protocol. But there's an additional problem with ; it's just a wrapper around a type defined in a C extension module, which has its own problems with pickling. You might be able to work around that as well…But that still isn't going to help. Under the covers, that C extension class is itself just a wrapper around a file descriptor. A file descriptor is just a number. Your operating system keeps a mapping of file descriptors to open sockets (and files and pipes and so on) for each process; file #4 in one process isn't file #4 in another process. So, you need to actually migrate the socket's file descriptor to the child at the OS level. This is not a simple thing to do, and it's different on every platform. And, of course, on top of migrating the file descriptor, you'll also have to pass enough information to re-construct the  object. All of this is doable; there might even be a library that wraps it up for you. But it's not easy.One alternate possibility is to open all of the sockets before launching any of the children, and set them to be inherited by the children. But, even if you could redesign your code to do things that way, this only works on POSIX systems, not on Windows.A much simpler possibility is to just use threads instead of processes. If you're doing CPU-bound work, threads have problems in Python (well, CPython, the implementation you're almost certainly using) because there's a global interpreter lock that prevents two threads from interpreting code at the same time. But when your threads spend all their time waiting on  and similar I/O calls, there is no problem using threads. And they avoid all the overhead and complexity of pickling data and migrating sockets and so forth.You may notice that the  module doesn't have a nice  class like  does. Surprisingly, however, there is a thread pool class in the stdlib—it's just in . You can access it as .If you're willing to go beyond the stdlib, the  module from Python 3 has a backport  named  that you can install off PyPI. It includes a  which is a slightly higher-level abstraction around a pool which may be simpler to use. But  should also work fine for you here, and you've already written the code.
If you do want to try jumping out of the standard library, then the following code for  (as you mention) should not throw pickling errors, as the  serializer knows how to serialize sockets and file handles.One issue however is that you need serialization with , and in many cases the sockets will serialize so that the deserialized socket is closed.  The reason is primarily because the file descriptor isn't copied as expected, it's copied by reference.  With  you can customize the serialization of file handles, so that the content does get transferred as opposed to using a reference… however, this doesn't translate well for a socket (at least at the moment).I'm the  and  author, and I'd have to agree with @abarnert that you probably don't want to do this with  (at least not storing a map of servers and sockets).  If you want to use  threading interface, and you find you run into any serialization concerns,  does have  instead of , so that you can access a wrapper around , but still get the additional features that  provides (such as multi-argument pools for blocking or asynchronous pipes and maps, etc).


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
