Natural Text
I have a wxPython GUI, and would like to use multiprocessing to create a separate process which uses PyAudio.  That is, I want to use PyAudio, wxPython, and the multiprocessing module, but although I can use any two of these, I can't use all three together.  Specifically, if from one file I import wx, and create a  which opens PyAudio, PyAudio won't open.  Here's an example:file: A.pyfile: B.pyIn all my tests I see  print, but the problem is that I don't see  for the program as shown.If I only comment out  I see  and pyaudio loadsIf I only set  so I use threading instead, I see  and pyaudio loads.If I do something else in , it will run (only pyaudio doesn't run) I've tried this with Python 2.6 and 2.7; PyAudio 0.2.4, 0.2.7, and 0.2.8; and wx 3.0.0.0 and 2.8.12.1; and I'm using OSX 10.9.4
There are two reasons this can happen, but they look pretty much the same.Either way, the root problem is that  is just ing a child. This could be either causing CoreFoundation to get confused about its runloop*, or causing some internal objects inside  to get confused about its threads.**But you don't care why your child process is deadlocking; you want to know how to fix it.The simple solution is to, instead of trying to  and then clean up all the stuff that shouldn't be copied,  a brand-new Python process and then copy over all the stuff that should.As of Python 3.4, there are actually two variations on this. See Contexts and start methods for details, and issue #8713 for the background.But you're on 2.6, so that doesn't help you. So, what can you do?The easiest answer is to switch from  to the third-party library .  is a fork of Python 2.7's , which adds many of the features and bug fixes from both Python 3.x and Celery.I believe new versions have the exact same fix as Python 3.4, but I'm not positive (sorry, I don't have it installed, and can't find the docs onlineâ€¦).But I'm sure that it has a similar but different solution, inherited from Celery: call  before calling anything else on the library. (Or, from outside the program, set the environment variable .)* Usually, CF can detect the problem and call , which logs an error message and fails. But sometimes it can't, and will wait end up waiting forever for an event that nobody can send. Google that string for more information.** See #5527 for details on the equivalent issue with threaded Tkinter, and the underlying problem. This one affects all BSD-like *nixes, not just OS X.
If you can't solve the problem by fixing or working around , there's another option. If you can spin off the child process before you create your main runloop or create any threads, you can prevent the child process from getting confused. This doesn't always work, but it often does, so it may be worth trying.That's easy to do with Tkinter or PySide or another library that doesn't actually do anything until you call a function like  or construct an  instance.But with wx, I think it does some of the setup before you even touch anything beyond the . So, you may have to do something a little hacky and move the  after the .In your real app, you probably aren't going to want to start doing audio until some trigger from the GUI. This means you'll need to create some kind of sync object, like an . So, you create the , then start the child process. The child initializes the audio, and then waits on the . And then, where you'd like to launch the child from the GUI, you instead just signal the .


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
