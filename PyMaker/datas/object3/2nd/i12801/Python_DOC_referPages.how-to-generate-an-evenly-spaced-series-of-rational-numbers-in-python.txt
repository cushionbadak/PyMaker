Natural Text
Is there a  equivalent for floats in Python?
I don't know a built-in function, but writing one like this shouldn't be too complicated.As the comments mention, this could produce unpredictable results like:To get the expected result, you can use one of the other answers in this question, or as @Tadhg mentioned, you can use  as the  argument. Make sure to initialize it with a string rather than a float.Or even:And then:
You can either use:or use lambda / map:
I used to use  but had some complications controlling the number of elements it returns, due to floating point errors.  So now I use , e.g.:
Pylab has  (a wrapper, actually, for ):
Eagerly evaluated (2.x ):Lazily evaluated (2.x , 3.x ):Alternately:
using : lazily evaluated floating point range:
I helped add the function numeric_range to the package more-itertools. acts like the built in function range but can handle floats, Decimal, and Fraction types.
A solution without numpy etc dependencies was provided by kichik but due to the floating point arithmetics, it often behaves unexpectedly. As noted by me and blubberdiblub, additional elements easily sneak into the result. For example  would yield  as its last value and thus yield 11 values in total.A robust version is provided here: Because the multiplication, the rounding errors do not accumulate. The use of  takes care of possible rounding error of the multiplication, even though issues of course might rise in the very small and very large ends. Now, as expected:And with somewhat larger numbers:The code is also available as a GitHub Gist.
There is no such built-in function, but you can use the following (Python 3 code) to do the job as safe as Python allows you to.You can verify all of it by running a few assertions:Code available on GitHub
Why Is There No Floating Point Range Implementation In The Standard Library?As made clear by all the posts here, there is no floating point version of . That said, the omission makes sense if we consider that the  function is often used as an index (and of course, that means an accessor) generator. So, when we call , we're in effect saying we want 40 values starting at 0, up to 40, but non-inclusive of 40 itself. When we consider that index generation is as much about the number of indices as it is their values, the use of a float implementation of  in the standard library makes less sense. For example, if we called the function , we would expect both 0 and 10 to be included, but that would yield a vector with 41 values. Thus, an  function depending on its use will always exhibit counter intuitive behavior; it either has too many values as perceived from the indexing perspective or is not inclusive of a number that reasonably should be returned from the mathematical perspective.The Mathematical Use CaseWith that said, as discussed,  performs the generation with the mathematical perspective nicely:The Indexing Use CaseAnd for the indexing perspective, I've written a slightly different approach with some tricksy string magic that allows us to specify the number of decimal places.Similarly, we can also use the built-in  function and specify the number of decimals:A Quick Comparison & PerformanceOf course, given the above discussion, these functions have a fairly limited use case. Nonetheless, here's a quick comparison:The results are identical for each:And some timings:Looks like the string formatting method wins by a hair on my system. The LimitationsAnd finally, a demonstration of the point from the discussion above and one last limitation:Further, when the  parameter is not divisible by the  value, there can be a yawning gap given the latter issue:There are ways to address this issue, but at the end of the day, the best approach would probably be to just use Numpy.
A simpler library-less versionAw, heck -- I'll toss in a simple library-less version.  Feel free to improve on it[*]:The core idea is that  is the number of steps to get you from start to stop and  always emits integers so there's no loss of accuracy.  The final step is to map [0..nsteps] linearly onto [start..stop].editIf, like alancalvitti you'd like the series to have exact rational representation, you can always use Fractions:[*] In particular,  returns a list, not a generator.  But it sufficed for my needs.
i wrote a function that returns a tuple of a range of double precision floating point numbers without any decimal places beyond the hundredths. it was simply a matter of parsing the range values like strings and splitting off the excess. I use it for displaying ranges to select from within a UI. I hope someone else finds it useful.
There several answers here that don't handle simple edge cases like negative step, wrong start, stop etc. Here's the version that handles many of these cases correctly giving same behaviour as native :Note that this would error out step=0 just like native . One difference is that native range returns object that is indexable and reversible while above doesn't.You can play with this code and test cases here.
Please note the first letter of Range is capital. This naming method is not encouraged for functions in Python. You can change Range to something like drange or frange if you want. The "Range" function behaves just as you want it to. You can check it's manual here [ http://reference.wolfram.com/language/ref/Range.html ].
I think that there is a very simple answer that really emulates all the features of range but for both float and integer. In this solution, you just suppose that your approximation by default is 1e-7 (or the one you choose) and you can change it when you call the function.
Is there a range() equivalent for floats in Python?NOUse this:


Answer URL
https://docs.python.org/3/library/fractions.html
https://docs.python.org/3/library/fractions.html
