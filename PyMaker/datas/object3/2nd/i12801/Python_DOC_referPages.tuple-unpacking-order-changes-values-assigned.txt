Natural Text
I think the two are identical.But the results are different.Why are the results different? (why is the second one that result?) 
Prerequisites - 2 important PointsLists are mutableThe main part in lists is that lists are mutable. It means that thevalues of lists can be changed. This is one of the reason why you arefacing the trouble. Refer the docs for more infoOrder of EvaluationThe other part is that while unpacking a tuple, the evaluation startsfrom left to right. Refer the docs for more infoIntroductionwhen you do  the values of  and  are first stored. Then starting from the left hand side, the value of  is first changed to  and then the value of  is changed to . The catch here is that if there are any side effects to the location of  while changing the value of , then  is assigned to the later , which is the  affected by the side effect of .Use CaseNow coming to your problemIn the first case, is initially  and  is  because it evaluates to . Hence 1,2 is now stored into memory. Now tuple unpacking happens from left hand side, so hence  will print However in this case    puts 2,1 on the stack just like the first case. However on the left hand side, that is  , the changing of  has a side effect as it is used as the index in . Thus remains unchanged at value . hence  will print 
You can define a class to track the process:For the first method:the output is:While the second method:the output is:In both methods, the first three lines are related to tuple generation while the last three lines are related to assignments. Right hand side tuple of the first method is  and the second method is .In the assignment stage, first method get  which is , and set , then , second method assign , then get  which is , and finally set .
It's because of that python assignment priority is left to right.So in following code:It first assigned the  to  means  and then since lists are mutable objects the nums would be :and then  will be assigned to  which means  and :And like so for second part.Note that the important point here is that list objects are mutable and when you change it in a segment of code it can be change in-place. thus it will affect of the rest of the code.Evaluation orderPython evaluates expressions from left to right. Notice that while evaluating an assignment, the right-hand side is evaluated before the left-hand side.
In the first example, what happens is nums[1] gets set to 1, and then nums[0] gets set to 2, as you might expect.In the second example, nums[0] gets set to 2, and then nums[2] gets set to 1.  This is because, in this case, the left hand side nums[nums[0]] is really referencing nums[2] when the assignment happens, because nums[0] had just been set to 2.


Answer URL
https://docs.python.org/3/tutorial/introduction.html#lists
https://docs.python.org/3/reference/expressions.html#evaluation-order
