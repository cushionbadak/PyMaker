Natural Text
I'm going to store on the order of 10,000 securities X 300 date pairs X 2 Types in some caching mechanism.I'm assuming I'm going to use a dictionary.Question Part 1:Which is more efficient or Faster?  Assume that I'll be generally looking up knowing a list of security IDs and the 2 dates plus type.  If there is a big efficiency gain by tweaking my lookup, I'm happy to do that.  Also assume I can be wasteful of memory to an extent.Method 1: store and look up using keys that look like strings "securityID_date1_date2_type"Method 2: store and look up using keys that look like tuples (securityID, date1, date2, type)Method 3: store and look up using nested dictionaries of some variation mentioned in methods 1 and 2Question Part 2:Is there an easy and better way to do this?
It's going to depend a lot on your use case. Is lookup the only activity or will you do other things, e.g:Iterate all keys/values? For simplicity, you wouldn't want to nest dictionaries if iteration is relatively common.What about iterating a subset of keys with a given , , etc.? Nested dictionaries (each keyed on one or more components of your key) would be beneficial if you needed to iterate "keys" with one component having a given value.What about if you need to iterate based on a different subset of the key components? If that's the case, plain  is probably not the best idea; you may want relational database, either the built-in  module or a third party module for a more "production grade" DBMS.Aside from that, it matters quite a bit how you construct and use keys. Strings cache their hash code (and can be interned for even faster comparisons), so if you reuse a string for lookup having stored it elsewhere, it's going to be fast. But s are usually safer (strings constructed from multiple pieces can accidentally produce the same string from different keys if the separation between components in the string isn't well maintained). And you can easily recover the original components from a , where a string would need to be parsed to recover the values. Nested s aren't likely to win (and require some finesse with methods like  to populate properly) in a simple contest of lookup speed, so it's only when iterating a subset of the data for a single component of the key that they're likely to be beneficial.If you want to benchmark, I'd suggest populating a  with sample data, then use the  module (or 's  magic) to test something approximating your use case. Just make sure it's a fair test, e.g. don't lookup the same key each time (using  to repeat a few hundred keys would work better) since  optimizes for that scenario, and make sure the key is constructed each time, not just reused (unless reuse would be common in the real scenario) so string's caching of hash codes doesn't interfere.


Answer URL
https://docs.python.org/3/library/sqlite3.html
