Natural Text
According to the Python 3.5 docs, subprocess.run() returns an a CompletedProcess object with a stdout member that contains "A bytes sequence, or a string if run() was called with universal_newlines=True." I'm only seeing a byte sequence and not a string, which I was assuming (hoping) would be equivalent to a text line. For example,Note: this uses a new feature in Python 3.5 that won't run in previous versions.Do I need to create my own line buffering logic, or is there a way to get Python to do that for me?
 is already a string in your case, run , to make sure. It contains all subprocess' output --  does not return until the child process is dead. is incorrect:  enumerates characters (Unicode codepoints) in Python, not lines. To get lines, call:The result may be different from  if there are Unicode newlines in the string.If you want to read the output line by line (to avoid running out of memory for long-running processes):Note:  is a file-like object in this case.  does not wait for the process to finish --  returns immidiately as soon as the child process is started.  is a  instance, not  here.If all you need is to count the number of lines (terminated by ) in the output, like :See Why is reading lines from stdin much slower in C++ than Python?
if you need to have STDOUT lines in an array to better manipulate them you simply miss to split output by the "Universal newline" separatorsoutput is:
You are seeing a string, compare:class 'bytes'run calls popen.communicatecommunicate() returns a tuple (stdout_data, stderr_data). The data  will be bytes or, if universal_newlines was True, strings.Have a look here for more explanation and other shell interactions.


Answer URL
https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess
