Natural Text
Consider the following ClassTo provide an indexed in-place add operator, I defined a Helper class (similar to iterator pattern) and provided the next level operator to be called on the instance of the class.For example, I intended to provide the following operator behaviourUnfortunately, Python did not like it and complainedInterestingly, if I assign the result of getitem, it just worksLooks like, I simply do not understand the behaviourNevertheless, for in-place add, it does invokes the setitem and the only way to get over it is to override the setitem function as inNoteQ1: @vaultah spam[0] += 1 is basically spam[0] = spam[0] + 1I couldn't;t find any documentation to support that python would treat an in-place operator as a binary-op with the first operand as self. Even the disassembly says otherwise
 is an augmented assignment operator that calls the  method of the LHS, if it exists, and then assigns its return value to the LHS:For instance, if x is an instance of a class with an   method,  is equivalent to .(source)Thusis equivalent toWhile  succeeds because  is implemented, subsequent assignment to  does not, since it needs  to work. At the same time, the  list is updated, since  works as expected:See this for a related FAQ.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__iadd__
https://docs.python.org/3/faq/programming.html#faq-augmented-assignment-tuple-error
