Natural Text
Peace, everyone!I'm using Python 3.6.3 and I find strange that such construction is possible:And using:I know that in Python there are standard methods with  as parameter (don't know how to call them properly), static methods, class methods, abstract methods.But what kind of method the  is?Is it static method?Edited:Are there any useful usecases of such method of determining a function inside a class?
In Python 3, (unlike Python 2) a function accessed and called from the class is just another function; nothing special:Note that the transformation from function object to instance method  object happens each time the attribute is retrieved from the instance.[Emphasis mine]You just happened to be calling the function with the right set of parameters albeit accessed via the class object. Same as calling the underlying function object for the method via an instance:A quick test explains it further:However, in Python 2, the behaviour is different as the transformation from function object to method object happens when the attribute is accessed via both the class or instance:Note that the transformation from function object to (unbound or  bound) method object happens each time the attribute is retrieved from  the class or instance.[Emphasis mine]
Let me explain with an example:Look what happens when you call test1 with the class or with the instance:First:that's because when you create an instance, the  parameter is used, but here, the method has not the self parameter, that's why it brakes.next one!That worked for instance and for class, why? well, as you can see test2(cls) take an argument, , here, I'm not using it, so, it's ok that it works.bring me the next subject, muajajaThat's easy to see, when you call it as class, you haven't provided the self parameter
In python 3, there is no difference between a function and a function defined in a class:Both of these are normal functions.The magic of the implicit  argument happens when you access a function through an instance of the class, like this:This is when the function  is turned into the (bound) method . You can see the difference if you print them:To sum it up:Accessing a function through the class gives you the original function.Accessing a function through an instance gives you a method with a bound  argument.For details about how exactly this conversion from function to bound method works, see the descriptor how-to, and specifically the section about functions.
Python 3 dispensed with the distinction between a bound and unbound method that existed in Python 2. What was previously an unbound method is now just a regular function.In Python 2:whereas in Python 3:(the address may differ) here is a descriptor; you don't (necessarily) get back the original function object when you access ; instead you get the return value of that object's (i.e. the function's)  method, which is called with two arguments. Which arguments depends on whether you access it via the class or via an instance of a class. =>  => In Python 2,  returns an  object, which is a wrapper around the original function. As an unbound , the wrapper still expects an instance of  as its first argument, even though the function itself was not defined with any parameters.In Python 3, however,  simply returns a reference to the original function, not a  object. As a result, you can use it exactly as you defined it in the first place.You can confirm this by examining  and  in Python 2 and Python 3. In Python 2, you'll get two different values; in Python 3, you'll get the same value for each.
 call actually executes the  on the class object. This is similar to a @staticmethod (a method that can be executed on the class object, without creating an object first).will throw an exception, since instance methods pass self as the first argument, and test() takes no args.When an object is created, the methods defined in the clas are bound to it. They are actually different objects, hence they have different ids:In Python 2.7, your code throws an exception which is self explantory:


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html#functions-and-methods
