Natural Text
I'm new to this framework and am trying to understand the difference/benefits of using one over the otherI could use a non-async function that is not a co-routine to doorI know that ensure_future takes a co-routine as parameter, I hope to learn about situations where it is more advantageous to use  over . 
The non-coroutine version will never act cooperatively. You can't  on anything else in that function, and because of the way you invoked it, you can't return a result to the caller. is specifically meant to be used for callbacks, which usually are very simple functions used to hook into events (job done, exception was raised in future, etc.), and they are not expected to cooperate.Callbacks are also not expected to return anything; they are fire-and-forget routines, trusted to not lock up the whole system by running anything heavy or blocking.  returns a  instance that only lets you cancel it again (a no-op if it already has been executed). The callbacks are executed next time the event loop checks the callback queue, at which point they (hopefully briefly) block any other work from being done*.Note that  only creates a  instance, the task is not actually started! But if you did start it (with, say, ), you get more control. You now have proper coroutine, it can await on other coroutines. Awaiting on other coroutines lets the event loop switch to other coroutines that are ready to continue, ensuring your CPU is busy doing actual work when there is work to be done. And your coroutine can return actual results to the caller too.Use whichever one better fits your use-cases. In a large application, you'll likely use both.* When you run in debug mode you are told when callbacks take too long, so you can debug these.


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Handle
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_until_complete
https://docs.python.org/3/library/asyncio-dev.html#asyncio-debug-mode
