Natural Text
Very simple question from a Python newbie:My understanding is that the keys in a dict are able to be just about any immutable data type. Is it possible to pass an immutable object (e.g., a member of an enum class) as a key in the **kwargs dictionary for a function or a class? I have tried it and the answer seems to be "no":Output:However, there may be something I am missing.EDIT: Note that I am not trying to make the key equal to  (which is a string in this case); I want the key to be the actual  object, e.g. . 
You're doing:Here, the problem is  -- Your keyword () is actually an expression (), and expressions can't be used as keywords in function calls.  In fact, only identifiers can be used as keywords.To get your call to work, you'll need to use dictionary unpacking like this:Note, to get the name of the attribute, I needed to do  or , depending on how you set up your enum -- In your case, I they are the same thing.
This won't work, because of the way keyword arguments are being processed. The documentation says:[...] Next, for each keyword argument, the identifier is used to determine the corresponding slot (if the identifier is the same as the first formal parameter name, the first slot is used, and so on) [...]So there must be a way to match the key from the dictionary to the formal parameter name. The exception:keywords must be stringswhen you try to pass something that's not a string:suggest the simplest case is required: keys must be strings.A possible workaround is to make implicit things explicit: just create a class that contains all the necessary information you want to pass in its attributes and pass it. The code will surely be more readable.
The answer to my original question is indeed "no". However, thanks to the input from mgilson and BartoszKP and others, the following work around I came up with is not a bad solution, and solves my current problem. I offer it for others to look at who are trying to do something similar: Output:(no errors)
Do you actually want to create an instnace of MyEnum?
One alternative I have found is to pass a dict into  instead of , or to assign a dict to  directly: (No errors produced)However, I really don't like either of these methods. EDIT: See my second answer for a much better solution. 


Answer URL
https://docs.python.org/3/library/enum.html#programmatic-access-to-enumeration-members-and-their-attributes
https://docs.python.org/3/reference/expressions.html#calls
