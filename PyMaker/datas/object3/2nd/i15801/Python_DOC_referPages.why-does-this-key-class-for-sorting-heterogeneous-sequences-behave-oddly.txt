Natural Text
Python 3.x's  function cannot be relied on to sort heterogeneous sequences, because most pairs of distinct types are unorderable (numeric types like , ,  etc. being an exception):In contrast, comparisons between objects that have no natural order are arbitrary but consistent in Python 2.x, so  works:In order to replicate Python 2.x's behaviour in Python 3.x, I wrote a class to use as the  parameter to , which relies on the fact that  is guaranteed to use only less-than comparisons:Example usage:So far, so good.However, I've noticed a surprising behaviour when  is called with certain sequences containing complex numbers:I would have expected ,  and  to be in one group (because they are mutually orderable), and  and  in another (because they are of the same type). The fact that the complex numbers in this result are not only separated from each other, but one of them is sitting in the middle of a group of objects that are comparable with each other but not with it, is somewhat perplexing.What's going on here?
You do not know what order the comparisons are done in, or even which items are compared, which means you can't really know what effect your  will have.  Your defined  sometimes depends on the actual values, and sometimes on the string representations of the types, but both versions may be used for the same object in the course of the sort.  This means that your ordering is not determined solely by the objects in the list, but also may depend on their initial order.  This in turn means that just because objects are mutually comparable does not mean they will be sorted together; they may be "blocked" by an incomparable object between them.You can get an inkling of what is going on by putting some debugging prints in to see what it's comparing:Then:You can see, for instance, that the type-based ordering is used for comparing the complex number to 1, but not for comparing 1 and 0.  Likewise  for "normal" reasons, but  for type-name-based reasons.The result is that it sorts  to the beginning, and then leaves  where it is above False.  It never even attempts to compare the two complex numbers to each other, and the only item they are both compared to is 1.More generally, your approach can lead to an intransitive ordering with appropriate choices for the names of the types involved.  For instance, if you define classes A, B, and C, such that A and C can be compared, but they raise exceptions when comparing to B, then by creating objects ,  and  (from the respective classes) such that , you can create a cycle .   will be true because the classes will be compared based on their names, but  since these types can be directly compared.  With an intransitive ordering, there is no hope of a "correct" sorted order.You can even do this with builtin types, although it requires getting a little creative to think of objects whose type names are in the right alphabetical sequence:(Because  :-)


Answer URL
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/howto/sorting.html#odd-and-ends
