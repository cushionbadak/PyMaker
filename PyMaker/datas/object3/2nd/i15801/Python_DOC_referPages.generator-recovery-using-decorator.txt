Natural Text
Let's have a class that has function that fails from time to time but after some actions it just works perfectly.Real life example would be Mysql Query that raises  but after client reconnection it works fine.I've tried to write decorator for this:And if client loses connection it just silently reconnect and everybody is happy.But what if I want to transform  to generator (and use  statement):Well, previous example won't work because inner function already returned generator and it will break after calling first .As I understand it if python sees  inside method it just yields control immediately (without executing one single statement) and waits for first .I've managed to make it work by replacing:With:But I'm curious whether there is more elegant (more pythonic) way to do this. Is there a way to make python run all the code up to first  and then wait?I'm aware of possibility of just calling  but I want to avoid loading all records at once.
First, I think the solution you're currently using is fine. When you decorate a generator, the decorator is going to need to at least behave like an iterator over that generator. Doing that by making the decorator a generator, too, is perfectly ok. As x3al pointed out, using  instead of  is a possible optimization.If you want to avoid actually making the decorator a generator, too, you can do that by using , which will run until the first , and return the first yielded value. You'll need to make the decorator somehow capture and return that first value, in addition to the rest of the values to be yielded by the generator. You could do that with :You could also make the decorator work with both generator and non-generator functions, using  to determine if you're decorating a generator:I would favor the /-based solution, unless you have a requirement to decorate regular functions in addition to generators.
Is there a way to make python run all the code up to first yield and then wait?Yes and it's called . Call  once and the code will wait exactly after first . You can place another  right before the loop if you don't want to lose first value.If you're using python 3.3+, you can also replacewith .


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.chain
https://docs.python.org/3/library/inspect.html
