Natural Text
I need help writing a function that will take a single list and return a different list where every element in the list is in its own original list.I know that I'll have to iterate through the original list that I pass through and then append the value depending on whether or not the value is already in my list or create a sublist and add that sublist to the final list.an example would be:
I'd do this in two steps:(The fact that these happen to be in sorted numerical order, and also in the order of first appearance, is just a coincidence here. Counters, like normal dictionaries, store their keys in arbitrary order, and you should assume that  would be just as possible a result. If that's not acceptable, you need a bit more work.)So, how does it work?The first step creates a , which is just a special subclass of  made for counting occurrences of each key. One of the many nifty things about it is that you can just pass it any iterable (like a ) and it will count up how many times each element appears. It's a trivial one-liner, it's obvious and readable once you know how  works, and it's even about as efficient as anything could possibly be.*But that isn't the output format you wanted. How do we get that? Well, we have to get back from  (meaning "3 copies of ") to ). You can write that as .** And the rest is just a bog-standard list comprehension.If you look at the docs for the  module, they start with a link to the source. Many modules in the stdlib are like this, because they're meant to serve as source code for learning from as well as usable code. So, you should be able to figure out how the  constructor works. (It's basically just calling that  function.) Since that's the only part of  you're actually using beyond a basic , you could just write that part yourself. (But really, once you've understood how it works, there's no good reason not to use it, right?)* For each element, it's just doing a hash table lookup (and insert if needed) and a . And in CPython, it all happens in reasonably-optimized C.** Note that we don't have to worry about whether to use  vs.  here, because the values have to be immutable, or at least of an "equality is as good as identity" type, or they wouldn't be usable as keys.
The most time efficient would be to use a dictionary:The other, more costly option is to sort, then group using :Demo:
What about this, as you said you wanted a function:


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
https://docs.python.org/3/library/collections.html#collections.Counter
