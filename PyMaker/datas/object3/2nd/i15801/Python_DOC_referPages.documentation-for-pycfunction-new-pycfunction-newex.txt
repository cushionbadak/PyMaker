Natural Text
I'm struggling to understand some PyCXX code (C++ Python wrapper) that revolves around PyCFunction_New.Could someone explain how this function works?(I can't figure it out from the CPython source code.)Here I will detail the problem I'm having. I've ruled a line above, because this probably won't be of such general use.Reason for asking is that I'm dealing with weird code. I've got a keyword-method handler function:It is getting stored as:Then it is getting bundled into a PyCFunction_New:Am I right in assuming that CPython will take care of typecasting it back to a 3-param function, where the first param is args (which matches the handler's _self_and_name_tuple first param)?And CPython would only know from the fact that it is having to parse: 'myFunc(7, a=1)' that it is in fact dealing with a keywords a.k.a. 3-param function?This doesn't look right.Maybe CPython is typecasting args1 back to a PyMethodDef, and then inspecting it's .ml_flagsIf that's happening then I need to know, because the code I'm working with simply has:In its original form, I think it must have had two copies of PyMethodDefAnd the first one never got touched because it was the base classIf this is really happening, i.e. If this class is indeed getting typecast back to PyMethodDef by the internals of PyCFunction_New, then this is dodgy.Surely someone could add a member variable at the front of MethodDefExt, and then the typecasting would break.  This is flimsy...The class I am dealing with allows the future C++ coder to implement a custom Python Type, and within this type, to implement methods that can be called from Python.So they derive MyExt : CustomExt and write the method:Now they have to store this method in a lookup, by calling the appropriate one of these three functions: Notice there is an associated handler function for each. These handler functions are static methods of CustomExt -- because a pointer to a static method can be called from CPython, i.e. It is just a standard C style function pointer.So when  Python wants  the pointer for this foo function, we intercept here:Construct a Python function that will call the handler for this method(while passing in this object args[0] the details of the method itself args1).The handler will take care of running the method while trapping errors.Note that we don t execute the handler at this pointInstead we return this Python function back to the Python runtimeMaybe the Python coder didn t want the function executed but just wanted to grab a pointer to it:                fp = MyExt.func; X (see below) & method_def_ext->meth_def pulls out the handler function, which is one of three handlersHowever, thanks to MethodDefExt s constructors, they have all been typecast into PyCFunction objectsWhich means the parameter list is wrong for keywords handler.(I had to break out the comments as SO's formatter was not handling them as code comments)What I'm struggling with is this: let's say foo is a function that takes keywords, so its signature will be:The matching handler looks like this:i.e. The third one.  I've read Python supplies an extra first _self_and_name_tuple parameter.When we register foo into the lookup, we supply this handler:And looking at the particular constructor of MethodDefExt,... It can be seen that it typecasts this handler into a PyCFunctionBut a PyCFunction only takes two arguments!!!We are typecasting handlers into this.  And these handlers have 2 or 3 parameters.This looks really wrong.And then going back so when CPython wants to execute foo, as described above, it will fetch this meth_def.ml_meth and feed it into PyCFunction_New:So I can make a guess: * the first parameter of PyCFunction_New must be a PyCFunction function pointer * the second parameter must be a PyObject* _self_and_name_tupleAnd we are feeding this back to CPythonMy guess is that when CPython wants to use 'foo(7, a=1,b=2)' it will package 7 into args, a=1,b=2 into kwds, and call:
I will hazard an answer:PyCFunction_New probably creates a Callable-Type PyObject, primed with a function (wrapped in ml) and additional data (wrapped in self)The second parameter could be anything, in fact it doesn't even need to be a PyObject*. When Python executes the function packaged inside ml, this will be the first argument. Subsequent arguments depend on ml->ml_flags, as detailed below.The first parameter is a PyMethodDef object, which we can use to encapsulate a function.So, it contains a (specific) function pointer:... and a flag,https://docs.python.org/3.4/c-api/structures.htmlWe can pass 3 kinds of function to Python in this way:EDIT: https://docs.python.org/3/tutorial/classes.html#method-objectsIf you still don’t understand how methods work, a look at the  implementation can perhaps clarify matters. When an instance attribute  is referenced that isn’t a data attribute, its class is searched. If  the name denotes a valid class attribute that is a function object, a  method object is created by packing (pointers to) the instance object  and the function object just found together in an abstract object:  this is the method object. When the method object is called with an  argument list, a new argument list is constructed from the instance  object and the argument list, and the function object is called with  this new argument list.


Answer URL
https://docs.python.org/3/tutorial/classes.html#method-objects
