Natural Text
Besides the above method, any other way to find out whether is fp is already at the eof?
 reads up to the end of the file, so after it's successfully finished you know the file is at EOF; there's no need to check. If it cannot reach EOF it will raise an exception.When reading a file in chunks rather than with , you know you've hit EOF when  returns less than the number of bytes you requested. In that case, the following  call will return the empty string (not ). The following loop reads a file in chunks; it will call  at most once too many.Or, shorter:
The "for-else" design is often overlooked. See: Python Docs "Control Flow in Loop":Example
I'd argue that reading from the file is the most reliable way to establish whether it contains more data. It could be a pipe, or another process might be appending data to the file etc.If you know that's not an issue, you could use something like:
When doing binary I/O the following method is useful:The advantage is that sometimes you are processing a binary stream and do not know in advance how much you will need to read.
You can compare the returned value of  before and after calling the  method. If they return the same value, fp is at eof.Furthermore, I don't think your example code actually works. The  method to my knowledge never returns , but it does return an empty string on eof.
read returns an empty string when EOF is encountered. Docs are here.
As python returns empty string on EOF, and not "EOF" itself, you can just check the code for it, written here

If file is opened in non-block mode, returning less bytes than expected does not mean it's at eof, I'd say @NPE's answer is the most reliable way:f.tell() == os.fstat(f.fileno()).st_size
The Python read functions will return an empty string if they reach EOF
I really don't understand why python still doesn't have such a function. I also don't agree to use the followingThe main reason is  doesn't likely to work for some special conditions.The method works for me is like the following. If you have some pseudocode like the followingYou can replace it with:This method is simple and you don't need to change most of you code.
You can use the file methods seek() and tell() to determine the position of the end of file. Once the position is found, seek back to the file beginning
You can use  method after reaching  by calling method, like this:
Get the EOF position of the file:and compare it with the current position: .
Although I would personally use a  statement to handle opening and closing a file, in the case where you have to read from stdin and need to track an EOF exception, do something like this:Use a try-catch with  as the exception:
Reading a file in batches of  lines (the last batch can be shorter):
I use this function:
You can use below code snippet to read line by line, till end of file:


Answer URL
