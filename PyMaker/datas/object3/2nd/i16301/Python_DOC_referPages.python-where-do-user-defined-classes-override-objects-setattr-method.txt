Natural Text
So, I was playing around with Python while answering this question, and I discovered that this is not valid:due to an . However, with any class inherited from object, it is valid:Printing  displays 'hello' as expected. Why is this the case? What in the Python language specification specifies that you can't assign attributes to vanilla objects?
To support arbitrary attribute assignment, an object needs a : a dict associated with the object, where arbitrary attributes can be stored. Otherwise, there's nowhere to put new attributes.An instance of  does not carry around a  -- if it did, before the horrible circular dependence problem (since , like most everything else, inherits from ;-), this would saddle every object in Python with a dict, which would mean an overhead of many bytes per object that currently doesn't have or need a dict (essentially, all objects that don't have arbitrarily assignable attributes don't have or need a dict).For example, using the excellent  project (you can get it via svn from here), we can do some measurements...:You wouldn't want every  to take up 144 bytes instead of just 16, right?-)Now, when you make a class (inheriting from whatever), things change...:...the  is now added (plus, a little more overhead) -- so a  instance can have arbitrary attributes, but you pay quite a space cost for that flexibility.So what if you wanted s with just one extra attribute ...? It's a rare need, but Python does offer a special mechanism for the purpose......not quite as tiny as an , mind you! (or even the two s, one the  and one the  -- the second one can be reassigned), but surely much better than a .When the class has the  special attribute (a sequence of strings), then the  statement (more precisely, the default metaclass, ) does not equip every instance of that class with a  (and therefore the ability to have arbitrary attributes), just a finite, rigid set of "slots" (basically places which can each hold one reference to some object) with the given names.In exchange for the lost flexibility, you gain a lot of bytes per instance (probably meaningful only if you have zillions of instances gallivanting around, but, there are use cases for that).
As other answerers have said, an  does not have a .  is the base class of all types, including  or . Thus whatever is provided by  will be a burden to them as well. Even something as simple as an optional  would need an extra pointer for each value; this would waste additional 4-8 bytes of memory for each object in the system, for a very limited utility.Instead of doing an instance of a dummy class, in Python 3.3+, you can (and should) use  for this.
It is simply due to optimization.Dicts are relatively large.Most (maybe all) classes that are defined in C do not have a dict for optimization.If you look at the source code you will see that there are many checks to see if the object has a dict or not.
So, investigating my own question, I discovered this about the Python language: you can inherit from things like int, and you see the same behaviour:I assume the error at the end is because the add function returns an int, so I'd have to override functions like  and such in order to retain my custom attributes. But this all now makes sense to me (I think), when I think of "object" like "int". 
It's because object is a "type", not a class. In general, all classes that are defined in C extensions (like all the built in datatypes, and stuff like numpy arrays) do not allow addition of arbitrary attributes.
This is (IMO) one of the fundamental limitations with Python - you can't re-open classes. I believe the actual problem, though, is caused by the fact that classes implemented in C can't be modified at runtime... subclasses can, but not the base classes.


Answer URL
https://docs.python.org/3/library/types.html#types.SimpleNamespace
