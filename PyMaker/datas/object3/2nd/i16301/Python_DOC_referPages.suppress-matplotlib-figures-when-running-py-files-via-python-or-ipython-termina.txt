Natural Text
I am writing a  to test the execution of a folder of python examples.  Currently I use  to parse the folder and then use  to execute each python file. The issue is that some of these files are plots and they open a  window that halts until the window is closed.A lot of the questions on this issue offer solutions from within the file, but how could I suppress the output whilst running the file externally without any modification?What I have done so far is:This kind of works, in that it suppresses the Figures, but it doesn't throw any exceptions (even if the program has an error). I am also not 100% sure what it is doing. Is it appending all of the figures to Qt4 or will the Figure be removed from memory when that script has finished?Ideally I would like to ideally run each  file and capture its  and , then use the exit condition to report the  and fail the tests. Then when I run  it will run the examples folder of programs and check that they all run. 
You could force matplotlib to use the  backend (which won't open any windows) by inserting the following lines at the top of each source file:Here's a one-liner shell command that will dynamically insert these lines at the top of  (without modifying the file on disk) before piping the output to the Python interpreter for execution:You should be able to make the equivalent call using , like this:You could capture the  and  from your scripts by passing the  and  arguments to . This would, of course, only work in Unix environments that have the  utility.UpdateThis is actually quite an interesting problem. I thought about it a bit more, and I think this is a more elegant solution (although still a bit of a hack):Conceptually this is very similar to my previous solution - it works by reading in the test scripts as strings, and prepending them with a couple of lines that will import matplotlib and set the backend to a non-interactive one. The string is then compiled to Python bytecode, then executed. The main advantage is that it this ought to be platform-independent, since  is not required.The  trick with the globals is necessary if, like me, you tend to write your scripts like this:A few points to consider:If you try to run this function from within an ipython session where you've already imported matplotlib and set an interactive backend, the  trick won't work and you'll still get figures popping up. The easiest way is to run it directly from the shell (), or from an (i)python session where you haven't set an interactive backend for matplotlib. It should also work if you run it in a different subprocess from within your ipython session.I'm using the  trick from this answer to redirect  and  to a log file. Note that this isn't threadsafe, but I think it's pretty unusual for scripts to open subprocesses.
Coming to this late, but I am trying to figure something similar out myself, and this is what I have come up with so far. Basically, if your plots are calling, for example,  to show the plot, you can mock that method out using a patch decorator. Something like:Basically the patch decorator should replace any call to  within the decorated function with a mock object that doesn't do anything. At least that's how it's supposed to work in theory. In my application, my terminal is still trying to open plots and this is resulting in errors. I hope it works better for you, and I will update if I figure out something wrong in the above that is leading to my issue.Edit: for completeness, you might be generating figures with a call to  or , in which case these are what you would mock out instead of . Same syntax as above, you would just use:or:


Answer URL
https://docs.python.org/3/library/unittest.mock.html#module-unittest.mock
https://docs.python.org/3/library/unittest.mock.html#the-patchers
