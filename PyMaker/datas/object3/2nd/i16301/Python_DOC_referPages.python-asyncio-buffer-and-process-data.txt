Natural Text
I'm having trouble with some CPU-intensive tasks within an asyncio event loop. The troubles I have arise when dealing with maintaining a buffer of incoming data and building packets from it. I've tried using executors to do the CPU bound stuff, but then had trouble maintaining the ordering of the buffer when packets were removed from it.I'm looking for a best-practice method to achieve the following functionality without having the CPU-bound tasks executed within the event loop.
You want to be able to handle all the data coming into  as quickly as possible, but you also can't have multiple threads/processes try to process that data in parallel; that's how you ran into race conditions using executors before. Instead, you should start one worker process that can handle processing all the packet data, one at a time, using a  to pass the data from the parent to the worker. Then, when the worker has a valid packet built, verified, and ready to be distributed, it uses another  to send it back to a thread in the parent process, which can use the thread-safe  method to schedule  to run.Here's an untested example that should give you an idea of how to do this:
I would try to wrap up the whole packet handling logic, and split the heavy task into pieces. Using MD5 hash for example:Note that the packets can come in much faster than  can handle, so make sure to monitor system load & stop receiving while needed. But that's another story :)


Answer URL
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.BaseEventLoop.call_soon_threadsafe
