Natural Text
This question already has an answer here:What does 'super' do in Python?                    6 answers                I'm trying to understand the use of . From the looks of it, both child classes can be created, just fine. I'm curious to know about the actual difference between the following 2 child classes.
 lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.Note that the syntax changed in Python 3.0: you can just say  instead of  which IMO is quite a bit nicer. The standard docs also refer to a guide to using super() which is quite explanatory.
I'm trying to understand The reason we use  is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).In Python 3, we can call it like this:In Python 2, we are required to use it like this:Without super, you are limited in your ability to use multiple inheritance:I further explain below."What difference is there actually in this code?:"The primary difference in this code is that you get a layer of indirection in the  with , which uses the current class to determine the next class's  to look up in the MRO.I illustrate this difference in an answer at the canonical question, How to use 'super' in Python?, which demonstrates dependency injection and cooperative multiple inheritance.If Python didn't have Here's code that's actually closely equivalent to  (how it's implemented in C, minus some checking and fallback behavior, and translated to Python):Written a little more like native Python:If we didn't have the  object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!How does super do this in Python 3 without being told explicitly which class and instance from the method it was called from? It gets the calling stack frame, and finds the class (implicitly stored as a local free variable, , making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use. Since it requires that first argument for the MRO, using  with static methods is impossible.Criticisms of other answers:super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.It's rather hand-wavey and doesn't tell us much, but the point of  is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.I'll explain here.And let's create a dependency that we want to be called after the Child:Now remember,  uses super,  does not:And  does not call the UserDependency method:But , because  uses , does!:Criticism for another answerIn no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB:(That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.)Explanation: That answer suggested calling super like this:This is completely wrong.  lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell  we're in the child instance's method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer's example, it does) or a  when the recursion depth is exceeded.
It's been noted that in Python 3.0+ you can use to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, it is possible to get this name-insensitive behaviour by writing  instead of the class name, i.e.HOWEVER, this breaks calls to  for any classes that inherit from your class, where  could return a child class. For example:Here I have a class , which is a sub-class of . Say I don't want to write a separate constructor for  because the constructor for  is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.When I create a  using , Python calls the constructor for  because I haven't given  its own constructor. However, in the constructor for , the call  is going to return the superclass of , so it calls the constructor for  again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run  I am calling the constructor for  but since I give it no arguments, I will get an error.
Super has no side effectsworks as expectedgets into infinite recursion.
Just a heads up... with Python 2.7, and I believe ever since  was introduced in version 2.2, you can only call  if one of the parents inherit from a class that eventually inherits  (new-style classes).Personally, as for python 2.7 code, I'm going to continue using  until I actually get the advantage of using .
There isn't, really.  looks at the next class in the MRO (method resolution order, accessed with ) to call the methods. Just calling the base  calls the base . As it happens, the MRO has exactly one item-- the base. So you're really doing the exact same thing, but in a nicer way with  (particularly if you get into multiple inheritance later).
The main difference is that  will unconditionally call  whereas  will call  in whatever class happens to be  ancestor in 's line of ancestors(which may differ from what you expect). If you add a  that uses multiple inheritance: then  is no longer the parent of  for  instances. Now  will point to  if  is a  instance.You have inserted  in between  and . And you can take advantage of it with So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use  because you don't really know who is going to be the ancestor at runtime. The super considered super post and pycon 2015 accompanying video explain this pretty well.  


Answer URL
https://docs.python.org/3/library/functions.html#super
