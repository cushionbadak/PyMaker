Natural Text
I have a list of dictionaries that all have the same structure within the list.  For example:What I need to do is compare each of these dictionaries and return "similar" dictionaries based on a value key pair.  For example, given the key  and the value , I want to find all the matching dictionaries almost similar to  which in this case would be . The  has a function  which is close to what I need.  I'm able to extract the values of the specific key using a list comprehension and then compare those values to my search:What I need this to do is go one step further and tie everything back together with the original dictionary:Note: The list of dictionaries is quite large, and therefore I'm hoping to be as efficient/fast as possible.
You can create a reverse lookup dict prior to running get_close_dicts on your data, so that once you have a set of values returned, you can use them to lookup the relevant dict(s).If you're guaranteed to have unique values across your dicts for the 'value' key, then you can do:If, however, you need to handle the case where multiple dicts will have the same value for the 'value' key, then you need to map all of them (this will give you a dict where the key is the value in 'value' and the value is the list of dicts that have that value):For example, if your test data had an extra dict in it like this:Then the above reverse lookup construction would give you this:Then after you have your values, just retrieve the dicts  (then you can chain if you have the list of lists use case, no need to chain if you have the first use case):
You could:Pay attention get_close_matches could return more than one result.
No matter what, you're going to end up iterating through every dictionary at some point. There's no getting around that. What you can do is get all the work done in a preprocessing phase, to make your actual calls to the function immediate.As ValAyal mentioned, a reverse lookup dictionary is a good idea here. I'm imagining a dictionary , where the  is the value from the first dictionary, and the  contains both exact and similar  matches. Take this example with  and , which are in your list that you want to search. IfThen:Whenever you insert a dictionary that has an already-seen value, you can immediately determine all the exact and close matches (just by looking up that value), and add to the various lists accordingly. If you have a new value that hasn't been seen before, you'd have to compare it to all the values currently in the . For example, if you wanted to addYou'd look up  and get both the  and  lists. These lists include all of the other  entries you need to modify. You'd need to add to the exact matches of  and the close matches of ; both these values you can get from the returned lists. You end up withSo once all that preprocessing is done, your function becomes simpler: something like  (I don't know what the third argument does in your example) can just do . You now have a function that gives an immediate answer.The preprocessing step is pretty complex, but the resulting speedup in  will hopefully make up for it. I can elaborate on this more when I get back from work, if you want to know how to implement this. Hopefully this can give you a good idea of a helpful data structure, and I didn't horrendously overthink this.


Answer URL
https://docs.python.org/3/library/difflib.html
https://docs.python.org/3/library/difflib.html#difflib.get_close_matches
