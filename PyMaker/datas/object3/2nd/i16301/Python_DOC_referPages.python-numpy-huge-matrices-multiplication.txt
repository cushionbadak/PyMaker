Natural Text
I need to multiply two big matrices and sort their columns.This process takes a lot of time and memory. Is there a way to fasten this process? If not how can I calculate RAM needed to do this operation? I currently have an EC2 box with 4GB RAM and no swap. I was wondering if this operation can be serialized and I dont have to store everything in the memory.
One thing that you can do to speed things up is compile numpy with an optimized BLAS library like e.g. ATLAS, GOTO blas or Intel's proprietary MKL.To calculate the memory needed, you need to monitor Python's Resident Set Size ("RSS"). The following commands were run on a UNIX system (FreeBSD to be precise, on a 64-bit machine).To get the RSS I ran:[Edit: See the  manual page for a complete explanation of the options, but basically these  options make it show only the command and resident set size of all processes. The equivalent format for Linux's  would be , I believe.]The results are;After starting the interpreter: 24880 kiBAfter importing numpy: 34364 kiBAfter creating : 42200 kiBAfter deleting : 34368 kiBCalculating the size;As you can see, the calculated size matches the 8 bytes for the default datatype  quite well. The difference is internal overhead.The size of your original arrays in MiB will be approximately;That's not too bad. However, the dot product will be way too large:That's 2235 GiB!What you can do is split up the problem and perfrom the  operation in pieces;load  as an ndarrayload every row from  as an  in turn.multiply the row by every column of  and write the result to a file. the row and load the next row.This wil not make it faster, but it would make it use less memory!Edit: In this case I would suggest writing the output file in binary format (e.g. using  or ). That would make it much easier to read a column from the file with e.g. a . 
What DrV and Roland Smith said are good answers; they should be listened to. My answer does nothing more than present an option to make your data sparse, a complete game-changer.Sparsity can be extremely powerful. It would transform your  operation into an  operation with k non-zero elements (sparsity only means that the matrix is largely zero). I know sparsity has been mentioned by DrV and disregarded as not applicable but I would guess it is.All that needs to be done is to find a sparse representation for computing this transform (and interpreting the results is another ball game). Easy (and fast) methods include the Fourier transform or wavelet transform (both rely on similarity between matrix elements) but this problem is generalizable through several different algorithms.Having experience with problems like this, this smells like a relatively common problem that is typically solved through some clever trick. When in a field like machine learning where these types of problems are classified as "simple," that's often the case.
YOu have a problem in any case. As  shows you in his answer, the amount of data and number of calculations is enormous. You may not be very familiar with linear algebra, so a few words of explanation might help in understanding (and then hopefully solving) the problem.Your arrays are both a collection of vectors with length 100. One of the arrays has 300 000 vectors, the other one 1 000 000 vectors. The dot product between these arrays means that you calculate the dot product of each possible pair of vectors. There are 300 000 000 000 such pairs, so the resulting matrix is either 1.2 TB or 2.4 TB depending on whether you use 32 or 64-bit floats.On my computer dot multiplying a (300,100) array with a (100,1000) array takes approximately 1 ms. Extrapolating from that, you are looking at a 1000 s calculation time (depending on the number of cores).The nice thing about taking a dot product is that you can do it piecewise. Keeping the output is then another problem.If you were running it on your own computer, calculating the resulting matrix could be done in the following way:create an output array as a  array onto the diskcalculate the results one row at a time (as explained by )This would result in a linear file write with a largish (2.4 TB) file. This does not require too many lines of code. However,  make sure everything is transposed in a suitable way; transposing the input arrays is cheap, transposing the output is extremely expensive. Accessing the resulting huge array is cheap if you can access elements close to each other, expensive, if you access elements far away from each other.Sorting a huge memmapped array has to be done carefully. You should use in-place sort algorithms which operate on contiguous chunks of data. The data is stored in 4 KiB chunks (512 or 1024 floats), and the fewer chunks you need to read, the better.Now that you are not running the code in our own machine but on a cloud platform, things change a lot. Usually the cloud SSD storage is very fast with random accesses, but IO is expensive (also in terms of money). Probably the least expensive option is to calculate suitable chunks of data and send them to S3 storage for further use. The "suitable chunk" part depends on how you intend to use the data. If you need to process individual columns, then you send one or a few columns at a time to the cloud object storage.However, a lot depends on your sorting needs. Your code looks as if you are finally only looking at a few first items of each column. If this is the case, then you should only calculate the first few items and not the full output matrix. That way you can do everything in memory.Maybe if you tell a bit more about your sorting needs, there can be a viable way to do what you want.Oh, one important thing: Are your matrices dense or sparse? (Sparse means they mostly contain 0's.) If your expect your output matrix to be mostly zero, that may change the game completely.


Answer URL
https://docs.python.org/3/library/resource.html
