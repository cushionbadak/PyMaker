Natural Text
I'm utilizing the enum with ToString implementation that was suggested here: How to convert an enum type variable to a string?It utilizes  and works fine as far as I can  tell.My issues arise when I try to wrap and export the macro to a Python library wrapped with SWIG. Similar question: SWIG errors because of preprocessor directiveThere, the solution was to add headers / declarations to the SWIG interface. I haven't had success with this so far. Chances are that I just don't know what I have to add.Tried:MWE:minimal.hminimal.cppminimal.iThe error is not very indicative. Line 29 is the actual definition of my_enum.Any advice on how I could wrap this?
If you wanted to make SWIG read boost/preprocessor.hpp you'd do that with:Since by default SWIG doesn't follow  directives. (You could also use  to make it follow them instead). In this case though I think making the SWIG preprocessor make any kind of sense of the crazy magic that the Boost preprocessor library uses is a lost cause. Instead though we can try to get something with equally nice, but "Pythonic" syntax instead. In esscence what we're going to do is write a totally different version of  for SWIG wrappers only. It will be compatible with the definitions seen by C++ though.To do this I'm going to start by splitting your file minimal.h into two files. One with the macro definition and one that uses it. (We could have done this different ways, for example by wrapping the macro definitions with  or , which would be equally valid solutions).Thus we now have enum.hh:And minimal.h:So your minimal.cpp continues to work as before, but now we can write a SWIG module that at least compiles, even if it doesn't do anything useful yet:This currently has a stub, SWIG specific macro that we're going to fill out. It's a little ugly how I've done this, simply because I'm trying to avoid changing the way the existing macro is defined/used at all.What I produced as a starting point is another file, enum.i:Such that minimal.i just needs to become:All that macro does is take the value of , which is going to be something like  and generate some code that's completely standard (if quirky) C++ that expands this into a . That's done by mapping the first enum member onto a constructor call, and the rest onto an overloaded . We use the  supplied by enum.h to find the string representation. Finally our macro has enough information to wrap the vector of tuples in a way which makes sense from within Python. With this in place we can do something like:Which, when compiled and run gives:I.e. enough to start writing Python code that's aware of both the label and the value of a C++ enum.But let's not stop there! Why did I deliberately call the resulting vector  instead of just ? Because there's more we can do now.Python 2.7 doesn't have any default "enum-ish", but that doesn't prevent us from wrapping this as something both Pythonic and natural to people who know about enums. I made my Python 2.7 enum support by reading this other answer. To start with I added some generic enum support routines to the file using , (labelled #1 in final source) but outside the SWIG macro since there's no need to vary it. I also added a  inside the SWIG macro (labelled #2) that invokes this once per actual enum. In order to make this work I had to convert the  from the previous version into a function so that it was accessible in the right part of the generated Python. Finally I had to show SWIG a forward declaration of the real enum, in order to persuade it to actually accept that as an argument to functions. The final result is:I added a function to minimal.i to prove it really does work:And finally test it with:Which you'll be pleased to see worked and resulted in:If you're using Python 3 there's a possibly nicer way to represent enums, but I'll leave that as an exercise for the reader for now. You can obviously tweak the Python 2.7 fake enums to your taste as well.


Answer URL
https://docs.python.org/3/library/enum.html#module-enum
