Natural Text
I'm trying to teach myself about how python bytecode works so I can do some stuff with manipulating functions' code (just for fun, not for real usage) so I started with some simple examples, such as:The bytecode is*:So it makes sense to me that  is the  bytecode, and the name of the object being loaded is  where  is the number after . And  indicates a  to load  where  is the number after . But then there are a bunch of auxiliary zeros, like the second and third and fifth zeros that seem to serve no purpose, at least to me. What do they indicate?Textual bytecode:*Note: In Python 3 (where bytecodes may be different from above), the bytecode can be found via:
A large number of bytecodes take arguments (any bytecode with a codepoint at or over . Those that do have a 2-byte argument, in little-endian order.You can see the definition for what bytecodes Python currently uses and what they mean in the  module documenation.With 2 bytes you can give any bytecode an argument value between 0 and 65535, for bytecodes than need more, you can prefix the bytecode with the  bytecode, adding 2 more bytes for a value between 0 and 4294967295. In theory you could use  multiple times, but the CPython interpreter uses  for the  variable and is thus for practical purposes limited to 4-byte values.As of Python 3.4 the  module provides you with  instances that make it easier to introspect each bytecode and their arguments. Using this we can walk through the byte codes you found for your function :So the first opcode, 124 or  puts the value for first local name on the stack; this is the  argument, little-endian interpreted as integer , an index into the code locals array.  has filled out the  attribute, showing us that the first local name is . In the above session I show how you can introspect the code object to see the list of names.The next instruction pushes a constant onto the stack; the argument is now , or little-endian for integer ; the second constant associated with the code object. The  tuple shows that it is , but the  object gives it too, as the  attribute.Next we have another , pushing another reference to local name  onto the stack.This is a bytecode without argument, the opcode 27 is below . No argument is needed, because this opcode takes the top two values on the stack, divides them, pushing the floating point result back on the stack. So the last  and the  constant are taken, divided and the result is push back on.Another argument-less bytecode; this one adds up the top two stack values, replacing those with the outcome. The outcome of the  is taken, and the value of  that was pushed on first, and the result is put back on the stack.Last instruction, and another that doesn't take arguments.  ends the current frame, returning the top value from the stack as the result to the caller.
Before CPython 3.6, CPython bytecode arguments take 2 bytes. The extra zeros are the high bytes of the arguments.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT
https://docs.python.org/3/library/dis.html#opcode-HAVE_ARGUMENT
https://docs.python.org/3/library/dis.html#opcode-EXTENDED_ARG
https://docs.python.org/3/library/dis.html#dis.Instruction
