Natural Text
I did this code that finds two integers in a said list (in this case [2,4,5,1,6,40,-1]) that multiply to twenty. I got a little stuck in the beginning, but adding a function to it solved my problems. I showed this code to a friend of mine who's a programmer and he said I could make this code more "pythonic", but I have no clue how.Here's the code:
I don't necessarily think it is 'unpythonic', you are using standard Python idioms to loop over your data and produce a single result or . The term Pythonic is nebulous, a subject marred in "I know it when I see it" parameters.Not that you produced a correct implementation. While  loops over ,  loops over an integer from  through to , mixing values from  with indices? For your sample input, you are taking   from the half-open ranges [4, 7), [6, 7), [7, 7) (empty), [3, 7), [8, 7) (empty), [42, 7) (empty) and [1, 7), respectively. That it produces the correct answer at all is luck, not due to correctness; if you give your function the list , it'll not find a solution! You want to loop over  again, limited with slicing, or generate indices starting at the current index of , but then your outer loop needs to add a  call too:orAll this is not nearly as efficient as it can be; the Python standard library offers you the tools to generate your  pairs without a nested  loop or slicing or other forms of filtering.Your double loop should generate combinations of the integer inputs, so use the  object to generate unique  pairs:This assumes there can be zero or more such solutions, not just a single solution.If you only ever need the first result or , you can use the  function:Next, rather than produce all possible combinations, you may want to invert the problem. If you turn  into a set, you can trivially check if the target number 20 can be divided cleanly without remainder by any of your given numbers and where the result of the division is larger and is also an integer in the set of numbers. That gives you an answer in linear time.You can further limit the search by dividing with numbers smaller than the square root of the target value, because you won't find a larger value to match in your input numbers (given a number  and it's square root , by definition  is going to be larger than ).If we add an argument for the target number to the function and make it a generator function, then you get:This approach is a lot faster than testing all permutations, especially if you need to find all possible factors. Note that I made both functions generators here to even out the comparisons:Note that I generate 10 different random targets, to try to avoid a lucky best-case-scenario hit for either approach.

This is my take on it, which uses :I think your friend may be hinting towards using comprehensions when it makes the code cleaner (sometimes it doesn't).
I can think of using list-comprehension. This also helps to find multiple such-pairs if they exist in the given list.Output:
I came up with this. It reverses the approach a little bit, in that it searches in  for the required pair partner that the iteration value  would multiply to 20 with. This makes the code easier and needs no imports, even if it's not the most efficient way.
You could make it more pythonic by using itertools.combinations, instead of nested loops, to find all pairs of numbers. Not always, but often iterating over indices as in  is less pythonic than directly iterating over values as in .Python also allows you to make your function into a generator via the  keyword so that instead of just returning the first pair that multiplies to 20, you get every pair that does by iterating over the function call.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
https://docs.python.org/3/library/functions.html#next
https://docs.python.org/3/tutorial/classes.html#generators
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
