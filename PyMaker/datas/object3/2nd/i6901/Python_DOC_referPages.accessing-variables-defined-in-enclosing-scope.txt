Natural Text
From the Google Style Guide on lexical scoping:A nested Python function can refer to variables defined in enclosing  functions, but can not assign to them.Both of these seem to check out at first:So why, then, does a combination of both reference and assignment in the nested function lead to an exception?
In first case, you are referring to a  variable which is ok because there is no local variable called .In the second case, you create a local variable  which is also fine (local  will be different than the nonlocal one thats why the original  wasn't changed). In the third case, you create a local variable but you have  before that and that is why the exception is raised. Because  will refer to the local variable  which was created after that line.To achieve what you want, you need to use  inside your inner function:
For anyone stumbling across this question, in addition to the accepted answer here, it is answered concisely in the Python docs:This code:works, but this code:results in an .This is because when you make an assignment to a variable in a scope,  that variable becomes local to that scope and shadows any similarly  named variable in the outer scope. Since the last statement in foo  assigns a new value to , the compiler recognizes it as a local  variable. Consequently when the earlier  attempts to print the  uninitialized local variable and an error results.In the example above you can access the outer scope variable by  declaring it :You can do a similar thing in a nested scope using the   keyword:


Answer URL
https://docs.python.org/3/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value
