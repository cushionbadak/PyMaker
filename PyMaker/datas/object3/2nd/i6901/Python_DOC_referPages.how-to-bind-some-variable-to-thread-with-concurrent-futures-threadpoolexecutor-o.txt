Natural Text
What I want to do is something like this:I got these output:This output is what I want. As you can see, my  is different in different threads, but in single thread, I share the same .( is just one of these variables, I have many other similar variable).Now, I want to do the same thing with But now  will be share by all threads:And with , I also try to do the same thing:Output is this:Of course, I get this result is not strange, because I just call  one time. But what I am asking is that:How can I do the same thing with  and (and also please with no more global variable).
There are a couple of issues going on here, and I will do my best to address all of them.In the first example you give, you have full control over all the s that you create, and so each thread gets a unique ID in the initializer. The problem there is of course that you start all the threads at once, which is probably very inefficient for a large number of threads.In both of the thread pool examples in the question, you initialize the ID once for the callable object, so of course you don't have separate IDs per thread. The correct way to do it would be to initialize an ID per thread, by doing it in the  method:Notice that you can shorten the  example by using the  method there as well, if all you care about is the final result and not the intermediate  objects. The  call is a standard idiom for consuming an iterator.Given the gist you linked to in your comments, I understand why you want to have thread-local data. However, you certainly do not need a global variable to achieve that result. Here are a couple of alternatives:Just add your thread-local data to  in the initializer, and voila, it is accessible to all calls without being global:Use function-local data instead of thread-local data. You are using thread-local data to avoid passing your connection (in the gist) to some private functions. That is not a real need, just an aesthetic choice. You can always have  and , since the only place a connection actually comes from is  anyway.While there may be situations where option #1 is a possibility, I highly recommend that you do not use it with any type of thread pool manager. A thread pool may reuse the same thread to run tasks sequentially from the queue that they are submitted to. This means that you will end up with the same connection in a task that should have opened its own. It would have been fine in your original example, where you create all your threads independently, but it may not be fine when you have multiple calls to  on a recycled pool thread.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor.map
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
https://docs.python.org/3/library/collections.html#collections.deque
https://docs.python.org/3/library/threading.html#thread-local-data
