Natural Text
Im in the process of moving some synchronous code to asyncio using aiohttp. the synchronous code was taking 15 minutes to run, so I'm hoping to improves this.I have some working code which gets data from some urls and returns the body of each. But this is just against 1 lab site, I have 70+ actual sites.So if I got a loop to create a list of all the urls for all sites that would make 700 urls in a list to be processed. Now processing them I don't think is a problem?But doing 'stuff' with the results, I'm not sure how to program? I have code already that will do 'stuff' to each of the results that are returned, but I'm not sure how to program against the right type of result.When the code runs does it process all urls and depending on the time to run, return an unknown order?Do I need a function that will process any type of result?
Here's an example with . If it's created without specifying , the implementation will use  instead. Also note that  is public but undocumented. Alternatively, there's . 
Your code isn't far from the mark.  returns the results in the order of the arguments, so order is preserved here, but  will not be called in order.A few tweaks:First of all, you do not need  here. Creating a Task is only needed if you are trying to have a coroutine outlive its parent, ie if the task has to continue running even though the function that created it is done. Here what you need is instead calling  directly with your coroutines:But calling this would schedule all the fetch at the same time, and with a high number of URLs, this is far from optimal. Instead you should choose a maximum concurrency and ensure at most X fetches are running at any time. To implement this, you can use a , this semaphore can only be acquired by at most 20 coroutines, so the others will wait to acquire until a spot is available.This way, all the fetches are started immediately, but only 20 of them will be able to acquire the semaphore. The others will block at the first  instruction and wait until another fetch is done.I have also replaced the aiohttp.Timeout with the official asyncio equivalent here.Finally, for the actual processing of the data, if you are limited by CPU time, asyncio will probably not help you much. You will need to use a  here to parallelise the actual work to another CPU.  will probably be of use to.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor
