Natural Text
I want to write a function that compares the first element of this list with the last element of this list, the second element of this list with the second last element of this list, and so on. If the compared elements are the same, I want to add the element to a new list. Finally, I'd like to print this new list.For example,I was thinking to take the first (i) and last (k) element, compare them, then raise i but lower k, then repeat the process. When i and k 'overlap', stop, and print the list. I've tried to visualise my thoughts in the following code:Please let me know if there are any errors in my code, or if there is a more suitable way to address the problem.As I am new to Python, I am not very good with understanding complicated terminology/features of Python. As such, it would be encouraged if you took this into account in your answer.
You could use a conditional list comprehension with , comparing the element  at index  to the element at index  ( being the last index of the list):Or, as already suggested in other answers, use . However, it is enough to slice the first argument; the second one can just be the  list, as  will stop once one of the argument lists is finished, making the code a bit shorter.In both approaches,  is equivalent to .
maybe you want something like for even length of list:And for odd length of list :so you can create a function :and use it this way :
What you can do is zip over the first half and the second half reversed and use list comprehensions to build a list of the same ones:What happens is that you take the first half and iterate over those as element_1, the second half reversed as element_2 and then only add them if they are the same:If you also want to include the middle element in the case of an odd list, we can just extend our lists to both include the middle element, which will always evaluate as the same:
Here is my solution:There is a lot going on, so let me explain step by step: is the first half of the list plus an extra element (which is useful for lists of odd lengths) is the second half of the list, reversed ()zip creates a list of pairs from two lists. it stops at the end of the shortest list. We use this in the case the length of the list is even, so the extra term in the first half is neglectedList comprehension essentially equivalent to a for loop, but useful to create a list "on the fly". It will return an element only if the if condition is true, otherwise it will pass.You can easily modify the solution above if you are interested in the indexes (of the first half) where the match occurs:
You can use the following which leverages from :On :Normally,  stops ping when one of its iterators run out.  does not have that limitation and it simply keeps on ping by adding dummy values.Example:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
