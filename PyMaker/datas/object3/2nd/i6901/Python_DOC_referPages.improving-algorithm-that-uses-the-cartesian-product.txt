Natural Text
ProblemSay you have  lists of integers, where each list only includes integers in the range from  to . For example, for , we might have:Now my question is: Can I tick off all the integers between  and  in those  lists but with the catch that once I find one number, I can't use that list anymore to find subsequent numbers?For example, in the above example with , I can choose 1 from , 2 from , 3 from , and 4 for , and I have therefore filled all the numbers from 1 to 4 but only using each list once.An example where I can't find the range (and hence should return ) would be:The reason is because if I choose 1 from a_1, I can't choose 2 anymore from any list.ApproachThis is my current straightforward approach. I make a cartesian product of the lists and check if there is any that, sorted, will be a range. QuestionAlthough my approach works, for large lists it becomes a bit inefficient. Any thoughts on how I can improve this algorithm?Thanks!
You can formulate this as a maximum flow problem in a bipartite graph where the left nodes correspond to lists, and the right nodes correspond to integers 1 to n.There is an edge in the graph iff the integer is in the corresponding list.All capacities in the graph are equal to 1.If you can find a flow of size n from the left side to the right side then the problem is soluble.Python code to do this below:This prints:
Instead of testing all the combinations in order, you can speed this up a lot by testing the most-constrained lists first, and also updating the alternatives in the other lists as you add elements to your solution set. This way, you can "solve" both your examples without backtracking once.Here's some debugging/tracing output for your two examples to help with the understanding. First value is , then the , and finally the previously chosen .If you also want the indices of the lists the elements have been taken from, the code gets a little more complicated, but not much:Result for your first example then is 
The cartesian product seems the most straightforward to me. I would do the following to streamline your code:remove []'s from your  expression as I mentioned in the commentscollapse all input lists to sets before computing cartesian product - there is no point in processing duplicate values from the same listsave  to a local variable and compare with that instead of recreating the range each time (this is a common optimization technique called "invariant lifting", in which a computed expression that doesn't change during the loop is "lifted" out of the loop and just computed once)But ultimately, the basic algorithm of computing a cartesian of your input lists, and then looking for any which are the values 1-n is still as you originally wrote.
This can be seen as a problem of matching in a bipartite graph. As it turns out, Hall's marriage theorem tells you the answer (that is, whether the matching exists, not the matching itself). Here is a possible implementation (using NumPy for convenience):However, this requires you to go through every subset of , so I guess the algorithm is O(2N). Not great, but maybe better than going through the whole Cartesian product, which I guess would be O(NN).
You could try mapping which values occur in which list, and decompose your problem from there. This code builds that sort of reverse-lookup:For instance, you can see at a glance, that 4 exists only in  (that is  in your original question). From there, if you eliminate 2 from the other values, 1 exists only in . Eliminating 0 shows that 2 only exists in , and 3 then can only be gotten from . If in doing this successive elimination, any of the sets to select from becomes empty, then there is no solution.


Answer URL
