Natural Text
To be exact, it does not update until everything it contains has been read(but only if the stream has been read at least once), which makes it effectively dysfunctional.Pardon the weird example, but I'm presently trying to write a simple graphical ping monitor:In this example, when you click, the subprocess is polled to see if a new line(containing output ping, or timeout message) is available. If you run the project and begin clicking immediately, you will notice that output of  has stopped updating and is always .I have also tried an alternative method of checking the length of 's output, but it is apparently never equal to zero, so that is worthless as well.Further, I attempted to invoke  method of the stream, but it does not appear to in any way help the situation eitherThe final result is that  appears to be dysfunctional, and not usable for its intended purpose of peeking into the output bufer, but Python is a mature language, and I would not expect to find this kind of bug in it, is there anything I am missing? If not, how can I work around this issue?
Answerjust use  method. if no line exists it returns empty bytes object - example usage of :this will output (on python3):for your case this is updated  func (also changed the regex a bit)Non-Blockingif you care from blocking operations, please take a look at this so answeryou can use the  module on unix to read from stdout in non-blocking fashion or run background thread to update a buffer for reading.Example using thread for bufferingSuggestionsuse an existing python lib for ping instead of parsing stdout. some libs requires to run as root under linux, this might be a limitation for you.send one ping at a time instead of long running background ping process. that way you can use .avoid using  on , passing unsanitized input to it may lead to command injection.
@Llamageddon I think the filepointer needs to be moved to refresh the buffer in the if not has_line check using a . Peek doesn't advance the pointer so you've essentially got a bug that will keep "peaking" at an empty filebuffer.re:  can be used to look at large file buffers and perhaps is not a good use for your work considering the response size; however, I think a good example when  is not "dysfunctional, and not usable" :) is when the line in the buffer is 100,000 characters long and looking at the first 100 characters will be sufficient to evaluate what to do with the line (i.e. skip it or apply additional logic).  Peak would allow us to perform the look and evaluate all while minimizing the block time.


Answer URL
https://docs.python.org/3/library/io.html#io.IOBase.readline
