Natural Text
I have a  object that is used to contain the read and write streams of  connections:On the server side,  creates a  object every time a client connects, then reads 4 bytes.And on the client side, 4 bytes are written out.This works almost as expected, but I have to  every  and  call. I've tried ing from inside :But rather than getting data, I get an output likeIf I call  and  from multiple places, I would prefer not to repeat the s every time; rather keeping them inside . My ultimate goal is cut down my  function to this:
Because  is a coroutine, your only options for calling it are a) wrapping it in a  or  and running that via an event loop, b) ing it from coroutine defined with , or c) using  with it from a coroutine defined as a function decorated with .Since  is called from an event loop (via the coroutine ), you can't reuse that event loop to run a  or  for : event loops can't be started while they're already running. You'd either have to stop the event loop (disastrous and probably not possible to do correctly) or create a new event loop (messy and defeating the purpose of using coroutines). Neither of those are desirable, so  needs to be a coroutine or an  function.The other two options ( in an  coroutine or  in a -decorated function) are mostly equivalent. The only difference is that  and  were added in Python 3.5, so for 3.4, using  and  is the only option (coroutines and  didn't exist prior to 3.4, so other versions are irrelevant). Personally, I prefer using  and , because defining coroutines with  is cleaner and clearer than with the decorator.In brief: have  and  be coroutines (using either the decorator or the  keyword), and use  (or ) when calling other coroutines ( in , and  in ).
I found a chunk of the StreamReader source code on line 620 is actually a perfect example of the function's usage.In my previous answer, I overlooked the fact that  is not only a coroutine (which I should've known considering it was from the  module XD) but it yields a result on line . So it is in fact a generator, and you will need to yield from it.Borrowing this loop from the source code, your read function should look something like this:Because  is a generator, you have to continue to yield from it until it yields an empty result to signal the end of the read. Now your read function should return data rather than a generator. You won't have to yield from this version of .


Answer URL
https://docs.python.org/3/library/asyncio-stream.html#asyncio.StreamReader.read
https://docs.python.org/3/library/asyncio-task.html#task
https://docs.python.org/3/library/asyncio-task.html#future
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.stop
https://docs.python.org/3/library/asyncio-eventloops.html#asyncio.new_event_loop
