Natural Text
I have created a (rather large) program that takes quite a long time to finish, and I started looking into ways to speed up the program.I found that if I open task manager while the program is running only one core is being used.After some research, I found this website: Why does multiprocessing use only a single core after I import numpy? which gives a solution of , however this doesn't work for me, and my program continues to run on a single core.I then found this: is python capable of running on multiple cores?, which pointed towards using multiprocessing.So after looking into multiprocessing, I came across this documentary on how to use it https://docs.python.org/3/library/multiprocessing.html#examplesI tried the code:After running the code (not in IDLE) It said this: Note: after it said Finished the first time I pressed enterSo after this I am now even more confused and I have two questionsFirst: It still doesn't run with multiple cores (I have an 8 core Intel i7)Second: Why does it input "Finished" before its even run the if statement code (and it's not even finished yet!)
To answer your second question first, "Finished" is printed to the terminal because  is outside of your  code block.  It is thus a module level constant which gets assigned when the module is first loaded and will execute before any code in the module runs.To answer the first question, you only created one process which you run and then wait to complete before continuing.  This gives you zero benefits of multiprocessing and incurs overhead of creating the new process.Because you want to create several processes, you need to create a pool via a collection of some sort (e.g. a python list) and then start all of the processes.In practice, you need to be concerned with more than the number of processors (such as the amount of available memory, the ability to restart workers that crash, etc.).  However, here is a simple example that completes your task above.Also note that if you join workers immediately after starting them, you are waiting for each worker to complete its task before starting the next worker.  This is generally undesirable unless the ordering of the tasks must be sequential.Typically WrongUsually DesiredFor more information, please refer to the following links:https://docs.python.org/3/library/multiprocessing.htmlDead simple example of using Multiprocessing Queue, Pool and Lockinghttps://pymotw.com/2/multiprocessing/basics.htmlhttps://pymotw.com/2/multiprocessing/communication.htmlhttps://pymotw.com/2/multiprocessing/mapreduce.html


Answer URL
https://docs.python.org/3/library/multiprocessing.html#examples
https://docs.python.org/3/library/multiprocessing.html
