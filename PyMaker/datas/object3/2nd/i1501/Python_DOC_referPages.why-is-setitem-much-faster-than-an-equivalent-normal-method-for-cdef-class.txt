Natural Text
It looks like, for Cython's cdef-classes, using class special methods is sometimes faster than identical "usual" method, for example  is 3 times faster than :and now:This neither the "normal" behavior for Python, for which the special functions are even somewhat slower (and obviosly slower than the Cython-equivalent):nor this is the case in Cython for all special functions:which leads to:i.e. almost identical running times.Why is  so much faster, than  in a cdef-class, even if both are cythonized?
There's quite a bit of overhead for a generic Python method call - Python looks up the relevant attribute (a dictionary lookup), ensures that the attribute is a callable object, and once it's called handles the result. This overhead also applies to generic  functions for  classes (the only difference being is that the implementation of the method is defined in C).However, special methods on C/Cython classes can be optimised, as follows:Lookup speedAs a shortcut, in the Python C API defines a number of different "slots" - direct function pointers for special methods. For  there's actually two available:  which corresponds to a generic "mapping" call, and , which lets you use an int as the indexer directly and corresponds to the C API function .For a , Cython only seems to generate the first (generic) one, so the speedup isn't from passing a C  directly. Cython does not fill these slots when generating a non- class.The advantage of these is that (for a C/Cython class) finding the  function just involves a couple of pointer NULL checks followed by a C function call. This also applies to  which is also defined by slots in In contrast,for a Python class calling , it instead uses a default implementation which does a dictionary lookup for the string .For either a  or Python class calling a non-special  function, the attribute is looked up from the class/instance dictionary (which is slower)Note that if the  regular function were to be defined in a  as  instead (and called from Cython) then Cython implements its own mechanism for a speedy lookup.Calling efficiencyHaving found the attribute it must be called. Where the special functions have been retrieved from  (e.g.  and  on a ), they are simply C function pointers and so can be called directly.For every other case the  retrieved from attribute lookup must evaluated to see if it's a callable, then called.Return handlingWhen  is called from  as a special function the return value is an int, which is simply used as an error flag. No reference counting or handling of Python objects is needed.When  is called from a  as a special function, the return type is a , which must be converted to a Python object and then destroyed when no longer needed.For normal functions (e.g.  called from a Python or Cython class, or  defined in a Python class), the return value is a , which must be reference counted/destroyed appropriately.In summary,  the difference is really to do with shortcuts in finding and calling the function rather than whether the contents of the function is Cythonized.
@DavidW's answer hits the nail on the head, here are some more experiments and details which corroborate his answer.Calling a special function which returns Â´None`is fast, no matter how many arguments:and nowThe signature of the functions is known, there is no need to construct , . The look-up in the slot is as fast as it gets.Overhead of calling a normal function depends on the number of arguments:and now:The overhead is bigger than for calling of methods from slots, but also bigger if there have (at least) two arguments (not taking  into account):  vs .The reason: cython-methods can be one of the following types - only with argument  - only with  + one argument - with arbitrary number of elementsThe method  is of third type, thus in order to be called it Python has to construct list , which leads to additional overhead.** Returning from a special method can have more overhead as from normal method":leads to:As @DavidW has pointed out, for , in every call a "new" int-object must be constructed from returned  (in the case of  it is an integer from the pool, so it is not really constructed - but it were in case of bigger numbers).This is not the case for : for this special implementation, Cython initializes a global object, which is returned by  - increasing the reference counter doesn't cost much (compared to creating an integer!).Thus, both  and  run approximately equally fast - but the time is spent for different things (creating integer vs. lookup overhead).


Answer URL
https://docs.python.org/3/c-api/typeobj.html#c.PyMappingMethods.mp_ass_subscript
https://docs.python.org/3/c-api/typeobj.html#c.PySequenceMethods.sq_ass_item
https://docs.python.org/3/c-api/sequence.html#c.PySequence_SetItem
https://docs.python.org/3/c-api/structures.html#METH_NOARGS
https://docs.python.org/3/c-api/structures.html#METH_O
https://docs.python.org/3/c-api/structures.html#METH_VARARGS
