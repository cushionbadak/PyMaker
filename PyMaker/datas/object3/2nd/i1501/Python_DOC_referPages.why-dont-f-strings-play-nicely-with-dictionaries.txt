Natural Text
f-strings don't behave nicely when used with dictionaries, as mentioned here.Here is an example of the not-so-nice behavior:The last two f-strings listed result in a , which happens because the string  is evaluated as foo. What is the underlying reason everything inside the curly brackets of f-strings doesn't get evaluated separately, as when using the old  method, and what could possibly be the reason for implementing f-strings in this way?I love f-strings, but this seems like a point in favor of the old method. 
One traditional way of including quotes within quotes is to use a backslash. But PEP498 forbids backslashes in expressions within f-strings:Backslashes may not appear inside the expression portions of  f-strings...You can use a different type of quote inside the expression...Therefore, the only way left to access a dictionary value given a key in an f-string expression is to use a different type quote. Using single quotes, or double quotes, everywhere is ambiguous and gives . is a regular method, and as such works differently:  is evaluated before the string is constructed. Just like when you feed arguments to a function, the arguments are evaluated before the function does anything.
This has nothing to do with -strings.  strings are common strings once evaluated. What you are trying would be a problem with standard strings tooThe problem is that is declares the literal while the quotes close and reopen. So, it is equivalent to string , followed by variable , followed by string .That's the whole reason python supports both types of quotation marks


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.format
