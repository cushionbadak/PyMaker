Natural Text
I need to dynamically load several potentially unsafe modules for testing purpose.Regarding security, my script is executed by a low-access user.Although, I still need a way to elegantly make the import process timeout as I have no guarantee that the module script will terminate. By example, it could contain a call to  or an infinite loop.I am currently using  with a , but this does not fully solve the issue since the script is then still alive in the background and there is no way to kill a thread.How can I import a module, but return  if the script timeouts?
You can't reliably kill importing a module. You are essentially executing live code in your own interpreter, so all bets are off.Never import untrusted codeFirst of all, there is no way to safely import unsafe modules from an untrusted source. It doesn't matter if you are using a low-access user. NEVER IMPORT UNTRUSTED CODE. The moment the code is imported it could have exploited security holes in your system well beyond the Python process itself. Python is a general purpose programming language, not a sandboxed environment, and any code you import has the full run of your systemInstead of using a low-access user, at the very least run this is a virtual machine. The virtual machine environment can be set up from a known-good snapshot, without network access, and be shut down when a time limit has been reached. You can then compare the snapshots to see what, if anything, the code has attempted to do. Any security breach at that level is short-lived and without value. Also see Best practices for execution of untrusted code over on Software Engineering Stack Exchange.You can't stop the code from undoing your workNext, because you can't control what the imported code does, it can trivially interfere with any attempts to time out the code. The first thing the imported code could do is revoke the protections you put in place! Imported code can access all of Python's global state, including the code that triggered the import. The code could set the thread switch interval to the maximum value (internally, an unsigned long modelling milliseconds, so the max is  milliseconds, just a smidgen under 71 minutes 35 seconds) to mess with scheduling.You can't stop threads, reliably, if they don't want to be stoppedExiting a thread in Python is handled by raising a exception:Raise the  exception. When not caught, this will cause the thread to exit silently.(Bold emphasis mine.)From pure Python code, you can only exit a thread from code running in that thread, but there is a way around this, see below.But you can't guarantee that the code you are importing isn't just catching and handling all exceptions; if that's the case, the code will just keep on running. At that point it becomes a weapons race; can your thread manage to insert the exception at the point the other thread is inside an exception handler? Then you can exit that thread, otherwise, you lose. You'd have to keep trying until you succeed.A thread that waits on blocking I/O or started a blocking operation in a native extension can't (easily) be killedIf the code you import waits on blocking I/O (such as an  call) then you can't interrupt that call. Raising an exception does nothing, and you can't use signals (as Python handles those on the main thread only). You'd have to find and close every open I/O channel they could be blocked on. This is outside of the scope of my answer here, there are just too many ways to start I/O operations.If the code started something implemented in native code (a Python extension) and that blocks, all bets are off entirely.Your interpreter state can be hosed by the time you stop themThe code you import could have done anything by the time you managed to stop them. Imported modules could have been replaced. Source code on disk can have been altered. You can't be certain that no other threads have been started. Anything is possible in Python, so assume that it has happened.If you wanted to do this, anywayWith those caveats in mind, so you accept thatThe code you import can do malicious things to the OS they are running in, without you being able to stop them from within the same process or even OSThe code you import could stop your code from working.The code you import might have imported and started things you didn't want importing or started.The code might start operations that prevent you from stopping the thread altogetherthen you can time out imports by running them in a separate thread, and then raise a  exception in the thread. You can raise exceptions in another thread by calling the  C-API function via the  object. The Python test suite actually uses this path in a test, I used that as a template for my solution below.So here is a full implementation that does just that, and raises an custom  exception (a subclass of ) if the import could not be interrupted. If the import raised an exception, then that exception is re-raised in the thread that started the import process:If the code can't be killed, it'll be running in a daemon thread, meaning you can at least exit Python gracefully.Use it like this:for a default 5 second timeout, and a 1 second wait to see if the import really is unkillable.


Answer URL
https://docs.python.org/3/library/sys.html#sys.setswitchinterval
https://docs.python.org/3/library/_thread.html#_thread.exit
https://docs.python.org/3/c-api/init.html#c.PyThreadState_SetAsyncExc
https://docs.python.org/3/library/ctypes.html#accessing-values-exported-from-dlls
