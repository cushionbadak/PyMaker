Natural Text
Every recipe that I've found for creating a daemon process in Python involves forking twice (for Unix) and then closing all open file descriptors. (See http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/ for an example).This is all simple enough but I seem to have an issue. On the production machine that I am setting up, my daemon is aborting - silently since all open file descriptors were closed. I am having a tricky time debugging the issue currently and am wondering what the proper way to catch and log these errors are.What is the right way to setup logging such that it continues to work after daemonizing? Do I just call  a second time after daemonizing? What's the right way to capture  and ? I am fuzzy on the details of why all the files are closed. Ideally, my main code could just call  and logging would continue to work.
I use the  library for my daemonization behavior. Interface described here: http://www.python.org/dev/peps/pep-3143/Implementation here:http://pypi.python.org/pypi/python-daemon/It allows specifying a  argument, to indicate any file descriptors that should not be closed when daemonizing.If you need logging via the same  instances before and after daemonizing, you can:First set up your logging Handlers using  or  or whatever.Log stuffDetermine what file descriptors your s depend on. Unfortunately this is dependent on the  subclass. If your first-installed  is a , it's the value of ; if your second-installed  is a , you want the value of ; etc. This is messy :-(Daemonize your process by creating a  with  equal to a list of the file descriptors you determined in step 3.Continue logging; your log files should not have been closed during the double-fork.An alternative might be, as @Exelian suggested, to actually use different  instances before and after the daemonziation. Immediately after daemonizing, destroy the existing handlers (by ing them from ?) and create identical new ones; you can't just re-call  because of the issue that @dave-mankoff pointed out.
You can simplify the code for this if you set up your logging handler objects separately from your root logger object, and then add the handler objects as an independent step rather than doing it all at one time.  The following should work for you.
We just had a similar issue, and due to some things beyond my control, the daemon stuff was separate from the stuff creating the logger. However, logger has a .handlers and .parent attributes that make it possible with something like:


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-with-statement
