Natural Text
I've been reading about magic methods in python, and I've found a lot of info about overriding them   and what purpose they serve, but I haven't been able to find where in the language specific operators and actions are mapped to those methods ( looks for ,  looks for , creating a new object from a class might call  and , etc.)  Is there somewhere I can see what happens when the python interpreter (or whatever lower level mechanism) encounters a plus sign?  
Your question is a bit generic. There is a comprehensive list of "special methods", even though it misses some stdlib specific methods(e.g.  and  used by  etc. But it's a protocol of the module  not a language protocol).If you want to know exactly what the interpreter does you can use the  module to disassemble the bytecode:You can see that the intereper executes a  byte code when doing addition.If you want to see exactly the operations that  does you can download Python's source code and check the  file:So here we can see that python special cases int and string additions, and eventually falls back to , which checks if the first operand implements  and calls it, eventually it tries  of the right hand side and if nothing works raises a .Note that the byte codes are version-specific, so  will show different results on different versions:Also the same byte code may be optimized in future versions, so even if the byte code is the same different versions of python will actually perform different instructions.If you're interested in learning how python works behind the scenes I'd advise you to write some C extensions, following the tutorials and documentation that you can find on the official python's website.
 module can somewhat help you on this:let's take an example of simple list:
It's non-trivial to pinpoint the single place in CPython sources mapping operator  to special method  because of the levels of abstraction involved.As other responded,  is implemented with the  operand, which calls  (except for some specially optimizedd cases). , on the other hand, looks at the  member of the type object to get to the  struct whose  member points to the C function that implements addition.This is all clear for built-in types which define their own , but how does your , defined in Python, translate to a function pointer stored in ? This part is handled by : when you define a class that implements , the machinery in  installs into  a generic function that looks up  on the object and calls it to implement the addition. For the case of , this generic function is called  and is defined using the  macro.As for  and , they are invoked from the  operator of the  object itself ( in CPython-implementation lingo). This is only logical, since in Python you are calling the type to construct an object.
http://docs.python.org/2/library/dis.htmlwhich returns something like thats the closest you will come to "low level"
You may want to check out this portion of the documentation:http://docs.python.org/3/reference/datamodel.html#special-method-names


Answer URL
