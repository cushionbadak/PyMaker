Natural Text
For example, list  consists of: 3 of , 4 of , 3 of , 5 of ...Now I want it to be like this:What's the fastest way to do this? 
Presuming I am understanding what you want, it can be done relatively easily by combining ,  and :We first group the items into sets (the s, the s, etc...), we zip them up to get them in the order your want (one from each set), use chain to produce a single list, and then remove the  values introduced by the zipping.You may want to separate out some of the list comprehensions to make it a bit more readable, however:(The given version is for 3.x, for 2.x, you will want .)As always, if you expect empty strings, 0, etc... then you will want to do , and if you need to keep  values in tact, create a sentinel object and check for identity against that.You could also use the  recipe given in the docs, as an alternative to zipping, which makes it as simple as:As a final note, the observant might note me making lists from the  generators, which may seem wasteful, the reason comes from the docs:The returned group is itself an iterator that shares the underlying  iterable with groupby(). Because the source is shared, when the  groupby() object is advanced, the previous group is no longer visible.  So, if that data is needed later, it should be stored as a list.
Now,  looks like this:Hope this helps
I'm not sure if this is fastest, but here's my stab at it:wrapped up in a function:Of course, this requires that the elements in your iterable be hashable.
A bit less elegant than Lattyware's:
Doing it "by hand and state machinne" should be way more efficient - but for relatively small lists (<5000), you should have no problem taking vantage of Python goodies doing this:The "big O" complexity of the function above should be really BIG. I had not event ried to figure it out.


Answer URL
