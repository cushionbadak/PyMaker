Natural Text
How do I restrict a class member variable to be a specific type in Python?Longer version:I have a class that has several member variables which are set externally to the class. Due to the way they're used, they must be of specific types, either int or list. If this was C++, I would simply make them private and do type-checking in the 'set' function. Given that that isn't possible, is there any way to restrict the type of the variables so that an error/exception occurs at runtime if they're assigned a value of incorrect type? Or do I need to check their type within every function that uses them?Thanks.
You can use a property like the other answers put it -so, if you want to constraina single attribute, say "bar",and constrain it to an integer, you could write code like this:And this works:(There is also a new way of writing properties, using the "property" built-in as a decorator to the getter method - but I prefer the old way, like I put it above).Of course, if you have lots of attributes on your classes, and want to protect all of them in this way, it starts to get verbose. Nothing to worry about - Python's introspection abilities allow one to create a class decorator that could automate this with a minimum of lines.And you just use as a class decorator, and declar theattributes you want in the class body to be equal to the types the attributes need to constrain too:
In general, this is not a good idea for the reasons that @yak mentioned in his comment. You are basically preventing the user from supplying valid arguments that have the correct attributes/behavior but are not in the inheritance tree you hard-coded in.Disclaimer aside, there are a few of options available for what you are trying to do. The main issue is that there are no private attributes in Python. So if you just have a plain old object reference, say , you can not guarantee that the user won't set it directly even though you have provided a setter that does type checking for it. The options below demonstrate how to really enforce the type checking.Override __setattr__This method will only be convenient for a (very) small number of attributes that you do this to. The  method is what gets called when you use dot notation to assign a regular attribute. For example,If we now do , it would call  under the hood. In fact,  in  uses  as well. You can use this to enforce the type check:The disadvantage of this method is that you have to have a separate  for each type you want to check (or  to check multiple names for a given type). The advantage is that it is the most straightforward way to make it nearly impossible for the user to circumvent the type check.Make a propertyProperties are objects that replace your normal attribute with a descriptor object (usually by using a decorator). Descriptors can have  and  methods that customize how the underlying attribute is accessed. This is sort of like taking the corresponding  branch in  and putting it into a method that will run just for that attribute. Here is an example:A slightly different way of doing the same thing can be found in @jsbueno's answer.While using a property this way is nifty and mostly solves the problem, it does present a couple of issues. The first is that you have a "private"  attribute that the user can modify directly, bypassing your type check. This is almost the same problem as using a plain getter and setter, except that now  is accessible as the "correct" attribute that redirects to the setter behind the scenes, making it less likely that the user will mess with . The second issue is that you have a superfluous getter to make the property work as read-write. These issues are the subject of this question.Create a True Setter-Only DescriptorThis solution is probably the most robust overall. It is suggested in the accepted answer to the question mentioned above. Basically, instead of using a property, which has a bunch of frills and conveniences that you can not get rid of, create your own descriptor (and decorator) and use that for any attributes that require type checking:The setter stashes the actual value directly into the  of the instance to avoid recursing into itself indefinitely. This makes it possible to get the attribute's value without supplying an explicit getter. Since the descriptor  does not have the  method, the search will continue until it finds the attribute in . This ensures that all sets go through the descriptor/setter while gets allow direct access to the attribute value.If you have a large number of attributes that require a check like this, you can move the line  into the descriptor's  method:UpdatePython3.6 does this for you almost out-of the box: https://docs.python.org/3.6/whatsnew/3.6.html#pep-487-descriptor-protocol-enhancementsTL;DRFor a very small number of attributes that need type-checking, override  directly. For a larger number of attributes, use the setter-only descriptor as shown above. Using properties directly for this sort of application introduces more problems than it solves.
Since Python 3.5, you can use type-hints to indicate that a class attribute should be of a particular type. Then, you could include something like MyPy as part of your continuous integration process to check that all the type contracts are respected.For example, for the following Python script:MyPy would give the following error:If you want types to be enforced at runtime, you could use the enforce package.From the README:
Note 1: @Blckknght thank you for your fair comment. I missed recursion issue in my much too simple test suite.Note 2: I wrote this answer when I was at the very beginning of learning Python. Right now I would rather use Python's descriptors, see e.g link1, link2.Thanks to the previous posts and some thinking, I believe I have figured out a much more user-friendly way of how to restrict a class attribute to be of specific type.First of all, we create a function, which universally tests for type:Then we simply use and apply it in our classes via setter. I think this is relatively simple and follow DRY, especially once you export it to a separate module to feed your whole project. See the example below:The tests produce reasonable results. See first the tests:And the tests result:
You can use same type of  as you mention in C++. You will get help for property from http://adam.gomaa.us/blog/2008/aug/11/the-python-property-builtin/. 
You can do it exactly as you say you said you would do it in C++; make assignment to them go through a setter method, and have the setter method check the type. The concepts of "private state" and "public interfaces" in Python are done with documentation and convention, and it's pretty much impossible to force anyone to use your setter rather than directly assign the variable. But if you give the attributes names beginning with an underscore and document the setters as the way to use your class, that should do it (don't use  with two underscores; it's almost always more trouble than it's worth unless you're actually in the situation they're designed for, which is clashing attribute names in an inheritance hierarchy). Only particularly obtuse developers will avoid the easy way of using the class the way it's documented to work in favour of figuring out what the internal names are and using them directly; or developers who are frustrated by your class behaving unusually (for Python) and not allowing them to use a custom list-like class in place of a list.You can use properties, as other answers have described, to do this while still making it look like you're assigning to attributes directly.Personally, I find attempts to enforce type safety in Python to be pretty useless. Not because I think static type checking is always inferior, but because even if you could add type requirements on your Python variables that worked 100% of the time, they just won't be effective in maintaining the assurance that your program is free of type errors because they will only raise exceptions at runtime.Think about it; when your statically compiled program successfully compiles with no errors, you know that it is completely free of all the bugs that the compiler can detect (in the case of languages like Haskell or Mercury that's a pretty good guarantee, though still not complete; in the case of languages like C++ or Java... meh).But in Python, the type error will only be noticed if it is ever executed. This means, even if you could get full static type enforcement everywhere in your program, you need to be regularly executing test suites with 100% code coverage to actually know your program is free of type errors. But if you had regularly executed tests with full coverage you'd know if you had any type errors, even without attempting to enforce types! So the benefit just really doesn't seem worth it to me. You're throwing away Python's strength (flexibility) without gaining more than a trifle in one of its weaknesses (static error detection).
I know this discussion has been settled, but a much simpler solution is to use the Python Structure module show below.  This would require you to make a container for your data before you assign a value to it, but it is very effective at keeping the data type static.  https://pypi.python.org/pypi/structures


Answer URL
https://docs.python.org/3/library/typing.html
