Natural Text
I'm trying to write my "personal" python version of STL binary file reader, according to WIKIPEDIA : A binary STL file contains :an 80-character (byte) headern which is generally ignored.a 4-byte unsigned integer indicating the number of triangular facets in the file.Each triangle is described by twelve 32-bit floating-point numbers: three for the normal and then three for the X/Y/Z coordinate of each vertex – just as with the ASCII version of STL. After these follows a 2-byte ("short") unsigned integer that is the "attribute byte count" – in the standard format, this should be zero because most software does not understand anything else. --Floating-point numbers are represented as IEEE floating-point numbers and are assumed to be little-endian--Here is my code :The output is :It represents an unsigned integer, I need to convert it without using any package (struct,stl...). Are there any (basic) rules to do it ?, I don't know what does \x mean ? How does \x90 represent one byte ? most of the answers in google mention "C structs", but I don't know nothing about C.Thank you for your time.
The typical way to interpret an integer is to use , like so:If you are allergic to , then you can also compute it by hand:As to what you are seeing when you print . You are printing a  object, which is an array of integers in the range [0-255]. The first integer has the value 144 (decimal) or 90 (hexadecimal). When printing a  object, that value is represented by the string . The 2nd has the value eight, represented by . The 3rd and final integers are both zero. They are presented by .If you would like to see a more familiar representation of the integers, try:To compute the 32-bit integers represented by these four 8-bit integers, you can use this formula:Or, in hex:Which results in:Perhaps you can see the similarities to decimal, where the string "1234" represents the number:
Since you're using Python 3, you can use . I'm guessing the value is stored little-endian, so you'd just do:Change the second argument to  if it's supposed to be big-endian.Mind you, the normal way to parse a fixed width type is the  module, but apparently you've ruled that out.For the confusion over the ,  objects will display ASCII printable characters (e.g. ) or standard ASCII escapes (e.g. ) if the byte value corresponds to one of them. If it doesn't, it uses , where  is the hexadecimal representation of the byte value, so  represents the byte with value 0x90, or 144. You need to combine the byte values at offsets to reconstruct the , but  does this for you faster than any hand-rolled solution could.Update: Since apparent  isn't "basic" enough, a couple more complex, but only using top-level built-ins (not alternate constructors) solutions. For little-endian, you can do this:You can use the same solution for big-endian by adding  to the loop, making it , or you can use this alternative solution that handles the offset adjustment a different way:Again, this big-endian solution can trivially work for little-endian by looping over  instead of . In both cases  is an alternative to  (the former makes a new  in reversed order and iterates that, the latter iterates the existing bytes object in reverse, but unless it's a huge  object, enough to strain RAM if you copy it, the difference is pretty minimal).


Answer URL
https://docs.python.org/3/library/stdtypes.html#int.from_bytes
