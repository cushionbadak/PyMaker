Natural Text
I have an infinite loop in which there are operations that are mandatory to be completely executed before exiting the loop. Namely, I am using the socket library for connecting to an external device and I need to wait the read instructions to be finished before interrupting the loop.I have tried using a signal handler (like in this question) for raising a flag when a Keyboard interrupt is detected. Current code:In the previous code, videosensor.VideoSensor is a class containing socket operations for getting data from an external device. The get_register() method used in the main routine is the following:The problem:I wanted the while loop to be continually  executed until the user pressed a key or used the Keyboard Interrupt, but after the current iteration was finished. Instead, using the previous solution does not work as desired, as it interrupts the ongoing instruction, and if it is reading the socket, an error is raised:/home/.../client.pyc  in read_register(self, regkey)error: [Errno 4] Interrupted system EDIT: It seems, from an answer below, that there is no way of using the Keyboard Interrupt and avoid the socket read function to be aborted. Despite there are solutions for catching the error, they don't avoid the read cancellation.I am interested, though, in finding a way of getting a user input e.g. specific key press, that raises the flag, which will be checked at the end of the loop, without interrupting the main routine execution until this check.EDIT2: The used OS is the Linux distribution Ubuntu 14.04
After quick SO search I found this solution for your issueBasically, there's nothing you can do: when you send a SIGINT to your process, the socket will return a SIGINT as well. The best you can do, then, is to actively ignore the issue, by catching the socket  error and going on with your loop:An alternative solution to avoid issues with  breaking reads, is to use parallel execution, to read your socket in a routine, and handle user input on the other:or with threadingor with multiprocessing:disclaimer: those codes are untested, and there might be some typos or little errors, but I believe the overall logic should be ðŸ‘Œ
You created your custom signal handler but did not overide the default keyboard interrupt behaviour. Add  to your code to accomplish this:
If I understand correctly, you do not want  to be interrupted, but you do want to use signals to let the user indicate that the I/O loop should be terminated once the current I/O operation has completed.With the assumption that you are using Python 2 on a Unix system, you can solve your problem by calling  before entering the loop. This will cause system calls to be restarted when a signal occurs rather than interrupting it and raising an exception.In your case this means that the  operation will be restarted after your signal handler is called and therefore  will not return until a message is received on the socket. If that is what you want your code will be:That's one way to do it, but it does require that your code is running on a Unix platform.Another way, which might work on other platforms, is to handle the exception, ignore further  signals (in case the user hits interrupt again), and then perform a final  before returning from the  function:Signal handling can get tricky and there might be race conditions in the above that I am not aware of. Try to use  if possible.


Answer URL
https://docs.python.org/3/library/signal.html#signal.siginterrupt
