Natural Text
When a function is assigned to an attribute during class definition, this attribute stays an ordinary function with its original signature:When the class is instantiated, this attribute becomes a bound method and its signature changes:I need to define a class that I can later customize by changing some attributes before instantiating. One of these attributes is a function and I need it to keep it's signature.Using  is obviously not an option, since no function is defined on  class definition/customization, and decorations dont apply to attributes.Is there any way to keep a function to be transformed into a bound method on instantiation? 
Using @staticmethod is obviously not an option, since no function is defined on class definition/customization, and decorations dont apply to attributes.No,  is the option, just call it directly to produce an instance: syntax is only syntactic sugar to produce the exact same assignment after a function object has been created.This works fine:It doesn't matter where a function is defined, a  statement produces a function object regardless where it is used.  is two things: creating the function object and an assignment of that function object no a name. Wether or not this takes place in a  statement or elsewhere doesn't actually matter.What turns functions into bound methods is accessing them on an instance, as then the descriptor protocol kicks in. For example,  accessing  is turned into , and it is the  method on a function that produces the bound method. The bound method is only a proxy for the actual function, passing in the instance as a first argument when called.A  defines a different , one that just returns the original function, unbound. You can play with those  methods directly:


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html
