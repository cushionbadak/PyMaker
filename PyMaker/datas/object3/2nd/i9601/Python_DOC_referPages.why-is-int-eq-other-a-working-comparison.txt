Natural Text
The following code works with Python 2.7:I do not understand, why it works, given that the  attribute is not explicitly given to  method call.[EDIT]Answers so far suggested, that it is about returning  by  and thus calling . Then  I expect to be an infinitive recursion, which is not the case:
It works because  returns  and when that happens it results in a call to  and that's what is returning  and  here.Demo:From 's docs:Special value which should be returned by the binary special methods  (e.g. , , , , etc.) to  indicate that the operation is not implemented with respect to the  other type; may be returned by the in-place binary special methods  (e.g. , , etc.) for the same purpose. Its  truth value is true.Note When  is returned, the interpreter will then try  the reflected operation on the other type, or some other fallback,  depending on the operator. If all attempted operations return  NotImplemented, the interpreter will raise an appropriate exception.What happens when both  return ?The behaviour is different in Python 2 and 3.In Python 2 it falls back to  method first and integers have  method in Python 2. It has been removed in Python 3.As per Python 2 docs if nothing is found it ultimately falls back to identity comparison:If no ,  or  operation is defined, class  instances are compared by object identity (“address”)Not let's define a class with no method defined:Python 3 doesn't have  method anymore but it seems to be falling back to identity now. And it seems it is not documented either.
When mixing float with an integer type, there's no good uniform approach.  https://github.com/python/cpython/blob/2.7/Objects/floatobject.c#L401-L417P.S.How int() object using "==" operator without __eq__() method in python2?
In Python 2.7, if you call  it always returns .  Example:When you use the  operator it will attempt to run the  method on the left argument, and if it gets  it will return the result of the  method from the argument on the right.In your example for , the interpreter first tries , and gets .  It then runs the  method on the  number  and gets .In the case of your  example, what's likely happening is that since both objects return  for their  methods, and since  inherits from , the interpreter falls back to using the  builtin behavior for  (according to this answer, which is linked-to in another answer to your question).Here's an example that illustrates your case:


Answer URL
https://docs.python.org/3/library/constants.html#NotImplemented
