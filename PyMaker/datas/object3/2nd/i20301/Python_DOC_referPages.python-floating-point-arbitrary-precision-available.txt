Natural Text
Just for fun and because it was really easy, I've written a short program to generate Grafting numbers, but because of floating point precision issues it's not finding some of the larger examples.This code misses at least one known Grafting number.   It seems to drop extra precision after multiplying by .So I wrote a short C++ program to see if it was my CPU truncating the floating point number or python somehow.Which outputs:So it looks like I'm running up hard against the limits of floating point precision and the CPU is chopping off the remaining bits because it thinks that the remaining difference is floating point error.  Is there a way to work around this under Python?  Or do I need to move to C and use GMP or something?
In the standard library, the  module may be what you're looking for. Also, I have found mpmath to be quite helpful. The documentation has many great examples as well (unfortunately my office computer does not have  installed; otherwise I would verify a few examples and post them).One caveat about the  module, though. The module contains several in-built functions for simple mathematical operations (e.g. ), but the results from these functions may not always match the corresponding function in  or other modules at higher precisions (although they may be more accurate). For example, In Python 3.2.3, this outputs the first two lineswhich as stated, isn't exactly what you would expect, and you can see that the higher the precision, the less the results match. Note that the  module does have more accuracy in this example, since it more closely matches the actual value. 
For this particular problem,  is a great way to go, because it stores the decimal digits as tuples! Since you're looking for a property that is most naturally expressed in decimal notation, it's a bit silly to use a binary representation. The wikipedia page you linked to didn't indicate how many "non-grafting digits" may appear before the "grafting digits" begin, so this lets you specify:I think there's a good chance the result of  will be more accurate, at least for this, than the result of  because of the conversion between binary representation and decimal representation. Consider the following, for example: 
You can try with Decimal instead of floatingpoint.
Python has no built-in arbitrary-precision floats, but there are 3rd-party Python packages that use GMP:  gmpy and PyGMP.
use , (here is a clearer example):


Answer URL
https://docs.python.org/3/library/fractions.html
