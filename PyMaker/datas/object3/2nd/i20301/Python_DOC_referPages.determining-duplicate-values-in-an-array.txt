Natural Text
Suppose I have an arrayHow can I (efficiently, Pythonically) find which elements of  are duplicates (i.e., non-unique values)?  In this case the result would be  or possibly  if efficient.I've come up with a few methods that appear to work:MaskingSet operationsThis one is cute but probably illegal (as  isn't actually unique):HistogramsSortingPandasIs there anything I've missed?  I'm not necessarily looking for a numpy-only solution, but it has to work with numpy data types and be efficient on medium-sized data sets (up to 10 million in size).ConclusionsTesting with a 10 million size data set (on a 2.8GHz Xeon):The fastest is sorting, at 1.1s.  The dubious  is second at 2.6s, followed by masking and Pandas  at 3.1s,  at 5.6s, and  and senderle's  both at 7.3s.  Steven's  is only a little slower, at 10.5s; trailing behind are Burhan's  at 110s and DSM's  subtraction at 360s.I'm going to use sorting for performance, but I'm accepting Steven's answer because the performance is acceptable and it feels clearer and more Pythonic.Edit: discovered the Pandas solution.  If Pandas is available it's clear and performs well.
I think this is most clear done outside of .  You'll have to time it against your  solutions if you are concerned with speed.note:  This is similar to Burhan Khalid's answer, but the use of  without subscripting in the condition should be faster.
As of numpy version 1.9.0,  has an argument  which greatly simplifies your task:This is similar to using , except you get a pair of arrays instead of a mapping. I'd be curious to see how they perform relative to each other.
People have already suggested  variants, but here's one which doesn't use a listcomp:[Posted not because it's efficient -- it's not -- but because I think it's cute that you can subtract  instances.]
For Python 2.7+
Here's another approach using set operations that I think is a bit more straightforward than the ones you offer:I suppose you're asking for -only solutions, since if that's not the case, it's very difficult to argue with just using a  instead. I think you should make that requirement explicit though.
If  is made up of small integers you can use numpy.bincount directly:This is very similar your "histogram" method, which is the one I would use if  was not made up of small integers.
I'm adding my solution to the pile for this 3 year old question because none of the solutions fit what I wanted or used libs besides numpy. This method finds both the indices of duplicates and values for distinct sets of duplicates.
If the array is a sorted numpy array, then just do:


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter
