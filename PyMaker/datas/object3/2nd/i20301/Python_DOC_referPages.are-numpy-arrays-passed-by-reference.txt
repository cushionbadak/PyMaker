Natural Text
I came across the fact that  arrays are passed by reference at multiple places, but then when I execute the following code, why is there a difference between the behavior of  and I'm using python 2.7 and numpy version 1.6.1
In Python, all variable names are references to values.When Python evaluates an assignment, the right-hand side is evaluated before the left-hand side.  creates a new array; it does not modify  in-place. makes the local variable  reference this new array. It does not modify the value originally referenced by  which was passed to . The variable name  simply gets bound to the new array, . Moreover,  is local variable name in the scope of the  function. Once the  function completes, there is no more reference to  and Python is free to garbage collect the value it references. As Reti43 points out, in order for 's value to affect ,  must return  and  must be assigned to that value:In contrast, , which Python translates into a call to the  special method, does modify the array referenced by  in-place.
The first function calculates , then assigns the local name  to it, which doesn't affect the array data passed in. My guess is that in the second function,  overrides the  operator, and operates in place on the array data.
Python passes the array by reference: The top answer is referring to a phenomenon that occurs even in compiled c-code, as any BLAS events will involve a "read-onto" step where either a new array is formed which the user (code writer in this case) is aware of, or a new array is formed "under the hood" in a temporary variable which the user is unaware of (you might see this as a  call). However, I can clearly access the memory of the array as if it is in a more global scope than the function called (i.e., ); which is exactly what "passing by reference" is, in terms of writing code. And let's do a few more tests to check the validity of the accepted answer: Seems to be passed by reference.  Let us do a calculation which will definitely compute an intermediate array under the hood, and see if x is modified as if it is passed by reference: Huh, I thought x was passed by reference, but maybe it is not?  -- No, here, we have shadowed the x, and python will not propagate this "shadowing" back to global scope (which would violate the python-use case, which is to be a beginner level coding language with a lot of water wings and training wheels).However, I can very easily perform this operation in a "pass-by-reference" manner by forcing the memory (which is not copied when I submit x to the function) to be modified instead: And so you see that python can be finessed a bit to do what you are trying to do. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__isub__
https://docs.python.org/3/tutorial/controlflow.html#id2
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
