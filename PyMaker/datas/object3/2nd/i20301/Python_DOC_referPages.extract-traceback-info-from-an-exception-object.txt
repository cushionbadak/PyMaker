Natural Text
Given an Exception object (of unknown origin) is there way to obtain its traceback? I have code like this:How can I extract the traceback from the Exception object once I have it?
The answer to this question depends on the version of Python you're using.In Python 3It's simple: exceptions come equipped with a  attribute that contains the traceback. This attribute is also writable, and can be conveniently set using the  method of exceptions: These features are minimally described as part of the  documentation.All credit for this part of the answer should go to Vyctor, who first posted this information. I'm including it here only because this answer is stuck at the top, and Python 3 is becoming more common.In Python 2It's annoyingly complex. The trouble with tracebacks is that they have references to stack frames, and stack frames have references to the tracebacks that have references to stack frames that have references to... you get the idea. This causes problems for the garbage collector. (Thanks to ecatmur for first pointing this out.)The nice way of solving this would be to surgically break the cycle after leaving the  clause, which is what Python 3 does. The Python 2 solution is much uglier: you are provided with an ad-hoc function,, which only works inside the  clause. It returns a tuple containing the exception, the exception type, and the traceback for whatever exception is currently being handled. So if you are inside the  clause, you can use the output of  along with the  module to do various useful things:But as your edit indicates, you're trying to get the traceback that would have been printed if your exception had not been handled, after it has already been handled. That's a much harder question. Unfortunately,  returns  when no exception is being handled. Other related  attributes don't help either.  is deprecated and undefined when no exception is being handled;  seems perfect, but it appears only to be defined during interactive sessions.If you can control how the exception is raised, you might be able to use  and a custom exception to store some of the information. But I'm not entirely sure how that would work.To tell the truth, catching and returning an exception is kind of an unusual thing to do. This might be a sign that you need to refactor anyway.
Since Python 3.0[PEP 3109] the built in class  has a  attribute which contains a  (with Python 3.2.3):The problem is that after Googling  for a while I found only few articles but none of them describes whether or why you should (not) use .However, the Python 3 documentation for  says that:A traceback object is normally created automatically when an exception is raised and attached to it as the  attribute, which is writable.So I assume it's meant to be used.
A way to get traceback as a string from an exception object in Python 3: returns a list of strings.  joins them together. For more reference, please visit: https://docs.python.org/3/library/traceback.html#traceback.format_exc
There's a very good reason the traceback is not stored in the exception; because the traceback holds references to its stack's locals, this would result in a circular reference and (temporary) memory leak until the circular GC kicks in.  (This is why you should never store the traceback in a local variable.)About the only thing I can think of would be for you to monkeypatch 's globals so that when it thinks it's catching  it's actually catching a specialised type and the exception propagates to you as the caller:
As an aside, if you want to actually get the full traceback as you would see it printed to your terminal, you want this:If you use  as above answers suggest you'll get less information:


Answer URL
https://docs.python.org/3/reference/simple_stmts.html?highlight=__cause__#the-raise-statement
https://docs.python.org/3/library/traceback.html#traceback.format_exc
