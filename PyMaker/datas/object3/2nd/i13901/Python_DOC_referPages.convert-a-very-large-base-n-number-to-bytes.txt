Natural Text
I have a very large number in base  ( is specified by user), stored as an array with each element representing a digit.  is the highest digit,  is the second highest,  is the lowest digit and so on. Leading zeros are understood to be meaningless: For instance, if  is 8,  is equivalent to  and both equal (473) in base 8, or 315 in base 10, or  in hex, or  as a byte array.I want to convert this into an array of bytes which correspond to base-256 representation of the same number, with minimal leading zeros. I have the following code to do so:This works for smaller numbers (a few hundred digits). However, it turns out that  is pretty limited, for instance if we use base 8,  is the highest power I can get, and  fails with .I know that the common way of dealing with large numbers is to represent them as floating points - but in this case I am using this code to encode/decode binary files into alternative representations (eg. trytes). Therefore, if due to loss of precision the less significant bytes are altered, a lot of the data will be corrupted, so I can't use an approximate power calculation - I need the result to be exact.How can I solve this problem? Is there a version of  that doesn't overflow? Is there a more efficient base conversion algorithm that I'm overlooking?
Is there a version of  that doesn't overflow?Try using the built-in exponentiation operator, . AFAIK it doesn't have the same limitations that  does.


Answer URL
https://docs.python.org/3/library/math.html#math.pow
