Natural Text
I understand that there are similar topics on this (such as here) but my intended design is a little more complex.I'm designing a CLI script that will be run in an SSH window. The script will be hosted and executed on an Ubuntu 14.10 server. It's intended to actively monitor, in the foreground, the current status of ports and clients on a host switch. Every 30 seconds or as defined by the user it will fetch data via SNMP and then refresh information and display it to the screen. When it's waiting for the next refresh there is a timer indicating when it will query the device again for information.I want to allow the user to press specific keys to change the output view or edit key variables at any time. (The functionality is similar to the Unix .) For example, pressing  would request them to enter a number of seconds desired between loops. , , or  would toggle showing/hiding certain columns. These would not pause the timer  nor exit the loop since changes would be applied at the next refresh.  would force an immediate refresh and apply changes.  or  would exit the script.The primary activity would look like this:With key-press interrupts it would act like this:I'm kind of stumped here. I'm led to believe that I'll probably need to implement threading - which I do not have experience with - as a  loop by itself doesn't seem to satisfy what we need. I'm also unsure of how to inject the changes to the object that contains the variables (e.g. timer, flags for display formatting) since it will be constantly used by our loop.
It's nothing complicated, and nothing requiring any packages.Its only problem is that it requires restoring terminal back to normal on program exit.I.e. If program crashes the terminal will not be restored and user won't see what he is typing.But if user knows what he is doing, he can force restart the shell and everything will be back to normal.Of corse, you can use this code in easier manner and use raw_input() to do the stuff.In practice program should never be able to exit without restoring the terminal to normal, but shit happens.Now, you can simplify things by using only one thread and your work loop put in the main thread, and use raw_input to acquire commands from user.Or maybe even better, put your server-client code in the background and wait for input in main thread.It will also probably be safer to use threading module instead of raw threads.If you use asyncore module, you will get each client running for its own, and your main thread will be occupied with the asyncore.loop().You can override it, I.e. rewrite it to check for input and other things you wish  to do, while keeping asyncore checks synchronized.Also, heavy loads require to override some nasty functions inside it, because its buffer is fixed to 512 bytes, if I am not mistaken. Otherwise, it may be a nice solution for your problem.And, lastly, just to be clear, code for no echoing user input is taken and adapted from getpass module.Just a little bit there is mine.
Ctrl+C is easy: it will throw an exception that you can catch (because the process is sent a signal when this happens).For providing interactivity while waiting, you should look writing asynchronous code. Twisted is time-tested and capable, but has a slight learning curve (IMHO). There is also asyncore that might be easier to get started with, but more limited and I am not sure it handles your use case. There is also asyncio, but it only exists in Python 3.4.


Answer URL
https://docs.python.org/3/library/asyncio.html
