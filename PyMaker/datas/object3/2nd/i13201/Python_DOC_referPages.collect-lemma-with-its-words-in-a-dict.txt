Natural Text
I have a text file in the formatlike thisWhat I have to do is to collect in dict the lemma with its words, so the output will like thisI tried thisBut this code gives the following output:Can someone help?
Your code is almost right! The problem is that  is going to overwrite any existing s associated with that . In reality each lemma can have more than one word associated with it , so what we really want to do is add the new word to a collection, rather than overwrite the existing value. The natural way to model this is with a dict of lists of strings, rather than a dict of strings.What does that  statement mean? If there is already an entry for a given  in , then we add it to the list. If it's not already there, we initialise the entry with a singleton list.I've also taken the liberty of using Python's syntax for unpacking sequences.  is equivalent to .One of the nice things about Python is that many simple tasks are catered for by the standard library. This sort of use-case is just what the standard library's  was designed for. When you index into a  using the subscripting operator (), if no value is found it is created using the function you supply. Here, we tell the  to initialise a new list.Now the code is simpler because  is taking care of checking  for us. It'll always give us back a (possibly-empty) list to which we can add the word.In a comment, you suggested that you didn't want duplicate s in the output. The standard library can help here, too.  is a data structure a bit like a list, except that it doesn't remember the order of the elements, and it automatically removes duplicates. (Under the hood, it works like a  with only keys and no values.)We just need to change the  function from  to , and change the  method to the version which works on s (which is called .)
as my comment suggests, you need to make a list as your value, not just setting the value for each key. somethign like this should work.
Well I would suggest using a , initialized with a  from the  module. It fits this case since you can easily add new elements and have the  ready for adding elements. Creating a  is easily done by importing it from collections and providing a  as the sole argument:Then, you can iterate for every line in your file and  the  according to the value of  :Using the input you supplied,  outputs the mapping you're looking for: 
If you want to do this without any help from csv:
If you're interested in the insane functional approach to this, there is a "single logical line" way to get it done, that doesn't involve creating an empty dictionary and avoids the repeated calls to which saystake each line of the file, split it, then reverse itsort those linesgroup them by their elementmap the element  to each word in the group by taking the  of the reversed split line.


Answer URL
https://docs.python.org/3/library/collections.html#collections.defaultdict
https://docs.python.org/3/library/functions.html#func-set
https://docs.python.org/3/library/functions.html#reversed
https://docs.python.org/3/library/functions.html#sorted
https://docs.python.org/3/library/itertools.html#itertools.groupby
https://docs.python.org/3/library/functions.html#func-set
