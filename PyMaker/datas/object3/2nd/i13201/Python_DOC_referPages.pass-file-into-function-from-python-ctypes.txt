Natural Text
I have a library function (written in C) that generates text by writing the output to .  I want to wrap this in Python (2.7.x) with code that creates a temp file or pipe, passes it into the function, reads the result from the file, and returns it as a Python string.Here's a simplified example to illustrate what I'm after:Python wrapper:I'm wondering what my best bet is for . I'm tempted to just use  and create a  wrapper that returns a Python c_void_t, then pass that into the library function.  I'm seems like that should be safe in theory--just wondering if there are issues with that approach or an existing Python-ism to solve this problem.Also, this will go in a long-running process (lets just assume "forever"), so any leaked file descriptors are going to be problematic.
First, do note that  is an stdio-specific entity. It doesn't exist at system level. The things that exist at system level are descriptors (retrieved with ) in UNIX ( returns plain descriptors already) and handles (retrieved with ) in Windows. Thus it's a poor choice as an inter-library exchange format if there can be more than one C runtime in action. You'll be in trouble if your library is compiled against another C runtime than your copy of Python: 1) binary layouts of the structure may differ (e.g. due to alignment or additional members for debugging purposes or even different type sizes); 2) in Windows, file descriptors that the structure links to are C-specific entities as well, and their table is maintained by a C runtime internally1.Moreover, in Python 3, I/O was overhauled in order to untangle it from . So,  is alien to that Python flavor (and likely, most non-C flavors, too).Now, what you need is tosomehow guess which C runtime you need, andcall its  (or equivalent).(One of Python's mottoes is "make the right thing easy and the wrong thing hard", after all)The cleanest method is to use the precise instance that the library is linked to (do pray that it's linked with it dynamically or there'll be no exported symbol to call)For the 1st item, I couldn't find any Python modules that can analyze loaded dynamic modules' metadata to find out which DLLs/so's it have been linked with (just a name or even name+version isn't enough, you know, due to possible multiple instances of the library on the system). Though it's definitely possible since the information about its format is widely available.For the 2nd item, it's a trivial  ( for MSVCRT).Second, you can do a small helper module that would be compiled against the same (or guaranteed compatible) runtime as the library and would do the conversion from the aforementioned descriptor/handle for you. This is effectively a workaround to editing the library proper.Finally, there's the simplest (and the dirtiest) method using Python's C runtime instance (so all the above warnings apply in full) through Python C API available via . It takes advantage ofthe fact that Python 2's file-like objects are wrappers over 's  (Python 3's are not) API that returns the wrapped  (note that it's missing from Python 3)for a standalone , you need to construct a file-like object first (so that there would be a  to return ;) )the fact that  of an object is its memory address (CPython-specific)2Do keep in mind that with s and C pointers, you need to ensure proper object lifetimes by hand!file-like objects returned by  do close the descriptor on so duplicate descriptors with  if you need them after a file object is closed/garbage collectedwhile working with the C structure, adjust the corresponding object's reference count with /.ensure no other I/O on the descriptors/file objects since it would screw up the data (e.g. ever since calling /, internal caching is done that's independent from 's caching)


Answer URL
https://docs.python.org/3/c-api/file.html?highlight=pyfile_asfile#c.PyFile_AsFile
