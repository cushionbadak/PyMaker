Natural Text
The following code works fine and prints out an empty list (on ):Appending this line to the very end makes it segfault:It seems like it is pure luck that the automatic collection does not happen on its own (it took me some time to get reproducible error). The collection is not ran at "end of program" either because I am running this interactively.Some googling led me to believe that some of the C/Cython code is creating/destroying objects without telling python that those objects are already removed from memory. Then python tries to remove them and crashes.How can I find what those objects are? I thought that they would be in  before the crash inducing ?Or are my assumptions completely incorrect?Prepending an  to this code leads to a python exception instead of a segfault.Edit: changed/simplified after comments from one of the answers
You're probably misunderstanding both  and .  turns off the cyclic garbage collector, leaving only reference-counting memory management active. There isn't some separate "garbage detector" that keeps detecting cyclic trash even when the garbage collector is turned off; garbage detection is the garbage collector's job.Also,  is only populated with specific kinds of weird garbage the GC couldn't clear. Most garbage never ends up there.As for how you'd go about debugging this, I'm not familiar with the tools you'd use. Generic tools like Valgrind would probably be useful, and GC flags like  might help.


Answer URL
https://docs.python.org/3/library/gc.html#gc.DEBUG_LEAK
