Natural Text
Breaking from a  works as expected:But if I do the same with , I get this:Why is multiprocessing's map behaving differently? How to avoid the unnecessary function calls?
multiprocessing's map behaves differently because it does not literate over the map iterable object synchronously as the built-in map does, it splits each iteration into a separate process immediately and joins the results.In case you're not familiar with concurrent principles I will try to briefly explain this a little better.In your first example using the built-in map the code would create an iterable object that allows you execute  one at a time, in sequence. The fact that it executes one at a time and in sequence means that your function that prints  will always print first before execution continues onto the inside of your loop which will print just the value of . It also means that when your loop hits 2 you can exit the loop without any extra calls to either map or the loop's body itself. This is a synchronous operation, everything is polite and waits its turn to execute.In your second example, using the multiprocessing map code would still create an iterable object that processes . This time, however, you are not executing each call to  one at a time (synchronously). The multiprocessing map call will immediately send out all of the map calls to separate processes to execute first, then combine the results. Your loop then executes the combined results and again stops at 2 as you've instructed it to. Unfortunately, all of the map entries were already executed in separate processes so while the body of the loop was executed the minimal number of times, the map was not.Hopefully that helps you understand the why a little better.
The fundimental nature of s is that, as soon as you say , it submits all the tasks in the passed iterable to the queue for the worker processes to do. Once such a task is put into the pool, it will eventually be consumed by a worker process and processed. Nothing you do with the result can change that. 
It should be noted that if you have tried first version with Python2.x (I did), result would have been:without any multiprocessing involved.The difference is that in Python 2, doc states:Apply function to every item of iterable and return a list of the results...when Python 3 doc states:Return an iterator that applies function to every item of iterable, yielding the results...That means that  was changed in Python 3 to return an iterable instead of a list.And even in Python 3,  doc says:A parallel equivalent of the map() built-in function (it supports only one iterable argument though). It blocks until the result is ready.(emphasize mine)That means that the method first computes the result list by spawning multiple processes and only then returns a full result object instead of yielding a values each time a subprocess ends. In that way, it is closer to Python2  builtin than to Python3 one.


Answer URL
https://docs.python.org/3/library/functions.html#map
