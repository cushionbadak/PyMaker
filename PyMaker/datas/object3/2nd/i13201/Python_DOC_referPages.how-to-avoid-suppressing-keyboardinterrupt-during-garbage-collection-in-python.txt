Natural Text
Default handler for SIGINT raises KeyboardInterrupt. However, if a program is inside a __del__ method (because of an ongoing garbage collection), the exception is ignored with the following message printed to stderr:As a result, the program continues to work despite receiving SIGINT. Of course, I can define my own handler for SIGINT that sets a global variable sigint_received to True, and then often check the value of the variable in my program. But this looks ugly.Is there an elegant and reliable way to make sure that the python program gets interrupted after receiving SIGINT? 
Before I dive into my solution, I want to highlight the scary red "Warning:" sidebar in the docs for  (emphasis mine):Due to the precarious circumstances under which  methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to  instead. [...]   methods should do the absolute minimum needed to maintain external invariants.This suggests to me that any  method that's at serious risk of being interrupted by an interactive user's  might be doing too much.  So my first suggestion would be to look for ways to minimize your  method, whatever it is.Or to put it another way:  If your  method really does do "the absolute minimum needed", then how can it be safe to kill the process half-way through?Custom Signal HandlerThe only solution I could find was indeed a custom signal handler for ... but a lot of the obvious tricks didn't work:Failed:  Calling  from the signal handler just raised a  exception, which was ignored.  Python's C API docs suggest that it is impossible for the Python interpreter to raise any exception during a  method:[Called when...] it is impossible for the interpreter to actually raise the exception [...] for example, when an exception occurs in an  method.Partial Success:  Flag VariableYour idea of setting a global "drop dead" variable inside the signal handler worked only partially --- although it updated the variable, nothing got a chance to read that variable until after the  method returned.  So for several seconds, the  appeared to have done nothing.This might be good enough if you just want to terminate the process "eventually", since it will exit whenever the  method returns.  But since you probably want to shut down the process without waiting (both  and  typically come from an impatient user), this won't do.Success:  Since I couldn't find a way to convince the Python interpreter to kill itself, my solution was to have the (much more persuasive) operating system do it for me.  This signal handler uses  to send a stronger  to its own process ID, causing the Python interpreter itself to exit.Once the custom signal handler was set,   caused the  method (and the entire program) to exit immediately.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__del__
https://docs.python.org/3/library/signal.html#signal.signal
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_WriteUnraisable
https://docs.python.org/3/reference/datamodel.html#object.__del__
https://docs.python.org/3/library/os.html#os.kill
