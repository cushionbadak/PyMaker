Natural Text
I'm new to programming and have been wrestling this problem for a while now...I'm writing a Python script to automate an interactive command-line based Perl script so that it may run on every file in a specified directory.  I can get the program to boot with  and , but from there I either open the program and it sits there waiting in the shell for a user input, or I open it an infinite amount of times.  I need the Perl script to open once per file, accept user inputs (with something similar to "enter" being pressed after each input, of course, and a command including the name of the file, which should be  in the example code below), begin the Perl script's calculations with a user input of , and then have it close.I know this is possible, but I've tried 1000 different approaches to no avail.  Could someone give me an "explain it like I'm 5" as to how I can get this Python and Perl script talking to each other as if a user was inputting commands?Here's what I have so far:I keep reading a lot about stdin pipes but don't quite understand them.  Are they used for this problem or should another approach be used?  Also, I've already looked at Pexpect but that doesn't seem to be working.Your help is immensely appreciated.  
To run a command for each file from a given directory:See @skmrx's answer  for the explanation of why your current code fails.
Pipes are one way for multiple processes to communicate and are widely used for that. A pipe is a pair of file descriptors with one opened for writing and the other for reading. If data is written to the former, reading from the latter will return back the same data.Popen can create pipes for the standard input (stdin), standard output (stdout) and standard error (stderr) file descriptors of the process it executes - but you have to explicitly ask for it. This way, you can write something to the  pipe which will be passed on to the  of the child. Similarly, if you want to read the output of the child process, you can read from the  pipe. This serves your purpose well and hence your approach is correct.Now let's see your code:This will execute the command, but won't create the pipes to allow communication with the child process. If you look at the documentation, it says that you need to explicitly ask it to create pipes through keyword arguments such as . Generally, scripts that take input line-by-line don't care about when they receive input. So you should be able to safely remove this.Look at the documentation again:Popen.communicate(input=None, timeout=None)Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. You can call  only once and you must pass in all the input as one string and it returns the data printed by the child process once it terminates. This also means that the calls to  are unncessary. Note that  returns the a tuple with contents of what the child printed to  and . You may need these.


Answer URL
https://docs.python.org/3/library/subprocess.html#popen-constructor
https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate
