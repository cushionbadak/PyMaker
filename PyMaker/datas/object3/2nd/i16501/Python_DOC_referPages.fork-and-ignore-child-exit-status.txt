Natural Text
While currently writing a daemon which automatically updates multiple long running programs. I don't care about the program's exit status as the only way the child will exit is when force quitting them on upgrade. Unfortunately I'm creating a large number of zombie processes as a result.I'm aware that I can use  to listen for changes from any of the children (which is almost exactly what I want), however I'm also using the python multiprocessing module to run multiple separate upgrade processes in parallel, so the long running process which I could run  from is actually the grandparent of the terminated process and therefore it never receives any signals.So, is there any way to fork a child process so that I never need to check the exit status, or do I just have to deal with my process table being filled with zombies?
You should be able to control this with the setting of the signal handler for SIGCHLD.In C, you would use:You'll need to adapt that to the Python interface.You can use the Python 2 signal or Python 3 signal module; they seem to be identical for the problem on hand:See: POSIX Signal Concepts for the underlying system behaviour (in particular, 'Signal Actions' and  under that section).Warning: Python code not formally tested!
As I understand your process tree layout, it looks something like the following, where  and  are the things using Python's  objects.If that's the case, you'll want to be sure to call  from the parent processes (i.e.,  and ) on their respective children. Once they terminate, regardless of reason, they will be cleaned up, which will allow  to gracefully clean up  and .If you'd like to add additional logic to your parent to cycle through all of the children processes instead of blocking on the first one, you can use the  kwarg mentioned at https://docs.python.org/2/library/multiprocessing.html#multiprocessing.Process.join to time out your join.


Answer URL
https://docs.python.org/3/library/signal.html?highlight=signal#module-signal
