Natural Text
Python 3.4 added the ability to define function overloading with static methods. This is essentially the example from the documentation:In its purest form, the  implementation relies on the first argument to identify type, therefore making it tricky to extend this functionality to instance methods. Does anyone have any advice for how to use (or jerry-rig) this functionality to get it to work with instance methods?
Looking at the source for , we can see that the decorator returns a function , which selects a function to call from those registered based on the type of  ...... which is fine for a regular function, but not much use for an instance method, whose first argument is always going to be .We can, however, write a new decorator , which relies on  to do the heavy lifting, but instead returns a wrapper function that selects which registered function to call based on the type of :Here's a simple example of the decorator in use:Notice that both the decorated  method and the method registered to  have an initial  argument as usual.Testing the  class:
A decorator is essentially a wrapper that takes the wrapped function as an argument and returns another function.As stated in the accepted answer,  returns a  that takes the first argument as registered type -  in instance methods.As shown in that answer, in cases like this you can write another wrapper to monkey patch the decorator. But this kind of hacky fixes are not always the best option.As with like any other function, you can call the wrapper and pass the arguments to it explicitly, which seems simpler, flatter and more readable to me if this kind of method overloading is only seldom made in a package.There's another module,  (not standard but included in Anaconda and without any non-standard dependencies) that, as the name already indicates and unlike , allows multimethods.In addition to  objects, with -compatible syntaxis, it provides a  decorator which hides the creation and manipulation of these objects from the user.The dispatch decorator uses the name of the function to select the  appropriate Dispatcher object to which it adds the new  signature/function. When it encounters a new function name it creates  a new Dispatcher object and stores name/Dispatcher pair in a namespace  for future reference.For instance:


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
