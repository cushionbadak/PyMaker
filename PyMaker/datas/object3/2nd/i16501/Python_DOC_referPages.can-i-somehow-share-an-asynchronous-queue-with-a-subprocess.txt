Natural Text
I would like to use a queue for passing data from a parent to a child process which is launched via . However, since the parent process uses Python's new  library, the queue methods need to be non-blocking. As far as I understand,  is made for inter-task communication and cannot be used for inter-process communication. Also, I know that  has the  and  methods but I actually need coroutines that would still block the current task (but not the whole process). Is there some way to create coroutines that wrap /? On another note, are the threads that  uses internally compatible after all with an event loop running in the same process?If not, what other options do I have? I know I could implement such a queue myself by making use of asynchronous sockets but I hoped I could avoid thatâ€¦ EDIT:I also considered using pipes instead of sockets but it seems  is not compatible with . More precisely,  returns a tuple of  objects which are not file-like objects. However, 's methods / methods and / all expect file-like objects, so it is impossible to asynchronously read from/write to such a . In contrast, the usual file-like objects that the  package uses as pipes pose no problem at all and can easily be used in combination with .UPDATE:I decided to explore the pipe approach a bit further: I converted the  objects  returned by  into file-like objects by retrieving the file descriptor via  and passing it to . Finally, I passed the resulting file-like object to the event loop's /. (There is some mailing list discussion on a related issue if someone is interested in the exact code.) However, ing the stream gave me an  and I didn't manage to fix this. Also considering the missing support for Windows, I will not pursue this any further. 
Here is an implementation of a  object that can be used with . It provides the entire  interface, with the addition of  and  methods, which are s that can be used to asynchronously get/put from/into the queue. The implementation details are essentially the same as the second example of my other answer:  is used to make the get/put asynchronous, and a  is used to share the queue between processes. The only additional trick is implementing  to keep the object picklable despite using a non-picklable  as an instance variable.Output:As you can see, you can use the  both synchronously and asynchronously, from either the parent or child process. It doesn't require any global state, and by encapsulating most of the complexity in a class, is more elegant to use than my original answer.You'll probably be able to get better performance using sockets directly, but getting that working in a cross-platform way seems to be pretty tricky. This also has the advantage of being usable across multiple workers, won't require you to pickle/unpickle yourself, etc.
The  library isn't particularly well-suited for use with , unfortunately. Depending on how you were planning to use the /, however, you may be able to replace it completely with a :Output:If you absolutely need a , It seems like it will behave ok when combined with :Output:


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Connection.fileno
https://docs.python.org/3/library/asyncio-eventloops.html#windows
https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes
