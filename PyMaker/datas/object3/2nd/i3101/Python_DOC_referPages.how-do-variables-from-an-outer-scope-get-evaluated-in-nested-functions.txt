Natural Text
Code first:I am not sure that, "inner_func" calls a parameter of "outer_func", but that is in the body of "outer_func". How can it "know" there is a "pa" when called by another_func?I mean, what is actually passed to another_func when its called in "outer_func"? It seems there is something more than a reference of the function object.
Function objects in Python aren't just functions, they're closures:1 they carry around a reference to the local environment where the  statement was executed.In particular, local variables from inside  can be accessed from inside . (Even if you , those values are kept alive so the closure will still work, for as long as  is alive.)If you add a  statement inside , it can even reassign the local variables from the body of .How does this work?Well, a  statement2 is just a statement, like any other. What it does is something like this:That  is actually a constant value—the compiler compiles the body of every function in your module into constant  objects at  time.But the function object that comes back from that  is a new thing that's created on the fly, and it has a reference to the local variables baked into it. Every time you run , it creates a new  closure from the same , each one capturing the current local environment.The details are a little more complicated—and, to some extent, they differ between implementations, so this will be CPython-specific.Part of the compiler's job is figuring out what kind of variable each name in a function is. You may have read the rules on globals vs. locals (a variable is local if and only if you have an assignment for the name somewhere in the function body, and there's no  statement). But closures make things more complicated. If a variable would have been local, but a nested function references the variable without assigning to it, or has a  statement, then it's a cell variable in the outer function, and a free variable in the inner function.3When the interpreter calls a function, it creates a  object that holds the local namespace—the references to all of the function's local variables. But cell variables are special: the interpreter creates a special  object for each one, and a reference to that cell goes into the namespace, so there's an extra dereference in front of the value every time you access or change it. And what that  pseudo-code above does is to copy the cells from the outer function's frame to a special attribute on the nested function called .Then, when you call the inner function, the interpreter copies those cells from the  into the frame for that function. So, the outer function's frame and the inner function's frame both have references to the same cells, which is how they can share variables.From more on this, see the  module's docs, which show you how to find things like  and  in your interactive interpreter, and the  module which lets you look at the actual bytecode that your functions get compiled to.1. This is one of those words that has a slew of related but different meanings. "Closure" can mean the technique of capturing the local namespace in a function, or it can mean the captured namespace, or it can mean the function with a captured namespace attached to it, or it can mean one of the variables in the captured namespace. Usually it's obvious which one you mean from context. If not, you have to say something like "closure capture" or "closure function" or "closure variable".2. In case you're wondering,  expressions work exactly the same way as  statements. And  definitions are not identical, but similar.3. It's actually still more complicated if you have multiple layers of nesting, but let's ignore that.
You seem to be confusing the code if the function with the function object. The code object is evaluated only once, when the source file is read. However, a new function object called  is created every time  is called. This happens because a  statement is a type of assignment: it associates a function object with the specified name.The function object contains a reference to its code as a matter of course, along with references to all the namespaces it will need to operate, including it's parent's nonlocal namespace and the global module namespace.So the value of  in  is going to be whatever it is in  at the time of calling. The reference is to the namespace, not the name itself. If  returns (think decorators), the namespace will be fixed, and only accessible through 's special reference to it.


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/dis.html
