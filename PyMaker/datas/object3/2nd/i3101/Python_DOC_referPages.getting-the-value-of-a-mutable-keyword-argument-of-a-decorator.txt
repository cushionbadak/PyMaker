Natural Text
I have the following code, in which I simply have a decorator for caching a function's results, and as a concrete implementation, I used the Fibonacci function.After playing around with the code, I wanted to print the  variable, that's initiated in the  wrapper.(It's not because I suspect the cache might be faulty, I simply want to know how to access it without going into debug mode and put a breakpoint inside the decorator)I tried to explore the  function in debug mode, which is supposed to actually be the wrapped , but with no success.
 is of course a perfectly normal local variable in scope within the  function, and a perfectly normal nonlocal cellvar in scope within the  function, so if you want to access the value from there, you just do it—as you already are.But what if you wanted to access it from somewhere else? Then there are two options.First,  happens to be defined at the global level, meaning any code anywhere (that hasn't hidden it with a local variable named ) can access the function object.And if you're trying to access the values of a function's default parameters from outside the function, they're available in the attributes of the function object. The  module docs explain the inspection-oriented attributes of each builtin type: is a sequence of the values for all positional-or-keyword parameters, in order. is a mapping from keywords to values for all keyword-only parameters.So:So, for a simple case where you know there's exactly one default value and know which argument it belongs to, all you need is:If you need to do something more complicated or dynamic, like get the default value for  in the  function above, you need to dig into other information—the only way to know that 's default value will be the second one in  is to look at the attributes of the function's code object, like , and figure it out from there. But usually, it's better to just use the  module's helpers. For example:Alternatively, if you're trying to access the cache from inside , while there's no variable in lexical scope in that function body you can look at, you do know that the function body is only called by the decorator , and it is available there.So, you can get your stack frame… follow it back to your caller:… and grab it from that frame's locals:It's worth noting that  works like the  function: it's actually a copy of the internal locals storage, so modifying it may have no effect, and that copy flattens nonlocal cell variables to regular local variables. If you wanted to access the actual cell variable, you'd have to grub around in things like  to get the index and then dig it out of the function object's . But usually, you don't care about that.
I admit this is not an "elegant" solution in a sense, but keep in mind that python functions are also objects. So with some slight modification to your code, I managed to inject the cache as an attribute of a decorated function:
Just for a sake of completeness, python has caching decorator built-in in  with some inspecting mechanisms:Prints:
I managed to find a solution (in some sense by @Patrick Haugh's advice).I simply accessed  which holds the cache's dict.The insights about the shared cache and how to avoid it we're also quite useful.Just as a note, the  dictionary can only be accessed through the  function object. It cannot be accessed through the decorated functions (at least as far as I understand). It logically aligns well with the fact that the cache is shared in my implementation, where on the other hand, in the alternative implementation that was proposed, it is local per decorated function.
You can make a class into a wrapper. Each function has its own cache. you can access it by calling .  This also allows for any methods you wish to attach to your function.  If you wanted all decorated functions to share the same cache, you could use a class variable instead of an instance variable:


Answer URL
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/functions.html#locals
