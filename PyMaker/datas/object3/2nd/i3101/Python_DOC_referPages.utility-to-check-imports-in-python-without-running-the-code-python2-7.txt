Natural Text
Is there a way to make sure all imports listed in all of my python files are in . Basically a validator for all my imports in files.My approach:  Change all file path from / to "." e.g. foo/bar to foo.bar and then run:Problem: It does not work if I have foo.bar.zoo.data as a module
The best way to do this is to use the  (Python 3.1+) or  (Python 2.x) module to do all the steps an  would do up to, but not including, running the code. The key functions for each Python version are:3.4-3.8: 3.3-3.3: .3.1-3.2: 3.0-3.0: 1.5-2.7: 0.9-1.4: No idea. (There were no packages yet; everything was different…)Advantages of doing it this way:It works whether the module is a normal Python module, a -only module, a C extension module, a builtin, or some funky special type of module that you've installed a custom import hook for.It works even if the module is inside a , or in the frozen bootstrap collection, or if the whole library is wrapped up in a  or even buried inside a .It automatically takes care of the funky rules, like figuring out what is or isn't a valid namespace package extension directory (including dealing with things like  and old-style  path-injection) that would be a huge pain to get right.In 3.4+, this is literally the same code that  uses, because the entire import system is written in Python. For older versions, that's not true—but for 2.3+, it's guaranteed to get you the same thing you would get in an import hook, which is almost surely close enough.Quoting the 3.7 docs:Find the spec for a module, optionally relative to the specified package name. If the module is in , then  is returned (unless the spec would be  or is not set, in which case  is raised). Otherwise a search using  is done.  is returned if no spec is found.If name is for a submodule (contains a dot), the parent module is automatically imported.name and package work the same as for .(You don't really have to care what a spec is here; if Python can find the spec for a module, the module is present; if it returns , the module is not present.)So, this will just magically handle .If you look at the Examples, there's one that does exactly what you want, "Checking if a module can be imported".From the 2.7 docs:Try to find the module name. If path is omitted or , the list of directory names given by  is searched, but first a few special places are searched: the function tries to find a built-in module with the given name (), then a frozen module (), and on some systems some other places are looked in as well (on Windows, it looks in the registry which may point to a specific file).Otherwise, path must be a list of directory names; each directory is searched for files with any of the suffixes returned by  above. Invalid names in the list are silently ignored (but all list items must be strings).If search is successful, the return value is a 3-element tuple :file is an open file object positioned at the beginning, pathname is the pathname of the file found, and description is a 3-element tuple as contained in the list returned by  describing the kind of module found.If the module does not live in a file, the returned file is , pathname is the empty string, and the description tuple contains empty strings for its suffix and mode; the module type is indicated as given in parentheses above. If the search is unsuccessful,  is raised. Other exceptions indicate problems with the arguments or environment.If the module is a package, file is , pathname is the package path and the last item in the description tuple is .This function does not handle hierarchical module names (names containing dots). In order to find P.M, that is, submodule M of package P, use  and  to find and load package P, and then use  with the path argument set to . When P itself has a dotted name, apply this recipe recursively.As you can see, it's a little more complicated—it doesn't magically handle ; you will need to find , verify that it's a package, load it, find , etc., and finally find (but not load) .Something like this (untested):


Answer URL
https://docs.python.org/3/library/importlib.html
https://docs.python.org/3/library/importlib.html#importlib.util.find_spec
https://docs.python.org/3/library/importlib.html#checking-if-a-module-can-be-imported
