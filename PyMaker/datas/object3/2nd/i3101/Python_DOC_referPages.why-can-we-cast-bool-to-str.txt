Natural Text
We know how  acts on various python objects such as , , .This is a question about the reverse.You can cast bool to int aswhich I think kinda makes sense, but with string we getwhich I don't get, as firstly it seems to imply some relation between  and , which only seems relevant at the code level. If what is written in code is to be treated this way, how does this work ...Second, it's not obvious it's for consistency, asMy question is ... is there a reason we're allowed to cast  to  in this way?  for example won't allow it ... 
For debugging. If you can't cast a thing to a string, you can't print it. If you want to print a data structure for debugging, you need to be able to cast each element to a string. That's what  is documented to do...Return a string containing a nicely printable representation of an object.If what is written in code is to be treated this way, how does this work ... resolves to  which is then passed to . It's similar to how with   receives 2.Second, it's not obvious it's for consistency, asCasting is not guaranteed to round trip. Examples are  or .There's an important difference between converting something to a string for humans, which is what  does, and converting something to a string for marshalling which must round trip. There are specialized packages like  or  for marshalling.But casting is the wrong way to think about  and  in Python. As above,  returns a printable representation, not a machine-readable one.  is for asking "what is the truthiness of this expression"? From the docs...x is converted using the standard truth testing procedure. and  are both true. If they added a special case just for  that would be very inconsistent.
 and  are not "casts", they're constructors (type objects). Calling  for any value  will construct a new  object with its value initialized (somehow) from . There is no implied relationship between the two objects;  could return anything as long as it is a  object.Basically: stop thinking of Python as having "casts" like other languages you may be used to. Constructors are just another kind of callable, and the general rule is for each type to do something sensible with the argument(s) passed to the constructor. In the case of , it delegates to the  special method if present, which means that  objects return the strings  and  because that's what the  type decided to do.
Well, what is the problem with  being ? That's quite the expected.Now, if you convert boolean to integer, it's obvious that the result must be a number. And, naturally,  evaluates to . That is , then: .About the  function, it's supposed to return  for anything that is not empty, zero, None or False. So any string that is not  fits this and returns . See more: https://docs.python.org/3/library/stdtypes.html#truth
There is a very limited set of things considered  in Python:NoneFalsezero of any numeric type, for example, 0, 0L, 0.0, 0j.any empty sequence, for example, '', (), [].any empty mapping, for example, {}.instances of user-defined classes, if the class defines a nonzero() or len() method, when that method returns the integer zero or bool value FalseSo if you do  it will only return  for those items. Everything else in Python is  including string representations of falsy things:  ,  etc because the string itself is .


Answer URL
https://docs.python.org/3/library/stdtypes.html#truth
https://docs.python.org/3/reference/datamodel.html#object.__str__
https://docs.python.org/3/library/functions.html#bool
