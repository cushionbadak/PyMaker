Natural Text
ContextI am relatively new to python / computer programming and trying to wrap my head around some basic concepts by playing around with them.In my understanding, python is an interpreted language i.e. it evaluates the line of code as it is being executed.QuestionIn a function, why does interpreter check for a variable assignment by going down the code and not execute the line it is on, especially, since all relevant information is available?Example:Error:The code above results in the following error:"SyntaxError: name 'eggs' is used prior to global declaration"Confusion:In my mind, 2nd line explicitly assigns "spam local" to the variable 'eggs'. Hence, when the interpreter reaches line 3 i.e print(eggs), it should print "spam local" and not go down the code to see there is a global declaration of the variable and return the SyntaxError.Why is the interpreter not executing the line it is one, given that all relevant information is available?
In my understanding, python is an interpreted language i.e. it evaluates the line of code as it is being executed.No.1 Python compiles a module at a time. All function bodies are compiled to bytecode, and the top-level module code is compiled to bytecode. That's what a  file is—all those bytecode objects marshaled into a container.2When you  a module, its top-level bytecode is interpreted. (If there isn't a  file, the  file is compiled on the fly to get that bytecode.)One more thing that might not seem obvious at first: While a function body is compiled, a  statement (or  expression) is compiled into interpretable bytecode, basically a call to a function that builds a function object out of the body's compiled bytecode.You can reproduce all of this manually if you want to, which can be handy for experimenting with how things work. You can call  on some module source with  mode to compile it the same way an  would, and you can call  on the result to run it the same way an  would, and you can even play with the  module to build your own  files from scratch or load them up. (In fact, if you're on Python 3.3+, this isn't just equivalent to what  does, it's exactly what  does;  is written in Python.)You can also view what the compiler has done (or would do, on source code that you haven't compiled yet and just have as a string) with the  and  modules.Part of the process of compiling a function body is detecting which names are local, cell, free, or global. A name is always consistently just one kind, for the entire lifetime of the function, which makes things easier to reason about.Forgetting about cellvar/freevar cases (which are only needed for closures), the rule is very simple:If there's a  statement for a name in a function body, it's global.Otherwise, if there's an assignment to a name in a function body,3 it's local.Otherwise, it's global.For the full details (and slightly more accurate details4), see Naming and binding in the reference documentation.In versions of Python before 2.2, it was legal to assign to a variable and then declare it  later in the same function. In 2.1, this followed the rules explained above: the first assignment was to the global. Which is pretty misleading, especially since it almost always happened only be accident. Which is presumably why it was made an error to do that. In earlier versions, things are just nuts.51. Well, in the interactive interpreter, it does sort of do this—but even there, it's a statement at a time, not a line at a time. For example, a four-line compound statement like a  or  is compiled and interpreted all at once.2. Actually, the "container" bit is pretty trivial. In fact, everything is recursively already part of the top-level module bytecode object—e.g., a top-level function's name, bytecode, etc. are all just constant values stored in the module bytecode, just like any other constant values.3. Things that count as assignments including being a parameter, or being a target or member of a target list for an assignment statement, a  statement, a  statement or clause, an  clause, an , a  or , or, in 3.8+, an assignment expression.4. A Python implementation doesn't actually have to determine all of this stuff at compile time, as long as the semantics end up the same. So the reference is written in terms that could be followed even by an implementation without a compiler. But in practice, at least CPython, PyPy, MicroPython, Jython, and IronPython work out the name bindings at compile time.5. Python 0.9 had no , and different scoping rules in general. In 1.1, as far as I can tell, the rule is that an assignment before the  statement rebinds the global if there already is one (you still et a local in the frame, but it stays unbound), but binds a local variable otherwise, which makes no sense to me. I've never managed to get 1.5, 1.6, or 2.0 to build on a modern system, but the code is clearly different from early 1.x and from 2.1, so for all I know they actually did what you were expecting here… or maybe they did something just as crazy as 1.1, but completely different.


Answer URL
https://docs.python.org/3/library/functions.html#compile
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/library/marshal.html
https://docs.python.org/3/library/importlib.html
https://docs.python.org/3/library/inspect.html
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/reference/executionmodel.html#naming-and-binding
