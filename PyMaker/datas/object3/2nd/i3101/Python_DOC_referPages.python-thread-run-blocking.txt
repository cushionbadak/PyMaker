Natural Text
I was attempting to create a thread class that could be terminated by an exception (since I am trying to have the thread wait on an event) when I created the following:However, running the program will only print out one Running message, until the other is terminated. Why is that?
The problem is that you're calling the  method.This is just a plain old method that you implement, which does whatever you put in its body. In this case, the body is an infinite loop, so calling  just loops forever.The way to start a thread is the  method. This method is part of the  class, and what it does is:Start the thread’s activity.It must be called at most once per thread object. It arranges for the object’s  method to be invoked in a separate thread of control.So, if you call this, it will start a new thread, make that new thread run your  method, and return immediately, so the main thread can keep doing other stuff.1 That's what you want here.1. As pointed out by Jean-François Fabre, you're still not going to get any real parallelism here. Busy loops are never a great idea in multithreaded code, and if you're running this in CPython or PyPy, almost all of that busy looping is executing Python bytecode while holding the GIL, and only one thread can hold the GIL at a time. So, from a coarse view, things look concurrent—three threads are running, and all making progress. But if you zoom in, there's almost no overlap where two threads progress at once, usually not even enough to make up for the small scheduler overhead.


Answer URL
https://docs.python.org/3/library/threading.html#threading.Thread.run
https://docs.python.org/3/library/threading.html#threading.Thread.start
