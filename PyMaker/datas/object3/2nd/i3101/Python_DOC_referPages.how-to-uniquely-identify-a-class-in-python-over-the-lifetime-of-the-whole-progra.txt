Natural Text
QuestionHow to uniquely identify a class in Python over the lifetime of the whole program? I'm interested in both built-in types and user-defined ones.  is not suitable because:[] returns the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.Is it possible?Concrete use-caseI have a dictionary with strings as keys and Python's types/classes as values. For example:The problem is to uniquely identify a combination of strings and types and use it as basis for comparison. Therefore, dictionary  and  dictionary  should be ruled unequal. Similarly,  and  .The catchAdditionally, the comparison should work if names and types are hashed and result is stored (because comparing integers is faster then comparing dicts). For example:This introduces the risk that two classes A and B, with disjoint lifetimes, are assigned the same  (in case A was destroyed before B was declared) and, therefore, the check passes.[1] https://docs.python.org/3/library/functions.html#id
First of all: built-in types and custom Python types are all just Python objects. For the purposes of  there are no differences you need to be concerned about.You really do want to use  to track classes. Because if the  has changed, that means you no longer have the same class. And vice-versa, because  values can be re-used for objects with non-overlapping life-times, having the same  value does not mean you still have the same object.Classes are meant to be singletons. Classes are rarely redefined, because most code would define them at the module level and modules are singletons too (they live in  and are loaded just the once).Moreover, a class with a different ID is not the same class. It may have the same name, it may live in the same module, but you can't use one to assert that instances of the other are of the same type. You should not try to track classes across the lifetime of Python and disregard their  value.A quick demo to illustrate why you can't:The  instance is an instance of the class , but it is the first  class it is an instance of. By creating a new  class,  changed with it, but it tells you we now have a distinct, new class object that is a different object.And if you were to only track the , if all references to the original  were to be removed, the object removed from memory, and then a new  was created, it could have the same  value, as  values can be re-used. So you could have a new , with the same . This matters less, because old  could only have been deleted from memory if there were no more references. Instances hold a reference to their class, so if there are instances of a class, the class continues to be retained in memory.If all you are doing is comparing classes contained in dictionaries, then you don't need to resort to  testing at all, because class equality tests only ever return true for objects that are identical.  is only ever  if both references are to the same class object; the test is essentially the same as . And dictionaries hold references to all their contents, keeping those contents alive. By virtue of storing types in a dictionary, you ensured their  values can't change either.The post you link to is not asking about the  of classes. They are discussing the  values of instances; it discusses things like multiple instances having different  values, and that creating and discarding instances in quick succession does not guarantee that the  of the first is reused for the second.
I'm assuming your use case is something like this (but not as trivial and pointless): You're keeping a set of every collection of types you've seen since startup, so you can do something like this:The problem is, you can't stick a dict mapping strings to types in a set. So, your idea was to flatten that out into something hashable, by storing, say, a frozenset or sorted tuple of  pairs.But the problem is:While this is unlikely to happen (your users are unlikely to ever destroy a class like that), it's not impossible.  and  have disjoint lifetimes, so they could end up with the same .But you don't need the  here. Types are already hashable, so you can just store them instead of their s:Now, because you're storing the types in the set, any type anyone ever passes you will live forever, so the whole issue of types with disjoint lifetimes colliding never arises.If you wanted to use the ids instead of the types themselves, for some other reason, that would still work… as long as you stored the types somewhere:… or:In idiomatic Python code, types usually live forever anyway, and there are only a few hundred of them, so this is fine.But what if someone were doing something weird, like creating and destroying huge types in a loop? Storing a million arbitrary-sized types might be a lot more expensive than storing a million 64-bit ints.Or, what if someone were doing something really weird, like creating types with a metaclass with a  method that does something important? Then storing every type you're handed is making an important semantic change (and one that's pretty well hidden, making it hard to debug).You could mitigate both of these problems by storing weakrefs to the types, instead of the types themselves (and then using the pair of the type's and weakref's ids as a key instead of just the type's id). Even if the type goes away, its dead weakref will not. Even if a new type gets the same id, it won't match the dead weakref, so it will get a new one, so its pair of ids will be different.Of course storing weakrefs still isn't free, or even quite as cheap as storing ints. But at least they're of static and pretty small size, no matter how big the things they refer to are. And they don't interfere with their targets' destruction any more than storing the s do.


Answer URL
https://docs.python.org/3/library/functions.html#id
