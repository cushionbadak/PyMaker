Natural Text
I am working with sockets using Python 3.5 and the  module and running into an unexpected behavior. My program is essentially a couple of threads running until a certain message is received by the client telling it to stop.If I execute it like this, I get a  that breaks the program, despite the  loop and the  block.However, when I added a  right before returning, not only the code runs as intended, but also no  is raised at any time. According to the docs, signals can only be handled by the main thread, but both sockets are being handled by secondary threads. What does  do to prevent the sockets from breaking, when they are not even being called in the same context?
The , as its name suggests returns immediately. Therefore in the first version of your program, the main thread exits right as it starts the child threads (dummy processes are just threads using the multiprocessing api).Therefore the main thread has exited the  block long before the exception happens.In the second case,  forces the main thread to wait in the  block, where it will catch the exception.Do note this is a fragile solution though, as receiving any signal will make  resume and the main thread exit.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.apply_async
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.dummy
