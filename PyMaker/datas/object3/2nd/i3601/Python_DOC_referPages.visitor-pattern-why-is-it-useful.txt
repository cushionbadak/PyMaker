Natural Text
I used the Visitor example given here Where we have this: We also have a  and a  that can  a , and a  that can  a flower. Using the vistor pattern I can write this: But the code is as readable and funcitonal without the visitor: The question is, what advantages provide the Visitor Pattern in this example?
The article you link to is pretty clear as to why you'd want to use a visitor pattern: when you can't alter the objects because they come from a third party:The assumption is that you have a primary class hierarchy that is fixed; perhaps it’s from another vendor and you can’t make changes to that hierarchy. However, your intent is that you’d like to add new polymorphic methods to that hierarchy, which means that normally you’d have to add something to the base class interface. So the dilemma is that you need to add methods to the base class, but you can’t touch the base class. How do you get around this?Sure, if you can just add a  method to bees, flies and worms, then that's fine. But when you can't, using the visitor pattern is the next best option.Note that in the article the relationship is reversed; you can't alter the  hierarchy:but the class does support the visitor dispatch pattern via the  method:That implementation could be much more complex; the example has been simplified down to a simple  call here, but in practice a real visitor pattern can and does do much more at this stage.For example, there could be composite classes, which contain multiple subcomponents. The  method would then delegate further down to those sub-elements to then call  on them all, as needed. Keeping with the flower theme, perhaps there's a Chrysanthemum or Dahlia class, where some visitors would eat the ray components, while others would like to visit the components in the eye to pollinate. It's up to the composite object to direct each visitor to those parts individually.If you are looking for specific examples, take a look at the  module, which offers a  class which should be subclassed to add methods to let you customise how the AST tree passed in is being processed. I've used the specific  subclass to alter how Python code works on several occasions. Here the visitor pattern is used to effectively filter out certain types in a larger hierarchy, greatly simplifying AST-handling code without having to alter any of the AST node classes themselves.


Answer URL
https://docs.python.org/3/library/ast.html
https://docs.python.org/3/library/ast.html#ast.NodeVisitor
https://docs.python.org/3/library/ast.html#ast.NodeTransformer
