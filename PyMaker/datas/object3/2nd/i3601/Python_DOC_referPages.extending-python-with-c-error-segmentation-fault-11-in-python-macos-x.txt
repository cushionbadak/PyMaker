Natural Text
I have written an extension module in C with the name extmodule.c and the code for it is as follows:After that I have created a setup.py to build and install the extension file in my python program and the code for the setup.py is as follows:Now on the command prompt I have built the setup.py using the following commands:running build   running build_extbuilding 'ext' extension gcc  -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/Users/somdipdey/ anaconda3/include -arch x86_64 -I/Users/somdipdey/anaconda3/include  -arch x86_64 -I/usr/local/include -I/Users/somdipdey/anaco nda3/include/python3.6m -c extmodule.c -o  build/temp.macosx-10.7-x86_64-3.6/extmodule.o extmodule.c:34:25:  warning: incompatible pointer types passing 'PyMethodDef (*)[1]' to  parameter of type        'struct PyModuleDef *' [-Wincompatible-pointer-types]      m = PyModule_Create(&ext_methods);  /Users/somdipdey/anaconda3/include/python3.6m/modsupport.h:158:26:  note: expanded from macro 'PyModule_Create'          PyModule_Create2(module, PYTHON_API_VERSION)                           ^~~~~~ /Users/somdipdey/anaconda3/include/python3.6m/modsupport.h:150:60:  note: passing argument to parameter here PyAPI_FUNC(PyObject )  PyModule_Create2(struct PyModuleDef,                                                             ^ 1 warning generated. gcc -bundle -undefined dynamic_lookup  -L/Users/somdipdey/anaconda3/lib -arch x86_64 -L/Users/somdipdey/anaconda3/lib -arch x86  _64 -arch x86_64 build/temp.macosx-10.7-x86_64-3.6/extmodule.o -L/Users/somdipdey/anaconda3/lib -lpthread -o build/lib.macosx-  10.7-x86_64-3.6/ext.cpython-36m-darwin.soThe install command worked properly but the build one gave 1 warning. Now when I am trying to import ext in my python program and use the function ext.cpu(integer_value), the program is giving me the following error:Segmentation Fault: 11Any idea what might be causing the issue and how to get rid of it?
The warning is telling you exactly what's wrong: you're passing a  to , when it expected a . Those are completely unrelated types. The segfault you're getting is like the C version of a .You need to create a module definition table, and pass that to .If you fix that, you may or may not have another segfault, or garbage data, or a mysterious segfault on exit, because your method table is missing the empty row at the end. C arrays don't know their size the way Python lists do, so code that uses them either needs to pass around the size in a separate variable, or use some "sentinel" value in the last slot.  uses the latter solution.So:With those changes, your module builds without warnings, and:… everything works fine.(Well, there might be a memory leak in there, but that's a separate issue…)


Answer URL
https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function
https://docs.python.org/3/c-api/module.html#c.PyModule_Create
https://docs.python.org/3/extending/extending.html
