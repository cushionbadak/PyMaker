Natural Text
From https://docs.python.org/3/library/ctypes.html#loading-shared-librariesShared libraries can also be loaded by using one of the prefabricated  objects, which are instances of the LibraryLoader class, either by  calling the LoadLibrary() method, or by retrieving the library as  attribute of the loader instance.I found an example for the first way Free the opened ctypes library in PythonI was wondering how to use the second way? In particular, how is the attribute of the loader instance  created?  My question comes from Why does loading the libc shared library have "'LibraryLoader' object is not callable" error?The whole point of the LibraryLoader is that it creates the library for you when you access it. And  doesn't create .Is there something wrong with my experiment? Why does  never exist?
Example (what happens):How it happens - it's all in "${PYTHON_SRC_DIR}/Lib/ctypes/__init__.py" ([GitHub]: python/cpython - (master) cpython/Lib/ctypes/__init__.py). I'm pasting code for  since  (that I used in the example above) is just a wrapper over it (and would require a bit more code):@EDIT0:Hmm, on Ux (Lnx at least) things aren't so nice:That is because apparently (as opposed to [MSDN]: LoadLibrary function), [man7]: DLOPEN(3) doesn't append the (default) library extension (.so) to the file name (if it doesn't contain it already).code.c:Output:So, the Win behavior can't be replicated on Ux (unfortunately,  (dot) can't be part of an attribute name, in order to overcome this). Or, maybe the linker could be configured to search for .so files implicitly? But that would only solve the problem partially as many libraries look like libc.so.6 (or AFAIK, on OSX both .so and .dylib are OK).


Answer URL
https://docs.python.org/3/library/ctypes.html#loading-shared-libraries
