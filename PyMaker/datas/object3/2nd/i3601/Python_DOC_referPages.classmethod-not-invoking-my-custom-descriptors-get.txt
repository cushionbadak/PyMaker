Natural Text
I have a decorator called  that turns a function into two versions of itself: one that can be called directly and prefixes the result with  and one that can be called with  and prefixes the results with :It works fine with regular methods and static methods - but  does not work with class methods: is invoking , which binds the underlying function and passes the bound method to a new instance of  - which is why both  and  work. is simply returning the original  instance - where both the regular and the special calls are simple. is binding without calling my .The new bound object knows to pass the class as the first argument when being called directly - so  works. is simply calling the  of the underlying function ( does not know how to bind it) - so  is invoking an unbound function, hence the .Is there any way for  to know it's being called from a ? Or some other way around this problem?
 is a descriptor that returns a bound method. It doesn't invoke your  method in this process because it can't do so without breaking some contracts of the descriptor protocol. (Namely, the fact that  should be an instance, not a class.) So your  method not being called is completely expected.So how do you make it work? Well, think about it: You want both  and  to return a  instance. In order to achieve that, you simply apply the  decorator last:This gives you full control over if/when/how the decorated function's descriptor protocol is invoked. Now you just need to remove the  special case in your  method, because it prevents classmethods from working correctly. (The reason is that classmethod objects are not callable; you have to invoke the descriptor protocol to turn the classmethod object into a function that can be called.) In other words, the  method has to unconditionally call the decorated function's  method, like this:And now all your assertions will pass.
The problem is that  doesn't call the wrapped function's —because that's basically the whole point of . You can look at the pure-Python equivalent to  in the Descriptors HOWTO, or the actual CPython C source in , for details, but you'll see that there's really no way around this.Of course if you just  a , instead of the other way around, everything will work fine when called on an instance:… but now it won't work when called on the class:… because you're trying to call a  object, which isn't callable.But this problem, unlike the previous one, is fixable. In fact, the only reason this fails is this part:When you try to bind a  instance to a class, it just returns  instead of binding its wrapped object. Which means it ends up as just a wrapper around a  object rather than a wrapper around a bound class method, and of course you can't call a  object.But if you just leave that out, it'll let the underlying  bind the same way a normal function does, which does exactly the right thing, and now everything works:Of course this will cause problems with wrapping unbound method objects in Python 2.7, but I think your design already breaks for normal methods in 2.7, and hopefully you only care about 3.x here anyway.


Answer URL
https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods
