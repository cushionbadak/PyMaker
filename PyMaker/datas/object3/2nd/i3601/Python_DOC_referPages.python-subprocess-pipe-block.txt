Natural Text
For some reasons, in this example  seems to be blocked (because it's waiting for EOF?). But the writing end of the pipe should have been closed.
The problem here is that all processes inherit all open file descriptors, and that there will only be an EOF on the read end of the pipe when the write end has been closed in all processes. Because the  process itself keeps the write end open calling  in your main process is not enough.For this case  has the  argument, which when set to  will cause all open file descriptors except those used for stdin, stderr and stout to be closed immediately after creating the subprocess. If you do that the your example should work as expected.On python2  is the default, in python3 this was changed to , and additionally since python3.4 file desciptors that should be inherited need to be marked as inheritable explicitly using . That reduces this kind of problem.
The reason your program never exits is that you're waiting on cat, except cat is waiting for an EOF that never comes.when you call , it reads from the file descriptor and prints it to stdout because you didn't redirect stdout.This is why you still see '123' on the screen.Consider either of these options instead:Use a queue:or use  but use  and  instead


Answer URL
https://docs.python.org/3/library/os.html#inheritance-of-file-descriptors
