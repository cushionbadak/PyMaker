Natural Text
I wonder how and why this happens. Can someone explain this?Contact is my own class that I made in my editor.What should I do if I want to make them point to the same memory address?
Each time you call  a new instance is created, even if you pass it identical args. How is Python to know that you want contacts with the same args to actually be the same object? In general, that would not be desirable. If you want two names for the same instance, just do a simple assignment, egIf you really do want two (or more) calls to  with identical args to return the same object you can give the  constructor a cache, eg . Here's a short demo.outputWhen you call , its  method is called to construct the new instance object. That object is then passed to  to get initialised. In most classes, the  method isn't defined, so the  method of the parent class is called, normally that's the default  inherited from the  base class. In the above code we define  and decorate it with . So when we call  the  type and any other args get processed by , which maintains an invisible dictionary of all  instances we create, keyed by the args passed to  (including the the  type). If that key is in the dict, the corresponding instance gets returned by . Otherwise, a new  is allocated and added to the . In either case, the instance is then passed to  for initialization.The above code is a proof of concept. I do not recommend doing this in real code. The invisible  maintained by  keeps a reference to every contact you create, so they will not get deleted when they (appear to) go out of scope, even if you pass them to , until the program terminates. To force a contact to be deleted you need to clear it from the cache, you could do that with:but of course that clears the entire cache.
Defining equivalence () for objects is pretty simple by implementing  (docs linked):Here,  is a method accepting one argument (the thing it's being compared to) and should return either  or  (or something coercible to a boolean).  This is a very simple and "flimsy" implementation as things like  will throw an error, but it demonstrates the idea.However, there is no magic method you can implement to define reference equality ().  In general you should think of  being used to test whether they're the exact same object, and  being used to test whether the two objects are equivalent.[1] Yes, it is nonetheless sort of possible with caching and either using metaclasses or , 
Alright so basically Python has aliasing. And to check if 2 objects are an alias to each other you writeIf it returns True then they are an alias. Well, basically Python checks for the two objects id. The above statement is equivalent to: is used to evaluate the address of an object in the memory.When your writing b already got an address in memory but when you're comparing it with ,  has a different address in memory. I don't understand why are you comparing the whole class instead of the attributes. and  will solve your problem.


Answer URL
https://docs.python.org/3/library/functools.html#functools.lru_cache
https://docs.python.org/3/reference/datamodel.html#object.__eq__
