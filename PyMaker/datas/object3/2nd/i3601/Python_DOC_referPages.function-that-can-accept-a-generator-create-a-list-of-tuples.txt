Natural Text
I need a rolling window (aka sliding window) iterable over a sequence/iterator/generator.  Default Python iteration can be considered a special case, where the window length is 1.  I'm currently using the following code.  Does anyone have a more Pythonic, less verbose, or more efficient method for doing this?
There's one in an old version of the Python docs with  examples:The one from the docs is a little more succinct and uses  to greater effect I imagine.
This seems tailor-made for a  since you essentially have a FIFO (add to one end, remove from the other). However, even if you use a  you shouldn't be slicing twice; instead, you should probably just  from the list and  the new item.Here is an optimized deque-based implementation patterned after your original:In my tests it handily beats everything else posted here most of the time, though pillmuncher's  version beats it for large iterables and small windows. On larger windows, the  pulls ahead again in raw speed.Access to individual items in the  may be faster or slower than with lists or tuples. (Items near the beginning are faster, or items near the end if you use a negative index.) I put a  in the body of my loop; this plays to the deque's strength (iterating from one item to the next is fast, so this loop ran a a full 20% faster than the next fastest method, pillmuncher's).  When I changed it to individually look up and add items in a window of ten, the tables turned and the  method was 20% faster. I was able to recover some speed by using negative indexes for the last five terms in the addition, but  was still a little faster. Overall I would estimate that either one is plenty fast for most uses and if you need a little more performance, profile and pick the one that works best.
I like :gives:
Here's a generalization that adds support for ,  parameters:It yields in chunks  items at a time rolling  positions per iteration padding each chunk with  if necessary. Example for :For an example of use case for the  parameter, see Processing a large .txt file in python efficiently.
Just a quick contribution.Since the current python docs don't have "window" in the itertool examples  (i.e., at the bottom of http://docs.python.org/library/itertools.html), here's an snippet based on the code for grouper which is one of the examples given:Basically, we create a series of sliced iterators, each with a starting point one spot further forward.  Then, we zip these together.  Note, this function returns a generator (it is not directly a generator itself).Much like the appending-element and advancing-iterator versions above, the performance (i.e., which is best) varies with list size and window size.  I like this one because it is a two-liner (it could be a one-liner, but I prefer naming concepts).It turns out that the above code is wrong.  It works if the parameter passed to iterable is a sequence but not if it is an iterator.  If it is an iterator, the same iterator is shared (but not tee'd) among the islice calls and this breaks things badly.  Here is some fixed code:Also, one more version for the books.  Instead of copying an iterator and then advancing copies many times, this version makes pairwise copies of each iterator as we move the starting position forward.  Thus, iterator t provides both the "complete" iterator with starting point at t and also the basis for creating iterator t + 1:
Just to show how you can combine  recipes, I'm extending the  recipe as directly as possible back into the  recipe using the  recipe:The  recipe is the same as for , it just replaces the single element "consume" on the second -ed iterator with progressively increasing consumes on  iterators. Using  instead of wrapping each iterator in  is marginally faster (for sufficiently large iterables) since you only pay the  wrapping overhead during the  phase, not during the process of extracting each window-ed value (so it's bounded by , not the number of items in ).Performance-wise, compared to some other solutions, this is pretty good (and better than any of the other solutions I tested as it scales). Tested on Python 3.5.0, Linux x86-64, using   magic.kindall's the  solution, tweaked for performance/correctness by using  instead of a home-rolled generator expression and testing the resulting length so it doesn't yield results when the iterable is shorter than the window, as well as passing the  of the  positionally instead of by keyword (makes a surprising difference for smaller inputs):Same as previous adapted kindall solution, but with each  changed to  so storing results from the generator works without all stored results really being a view of the most recent result (all other reasonable solutions are safe in this scenario), and adding  to the function definition to move use of  from the  in  to the :-based solution shown above:Same as , but inlining  case of  to avoid function call and  test to reduce runtime, particularly for small inputs where the setup overhead is a meaningful part of the work:(Side-note: A variant on  that uses  with the default argument of 2 repeatedly to make nested  objects, so any given iterator is only advanced once, not independently consumed an increasing number of times, similar to MrDrFenner's answer is similar to non-inlined  and slower than the inlined  on all tests, so I've omitted it those results for brevity).As you can see, if you don't care about the possibility of the caller needing to store results, my optimized version of kindall's solution wins most of the time, except in the "large iterable, small window size case" (where inlined  wins); it degrades quickly as the iterable size increases, while not degrading at all as the window size increases (every other solution degrades more slowly for iterable size increases, but also degrades for window size increases). It can even be adapted for the "need tuples" case by wrapping in , which runs ever so slightly slower than putting the tupling in the function, but it's trivial (takes 1-5% longer) and lets you keep the flexibility of running faster when you can tolerate repeatedly returning the same value.If you need safety against returns being stored, inlined  wins on all but the smallest input sizes (with non-inlined  being slightly slower but scaling similarly). The  & tupling based solution wins only for the smallest inputs, due to smaller setup costs, and the gain is small; it degrades badly as the iterable gets longer.For the record, the adapted version of kindall's solution that s s I used was:Drop the caching of  in the function definition line and the use of  in each  to get the faster but less safe version.
I use the following code as a simple sliding window that uses generators to drastically increase readability.  Its speed has so far been sufficient for use in bioinformatics sequence analysis in my experience.I include it here because I didn't see this method used yet.  Again, I make no claims about its compared performance.
a slightly modified version of the deque window, to make it a true rolling window. So that it starts being populated with just one element, then grows to it's maximum window size, and then shrinks as it's left edge comes near the end:this gives

There is a library which does exactly what you need:
Multiple iterators! raises  when the sequence is finished, and for some cool reason that's beyond me, the yield statement here excepts it and the function returns, ignoring the leftover values that don't form a full window.Anyway, this is the least-lines solution yet whose only requirement is that  implement either  or  and doesn't rely on  or  besides @dansalmo's solution :)
Made this for a rolling average function
why notIt is documented in Python doc .You can easily extend it to wider window. 
"""
Let's make it lazy!

How about using the following:Output:
This is an old question but for those still interested there is a great implementation of a window slider using generators in this page (by Adrian Rosebrock). It is an implementation for OpenCV however you can easily use it for any other purpose. For the eager ones i'll paste the code here but to understand it better I recommend visiting the original page. Tip: You can check the  of the window when iterating the generator to discard those that do not meet your requirementsCheers
Modified DiPaolo's answer to allow arbitrary fill and variable step size


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/itertools.html
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists
