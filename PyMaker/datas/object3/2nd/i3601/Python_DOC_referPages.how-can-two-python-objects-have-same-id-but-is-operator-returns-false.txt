Natural Text
If two variable point to same object 'is' operator will return true.But first line said both have same id but 'is' operator give false value.
In the first example, your objects don't overlap in time: one is created then destroyed, then another is created with the same id.When you compare them with , you are holding onto both objects, so they get different ids.
As explained by Ned Batchelder's answer, and by the docs for the  function:Two objects with non-overlapping lifetimes may have the same  value.And the two objects have non-overlapping lifetimes.The fact that they're part of the same tuple expression doesn't change that, because it's not  and  that are part of a tuple, it's  and . So, those two integer values returned by  have an overlapping lifetime, but the arguments passed to  do not.One way to understand this is to look at how CPython compiles the code:So, here's what happens. (I'm going to pick a value for , say , just to make this a bit easier to follow.), , and  get pushed on the stack. creates a  value at location . gets called on that value and returns a  value at location, say, .Since the  value is no longer on the stack and wasn't stored anywhere, 's parameter was the only reference to it, so when it gets decrefed at the end of the function, it's immediately deleted., , and  get pushed on the stack. creates a new  object. Since location  was just returned to the object pool, the new value reuses that location. returns another , this time at location, say, .So, the two  values  and  have overlapping lifetimes (and the first one overlaps with the second ), the two s do not overlap.And finally, notice that if  is a small number, … because all  values (except in unusual cases) are references to the same object.And meanwhile, if  is a constant rather than a variable,  may or may not be true, depending on your CPython version, because of the way constant folding within a compilation unit works.All of which goes to show that trying to actually take advantage of whether two equal s are or are not the same object is pretty much always a terrible idea. The only reason you should ever care about this question is if you're trying to learn more about the internals of CPython.And of course this is all CPython-specific. Most other Python interpreters use some form of garbage collector instead of refcounting, so the first  is unlikely to be destroyed before the second one is created. Plus, not all of them use an object pool like CPython. Not to mention that they're allowed to do completely different things for  as long as they can guarantee unique values for non-overlapping objects.PyPy will actually usually return the same value here—but only because it folds  and  into the same object in the first place; try it with  and t*3id`s.


Answer URL
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/library/functions.html#id
