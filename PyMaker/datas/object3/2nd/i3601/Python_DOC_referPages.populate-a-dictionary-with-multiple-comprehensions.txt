Natural Text
I'm trying to create a dictionary that looks something like this (a partial example):The critical logic that seems to be a problem for some cleverer solutions is that one set of values are spread across 3 keys, another set is spread across 2 keys, and a third set has one key each.Instead of writing the duplicates multiple times, I'd rather create it programmatically with some kind of comprehension. This works great, for example, to create the first part of it. I could do:This is messy, inelegant, and poor style for constants.I'm at a loss for any other strategy. I've tried some forms of serial comprehension:But this fails because dict() doesn't take more than one argument. I can't do Python 3 unpacking generalizations:Because that style is restricted to strings for reasons I don't understand. Using strings would require later conversion of the random numbers that will be used to reference the dict, and seems like more of a headache (although, I suppose that depends on if there's an elegant solution at all).And a dict comprehension doesn't seem robust enough (full data here: where the first 6 are 3 times as common as the last 6):This ends up leaving my 6x6 bounds due to the list size. If I modulo x, it ends up overwriting entries. It seems like I'd have to write a specialized function in order to cover the quirky 3/2/1 repetition, which seems unnecessary for what should be possible via some kind of comprehension.Is there some way to declare a dictionary with this complexity in a single line? If not, what's the proper style to declare this kind of constant?
As the saying goes:Don't write programs, write programs that write programs.What I would suggest is to start an interactive session (or IPython), create the partial dicts and use  to merge them.Then print out the combined  and paste it into your source code.
The 2D structure you are describing is actually a good fit for numpy arrays:Please note how natural this line reads: make an array, reshape to 3 rows, 6 columns each, repeat vertically (axis 0) the first element 3 times, the second twice and the last once.Result:This is almost correct, only indexing is zero-based, so we need to add one dummy column and one dummy row:Now, this is "duck"-equivalent to your dictionary, lookup-wise. For example:
If you're looking for a one-liner comprehension, how about something like this?
That key scheme is a bit arcane. Here's one way to condense it a little. Let (n0, n1) be a key for a given category name. For each name, n1 is constant, but n0 covers a contiguous range, so we can just store the first and last items of that range. Then we use a dict comprehension with a double  loop to expand the condensed version into the dict that you actually want.outHere's the equivalent of that dict comp using traditional  loops. You may find this version a little more readable.


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#dictionaries
