Natural Text
TL;DR Is there any way to create a weak reference that will call a callback upon having 1 strong reference left instead of 0?For those who think it's an X Y problem, here's the long explanation:I have quite a challenging issue that I'm trying to solve with my code.Suppose we have an instance of some class Foo, and a different class Bar which references the instance as it uses it:Now here's the tricky part: You can solve this issue using a circular reference, where  references  and  references , but hey, what's the fun part in that? It will take longer to clean up, will not work in case Foo defines  and generally will be a poor solution.Is there any way, I can create a  mapping that cleans upon a single reference to both  and ? In essence:This way it can work perfectly as having  outside the function makes sure  is still there (I might require  on  to support ) and having  outside the function results in  still being there (because of the strong reference in ). does not work beacuse  will cause circular reference.Alternatively, is there any way to hook into the reference counting mechanism (in order to clean when both objects get to 1 reference each) without incurring significant overhead?
You are overthinking this. You don't need to track if there is just one reference  left. Your mistake is to create a circular reference in the first place.Store  objects in your cache, that have no reference to  instances. Upon access to the mapping, return a lightweight  instance that contains both the  and  references:Translating this to the  project linked in the comments, you can simplify things drastically:Don't worry about lack of support for weak references in projects. Document that your project will only support per-instance data on types that have a  attribute. That's enough.Don't distinguish between slots and no-slots types. Always store per-instance data away from the instances. This lets you simplify your code.The same goes for the 'strong' and 'autocache' flags. The flyweight should always keep a strong reference. Per-instance data should always be stored. Use a single class for the descriptor return value. The  type is all you need. Store the  and  data passed to  in that object, and vary behaviour in  accordingly.Look at  to encapsulate access to the class and instance mappings for read access.


Answer URL
https://docs.python.org/3/library/collections.html#collections.ChainMap
