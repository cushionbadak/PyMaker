Natural Text
Is saying:The same as saying:I would rather not use the types module if I can avoid it.
No, they are not the same. just checks whether  is callable. Things that are callable include:Bound method objects (whose type is ).Plain-old functions (whose type is ) instances wrapping bound method objects (whose type is )Instances of you own custom callable class with a  method that are designed to be indistinguishable from bound method objects (whose type is your class).Instances of a subclass of the bound method type (whose type is that subclass).… accepts only the first of these. Nothing else, not even subclasses of , will pass. (If you want to allow subclasses, use .)The former is almost certainly what you want. If I've monkeypatched an object to replace the  method with something that acts just like a  method when called, but isn't implemented as a bound method, why would your code want to reject my object?As for your side question in the comments:I do want to know if the exceptions.ValueError is necessaryNo, it's not.In Python 2.7, the builtin exceptions are also available in the  module:In Python 3, they were moved to  along with all the other builtins:But either way, the only reason you'd ever need to refer to its module is if you hid  with a global of the same name in your own module.One last thing:As user2357112 points out in a comment, your solution doesn't really ensures anything useful.The most common problem is almost certainly going to be  not existing at all. In which case you're going to get an  rather than the  you wanted. (If this is acceptable, you don't need to check anything—just call the method and you'll get an  if it doesn't exist, and a  if it does but isn't callable.) You could solve that by using  instead of , because  is not callable.The next most common problem is probably going to be  existing, and being callable, but with the wrong signature. Which means you'll still get the same  you were trying to avoid when you try to call it. You could solve that by, e.g., using the  module.But if you really want to do all of this, you should probably be factoring it all out into an ABC. ABCs only have built-in support for checking that abstract methods exist as attributes; it doesn't check whether they're callable, or callable with the right signature. But it's not that hard to extend that support. (Or, maybe better, just grabbing one of the interface/protocol modules off PyPI.) And I think something like  would declare your intention a lot better than a bunch of lines involving  or , type checking, and  grubbing.


Answer URL
https://docs.python.org/3/library/functions.html#callable
https://docs.python.org/3/library/abc.html
