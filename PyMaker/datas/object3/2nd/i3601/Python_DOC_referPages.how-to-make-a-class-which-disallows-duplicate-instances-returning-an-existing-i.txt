Natural Text
I have data, and each entry needs to be an instance of a class.  I'm expecting to encounter many duplicate entries in my data. I essentially want to end up with a set of all the unique entries (ie discard any duplicates).  However, instantiating the whole lot and putting them into a set after the fact is not optimal because...I have many entries,the proportion of duplicated entries is expected to be rather high,my  method is doing quite a lot of costly computation for each unique entry, so I want to avoid redoing these computations unnecessarily.I recognize that this is basically the same question asked here but...the accepted answer doesn't actually solve the problem.  If you make  return an existing instance, it doesn't technically make a new instance, but it still calls  which then redoes all the work you've already done, which makes overriding  completely pointless.  (This is easily demonstrated by inserting  statements inside  and  so you can see when they run.)the other answer requires calling a class method instead of calling the class itself when you want a new instance (eg:  instead of ).  This works, but it isn't ideal IMHO since it is not the normal way one would think to make a new instance.Can  be overridden so that it will return an existing entity without running  on it again?  If this isn't possible, is there maybe another way to go about this?
Assuming you have a way of identifying duplicate instances, and a mapping of such instances, you have a few viable options:Use a  to get your instances for you. The classmethod would serve a similar purpose to  in your metaclass (currently ). The main difference is that it would check if an instance with the requested key already exists before calling :I would recommend using this base class, especially if your class is mutable in any way. You do not want modifications of one instance show up in another without making it clear that the instances are potentially the same. Doing  implies that you are getting a different instance every time, or at least that your instances are immutable and you don't care.Redefine  in your metaclass:Here,  is equivalent to calling  and  for .In both cases, the basic caching code is the same. The main difference is how to get a new instance from the user's perspective. Using a  like  intuitively informs the user that they are getting a duplicate instance. Using a normal call to the class object implies that the instance will always be new, so should only be done for immutable classes.Notice that in neither case shown above is there much of a point to calling  without .A third, hybrid option is possible though. With this option, you would be creating a new instance, but copying over the expensive part of 's computation from an existing instance, instead of doing it all over again. This version would not cause any problems if implemented through the metaclass, since all the instances would in fact be independent:With this option, remember to call  and ( if you need it).


Answer URL
https://docs.python.org/3/library/functions.html#classmethod
