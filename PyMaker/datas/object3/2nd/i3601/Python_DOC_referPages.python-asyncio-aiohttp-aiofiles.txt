Natural Text
I seem to be having a difficult time understanding pythons asyncio. I have not written any code, as all the examples I see are for one-off runs. Create a few coroutine's, add them to an event loop, then run the loop, they run the tasks switching between them, done. Which does not seem all that helpful for me.I want to use asyncio to not interrupt the operation in my application (using pyqt5). I want to create some functions that when called run in the asyncio event loop, then when they are done they do a callback.What I imagine is. Create a separate thread for asyncio, create the loop and run it forever. Create some functions , , , etc. Then in the UI, I have a text box with a submit button, user enters url, clicks submit, it downloads the file.But, every example I see, I cannot see how to add a coroutine to a running loop. And I do not see how I could do what I want without adding to a running loop. This is what I imagine, but it does not work.
To add a coroutine to a loop running in a different thread, use :In general, when you are interacting with the event loop from outside the thread that runs it, you must run everything through either  (for coroutines) or  (for functions). For example, to stop the loop, use . Also note that  must not be invoked inside a loop callback, so you should place that call in , right after the call to , at which point the loop has definitely stopped running.Another thing with asyncio is that passing explicit  callbacks isn't idiomatic because asyncio exposes the concept of futures (akin to JavaScript promises), which allow attaching callbacks to a not-yet-available result. For example, one could write  like this:It doesn't need a  argument because any interested party can convert it to a task using  and use  to be notified when the task is complete. For example:In your case you're not dealing with the task directly because your code aims to communicate with the event loop from another thread. However,  returns a very useful value - a full-fledged  which you can use to register done callbacks. Instead of accepting a  argument, you can expose the future object to the caller:Now the caller can choose a callback-based approach:or, when appropriate, they can even wait for the result:The latter is by definition blocking, but since the event loop is safely running in a different thread, it is not affected by the blocking call.
Install QualMash to smooth integration between Qt and asyncio.Example from the project's README gives an inspiration for how it looks like:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe%60
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.call_soon_threadsafe
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
