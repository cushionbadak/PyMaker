Natural Text
I thought I understood the basics of list slicing in python, but have been receiving an unexpected error while using a negative step on a slice, as follows:(Note that this is being run in Python 3.5)Why doesn't a[:-1:-1] reverse step through the a[:-1] slice in the same manner as it does through the whole list with a[::-1]? I realize that you can use list.reverse() as well, but trying to understand the underlying python slice functionality better. 
The first  in  doesn't mean what you think it does.In slicing, negative start/end indices are not interpreted literally. Instead, they are used to conveniently refer to the end of the list (i.e. they are relative to ). This happens irrespectively of the direction of the slicing.This means thatis equivalent toWhen omitted during reverse slicing, the start index defaults to , making the above equivalent toThis always gives an empty list, since the start and end indices are the same and the end index is exclusive.To slice in reverse up to, and including, the zeroth element you can use any of the following notations:
When you type  it is the same as . So  is the shorthand for  object.  signature is  or  and you can also use  for arguments.Suppose we have got . Rules for indices will be as follows:  First  is checked. Default is , sign of  indicates forward or backward direction of the step. Absolute value of  indicates the step size.  Than  is checked. When  is positive or , default for  is . When  is negative, default for  is .Finally  is checked. When  is positive or , default for  is . When  is negative default for  is .Note 1: Degenerated slices in Python are handled gracefully:  the index that is too large or too small is replaced with  or .  an upper bound smaller than the lower bound returns an empty list or string or whatever else (for positive ). Note 2: Roughly speaking, Python picks up elements while this condition  is  (updating  on every step). Also, all negative indices are replaced with .If you combine this rules and notes it will make sense why you got an empty list. In your case:There is very good discussion about slice notation: Explain Python's slice notation!
I generally find it useful to slice a -object (this is only possible in python3 - in python2  produces a  and  can't be sliced) if I need to see which indices are used for a list of a given length:And in your last case:This also explains what happened. The first index is 9, but 9 isn't lower than the stop index 9 (note that in python the stop index is excluded) so it stops without giving any element.Note that indexing can also be applied sequentially:
Python's slices seem fairly simple at first, but their behaviour is actually quite complex (notes 3 and 5 are relevant here). If you have a slice :If  or  are negative, they refer to an index from the end of  (so  refers to the last element of )If  or  are not specified, or are , they default to the ends of , but which ends depends on the sign of :if  is positive, you're slicing forwards, so  becomes 0 and  becomes if  is negative, you're slicing backwards, so  becomes  and  becomes the element before the start of .NB:  cannot be replaced with -1, since doing that will cause Python to treat  as the last element of  rather than the (nonexistent) element before . To get the desired behaviour, you must use  (or ) in place of , which means that to get to , slice starts at the last element of , goes left for  elements and then left one more element, ending up before  starts and thus including  in the slice.Therefore,  means "go from the end of , which is  (since  is unspecified and  is negative), to the last element of  (since ), with step size of -1".  and  are equal – you start and stop slicing in the same place – so the expression evaluates to an empty list.To reverse , you can use . This way, the slice starts at the penultimate element,  (since  does not include ) and goes backwards until the element "before" , meaning that  is included in the slice.
 works similar to  in that when you make the  argument a negative number, the  and  arguments work in the opposite direction.Some examples that may help make this more clear:


Answer URL
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
https://docs.python.org/3/library/stdtypes.html#common-sequence-operations
