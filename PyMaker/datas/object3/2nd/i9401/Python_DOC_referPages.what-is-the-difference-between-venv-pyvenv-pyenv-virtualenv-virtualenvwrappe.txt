Natural Text
Python 3.3 includes in its standard library the new package . What does it do, and how does it differ from all the other packages that seem to match the regex ?
PyPI packages not in the standard library: is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool, and I'll be making comparisons to it for the rest of this answer.It works by installing a bunch of files in a directory (eg: ), and then modifying the  environment variable to prefix it with a custom  directory (eg: ). An exact copy of the  or  binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using . is used to isolate Python versions. For example, you may want to test your code against Python 2.6, 2.7, 3.3, 3.4 and 3.5, so you'll need a way to switch between them. Once activated, it prefixes the  environment variable with , where there are special files matching the Python commands (, ). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the  environment variable, or the  file, or the  file.  also makes the process of downloading and installing multiple Python versions easier, using the command . is a plugin for  by the same author as , to allow you to use  and  at the same time conveniently. However, if you're using Python 3.3 or later,  will try to run  if it is available, instead of . You can use  and  together without , if you don't want the convenience features. is a set of extensions to  (see docs). It gives you commands like , , and especially  for switching between different  directories. This tool is especially useful if you want multiple  directories. is a plugin for  by the same author as , to conveniently integrate  into ., by Kenneth Reitz (the author of ), is the newest project in this list. It aims to combine ,  and  into one command on the command-line. The  directory typically gets placed in , with  being a hash of the path of the project directory. This is different from , where the directory is typically in the current working directory.The Python Packaging Guide recommends  when developingPython applications (as opposed to libraries). There does not seem tobe any plans to support  instead of  (#15).Confusingly, its command-line option  refers to the directory, not , and similarly, the environmentvariable  affects the location of the directory, not  directory (#1919).Standard library: is a script shipped with Python 3 but deprecated in Python 3.6 as it had problems (not to mention the confusing name). In Python 3.6+, the exact equivalent is . is a package shipped with Python 3, which you can run using  (although for some reason some distros separate it out into a separate distro package, such as  on Ubuntu/Debian). It serves a similar purpose to , and works in a very similar way, but it doesn't need to copy Python binaries around (except on Windows). Use this if you don't need to support Python 2. At the time of writing, the Python community seems to be happy with  and I haven't heard much talk of .Most of these tools complement each other. For instance,  integrates ,  and even  if desired. The only tools that are true alternatives to each other here are  and .Recommendation for beginners:This is my personal recommendation for beginners: start by learning  and , tools which work with both Python 2 and 3 and in a variety of situations, and pick up the other tools once you start needing them.
I would just avoid the use of  after Python3.3+ and instead use the standard shipped library . To create a new virtual environment you would type: tries to copy the Python binary into the virtual environment's bin directory. However it does not update library file links embedded into that binary, so if you build Python from source into a non-system directory with relative path names, the Python binary breaks. Since this is how you make a copy distributable Python, it is a big flaw. BTW to inspect embedded library file links on OS X, use . For example from within your virtual environment, type:Consequently I would avoid  and .  is deprecated.  seems to be used often where  is used but I would stay away from it also since I think  also does what  is built for.   creates virtual environments in the shell that are fresh and sandboxed, with user-installable libraries, and it's multi-python safe. Fresh because virtual environments only start with the standard libraries that ship with python, you have to install any other libraries all over again with  while the virtual environment is active. Sandboxed because none of these new library installs are visible outside the virtual environment, so you can delete the whole environment and start again without worrying about impacting your base python install. User-installable libraries because the virtual environment's target folder is created without  in some directory you already own, so you won't need  permissions to install libraries into it. Finally it is multi-python safe, since when virtual environments activate, the shell only sees the python version (3.4, 3.5 etc.) that was used to build that virtual environment.    is similar to  in that it lets you manage multiple python environments. However with  you can't conveniently rollback library installs to some start state and you will likely need  privileges at some point to update libraries. So I think it is also best to use .  In the last couple of years I have found many problems in build systems (emacs packages, python standalone application builders, installers...) that ultimately come down to issues with . I think python will be a better platform when we eliminate this additional option and only use .


Answer URL
https://docs.python.org/3/library/venv.html
https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH
