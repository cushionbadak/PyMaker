Natural Text
Summary:There is a variety of function for which it would be very useful to be able to pass in two kinds of objects: an object that represents a path (usually a string), and an object that represents a stream of some sort (often something derived from , but not always). How can this variety of function differentiate between these two kinds of objects so they can be handled appropriately?  Say I have a function intended to write a file from some kind of object file generator method: This works. Yay. But I'd prefer to not have to worry about opening the file first or passing streams around, at least sometimes... so I refactor with the ability to take a file path like object instead of a file like object, and a  statement:But now I get the idea that it would be useful to have a third function that combines the other two versions depending on whether  is file like, or file path like, but returns the f destination file like object to a context manager. So that I can write code like this: ...but also like this: Note that this will require something a bit different than the simplified versions provided above. Try as a I might, I haven't been able to find an obvious way to do this, and the ways I have found seem pretty contrived and just a potential for problems later. For example:Are there any suggestions for a better way? Am I way off base and need to be handling this completely differently? 
For my money, and this is an opinionated answer, checking for the attributes of the file-like object for the operations you will need is a pythonic way to determine an object’s type because that is the nature of pythonic duck tests/duck-typing:Duck typing is heavily used in Python, with the canonical example being file-like classes (for example,  allows a Python string to be treated as a file).  Or from the python docs’ definition of duck-typingA programming style which does not look at an object’s type to determine if it has the right interface; instead, the method or attribute is simply called or used (“If it looks like a duck and quacks like a duck, it must be a duck.”) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using  or . (Note, however, that duck-typing can be complemented with abstract base classes.) Instead, it typically employs  tests or EAFP programming.If you feel very strongly that there is some very good reason that just checking the interface for suitability isn't enough, you can just reverse the test and test for  or  to test whether the provided object is path-like.  The test will be different depending on your version of python.In any case, for your context manager, I would go ahead and make a full-blown object like the below in order to wrap the functionality that you were looking for.  And then use it like this:If you wanted to use try/catch semantics to check for type suitability, you could also wrap the file operations you wanted to expose on your context guard:
Probably not the answer you're looking for, but from a taste point of view I think it's better to have functions that only do one thing. Reasoning about them is easier this way.I'd just have two functions: , which handles your first case, and a convenience function that wraps  and creates a file for you.
my suggestion is to pass  objects around. you can simply  or   to these objects.other that that you'd have to check the type of your  variable (this is how polymorphism can be done in python):(i hope  is the most basic class to check against...). and you would have to catch possible exceptions around all that.
Another approach to this problem, inspired by this talk from Raymond Hettinger at PyCon 2013, would be to keep the two functions separate as suggested by a couple of the other answers, but to bring the functions together into a class with a number of alternative options for outputting the object. Continuing with the example I started with, it might look something like this: Now we have lots of different options for exporting a  object by using a  object. We can just write it to a file directly: We can override the path, too:But we can also use an existing open stream:Or, if we want to edit the string first we could open a new file stream ourselves and write the edited string to it: And finally, we can just use a context manager with the  object directly to as many different locations- or streams- as we like (note that we can pass the  object directly without worrying about string conversion, which is nifty):This approach is more consistent with the mantra: explicit is better than implicit. 


Answer URL
https://docs.python.org/3/library/pathlib.html
https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes
https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text
https://docs.python.org/3/library/io.html#io.IOBase
