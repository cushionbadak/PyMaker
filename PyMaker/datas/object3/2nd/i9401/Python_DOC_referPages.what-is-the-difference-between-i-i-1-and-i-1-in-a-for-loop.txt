Natural Text
This question already has an answer here:When is “i += x” different from “i = i + x” in Python?                    4 answers                I found out a curious thing today and was wondering if somebody could shed some light into what the difference is here?After running each  loop,  has not changed, but  has had one added to each element. I actually use the  version to write to a initialized NumPy array within a  loop.
The difference is that one modifies the data-structure itself (in-place operation)  while the other just reassigns the variable .Just for completeness: is not always doing an in-place operation, there are (at least) three exceptions:If  doesn't implement an  method then the  statement is just a shorthand for . This would be the case if  was something like an .If  returns , Python falls back to .The  method could theoretically be implemented to not work in place. It'd be really weird to do that, though.As it happens your s are s which implements  and return itself so your second loop modifies the original array in-place.You can read more on this in the Python documentation of "Emulating Numeric Types".These [] methods are called to implement the augmented arithmetic assignments (, , , , , , , , , , , , ). These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). If a specific method is not defined, the augmented assignment falls back to the normal methods. For instance, if x is an instance of a class with an  method,  is equivalent to  . Otherwise,  and  are considered, as with the evaluation of . In certain situations, augmented assignment can result in unexpected errors (see Why does  raise an exception when the addition works?), but this behavior is in fact part of the data model.
In the first example, you are reassigning the variable , while in the second one you are modifying the data in-place, using the  operator.See the section about 7.2.1. Augmented assignment statements:An augmented assignment expression like  can be rewritten as  to achieve a similar, but not exactly equal effect. In the augmented version, x is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead. operator calls . This function makes the change in-place, and only after its execution, the result is set back to the object you are "applying" the  on. on the other hand takes the parameters and returns their sum (without modifying them).
As already pointed out,  updates  in-place, while  computes  and then assigns the name  to the result (now  does not refer to a row of  anymore).To understand the  operator properly though, we need also to understand the concept of mutable versus immutable objects. Consider what happens when we leave out the :We see that  is not updated, meaning that  and  are equivalent. This is because now  is a 1D array (), and so when iterating over , each integer element is pulled out and assigned to .Now in Python, integers are immutable, meaning that in-place updates are not allowed, effectively transforming  into , where  now refers to a new integer, not coupled to  in any way. When you loop over the reshaped arrays, whole rows (s) are assigned to  (and ) at a time, which are mutable objects, meaning that you are allowed to stick in new integers at will, which happens when you do .It should be mentioned that though  and  are ment to be related as described above (and very much usually are), any type can implement them any way it wants by defining the  and  methods, respectively.
The short form() has the option to modify  in-place , instead of creating a new object representing the sum and rebinding it back to the same name().So,The short form() is much efficient as it doesn't necessarily need to make a copy of  unlike .Also even if they are outputting the same result, notice they are different because they are separate operators:  and 
First off: The variables a and b in the loops refer to  objects.In the first loop,  is evaluated as follows: the  function of  is called. This creates a new object and hence, A is not modified. Afterwards, the variable  is set to refer to the result. In the second loop, no new object is created. The statement  calls  the  function of  which modifies the  object in place to which b is referring to. Hence,  is modified.
A key issue here is that this loop iterates over the rows (1st dimension) of :Thus the  is acting on a mutable object, an array.This is implied in the other answers, but easily missed if your focus is on the  reassignment.I could also make an in-place change to  with  indexing, or even something fancier, :Of course with a 2d array like  we usually don't need to iterate on the rows.  Many operations that work on a single of  also work on the whole thing.  , , etc.


Answer URL
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
https://docs.python.org/3/faq/programming.html#faq-augmented-assignment-tuple-error
