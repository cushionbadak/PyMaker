Natural Text
I have a list of geodesic points by the format:  in a grid formation with regular spacing throughout the dataset.  I'm trying to find all neighbouring points that are land (elv > 0) to the current point in the list.I keep getting this error:   and although I understand the sort of thing that could be causing this, I have no idea how this applies to this situation as I'm not explicitly using recursion.  How am I able to remedy this error?  How can I understand the problem better as well?(topLat, bottomLat, westLong, eastLong are the lats and longs for the first and last point in the grid/map to identify points at the edge of the map)
To stringify a point (really a ),  must first get the string representation of every element.  The last element of each point is a  of neighboring points, each of which is a  that contains yet another  of neighboring points... one of which is the original point.  And so it continues...'s  attempts to limit recursive cases, eventually giving up and returning .  Assuming it uses the same defaults as  objects, the  (max recursion depth) is 6.  With 8 neighbors each, that could mean thousands of visits to a relatively small number of unique points.I was able to print a 3×3 grid, where the fan-out is limited because most of the points only have 3 or 5 neighbors (corners and sides).  My simplified  lists, which didn't contain altitude or land/sea elements, required about 700kiB to represent the whole grid... about 40KiB for the upper-left corner alone.  On a 4×4 grid, a single point ballooned up to about 16MiB.That said, I'm guessing what your inputs look like, and I probably haven't reproduced what you're really doing.  More importantly, I did not get a  like you did, perhaps because I gave up waiting for it.With those caveats in mind, I suggest:In each point's  list, store the indices of the neighbors.  Look them up later whenever you need them.  (This is the simplest solution I could come up with.)  Write a couple helper functions that calculate the northwest or south or whatever neighbor of a given index, since you'll be doing that a lot.Alternatively, consider creating a  dictionary, mapping each point's index to a list of indices.  You'd have to keep that dictionary alongside  at all times, but it would let you remove the list of neighbors from all of your points.If you really have to store the neighbors themselves, create a  class with custom  and  methods that don't try to print the neighbors.  As a bonus, a class would let you refer to fields with names like , , and  instead of mysterious subscripts like  and .


Answer URL
https://docs.python.org/3/library/reprlib.html#repr-objects
