Natural Text
I am investigating caching behavior in different languages. I create two matrices in python using lists (yes, I know it's a linked list but bear with me here). I then multiply these matrices together in three ways:My timings are as follows:Some things to note:I am familiar with CPU caching behavior. To see my experiment in C see here though I havent gotten any reviews for it.I've done this in Javascript and C# and the flip-j-k function provides significant performance gains using arrays (JS run on chrome browser)Python implementation is Python 3.5 by way of AnacondaPlease dont tell me about numpy. My experiment is not about absolute performance but rather understanding caching behavior.Question:Anyone know what is going on here? Why does flip-j-k not provide speedup? Is it because it's a linked list? But then why does blocking provide a non-marginal improvement in performance?
The latter version (block multiplication) is only faster by 30% because you save 30% of index accessing by using a local variable in the inner loop!(and FYI this is not C++:  type is like C++  otherwise people would waste their time trying to access elements by index. So this is the fastest standard random access container available in python)I just made some test program based on your code to prove my point and what I was suspecting (I had to complete your code, sorry for the big block but at least it is minimal complete & verifiable for all).results on my PC (last results surrounded with stars are my versions):As you can see, my version of your  (the fourth one) is faster than even the block multiply, meaning that index checking & accessing dwarves the cache effect that you can experience in compiled languages & using direct pointers like C or C++.I just stored the values that were not changing in the inner loop (the one to optimize most) to avoid index access.Note that I tried to apply the same recipe to the block multiply and I gained some time compared to your version, but is still beaten by the flipjk_faster version because of the unability to avoid index access.Maybe compiling the code using Cython and drop the checks would get the result you want. But pre-computing indexes never hurts.
Python tends to not cache the results of its functions. It requires explicit notice of when you want build a cache for a function. You can do this using the  decorator.The following is code I threw together the other day and I've just added some readability. If there's something wrong, comment and I'll sort it out:BTW: "#" indicates a comment, in case you're unfamiliar with Python.So try running this and try AGAIN without the "#" on the line  Additionally, maxsize is the maximum size of the cache (works best in powers of two according to the docs) and typed just makes the cache add a new cached condition whenever a different type of the same value is passed as an argument.Finally, the "Func" function is known as Ackermann's function. A stupidly deep amount of recursion goes on so be aware of stackoverflows (lol) if you should change the max recursion depth.


Answer URL
https://docs.python.org/3/faq/design.html#how-are-lists-implemented
