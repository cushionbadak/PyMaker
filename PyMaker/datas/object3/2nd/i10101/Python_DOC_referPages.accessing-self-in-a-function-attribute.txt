Natural Text
I'm trying to add a decorator that adds callable attributes to functions that return slightly different objects than the return value of the function, but will execute the function at some point.The problem I'm running into is that when the function object is passed into the decorator, it is unbound and doesn't contain the implicit  argument.  When I call the created attribute function (ie. ), I don't have access to  and can't pass it into the original function.When I go to execute the attribute created by the decorator, this is the error I get, because  doesn't contain the  reference.Is there a way to create a decorator like this that can get a reference to ?  Or is there a way to bind the added attribute function () so that it also gets called with the implicit  argument?
You can use descriptors here:so that:This warrants an explanation.  is a decorator, but it is also a descriptor. A descriptor is an object that defines alternative behavior that is to be invoked when the object is looked up as an attribute of its parent. Interestingly, bounds methods are themselves implemented using the descriptor protocolThat's a mouthful. Let's look at what happens when we run the example code. First, when we define the  method, we apply the  decorator. Now normally we see functions as decorators, and the return value of the function is the decorated result. Here we are using a class as a decorator. As a result,  isn't a function, but rather an instance of the  type. This instance contains a reference to the  function that we wish to wrap. The  class has a  method that allows instances of it to act like functions. This implementation simply passes the arguments given to the  function it has a reference to. Note that the first argument will be the reference to the  instance.The tricky part comes in implementing . To do this, we need a reference to the  instance of which the  instance is an attribute. To accomplish this, we use the descriptor protocol. That is, we define a  method which will be invoked whenever the  instance is accessed as an attribute of some parent class instance. When this happens, it stores the parent object inside itself. Then we can simply implement  as a method on the  class, and use the reference to the parent object stored within the  instance to get at the  instance to which  belongs.This is a lot of magic, so here's a disclaimer: Though this looks cool, it's probably not a great idea to implement something like this.
You need to decorate your function at instantiation time (before creating the instance method). You can do this by overriding the  method:Demo:1. Since python doesn't let you access the real instance attribute at setting time you can use  method in order to access the real function object of the instance method.


Answer URL
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html
