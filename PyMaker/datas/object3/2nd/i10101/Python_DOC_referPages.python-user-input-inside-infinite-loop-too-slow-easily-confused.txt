Natural Text
I have a Python script running on a Raspberry Pi that sits waiting for user input and records the input in a SQLite database:That  method looks like this:(Note: The whole code repo is available at https://github.com/martinjoiner/bookfetch-scanner-python/ if you wanna see how I'm connecting to the db and such) My problem is that using a USB barcode scanner (which is effectively just a keyboard input that sends a series of keystrokes followed by the  key) it is really easy to input at such a fast rate that the command line seems to get "confused". For example compare the following results... When you go slow the script works well and the command looks neat like this:But when you hammer it hard and go really fast the input prompt kind of gets ahead of itself and the messages printed by the script get written on top of the input prompt:It sometimes hangs in that position indefinitely, I don't know what it's doing but you can wake it back up again with another input and it carries on as normal although the input before the one it hung on doesn't get recorded which is bad because it makes the whole system unreliable. My question is: Is this an inevitability that I just have to live with? Will I always be able to out-pace the low-powered Raspberry Pi by hitting it with too many inputs in close succession or is there some faster way of doing this? Can I push the database write operation to another thread or something along those lines? Forgive my ignorance, I am learning. 
Don't build SQL strings from user input. Ever. Always use parameterized queries.Please read https://docs.python.org/2/library/sqlite3.html, at the very least the upper part of the page, where they explain this approach.
You appear to be opening and closing the database each and every time. That will clearly add a huge overhead, especially as you are "hammering" away at it.Connect to the database once at the beginning and close it upon exit.In between, simply perform your ,  and  statements. Edit:For the purposes of this I renamed  to be called  so edit appropriately.Alter  to be as follows:    For your purposes replace references to "barcode1" with "db"As you can see all that happens here is that a separate function has been added to do the writing and only the writing.Clearly this is a quick mock up and could be improved immeasurably, in fact I'd rewrite it as a single script. This is one of those classic examples where in an attempt to write object oriented code, you end up shooting yourself in the foot.In fact you could do without the function and just include the  code within the  statement.Locking:from the sqlite3 documents:Opens a connection to the SQLite database file database. You can use ":memory:" to open a database connection to a database that resides in RAM instead of on disk.When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The timeout parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).
After much experimenting based on helpful advice from users @tomalak, @rolf-of-saxony and @hevlastka my conclusion is that yes, this is an inevitability that I just have to live with. Even if you strip the example down to the basics by removing the database write process and making it a simple parrot script that just repeats back inputs (See Python on Raspberry Pi user input inside infinite loop misses inputs when hit with many), it is still possible to scan items so fast that inputs get missed/skipped/ignored. The Raspberry Pi simply cannot keep up. So my approach will now be to add an audio feedback feature such as a beep sound to indicate to the user when the device is ready to receive the next input. A route I didn't want to go down but it seems my code is the most efficient it can be and we're still able to hit the limits. Responsibility is with the user to not go at breakneck speed and the best we can do a responsible product builders is give them good feedback. 
In addition to the issues I brought up in my first answer, there is another problem which effects the speed of the updates, namely the .You will find that if you  in batches, the speed goes up exponentially. Adjust the journaling and up it goes again.Working on a PI 3, I mocked up 5000 updates in 10 seconds with the journal on and in 0.43 seconds with the journal off.If you change your code to store the barcodes in a list and then fire off the database updates in batches, you code will work on a Raspberry Pi.See below for my test code:


Answer URL
https://docs.python.org/3/library/sqlite3.html
