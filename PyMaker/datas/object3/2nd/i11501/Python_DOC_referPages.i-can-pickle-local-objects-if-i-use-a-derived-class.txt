Natural Text
The  reference states that the set of objects which can be pickled is rather limited. Indeed, I have a function which returns a dinamically-generated class, and I found I can't pickle instances of that class:Such objects are too complicated for . Ok. Now, what's magic is that, if I try to pickle a similar object, but of a derived class, it works!What's happening here? If this is so easy, why doesn't  use this workaround to implement a  method that allows "local objects" to be pickled?
I think you did not read the reference you cite carefully. The reference also clearly states that only the following objects are pickleable: functions defined at the top level of a module (using def, not >lambda)built-in functions defined at the top level of a moduleclasses that are defined at the top level of a moduleYour example does not define a class at the top level of a module, it defines a class within the scope of .  works on global classes, not local classes. This automatically fails the pickleable test.  is a global class, so all is well.As for why only top-level (global to you) classes and functions can't be pickled, the reference answers that question as well (bold mine):Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value.  This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised.Similarly, classes are pickled by named reference, so the same restrictions in the unpickling environment apply.So there you have it.  only serialises objects by name reference, not by the raw instructions contained within the object. This is because  job is to serialise object hierarchy, and nothing else.
I disagree, you can pickle both.  You just need to use a better serializer, like .   (by default) pickles classes by saving the class definition instead of pickling by reference, so it won't fail your first case. You can even use  to get the source code, if you like.
 instances are pickleable because  is available through a global variable matching its fully-qualified name, which is how  looks for classes when unpickling.The problem with trying to do something like this with local classes is that there's nothing identifying which  class an instance corresponds to. If you run  twice, you get two  classes, and there's no way to tell which one should be the class of unpickled  instances from another run of the program. If you don't run  at all, you get no  classes, and then what the heck do you do about the type of unpickled instances?
You can only pickle instances of classes defined at module's top level.However, you can pickle instances of locally-defined classes if you promote them to top level.You must set the __ qualname__ class attribute of the local class. Then you must assign the class to a top-level variable of the same name.


Answer URL
https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled
https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled
