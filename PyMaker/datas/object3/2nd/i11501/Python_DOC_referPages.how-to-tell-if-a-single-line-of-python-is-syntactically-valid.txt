Natural Text
It is very similar to this:How to tell if a string contains valid Python codeThe only difference being instead of the entire program being given altogether, I am interested in a single line of code at a time.Formally, we say a line of python is "syntactically valid" if there exists any syntactically valid python program that uses that particular line.For instance, I would like to identify these as syntactically valid lines:Because one can use these lines in some syntactically valid python programs.I would like to identify these lines as syntactically invalid lines:Because no syntactically correct python programs could ever use these linesThe check does not need to be too strict, it just need to be good enough to filter out obviously bogus statements (like the ones shown above). The line is given as a string, of course.
This uses  to attempt to compile the code. This is the same logic that the  module does to determine whether to ask for another line or immediately fail with a syntax error.It can be used as follows:I'm sure at this point, you're saying "what gives?  was supposed to be invalid!" The problem with this line is that  is technically syntactically valid, at least according to the Python interpreter. In the REPL, you get this:Notice how this is a , not a .  says it is valid as well, and just treats it as a call with the function being an .These kinds of things can't easily be caught until they actually run.If some kind of monster managed to modify the value of the cached  value (which would technically be possible), you might be able to do . It's still allowed by the syntax.What about the unbalanced parentheses? This fits the same bill as . This line is invalid on its own, but may be the first line in a multi-line expression. For example, see the following:The second line is  because the expression could continue like this:and the expression would be complete. In fact,  distinguishes between these different situations by returning a code object if it's a valid self-contained line,  if the line is expected to continue for a full expression, and throwing a  on an invalid line.However, you can also get into a much more complicated problem than initially stated. For example, consider the line . If it's the start of the module, or the previous line is , then it's invalid. However, if the previous line is , it's completely valid.The solution given here will work if you only work forward, and append previous lines as context, which is what the code module does for an interactive session. Creating something that can always accurately identify whether a single line could possibly exist in a Python file without considering surrounding lines is going to be extremely difficult, as the Python grammar interacts with newlines in non-trivial ways. This answer responds with whether a given line could be at the beginning of a module and continue on to the next line without failing.It would be better to identify what the purpose of recognizing single lines is and solve that problem in a different way than trying to solve this for every case.
I am just suggesting, not sure if going to work... But maybe something with  and ?Simple lines should cause an appropriate answer


Answer URL
https://docs.python.org/3/library/codeop.html#codeop.compile_command
https://docs.python.org/3/library/code.html
https://docs.python.org/3/library/ast.html#ast.parse
https://docs.python.org/3/library/codeop.html#codeop.compile_command
https://docs.python.org/3/library/code.html
