Natural Text
I needed to create a list of lists in Python, so I typed the following:  The list looked like this:  Then I changed one of the innermost values:  Now my list looks like this:  which is not what I wanted or expected. Can someone please explain what's going on, and how to get around it?
When you write  you get, essentially, the list . That is, a list with 3 references to the same . When you then modify this single  it is visible via all three references to it.To fix it, you need to make sure that you create a new list at each position. One way to do it iswhich will reevaluate  each time instead of evaluating it once and making 3 references to 1 list.You might wonder why  can't make independent objects the way the list comprehension does. That's because the multiplication operator  operates on objects, without seeing expressions. When you use  to multiply  by 3,  only sees the 1-element list  evaluates to, not the  expression text.  has no idea how to make copies of that element, no idea how to reevaluate , and no idea you even want copies, and in general, there might not even be a way to copy the element.The only option  has is to make new references to the existing sublist instead of trying to make new sublists. Anything else would be inconsistent or require major redesigning of fundamental language design decisions.In contrast, a list comprehension reevaluates the element expression on every iteration.  reevaluates  every time for the same reason  reevaluates  every time. Every evaluation of  generates a new list, so the list comprehension does what you wanted.Incidentally,  also doesn't copy the elements of , but that doesn't matter, since integers are immutable. You can't do something like  and turn a 1 into a 2.
Live Python Tutor Visualize
Actually, this is exactly what you would expect. Let's decompose what is happening here:You writeThis is equivalent to:This means  is a list with 3 elements all pointing to . This means the two following lines are equivalent:As  is nothing but .To obtain the desired behavior, you can use list comprehension:In this case, the expression is re-evaluated for each n, leading to a different list.
or even:Creates a list that references the internal  3 times - not three copies of the inner list, so any time you modify the list (in any position), you'll see the change three times.It's the same as this example:where it's probably a little less surprising.
Alongside the accepted answer that explained the problem correctly, within your list comprehension, if You are using python-2.x use  that returns a generator which is more efficient ( in python 3 does the same job)  instead of the throwaway variable : Also, as a much more Pythonic way you can use  to create an iterator object of repeated elements :P.S. Using numpy, if you only want to create an array of ones or zeroes you can use  and  and/or for other number use :
In simple words this is happening because in python everything works by reference, so when you create a list of list that way you basically end up with such problems.To solve your issue you can do either one of them:1. Use numpy array documentation for numpy.empty2. Append the list as you get to a list.3. You can also use dictionary if you want  
Python containers contain references to other objects. See this example:In this  is a list that contains one item that is a reference to list . The list  is mutable.The multiplication of a list by an integer is equivalent to adding the list to itself multiple times (see common sequence operations). So continuing with the example:We can see that the list  now contains two references to list  which is equivalent to .Python FAQ also contains explanation of this behavior: How do I create a multidimensional list?
 creates one list object  in memory and copies its reference 3 times over. This is equivalent to . Any modification to  will be reflected at three places, wherever  is referenced in the list.The right statement would be:orImportant thing to note here is that  operator is mostly used to create a list of literals. Since  is a literal, hence  will create  where each  is atomic and not a reference of  repeated 4 times. This means if we do , then  will become  not  as some may assume.
Let us rewrite your code in the following way:Then having this, run the following code to make everything more clear. What the code does is basically print the s of the obtained objects, whichReturn the “identity” of an objectand will help us identify them and analyse what happens:And you will get the following output:So now let us go step-by-step. You have  which is , and a single element list  containing . Your first step is  which will get you a new list , which is basically , i.e. it creates a new list which will have 4 elements, which are references to the initial  object. The net step is pretty similar. You basically do , which is  and returns , for the same reason as for the first step.
I guess everybody explain what is happening.I suggest one way to solve it:And then you have:
Trying to explain it more descriptively,Operation 1:Operation 2:Noticed why doesn't modifying the first element of the first list didn't modify the second element of each list? That's because  really is a list of two numbers, and a reference to 0 cannot be modified.If you want to create clone copies, try Operation 3:another interesting way to create clone copies, Operation 4:
By using the inbuilt list function you can do like this


Answer URL
https://docs.python.org/3/library/stdtypes.html#typesseq-common
https://docs.python.org/3/faq/programming.html#faq-multidimensional-list
