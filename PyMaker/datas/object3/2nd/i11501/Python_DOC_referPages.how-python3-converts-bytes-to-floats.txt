Natural Text
I’d like to understand how python converts bytes to floats, in detail.Let’s create a binary file containing just one float 23.0:Let’s now write a python3 code 23.py:  Execute the code:  So, I am wondering how python converts the bytes '\x00\x00\xb8A' into float 23.0? This has something to do with the DEC-BIN-HEX-ASCII representation, but I have already broken my brain trying to understand this.  How do we get '\x00\x00\xb8A' from it? Or vice-versa, how '\x00\x00\xb8A' transforms into 23.0?Could anyone explain me step by step? Thanks.
This is clearly documented in the format table:For the  and  conversion codes, the packed representation uses the IEEE 754 binary32 (for ) or binary64 (for ) format, regardless of the floating-point format used by the platform.So to understand that format, reference the IEEE floating point standard; you used the  code, so look for the binary32, or single precision format.This format consists of 32 bits, divided over:Sign bit: 1 bitExponent width: 8 bitsSignificand precision: 24 bits (23 explicitly stored)Looking at your binary data as bits, (which you treat as little endian, so I'm reversing these to match the Wikipedia big-endian ordering):we see that the sign is 0, the exponent width is 131 (in 2's complement, so minus 127 makes 4), and the significand precision or mantissa is 1.4375 (1 + 1/4 + 1/8 + 1/16, each binary fraction is an enabled bit).Together these form the actual floating point value:To go the other way, express the whole integer number and the value after the decimal point in binary; you may have to approximate the non-integer portion as binary fractions can't express all possible real numbers. 23.0 has no non-integer component, so that is easy here, we only have to convert the integer component to binary:So the binary representation for the real number is . You then shift the decimal point up or down to get  and a fraction; here you need to shift the decimal point up 4 spots to . This gives you the exponent (4), and the significant (0111 plus another 19 zeros for the unused fractions). The value is positive, so you encode the sign as , the exponent as a signed value (add 127 == 131, encode 131 to binary == ), and add the significant:Chopping that into 4 groups of 8 bits (4 bytes) gives you . Python's  output for a byte gives you printable ASCII characters for bytes where possible, and  is the letter  in the ASCII table:Reverse those bytes for a little-endian representation:You can visualise how the IEEE binary32 format works with this online converter.


Answer URL
https://docs.python.org/3/library/struct.html#format-characters
