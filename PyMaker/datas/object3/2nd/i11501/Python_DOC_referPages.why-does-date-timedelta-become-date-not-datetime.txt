Natural Text
In Python, in an operation of numbers of mixed type, the narrower type is widened to that of the other, such as  +  → :But for , we have  +  → , not :Why is the widening reasoning applied to numbers, but not to //?(Background: I'm writing a reading routine for a file format where one field is year, one field is day-of-year, one field is milliseconds-since-midnight.  Of course, the simple and explicit solution is , but one could equally reason that one should rewrite  as )
The behaviour is documented:date2 is moved forward in time if , or backward if . Afterward .  and  are ignored.(My emphasis. This behaviour has remained unchanged since  objects were added in Python 2.3.)I haven't been able to find any evidence as to why the module is designed like this. Certainly there are use cases like yours where you want to represent the point in time corresponding to the midnight at the start of a day. In these cases it is annoying to have to convert back and forth. But there are other use cases in which you want to represent a whole day (and not just some point in time on that day), in which case you don't want to accidentally end up with partial days when you add timedeltas.Chris Withers suggested that the behaviour be changed, in issue 3249, but Tim Peters noted that:an incompatible change to documented always-worked-this-way behavior is unlikely to be accepted.If you want an object that behaves like a , but where arithmetic operations return  objects, then it shouldn't be not too hard to write one:(This is untested, but it's shouldn't be hard to get it working from here.)
The  object doesn't store any information on whether or not it just concerns dates, or also times. (The fact that the number of hours/minutes/seconds/micros is 0 may just be a coincidence!)Hence, suppose we have someone who just wants to manipulate dates, ignoring times, she'd do something like . She'd be very surprised and possibly annoyed to find that  is now a  object rather than a  object.
A date is not a subclass of datetime; datetime is a compound type, combining a  and a  object into one. You can't decide to produce a compound type from operations on  here; the  component is not a fraction of a date.On the other hand, the Python numeric hierarchy defines integers as a type of specialised float ( is an indirect subclass of ), and as such mixing operations between integers and floats results in the base type being produced. And a  is not a compound type, there is no separate type for the decimal portion of the value.If you want to produce the compound type from operations on dates, you'll have to be explicit (and explicit is better than implicit). Add a time component yourself:where  could be produced from a  parsing of your year plus day-of-the-year input.The alternatives (either producing a  object sometimes based on the  value, or always) require the programmer to unwrap the date component again if that is all that they expected.
The likely technical reason is that builtin types in Python do not return subclasses from its operators  as a rule i.e.,  won't return . And the consistent behavior would require  and  to be interchangeable (they are not). behavior is documented and won't change.  If you want  as a result; create  from date :Technically,  could have delegated the work to .  stores  separately and therefore it simple and efficient to find out whether it represents whole number of days i.e., we could if we wanted to get  or  from  (it doesn't mean we should).The issue is that  and  are the same  in this case i.e., if we were to allow  to return  then it should return  for all values if we consider only types.There was a precedent when  returned either  or  depending on the result i.e., the operation with the same types may return values of different types depending only on the input values. Though  and  are not as much interchangeable as  and  were. returning  for some values of  and  for others would create confusion unless we introduce  too (like ) or  from the related Python issue mentioned by @Gareth Rees (like ).  being a subclass suggest this route though I heard an argument that it was a mistake to make  a  subclass.The desired behavior is implemented in  package: is invalid, so  doesn't help me here. works . Though, you could write it as: .Of course, the simple and explicit solution is , but one might as well rewrite  as ) +  is always :unlike  and ;  (same type in addition to being equal).I'm writing a reading routine for a file format where one field is year, one field is day-of-year, one field is milliseconds-since-midnight.
When you sum a timedelta to a date, python will only look for the days attribute of the timedelta. So if if add 42 seconds, the day will be 0 and it will not affect your date.


Answer URL
https://docs.python.org/3/library/datetime.html
