Natural Text
Consider a numpy 2D array of integers, where some entries are 0 (array1). Consider a different 2D array (array2) in which the first column has the same non zero values of array1 and another column, say index 2, has different numeric values (floats).How do you create a new array3 by replacing in array1 each non-zero entry by the correspondent value of column 2 of array2? How do you do it super clean?Example:
You can use boolean indexing together with advanced numpy array indexing:the result is:ExplanationYou first create a boolean array which indicates where there are non-zero entries:this will be used to find the elements that should be replaced.Then you need to find the values of these elements:Since your  is ordered and starts with value 1 we need to subtract one to find the appropriate row for the replacement value. If your  isn't sorted you might need to sort it or do another indexing in between:and then just assign these values to the original or new array:This approach relies on the ordering of  so it will break if there are more complicated conditions. But that would either requiring finding that relation between value and index and inserting it instead of the simple  I did or doing another intermediate /boolean indexing.ExtendedIn case you don't have a sorted  and you can't sort it you could do:since this works with broadcasting the arrays against each other you'll create an array with size . So this might not be very memore-efficient but still completly vectorized.Numba (if you want speed)numba is great if you want to speed up things that would be slow because there is no native numpy or scipy version. If you have anaconda or conda it is already installed so it might be a viable option:Especially for large arrays this will clearly be the fastest and memory-efficient solution since no temporary arrays are created. The first call will be a lot slower because the function needs to compile on the fly.Timings:100000 loops, best of 3: 6.23 µs per loop10000 loops, best of 3: 74.8 µs per loop1000 loops, best of 3: 689 µs per loop
I'm not sure I understood your requirements but let's try with list comprehensions:But it's hard to read, I prefer it tabulated:


Answer URL
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
