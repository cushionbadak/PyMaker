Natural Text
So the question is pretty simple:If we have a random class, let's say an int and we try to access a non defined attribute: We will get this error:But if we try to access an index of it (in which case Python will do a lookup for a  attribute):We get:What is the logic behind the change in exception type? It seems weird to me that a  is raised, complaining about a missing attribute ( seems like a much better candidate for that)
It depends on your intention. When you use  you implicitly call the  function, that naturally raises the  if the attribute doesn't exist.Update 2. Let's look at the bytecode.As you see, the  has a special virtual-machine instruction. From the docsBINARY_SUBSCR: Implements TOS = TOS1[TOS].Hence it's quite natural to raise a , when you fail at executing an instruction. Update 1: Looking at the  sources, it's clear that this function can never raise such a , hence the  operator doesn't call it under the hood (for the built-in types at least, though it's better to find the sources to clarify this bit). 
An  for  may be misleading because you aren't trying to access an attribute of , you are trying to access an item. The  is raised because  doesn't support subscripting, and this exception message was updated in Python 3.X.That being said, it wouldn't be inappropriate to throw an  that there is no . I suspect that this may be a  because numbers (, , ) are the only built-in data-types that do not support subscripting. When this error comes up, it will be due to you thinking that  contains an object of a different type, hence the .


Answer URL
https://docs.python.org/3/library/dis.html
