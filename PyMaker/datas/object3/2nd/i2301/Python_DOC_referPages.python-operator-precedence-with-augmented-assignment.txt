Natural Text
It seems this question only answered for Java but I would like to know how it works in Python. So are these the same?and
Yes, those are the same. Python's augmented assignment is not an expression, it is a statement, and doesn't play in expression precedence rules.  is not an operator, and instead it's part of the augmented assignment statement syntax.So everything to the right of the  is an expression, but  itself is not, so the assignment will always be handled last.And because (augmented) assignment is not an expression, it can't produce a value to use in a surrounding expression either. There is no , that'd be a syntax error, and certainly no  or other such shenanigans.See the reference documentation on Augmented assignment statements, which states the grammar is:So the  is part of the statement syntax, and only the part following is an expression (specifically, either a  or  grammar rule).Furthermore, the explanation shows:An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once.So the  part is handled first, the expression list (or yield expression) is handled second, and then the augmented assignment applies the operator and assigns back the result.Furthermore, the expressions reference documentation does include a precedence table, but that table doesn't include assignments (augmented or otherwise), simply because assignments are not expressions but statements.
Short answer:  is an augmented assignment, and if we take the grammar into account, this is parsed higher in the syntax tree, than the operators in general (and hence the  operator in particular).Python sees the  as an "augmented assignment". If we inspect the Python grammar we see:Now the grammar also enforces the priority rules when parsing. If we look at the grammar that is related to  ("statement"), we see:Exhaustively explaining all the other statements (like the ) would take too long, but the  is the only one that leads to an  (and  is the only variable that results in a  token). So we can ignore the other expressions.Now if we "specialize" the expression of  such that it has an  in it, we retrieve the production rule:The  is a variable that results in an identifier (or multiple identifiers in case of sequence unpacking), etc.On the right we see a , or a . A  can result in comma separated expressions, with:This  allows to write ternary operators, but that is not mandatory:We can take the  variable, which is used to group expressions with an  separator (again optional), since the  has the highest precedence.Then follows the  which, as the name probably suggests, allows us to write  operators:then follows the  operator (with the ):We can have an arbitrary number of s in front, but eventually we will pick the .If we look at the production roule for the , we see:This thus allows comparator chaining, like , next we look at the :So this defines precedence rules, and we see that  takes precedence over , that takes precedence over , and so on until we see a  is a sequence of s with operators of , , , , and , so here we finally "consume" our . This thus means that the  is lower in the syntax tree than the  node.Hence the way Python parses this expression is:


Answer URL
https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements
https://docs.python.org/3/reference/expressions.html#operator-precedence
https://docs.python.org/3/reference/grammar.html#full-grammar-specification
https://docs.python.org/3/reference/expressions.html?highlight=precedence#evaluation-order
