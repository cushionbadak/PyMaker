Natural Text
Using Python 3.x, I have a list of strings for which I would like to perform a natural alphabetical sort. Natural sort: The order by which files in Windows are sorted.For instance, the following list is naturally sorted (what I want):And here's the "sorted" version of the above list (what I have):I'm looking for a sort function which behaves like the first one.
There is a third party library for this on PyPI called natsort (full disclosure, I am the package's author).  For your case, you can do either of the following:You should note that  uses a general algorithm so it should work for just about any input that you throw at it. If you want more details on why you might choose a library to do this rather than rolling your own function, check out the  documentation's How It Works page, in particular the Special Cases Everywhere! section.If you need a sorting key instead of a sorting function, use either of the below formulas.
Try this:Output:See it working online: ideone.Code adapted from here: Sorting for Humans : Natural Sort Order.
Here's a much more pythonic version of Mark Byer's answer:Now this function can be used as a key in any function that uses it, like , , , etc.As a lambda:
I wrote a function based on http://www.codinghorror.com/blog/2007/12/sorting-for-humans-natural-sort-order.html which adds the ability to still pass in your own 'key' parameter. I need this in order to perform a natural sort of lists that contain more complex objects (not just strings).For example:
Let's analyse the data. The digit capacity of all elements is 2. And there are 3 letters in common literal part . So, the maximal length of element is 5. We can increase this value to make sure (for example, to 8).Bearing that in mind, we've got a one-line solution:without regular expressions and external libraries!Explanation:
Given:Similar to SergO's solution, a 1-liner without external libraries would be:or Explanation:This solution uses the key feature of sort to define a function that will be employed for the sorting. Because we know that every data entry is preceded by 'elm' the sorting function converts to integer the portion of the string after the 3rd character (i.e. int(x[3:])). If the numerical part of the data is in a different location, then this part of the function would have to change.Cheers
And now for something more* elegant (pythonic) -just a touchThere are many implementations out there, and while some have come close, none quite captured the elegance modern python affords.Tested using python(3.5.1)Included an additional list to demonstrate that it works when thenumbers are mid stringDidn't test, however, I am assuming that if your list was sizable it would be more efficient to compile the regex beforehandI'm sure someone will correct me if this is an erroneous assumptionQuickyFull-CodeCaution when usingyou will need to differentiate the importsInspiration fromPython Documentation- Sorting HOW TOSorting for Humans : Natural Sort OrderHuman SortingContributors/Commentators to this and referenced posts 
One option is to turn the string into a tuple and replace digits using expanded form http://wiki.answers.com/Q/What_does_expanded_form_meanthat way a90 would become ("a",90,0) and a1 would become ("a",1)below is some sample code (which isn't very efficient due to the way It removes leading 0's from numbers)output:
Value Of This PostMy point is to offer a non regex solution that can be applied generally.I'll create three functions: which I borrowed from @AnuragUniyal.  It will find the position of the first digit or non-digit in a string. which is a generator that picks apart a string into digit and non digit chunks.  It will also  integers when it is a digit. just wraps  into a .  This is what we use as a key for , , .FunctionsWe can see that it is general in that we can have multiple digit chunks:Or leave as case sensitive:We can see that it sorts the OP's list in the appropriate orderBut it can handle more complicated lists as well:My regex equivalent would be
The above answers are good for the specific example that was shown, but miss several useful cases for the more general question of natural sort. I just got bit by one of those cases, so created a more thorough solution:Test code and several links (on and off of StackOverflow) are here:http://productarchitect.com/code/better-natural-sort.pyFeedback welcome. That's not meant to be a definitive solution; just a step forward.
Most likely  is closely tied to the underlying implementation of python's sort. Besides, the cmp parameter is legacy. The modern way is to transform the input items into objects that support the desired rich comparison operations.Under CPython 2.x, objects of disparate types can be ordered even if the respective rich comparison operators haven't been implemented. Under CPython 3.x, objects of different types must explicitly support the comparison. See How does Python compare string and int? which links to the official documentation. Most of the answers depend on this implicit ordering. Switching to Python 3.x will require a new type to implement and unify comparisons between numbers and strings.There are three different approaches. The first uses nested classes to take advantage of Python's  comparison algorithm. The second unrolls this nesting into a single class. The third foregoes subclassing  to focus on performance. All are timed; the second is twice as fast while the third almost six times faster. Subclassing  isn't required, and was probably a bad idea in the first place, but it does come with certain conveniences.The sort characters are duplicated to force ordering by case, and case-swapped to force lower case letter to sort first; this is the typical definition of "natural sort". I couldn't decide on the type of grouping; some might prefer the following, which also brings significant performance benefits:Where utilized, the comparison operators are set to that of  so they won't be ignored by .Natural sorting is both pretty complicated and vaguely defined as a problem. Don't forget to run  beforehand, and consider use  rather than . There are probably subtle encoding issues I haven't considered. So I tentatively recommend the natsort library. I took a quick glance at the github repository; the code maintenance has been stellar.All the algorithms I've seen depend on tricks such as duplicating and lowering characters, and swapping case. While this doubles the running time, an alternative would require a total natural ordering on the input character set. I don't think this is part of the unicode specification, and since there are many more unicode digits than , creating such a sorting would be equally daunting. If you want locale-aware comparisons, prepare your strings with  per Python's Sorting HOW TO.
Based on the answers here, I wrote a  function that behaves like the built-in function :The source code is also available in my GitHub snippets repository:https://github.com/bdrung/snippets/blob/master/natural_sorted.py
I suggest you simply use the  keyword argument of  to achieve your desired listFor example:
Acknowledgments:Bubble Sort HomeworkHow to read a string one letter at a time in python



Answer URL
https://docs.python.org/3/library/locale.html#locale.strxfrm
https://docs.python.org/3/howto/sorting.html#odd-and-ends
