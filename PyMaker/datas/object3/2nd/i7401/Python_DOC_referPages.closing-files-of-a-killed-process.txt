Natural Text
python: 3.4OS: win7 / win10I want to kill a running process with python and close all the files it opened:Somehow  does not work.Explanation:It's like I would like to kill Microsoft Word with python, but it leaves some files open. And I would like to close those files as well.Microsoft Word is just an example. It is a self-written python programm. The opened files are:fonts (.ttf)clr.pyd and .dll-sHow should I close these files?
You don't need to close any files that were opened by the process.  That is done automatically:Terminating a process has the following results:Any remaining threads in the process are marked for termination.Any resources allocated by the process are freed.All kernel objects are closed.The process code is removed from memory.The process exit code is set.The process object is signaled.The important bit is "All kernel objects are closed."  For every open file handle, there is an associated kernel object--that's actually what a handle is, a mapping from a number to a kernel object.  When the process exits, the kernel will walk behind and close all associated file handles, sockets, etc.Additionally, you're original approach has a few problems.  First, the list of open files is only a snapshot of which ones were open at that time.  In between asking for the list of open files and killing the process, the process could have opened many more, or closed and removed many as well.  Second, the Python 3 docs say that the constructor for IOBase isn't public, so using it in this way is wrong:class io.IOBaseThe abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.Generally, you'd use something like  which takes the path.  This leads to the third issue.  All you have to work with is the path.  In order to close a file, you really need the handle.  Those handles are process-specific.  This means in one process, 0x5555AAAA may correspond to "file1.txt", but in another process, it might correspond to "file2.txt" or maybe not even a file at all (it could be a socket or something else).  So even if you have the kernel handle, we don't really have a way of saying "close this handle in the context of this other process."  That violates some security goals of processes.  Also, it means that what you're actually doing here is creating your own handle to only turn around and close it (or in this case, it possibly does nothing at all since the object wasn't created correctly).So, if you're having a problem with files still being held, perhaps the problem is that the process didn't actually die yet before trying whatever work you needed to get done.  You may need to wait for the process to exit before attempting to move on if there are files the process was using that you want to use again.  It looks like you can use  to do that.Also, on Windows I find that anti-virus tools often get in the way.  They hold open files accessed by applications making it look like a process is still holding onto them when it's actually the virus scanner doing its thing.  I remember one instance of having to deal with this in Subversion.  The code still exists today.  So you might need to simply wait a bit and try again.UpdateMicrosoft Word is just an example. It is a self-written python programm. The opened files are:fonts (.ttf)clr.pydand .dll-sHow should I close these files?The answer is that you shouldn't need to.  Just make sure the process has actually exited.  It's not an instantaneous operation, so there's some time between killing it and it actually exiting that it still retains the file handles.Given that you've actually written the process being killed, I think a far better approach would be to introduce a way to launch that process, have it do its work, then exit gracefully.  Then use  to run the script and wait for it to exit.
It's like I would like to kill Microsoft Word with python, but it leaves some files open. And I would like to close those files as well.There is some misunderstanding here. When you terminate Word with kill, all files are closed from a system point of view, but they will be dirty closed. When Word terminates normally, it flushes its internal buffers, removes any temporary files and mark the files as clean. When it crashes or is abruptely terminated, all that cleaning does not occur. Some modifications may not be written to disk, and temp files are still there, so on next execution, Word will warn you that the files have not been orderly closed and have to be repaired.So you do not want to kill Microsoft Word, but to close it, meaning posting a WM_QUIT message to its main window. Unfortunately, there is no clean and neat support in Python for that. There is an example of closing Excel by the win32com module here. The convertion for Word should be (beware untested):
Take a look at the  statement syntax.  There's a brief overview here


Answer URL
https://docs.python.org/3/library/io.html#io.IOBase
https://docs.python.org/3/library/subprocess.html#subprocess.run
