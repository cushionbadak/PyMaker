Natural Text
Consider the following function, whose output is supposed to be the cartesian product of a sequence of iterables:Works fine when generator comprehensions are replaced with list comprehensions. Also works when there are only 2 iterables. But when I tryI get Why this and not the cartesian product?
You are creating generator expressions, that are not iterated over until the next iteration of the  loop. They are using closures, which are looked up at runtime.Generator expressions are essentially small functions in this regard, they create their own scope, and any names from the parent scope need to be treated as closures for this to work. The 'function' is executed when you iterate, and only then the closure is needed and resolved to the current value of the variable referenced.So you create one generator expression like this:where  is a closure taken from the parent scope (your function locals). But the lookup is not done until the next iteration when you loop, at which point  is the next element in the sequence.So for your input of , you create a generator expression when  but by the time you actually iterate, the  loop has assigned a new value and is now . When you finally iterate over the final (chained) generator, only the very last assignment to  counts.You are effectively creating a product over ;  through to  are skipped over entirely, all replaced by .You could use a generator function to avoid the closure issue, passing in  to be bound to a local:You could do the same with a lambda returning the generator expression:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
