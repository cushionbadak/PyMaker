Natural Text
I'm trying to implement the frequent words pseudocode. According to a sample dataset I should be returning 2 frequent words but I'm only returning the first. Here is the pseudocode:And here is my implementation:Here is the sample dataset:ACGTTGCATGTCGCATGATGCATGAGAGCT4I should get returned from code:CATG GCATBut I'm only getting the first - CATG. Please help.
I would use a dictionary to accumulate the results. Use a slice to extract the next word; add one to that word's value in the dictionary; then drop the first character in the string; loop while the string has a word in it.You might be able to make use of collections.Counter or collections.defaultdict for that bit.  If the words cannot overlap, drop  characters from the front of the string. Keeping the process simple does result in a bit of inefficiency when the character(s) are removed from the string at the bottom of the loop.  Unless the data is very long or the process is performed a LOT of times it shouldn't matter.Then just find the word(s) with the highest frequencyBorrowing from an itertools recipe you can make an iterator that produces words of the required lengthThe counting portion of the procedure would change to The keys in  will be tuples, e.g.  but they can be reconstructed with .
you should consider using list comprehensions. pattern_count will parse a string for a pattern. We splice the text character array, so we can check if that portion contains the pattern. This allows us to include overlapping entries in our results. For instance,pattern_count(ABABA, ABA) -> results in 2, instead of 1.frequent_words takes the same text but instead of a pattern, we give it an int for how long the pattern should be. Once we get a list of the number of occurrences for each pattern that meets our character k requirement, we filter it by taking the entries which occur the most frequently.  Finally, to remove any duplicates, we convert the list into a hashset which inherently prevents duplicate entries, thus returning a collection with only unique values.Test:Hope that was of some use to you.
Use  instead:


Answer URL
https://docs.python.org/3/library/collections.html
https://docs.python.org/3/library/itertools.html#itertools-recipes
