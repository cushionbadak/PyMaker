Natural Text
Consider the following example:This raises the following :But interestingly the exception is only raised when I try to  the result, not when the "sharing" happens. Commenting the corresponding line silences the error while I actually did share the queue (and  is never executed!).So here goes my question: Why is this exception only raised when the result is requested, and not when the  method is invoked even though the error seems to be recognized because the target  function is never called?It looks like the exception occurs in a different process and can only be made available to the main process when inter-process communication is performed in form of requesting the result. Then, however, I'd like to know why such checks are not performed before dispatching to the other process.(If I used the queue in both  and the main process for communication then this would (silently) introduce a deadlock.)Python version is 3.5.2.I have read the following questions:Sharing many queues among processes in PythonHow do you pass a Queue reference to a function managed by pool.map_async()?Sharing a result queue among several processesPython multiprocessing: RuntimeError: “Queue objects should only be shared between processes through inheritance”Python sharing a lock between processes
This behavior results from the design of the .Internally, when you call , you put your job in the  call queue and then get back a  object, which allow you to retrieve your computation result using get.Another thread is then in charge of pickling your work. In this thread, the  happens but you already returned from the call to . Thus, it sets the results in  as the exception, which is raised when you call .This behavior using some kind of future results is better understood when you try using , which have explicit future objects and, IMO, a better design to handle failures, has you can query the future object for failure without calling the  function.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html
https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes
