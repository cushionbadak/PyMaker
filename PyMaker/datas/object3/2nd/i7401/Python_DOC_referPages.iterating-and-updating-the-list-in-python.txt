Natural Text
This question already has an answer here:What is the meaning of list[:] in this code? [duplicate]                    4 answers                I am not able to understand why the following code goes in indefinite  loop(when i am not using the copy list)The Above code prints inside loop indefinitely.Now if in place of the list, i use a copy list like below works fine.Now i have read in the python documentation that this is the behavior  i will get but i want to understand the reason behind it. Thanks in  advance.
The first for loop  will use an iterator (from ) to retrieve and loop through each item in the list. This iterator does not fetch the entire list immediately - it is lazy, meaning it only gets one item at a time from the list, when it's needed. You can learn about  the iteration protocol here, or iteration/generators and laziness here.Looping through indexes 0 and 1 do nothing, as their string lengths are less than 6. At index 2, however, you add  to the beginning of . Now  has grown and there's something at index 3: . Iteration then continues, picking the value from the next index (3), which gets added at the beginning again, moving the same value which was at index 3 to index 4... The cycle never ends.In your second loop  you create a copy of the entire list (by using a slice operator) and iterate through that. You're adding items to the original list, not the copy, so the iterator won't touch the items that you've added.PS: I tried to search the Python source code (which is C) to prove that list iterators in fact use an incrementing index (as described above). I'm not well versed in reading Python's source code, but here's what I found in cpython/listobject.c:Iterator creation, sets starting index to 0 uses  from above and then increments itSeems legit to me?
To simulate how list iteration works internally, let's rewrite your program using integer indices and a  loop.The following shows what happens when you run this:(This goes on until you run out of either RAM or patience.)As you can see, you keep shifting the final  to the right, so your code keeps looking at it and never stops.This doesn't happen if you work on a copy since you're no longer modifying the list you're iterating over.It also wouldn't happen if you were to either adjust the loop index after the insertion:or move the word instead of copying it:
That happens because you're appending "sffsfshfsd" to list on each iteration starting from third, so list never ends.
In the first code, you are inserting elements on the very same list that you're looping. That's why it keeps going at the inner loop, because list is growing indefinitely.In the second code you're making a copy, separating your for loop and your original list, so it will eventually stop.
Quoting from the docs:Note: There is a subtlety when the sequence is being modified by the  loop (this can only occur for mutable sequences, i.e. lists). An  internal counter is used to keep track of which item is used next, and  this is incremented on each iteration. When this counter has reached  the length of the sequence the loop terminates. This means that if the  suite deletes the current (or a previous) item from the sequence, the  next item will be skipped (since it gets the index of the current item  which has already been treated). Likewise, if the suite inserts an  item in the sequence before the current item, the current item will be  treated again the next time through the loop. This can lead to nasty  bugs that can be avoided by making a temporary copy using a slice of  the whole sequence, e.g.,A for-loop over a list in Python maintains a counter internally and that is used to get the next item.In your first code when it reaches (i.e index 2) you insert it to the start of list again, hence all items shift one place and now  will be shifted to index 3 and will be picked up in the next iteration. And this goes on...In your second code you're iterating over a copy of list and a copy of the list is not modified when you modify the original list.Outputs:
I think this a very interesting question. I believe the answer should present itself in python source code implementation (sorry I could not find it and Hope someone expert could direct us to Python implementation)for loop will not create a copy of your original data. Thus every time a new data added, the loop will continue. (I am not sure how for loop is achieved in implementation level, I do believe it might use iterator)on the other hand [:], this operator will create a new copy of original data set. Thus no matter how you change original data set, the for loop is looping on a copy (which does not change). Proof as following:Thus it is clear in your second example, your for loop is looping on a copy of original data. Thus original data set change will not affect the copy data. Thus your second example is working and first example will loop indefinitely.Hope it helps.


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
