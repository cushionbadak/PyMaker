Natural Text
Suppose I have:It is obvious that the  part is calculated once.But is this guaranteed to be the same for ?According to this answer,  is a sequence object that evaluates lazily.So the question is basically - which part evaluates lazily?Is it only the  part, or also the  part?I tried a simple test in order to determine the answer:This test clearly shows that  is not reevaluated at every iteration.But I'm suspecting that perhaps the  inside the  expression "lives in a different scope" than that of the  declared before the .Thank you.
Neither  nor  care how the step value was derived; the expression is executed and the result of the expression is passed to the call, be that ,  or any other callable object.That's because  is an expression too; it is a call expression; the arguments passed into a call are all expressions that are evaluated before the result is passed in to the  call. It doesn't matter what is being called here.TLDR; the  object is passed the outcome of the expression, not the expression itself. As long as that outcome is an integer object, it'll be stored by the object (as an immutable value) to base the virtual sequence of.
The fact that  works lazily means that the arguments are evaluated at "construction" time of the  (in fact  never knew what the expressions were in the first place), but the elements that are emitted are generated lazily. So the  parameter is actually calculated before you even call . As a result,  does not know how the step was calcuated, and thus cannot ask to re-evaluate it.Although  is more complex than that (since it can work with negative steps, etc.), a very basic implementation would be:
To add on top of the other answers: A good way to test this would be to provide a function as the step argument. If it is to be evaluated multiple times then the  function would need to be called multiple times.The above code outputswhich shows that the step argument is evaluated exactly once.
when you pass the appropriate arguments into , Python will construct a generator object that will compute values "on the fly".Once that generator object is constructed and returned, the object is set. It no longer cares whether a variable originally used in calculating its constructor arguments changes or not. This same principal applies not only to , but to other callable objects as well. Once you pass arguments to a callable, Python calculates the expressions using the current value of any variables, and passes the result to the callable. If any variables that were used in calculating the arguments of the callable have their value changed, Python does not care because only the current value of the variable was used. Python will not keep recalculating the arguments of a function every time a variable used in an expression passed into it changes:
Lazy evaluation does not mean you can change the evaluation while it is going on; while iterating  you are dealing with a generator, that is created with the parameters you provide. It can not change its  during iteration, at least not with the built in one.


Answer URL
https://docs.python.org/3/reference/expressions.html#calls
