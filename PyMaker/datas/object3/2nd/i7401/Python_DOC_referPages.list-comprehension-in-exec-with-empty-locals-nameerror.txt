Natural Text
Consider the following snippet:It gives an expected output .However, if I try to  the same snippet in empty environment ( and  both are set to ), it gives :If I invoke  like  or , it is executed as expected.Why?EDIT:Consider also the following snippet:Just like in my first exec, we don't have bar in locals inside list comprehension. However, if we try to invoke it, it works!
The solution to your problem lies here:In all cases, if the optional parts are omitted, the code is executed in the current scope. If only globals is provided, it must be a dictionary, which will be used for both the global and the local variables. If globals and locals are given, they are used for the global and local variables, respectively. If provided, locals can be any mapping object. Remember that at module level, globals and locals are the same dictionary. If exec gets two separate objects as globals and locals, the code will be executed as if it were embedded in a class definition.https://docs.python.org/3/library/functions.html#execBasically, your problem is that bar is defined in the scope of  and only in . Therefore, this  statement works:The list comprehension however creates a new local scope, one in which  is not defined and can therefore not be looked up.This behaviour can be illustrated with:which returnsEDITIn your original example, the definition of  is found in the (module level) global scope. This corresponds toRemember that at module level, globals and locals are the same dictionary.In the  example, you introduce an artificial split in scopes between globals and locals by passing two different dictionaries. If you passed the same one or only the globals one (which would in turn mean that this one will be used for both  and ) , your example would also work.As for the example introduced in the edit, this boils down to the scoping rules in python. For a detailed explanation, please read: https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespacesIn short, while  is not in the local scope of the list comprehension and neither in the global scope, it is in the scope of foo. And given Python scoping rules, if a variable is not found in the local scope, it will be searched for in the enclosing scopes until the global scope is reached. In your example, foo's scope sits between the local scope and the global scope, so bar will be found before reaching the end of the search.This is however still different to the exec example, where the locals scope you pass in is not enclosing the scope of the list comprehension, but completely divided from it.Another great explanation of scoping rules including illustrations can be found here: http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html
As Hendrik Makait found out, the  documentation says thatIf  gets two separate objects as  and , the code will be executed as if it were embedded in a class definition.You can get the same behaviour by embedding the code into a class definition:Run it in Python 3 and you will getThe reason for the error is as Hendrik said that a new implicit local scope is created for list comprehensions. However Python only ever looks names up in 2 scopes: global or local. Since neither the global nor the new local scope contains the name , you get the .The code works in Python 2, because list comprehensions have a bug in Python 2 in that they do not create a new scope, and thus they leak variables into their current local scope:Run it in Python 2 and the output is . The variable  is now within the locals in the class body, and retains the value from the last iteration. In Python 3 you will get a .You can get the same error in Python 2 too though, if you use a generator expression, or a dictionary/set comprehension:The error can be produced also by just using simplyThis is unlikebecause upon execution of , Python makes  into a closure, which will access the  variable via a special bytecode instruction.
I'm late to the party here, but there is a better documentation reference buried in the execution model.  In section 4.2.2 Resolution of names:Class definition blocks and arguments to  and  are special in the context of name resolution. ... And then in 4.2.4 Interaction with dynamic features:The  and  functions do not have access to the full environment for resolving names. Names may be resolved in the local and global namespaces of the caller. Free variables are not resolved in the nearest enclosing namespace, but in the global namespace. [1] The  and  functions have optional arguments to override the global and local namespace.  If only one namespace is specified, it is used for both.[1] This limitation occurs because the code that is executed by these operations is not available at the time the module is compiled.
EditTo answer your edited question, user @Hendrik Makait said  is not in the scope of list comprehension:To answer the original question:If you create two different dictionaries, it wont recognize the local and globals definitions, the variables are not updated as @PM 2Ring said:  it prints:A way to do it, is update the variables, like this globals().update(locals()):wich gives:But, if you remove the dictionaries, or create one and give it to the exec function as same parameter, it works:it prints:That's why you get the error, it could't find your function in the globals Or simply, don't give the parameters:Cause the same efect.
Here's a solution!We needed to get the local namespace out after the exec() to track modifications. This doesn't work with only one namespace, so we did this:Replace the old code:with:


Answer URL
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces
https://docs.python.org/3/library/functions.html#exec
https://docs.python.org/3/reference/executionmodel.html
https://docs.python.org/3/reference/executionmodel.html#resolution-of-names
https://docs.python.org/3/reference/executionmodel.html#interaction-with-dynamic-features
