Natural Text
I am trying to design an async pipeline that can easily make a data processing pipeline. The pipeline is composed of several functions. Input data goes in at one end of the pipeline and comes out at the other end. I want to design the pipeline in a way that: Additional functions can be insert in the pipelineFunctions already in the pipeline can be popped out.  Here is what I came up with:This works, of course, but the problem is that if I want to add another function into (or pop out a function from) this pipeline, I have to disassemble and reconnect every function again.I would like to know if there is a better scheme or design pattern to create such  a pipeline?
I don't know if it is the best way to do it but here is my solution.While I think it's possible to control a pipeline using a list or a dictionary I found easier and more efficent to use a generator.Consider the following generator:This is basically a one-element queue, it stores the value that you send it and releases it at the next call of  (or ).Example:By associating every coroutine in the pipeline with its controller we will have an external handle that we can use to push the target of each one. We just need to define our coroutines in a way that they will pull the new target from our controller every cycle.Now consider the following coroutines:The source is a coroutine that does not  so that it will not terminate itself after the first cycle. The other coroutines are "sinks" and does not need a controller.You can use these coroutines in a pipeline as in the following example. We initially set up a route  and after receiving the first result we change the route to .Output:
I've done something similar before, using just the multiprocessing library. It's a bit more manual, but it gives you the ability to easily create and modify your pipeline, as you've requested in your question.The idea is to create functions that can live in a multiprocessing pool, and their only arguments are an input queue and an output queue. You tie the stages together by passing them different queues. Each stage receives some work on its input queue, does some more work, and passes the result out to the next stage through its output queue.The workers spin on trying to get something from their queues, and when they get something, they do their work and pass the result to the next stage. All of the work ends by passing a "poison pill" through the pipeline, causing all stages to exit:This example just builds a string in multiple work stages:The code produces this output:Main started the job.  Stage 1 did some work.  Stage 2 did some work.  Main finished the job.  You can easily put more stages in the pipeline or rearrange them just by changing which functions get which queues. I'm not very familiar with the asyncio module, so I can't speak to what capabilities you would be losing by using the multiprocessing library instead, but this approach is very straightforward to implement and understand, so I like its simplicity.


Answer URL
https://docs.python.org/3/library/asyncio.html
