Natural Text
I have written a code for design optimization using the Inspyred library and its implementation of Genetic Algorithms. In essence, the optimization process creates a large number of variations on a single data structure, which is a nested dictionary in my case.In order to reduce the amount of memory used in the process, I have been trying to create some kind of differential dictionary type, which only stores items which are different from the base dictionary. The reason for this is that in a typical case, 95% of the data in the data structure will not be modified in any of the variations, but any part of the data structure can contain variations. So for flexibility reasons, I would like to have a data type that behaves more or less like a dictionary, but only stores the changes.This is the result of my attempt to create this: It works fine for a simple dictionary, but breaks down when new dictionaries are nested within the main dictionary. I understand that this happens because these second level dictionaries are real Python dictionaries instead of instantiations of my DifferentialDict, resulting in an overwriting of entries in global_base rather than changes in self.changes. However, they have to be because of the premise that all DifferentialDict instantiations share the same base dictionary. I could add an 'entry level' key to each DifferentialDict instantiation, but my feeling is that there is a more elegant solution which eludes me.I would really appreciate any suggestions on how to get my differential dictionary working when nested. Thanks in advance!
I don't have the time to try this right now (maybe a bit later), but here are two observations:combined indexesIf you would use tuples as indexes, for example like this  you would not have this problem. If you base either your base dict or also the differential dicts on this, you could circumvent the problem.Maybe you could even write some classes that rewrite to  to make this internal change transparent.global baseI don't understand why you use a global base. From my point of view this makes the code more complicated without adding anything. Why don't you just store the base as in:If you want to change all the content of the base, just delete all items using  and then add new ones using . This way your code is more flexible and does not have any surprising behavior because of the global variables.abstract base classesWhen reimplementing classes like sequences, dictionaries etc. it might come in handy to use the abstract base classes provided by Python, they do some of the implementation work for you.


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference
