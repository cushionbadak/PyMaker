Natural Text
I've got an iterator with some objects in it and I wanted to create a collection of uniqueUsers in which I only list every user once. So playing around a bit I tried it with both a list and a dict:So I tested it by converting the dict to a list when doing the if statement, and that works as I would expect it to:and I can get a similar result by testing against . The thing is that I don't understand why this difference occurs. I always thought that if you do , it simply creates a list of the dicts keys and tests agains that, but that's obviously not the case.Can anybody explain how  internally works and why it doesn't behave similar to  (as I would expect it to)?
In order to understand what’s going on, you have to understand how the  operator, the membership test, behaves for the different types.For lists, this is pretty simple due to what lists fundamentally are: Ordered arrays that do not care about duplicates. The only possible way to peform a membership test here is to iterate over the list and check every item on equality. Something like this:Dictionaries are a bit different: They are hash tables were keys are meant to be unique. Hash tables require the keys to be hashable which essentially means that there needs to be an explicit function that converts the object into an integer. This hash value is then used to put the key/value mapping somewhere into the hash table.Since the hash value determines where in the hash table an item is placed, it’s critical that objects which are meant to be identical produce the same hash value. So the following implication has to be true: . The reverse does not need to be true though; it’s perfectly valid to have different objects produce the same hash value.When a membership test on a dictionary is performed, then the dictionary will first look for the hash value. If it can find it, then it will perform an equality check on all items it found; if it didn’t find the hash value, then it assumes that it’s a different object:Since you get the desired result when using a membership test against a list, that means that your object implements the equality comparison () correctly. But since you do not get the correct result when using a dictionary, there seems to be a  implementation that is out of sync with the equality comparison implementation:Note that for new-style classes in Python 2 (classes that inherit from ), this “bad hash implementation” (which is based on the object id) is the default. So when you do not implement your own  function, it still uses that one. This ultimately means that unless your  only performs an identity check (the default), the hash function will be out of sync.So the solution is to implement  in a way that it aligns with the rules used in . For example, if you compare two members  and , then you should use a compound hash over those two members. The easiest way to do that is to return the hash value of a tuple of those values:Note that you should not make an object hashable if it is mutable:If a class defines mutable objects and implements an  method, it should not implement , since the implementation of hashable collections requires that a key’s hash value is immutable (if the object’s hash value changes, it will be in the wrong hash bucket).
TL;DR: The  test calls  for lists. For dicts, it first calls  and if the hash matches, then calls .The  test only calls  for lists.Without an , the in-ness comparison is always .For dicts, you need a correctly implemented  and  to be able to compare objects in it correctly:First gets the object's hash from Without , for new-style classes, it uses  which is unique for all objects created and hence never matches an existing one unless it's the same object.And as @poke pointed out in a comment:In Python 2, new style classes (inheriting from ) inherit object’s  implementation which is based on , so that’s where that comes from.If the hash matches, then  is called for that object with the .The result then depends on what  returns.If the hash does not match, then  is not called.So the  test calls  for lists and for dicts...but for dicts, only after  returns a matching hash. And not having a  doesn't return , doesn't throw an error and doesn't make it "unhashable". ...in Python 2. To use your  class correctly as dict keys, you do need to have a  method which is implemented correctly, in sync with .Details:The check for  "object in list" worked correctly because you have probably implemented an  method, as @poke pointed out. (And it appears  returns an object, not a string.)The same check doesn't work for "object in dict" either because:(a)  in that class is badly implemented, as @poke also pointed out.(b) Or you have not implemented  at all. This doesn't raise an error in Python2 new-style classes.Using the class in this answer as a starting point:


Answer URL
https://docs.python.org/3/reference/expressions.html#membership-test-details
https://docs.python.org/3/reference/datamodel.html#object.__eq__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
