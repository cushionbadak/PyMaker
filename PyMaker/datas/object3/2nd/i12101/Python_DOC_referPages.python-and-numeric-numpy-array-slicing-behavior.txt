Natural Text
On Python2.4, the single colon slice operator  works as expected on  matrices, in that it returns all values for the dimension it was used on. For example all  and/or  values for a 2-D matrix.On Python2.6, the single colon slice operator seems to have a different effect in some cases: for example, on a regular 2-D MxN matrix,  can result in  being returned as the resulting slice. The full matrix is what one would expect - which is what one gets using Python2.4.Using either a double colon  or 3 dots  in Python2.6, instead of a single colon, seems to fix this issue and return the proper matrix slice.  After some guessing, I discovered you can get the same zeros output when inputting  as the stop index. e.g.  returns the same "zeros" output as .  Is there any way to debug what indexes are being picked when trying to do ?  Or did something change between the two Python versions (2.4 to 2.6) that would affect the behavior of slicing operators?The version of  being used (24.2) is the same between both versions of Python. Why does the single colon slicing NOT work on Python 2.6 the same way it works with version 2.4?Python2.6:Python2.4:(I typed the "code" up from scratch, so it may not be fully accurate syntax or printout-wise, but shows what's happening)
It seems the problem is an integer overflow issue.  In the Numeric source code, the matrix data structure being used is in a file called MA.py.  The specific class is called MaskedArray.  There is a line at the end of the class that sets the "array()" function to this class.  I had much trouble finding this information but it turned out to be very critical.There is also a getslice(self, i, j) method in the MaskedArray class that takes in the start/stop indices and returns the proper slice.  After finding this and adding debug for those indices, I discovered that under the good case with Python2.4, when doing a slice for an entire array the start/stop indices automatically input are 0 and 2^31-1, respectively.  But under Python2.6, the stop index automatically input changed to be 2^63-1.Somewhere, probably in the Numeric source/library code, there is only 32 bits to store the stop index when slicing arrays.  Hence, the 2^63-1 value was overflowing (but any value greater than 2^31 would overflow).  The output slice in these bad cases ends up being equivalent to slicing from start 0 to stop 0, e.g. an empty matrix.  When you slice from [0:-1] you do get a valid slice.  I think (2^63 - 1) interpreted as a 32 bit number would come out to -1.  I'm not quite sure why the output of slicing from 0 to 2^63-1 is the same as slicing from 0 to 0 (where you get an empty matrix), and not from 0 to -1 (where you get at least some output).Although, if I input ending slice indexes that would overflow (i.e. greater than 2^31), but the lower 32 bits were a valid positive non-zero number, I would get a valid slice back.  E.g. a stop index of 2^33+1 would return the same slice as a stop index of 1, because the lower 32 bits are 1 in both cases.Python 2.4 Example code:Python 2.6 Example code:
I think I was using 2.4 10 years ago.  I used  back then, but may have added  for its  capabilities.  But the details are fuzzy.  And I don't have any of those versions now for testing.Python documentation back then should be easy to explore.  / documentation was skimpier.I think Python has always had the basic  slicing for lists.   to make a copy,  to slice of the first and last elements, etc.I don't know when the  was added, e.g.  to reverse a list.Python started to recognize indexing tuples at the request of numeric developers, e.g. , , , .  But I don't know when that appeared is also mainly of value for multidimensional indexing.  The Python interpreter recognizes , but lists don't handle it.  About the same time the  notation was formally implemented as , e.g.In 3.5, we can reverse a list with a I would suggest a couple of things:make sure you understand  (and ) indexing/slicing in a current systemtry the same things in the older versions; ask SO questions with concrete examples of the differences.  Don't count on any of us to have memories of the old code.study the documentation to find when suspected features where changed or added.


Answer URL
https://docs.python.org/3/whatsnew/2.5.html#pep-357-the-index-method
