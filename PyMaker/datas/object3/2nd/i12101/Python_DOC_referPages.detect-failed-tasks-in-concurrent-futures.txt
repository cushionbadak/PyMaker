Natural Text
I've been using concurrent.futures as it has a simple interface and let user easily control the max number of threads/processes. However, it seems like concurrent.futures hides failed tasks and continue the main thread after all tasks finished/failed.Calling f on any integer leads an TypeError. However, the whole script runs just fine and exits with code 0. Is there any way to make it throw an exception/error when any thread failed?Or, is there a better way to limit number of threads/processes without using concurrent.futures?
 will ensure all the tasks completed, but it doesn't check success (something -ed) vs. failure (exception raised and not caught in worker function). To do that, you need to call  on each  (which will cause it to either re- the exception from the task, or produce the -ed value). There are other methods to check without actually raising in the main thread (e.g. ), but  is the most straightforward method.If you want to make it re-, the simplest approach is just to replace the  call with:which will process results as s complete, and promptly  an  if one occurred. Alternatively, you continue to use  so all tasks finish before you check for exceptions on any of them, then iterate over  directly and call  on each.
There is another way to do the same with multiprocessing.Pool (for processes) or multiprocessing.pool.ThreadPool (for threads). As far as I know it rethrows any caught exceptions.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future.result
