Natural Text
I'm teaching myself Python when I run into the  method. While I can find explanation on the method in the official documentation:These methods are called to implement the binary arithmetic operations (, , , , , , , , , , , , , ) with reflected (swapped) operands. These functions are only called if the left operand does not support the corresponding operation and the operands are of different types. For instance, to evaluate the expression , where  is an instance of a class that has an  method,  is called if  returns .I can't picture why the method is necessary and how exactly it is used in reality.Would you kindly give me a typical environment where the method is useful?
Basic example. You write your own -like class:Now you have code that does:This works fine; Python sees  on the left side, sees it has , and calls  which returns without error, and we're good.Next we see:Python tries calling , but  has no idea how to handle a , and returns ; it has no idea that  has a value it can use for this purpose. At this point, Python can't just call  because it can't assume subtraction is commutative (and in fact, as in most numerical systems, subtraction is not commutative in this case, you can't just swap the right and left sides of the operator and get the correct result). This is why  exists; it lets you check the other class for a means of handling the operation while telling it two things:It's on the right side of the binary operator (allowing it to handle commutativity correctly)The item on the left side did not know how to handle the operation, so this is the last chance to get it rightThe second point is also very important. When implementing  (the left hand operator) you want to be very conservative on the types you recognize. If you don't know for a fact you're working with a known concrete type with a known correct handler, you shouldn't try to handle unknown types; the other type might know how to do the operation correctly, so you return  and let the other side handle it. When you're implementing , you're the last chance; the other guy didn't know what to do, so you should be liberal in what you accept and do your best if you have any means of handling it. You can see this in action in the Python docs on Implementing the arithmetic operations; the  operations check for concrete types (for , it checks for , , , and ), while the  operators check for general interfaces (, , , etc.).I've glossed over one point that is relatively important: If the class on the right side is a subclass of the class on the left, it has its reflected  method called first; the assumption is that the subclass will have more information to correctly determine what to do, so it's given the first stab at performing the operation.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__rsub__
https://docs.python.org/3/library/numbers.html#implementing-the-arithmetic-operations
https://docs.python.org/3/reference/datamodel.html#object.__radd__
