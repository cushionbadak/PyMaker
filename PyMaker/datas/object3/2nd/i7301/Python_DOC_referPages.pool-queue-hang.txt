Natural Text
I want to use a queue to hold result because I want a consumer (serial not parallel) to process the result of the workers as the workers produce the result.For now, I want to know why the following program hangs.
 objects cannot be shared. I came to the same conclusion as the OP first by finding this answer.Unfortunately, there were other problems in this code (which doesn't make it an exact duplicate of the linked answer) should be  for the args unpacking to work. Without that, my process locked up too (I admit I don't know why. It should have thrown an exception, but I guess that multiprocessing & exceptions don't work well together)passing the same  to the workers result in same number as a result (with  it works, but not with Another thing: for the code to be portable, wrap the main code by , required on Windows because of differences in process spawningFully fixed code that outputs 0,3,2,1 for me:
Change apply_async to apply gives error message:A solution:Result:Apparently, I need to manually make copies of the numpy array because the desired result should be 0, 1, 2, 3 in any order instead of 3, 3, 3, 3.
I think your choice to use  alongside your own  is the source of the main problems you're having. Using a pool creates the child processes up front, which jobs are later assigned to. But since you can't (easily) pass a  to an already existing process, that's not a good match for your problem.Instead, you should either get rid of your own queue and use the queue that's built into the pool to get a value ed by  or scrap the pool completely and use  to start a new process for each task you have to do.I'd also note that your code has a race condition in the main processes between the main thread that modifies the  array and the thread that serializes the old value before it's sent to a worker process. Much of the time you'll probably end up sending many copies of the same array (with the final value) instead of the several different values you intend.Here's a quick and  untested version that drops the queue:And here's a version that drops the  and keeps the queue:Note that in the last version it may be important that we  the results from the queue before we try to  the processes (though probably not if we're only dealing with four values). If the queue were to fill up, a deadlock could occur if we did it in the other order. The worker might be blocked trying to write to the queue, while the main process is blocked waiting for the worker process to exit.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#sharing-state-between-processes
https://docs.python.org/3/howto/logging-cookbook.html
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.imap
