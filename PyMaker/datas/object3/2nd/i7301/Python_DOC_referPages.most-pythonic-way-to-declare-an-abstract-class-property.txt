Natural Text
Assume you're writing an abstract class and one or more of its non-abstract class methods require the concrete class to have a specific class attribute; e.g., if instances of each concrete class can be constructed by matching against a different regular expression, you might want to give your ABC the following:(Maybe this could be better implemented with a custom metaclass, but try to ignore that for the sake of the example.)Now, because overriding of abstract methods & properties is checked at instance creation time, not subclass creation time, trying to use  to ensure concrete classes have  attributes won't work â€” but surely there should be something there to tell anyone looking at your code "I didn't forget to define  on the ABC; the concrete classes are supposed to define their own."  The question is: Which something is the most Pythonic?Pile of decorators(Assume Python 3.4 or higher, by the way.)  This can be very misleading to readers, as it implies that  should be an instance property instead of a class attribute.Tower of decoratorsThis can be very confusing to readers, as  and  normally can't be combined; they only work together here (for a given value of "work") because the method is ignored once it's overridden.Dummy valueIf a concrete class fails to define its own ,  will only accept empty input.  This option isn't widely applicable, as not all use cases will have an appropriate dummy value.Error-inducing dummy valueIf a concrete class fails to define its own ,  will raise an error, and the programmer gets what they deserve.Do nothing.  Basically a more hardcore variant of #4.  There can be a note in the ABC's docstring somewhere, but the ABC itself shouldn't have anything in the way of a  attribute.Other???
Python >= 3.6 Version(Scroll down for a version that works for Python <= 3.5).If you are fortunate enough to only be using Python 3.6 and not have to worry about backwards compatibility, you can use the new  method which was introduced in Python 3.6 to make customizing class creation easier without resorting to metaclasses.  When defining a new class, it is called as the last step before the class object is created.In my opinion, the most pythonic way to use this would be to make a class decorator that accepts the attributes to make abstract, thus making it explicit to the user what they need to define.The traceback might be as follows, and occurs at subclass creation time, not instantiation time.Before showing how the decorator is implemented, it is instructive to show how you could implement this without the decorator. The nice thing here is that if needed you could make your base class an abstract base class without having to do any work (just inherit from  or make the metaclass ).Here is how the decorator could be implemented.Python <= 3.5 VersionIf you are not fortunate enough to only be using Python 3.6 and not have to worry about backwards compatibility, you will have to use a metaclass. Even though this is perfectly valid Python, one could debate how pythonic the solution is because metaclasses are hard to wrap your brain around, but I think it hits most of the points of The Zen of Python so I think it's not so bad.This behaves exactly like the Python >= 3.6  method shown above (except the traceback will look bit different because it is routed through a different set of methods before failing).Unlike the  method, if you want to make a subclass an abstract base class you will have to do just a bit of extra work (you'll have to compose the metaclass with ).Outputs just as you'd expect.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
