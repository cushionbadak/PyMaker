Natural Text
I was playing around with the  type in Python 3.6 and was surprised by its behaviour. When I create a simple  like this in IPython:I get:as an output, which doesn't preserve the order of elements at instantiation for some reason. Now, when I create an  from  like this:the output is:Now I ask myself, how can the -constructor know about the order of elements at instantiation of ? And does it always behave the same, such that I can rely on the order of elements in the ?I was already reading the Python docs about dictionaries and s but I didn't find an answer to my question.The output from ():
It's now obvious that the custom hook () that IPython uses to display output is pretty printing things (using it's own pretty printer). By directly calling  you can see how it ruins the insertion order:In addition, if you grabbed the dictionary  instead (sending a string to be displayed instead of a dict object) you'd get the correct and expected order:similarly by ing it.I'm not sure why IPython does this with , it was quite confusing (edit: see relevant issue on GitHub). In your standard Python REPL, this behavior won't manifest since  isn't implemented to do any pretty printing.The dict  you've created does maintain insertion order, that's why the  is maintaining that same order.The fact that it does is, of course, an implementation detail. Until that is changed (and it does appear that it will) you should stick to using  to reliably maintain order across implementations.By the way, if you want this disabled, you could start IPython with the  option which disables its pretty printer:
In 3.6, as an implementation detail, all s are ordered. You're being fooled by IPython: Before 3.6, the order of keys was arbitrary, so for user-friendliness, IPython's interactive output for  and  (where normal Python would just print the ) sorts the keys. That's why your  appears to be in alphabetical order. It's possible IPython might eventually drop that behavior when running on 3.6+, since as you've noticed, it is quite confusing.If you explicitly , rather than relying on  to output the results of the previous expression for you, you'll bypass 's REPL magic and see the "natural" order. Same goes for just about any other means of interacting with the , since iteration will proceed in the expected order.
As you probably know, dictionaries in Python are not ordered according to the language specification. They do have an inherent order but that order is arbitrary.So when you pass a standard dictionary to the constructor of an , the new  will be filled from the values of the original dictionary by iterating its values. That way, the inherent order of the dictionary will be used, and that will be what you will be seeing in the final .Now, with Python 3.6, there was a change in the implementation of the default dictionary. As discussed and explained on this question, standard dictionaries now preserve the insertion order. That’s why when you created the  from the Python 3.6 dict, the original order is preserved as well.Does this mean that  becomes obsolete in Python 3.6+? No, as the order preserving of standard dictionaries is an implementation detail. Instead of the arbitrary order of previous implementations, the new dictionary just happens to have the “correct” order. But this is in no way guaranteed by the language specification, and may or may not be the case for other implementations. As such you cannot and should not rely on it.Btw. note that Python 3.6 (the language, not just the implementation) does guarantee that the order of keyword arguments to  is preserved. E.g. this preserves the order:


Answer URL
https://docs.python.org/3/library/sys.html#sys.displayhook
