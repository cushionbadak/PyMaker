Natural Text
This question already has an answer here:python class instance variables and class variables                    4 answers                How to avoid having class data shared among instances?                    8 answers                The following code troubles me:-The output is:- meaning that the list  is shared by the two instances t1 and t2, which has been explained in the section 9.3.5 of https://docs.python.org/3/tutorial/classes.html However, if I execute the following code:-The output is the following:-Now it seems that the list  is no longer shared by those two instances t1 and t2. My question is, what are the mechanics here? 
The difference is that in your second example you are creating a new list, self.tricks, as an attribute of the object:The first example works because of Python's way of resolving the names: If self.tricks cannot be found in the object (because it hasn't been created), then it tries to find it as a member of the class. Since tricks is there, then you can access it.It may become clear to you if you try to use mytest.tricks in your second example:That will output what you are actually expecting.
In the first case, you didn't create a  attribute on the object scope, so Python used the one from the class; in the second case, you created a new list and associated it with the object itself, so Python used that.For a way more thorough explanation, please, take a look at: Python Class Attributes: An Overly Thorough Guide
In your first example, the class  has a  member, shared by all its instances:In your second example, however,  instances additionnally have a  member:The  statement gives an attribute named  to , that is, the  instance.The class still has a common  member.When calling , Python first looks for a  member in . If it does not find any, it looks for a  member in .Therefore, instances of your first example have no  attribute, but Python will give you the  they all share.On the other hand, instances of your second example do have their own  attribute, and Python will return this one.
Your first case creates a class variable, and the second creates an instance variable.When you do refer , Python first checks for a   element in the instance's namespace dictionary, and then checks for a  element in the class's namespace dictionary.In the first case, since you created a class variable named  with a mutable type (a list), and didn't re-assign it specifically on the method, modifications to that list are available to every instance of the class.In your second case, things are identical except that you hid the class variable with an instance variable of the same name, so from that point on, all references to  refer to the instance variable instead of the class variable.The second case illustrated:
There's a little thing to note here in this problem.When you pass in the name and append it to the existing shared  list, it is, as you saw, shared by all the values, because it is that list.However, when you do  in your second example, you are erasing that objects instance of  and are replacing it with the list This is similar to having a parent and child class; when the child class doesn't give a different definition for an existing function, calling it calls the parent's function. But if you do, it calls the child's function.
In the both case, you replacing the  to a new value.In the first case you're mutating the  list, mutating a list don't replace it. so during the whole execution you have a single list, being mutated.In the second case, the line  is changing the list, creating a new list object.You can easily introspect this like:Giving:


Answer URL
https://docs.python.org/3/tutorial/classes.html
