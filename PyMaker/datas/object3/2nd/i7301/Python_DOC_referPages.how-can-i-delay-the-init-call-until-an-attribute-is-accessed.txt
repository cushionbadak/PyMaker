Natural Text
I have a test framework that requires test cases to be defined using the following class patterns:When I create and run a test, I get the following:The test framework searches for and loads all  classes it can find, instantiates each one, then calls the  method for each test.However, I now have some test cases for which I don't want the  method called until the time that the  method is called, but I have little control over the framework structure or methods.  How can I delay the call to  without redefining the  or  methods?UpdateThe speculations that this originated as an XY problem are correct.  A coworker asked me this question a while back when I was maintaining said test framework.  I inquired further about what he was really trying to achieve and we figured out a simpler workaround that didn't involve changing the framework or introducing metaclasses, etc.However, I still think this is a question worth investigating:  if I wanted to create new objects with "lazy" initialization ("lazy" as in lazy evaluation generators such as , etc.) what would be the best way of accomplishing it?  My best attempt so far is listed below, I'm interested in knowing if there's anything simpler or less verbose.
First Solutionï¼šuse property.the elegant way of setter/getter in python.Second Solution:the proxy solution,and always implement by decorator.In short, Proxy is a wrapper that wraps the object you need. Proxy could provide additional functionality to the object that it wraps and doesn't change the object's code. It's a surrogate which provide the abitity of control access to a object.there is the code come form user Cyclone.To be used for true one-time calculated lazy properties. I like it because it avoids sticking extra attributes on objects, and once activated does not waste time checking for attribute presence
Metaclass optionYou can intercept the call to  using a metaclass.  Create the object with  and overwrite the  method to check if  has been called or not and call it if it hasn't.In the example below, you'll see that the init print won't occur until the  method is executed.Decorator optionYou could also use a decorator that has a similar pattern to the metaclass above:This will behave identically to the example above.
In Python, there is no way that you can avoid calling  when you instantiate a class . If calling  returns an instance of , then the language guarantees that  will have been called.So the only way to achieve something similar to what you are asking is to introduce another class that will postpone the calling of  in the original class until an attribute of the instantiated class is being accessed.Here is one way:This wrapper function works by catching any attempt to access an attribute of the instantiated class. When such an attempt is made, it changes the instance's  to the original class, calls the original  method with the arguments that were used when the instance was created, and then returns the proper attribute. This function can be used as decorator for your  class:Be careful where you apply this function though. If you decorate  with , it will not work, because it will turn the  instances into  instances.
In my answer I'd like to focus on cases when one wants to instantiate a class whose initialiser (dunder init) has side effects. For instance, , creates an SSH connection, which may be undesired until it's actually used.In a great blog series about conceiving of  package (nit-picky decorator implementaion), the author describes Transparent object proxy. This code can be customised for the subject in question.Then it can be used as:But ,  and other language constructs which invoke Python object protocols (dunder methods, like  and ) will not work. However, for many cases, which are limited to regular methods, this is a  solution.To proxy object protocol implementations, it's possible to use neither , nor  (to do it in a generic way). The latter's documentation notes:This method may still be bypassed when looking up special methods as the result of implicit invocation via language syntax or built-in functions. See Special method lookup. As a complete solution is demanded, there are examples of manual implementations like werkzeug's  and django's . However a clever workaround is possible.Luckily there's a dedicated package (based on wrapt) for the exact use case, lazy-object-proxy which is described in this blog post.
One alternative would be to write a wrapper that takes a class as input and returns a class with delayed initialization until any member is accessed. This could for example be done as this:This could then be used as such
Answering your original question (and the problem I think you are actually trying to solve), "How can I delay the init call until an attribute is accessed?": don't call init until you access the attribute.Said another way: you can make the class initialization simultaneous with the attribute call. What you seem to actually want is 1) create a collection of  classes along with their associated parameters; 2) run each test case.Probably your original problem came from thinking you had to initialize all your  classes in order to create a list of them that you could iterate over. But in fact you can store class objects in ,  etc. That means you can do whatever method you have for finding all  classes and store those class objects in a  with their relevant parameters. Then just iterate that  and call each class with its  method.It might look like:
Overridding You could do this by overriding  method and replacing  method with a custom function.Demo:Using cached propertiesThe idea is to do the heavy calculation only once by caching results. This approach will lead to much more readable code if the whole point of delaying initialization is improving performance.Django comes with a nice decorator called . I tend to use it a lot in both code and unit-tests for caching results of heavy properties.A  is a non-data descriptor. Hence once the key is set in instance's dictionary, the access to property would always get the value from there.Usage:Demo:
I think you can use a wrapper class to hold the real class you want to instance, and use call  yourself in your code, like(Python 3 code):but it's a dump way, but without any trick.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__
https://docs.python.org/3/reference/datamodel.html#special-lookup
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
