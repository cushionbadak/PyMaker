Natural Text
Edit: I condensed this question given that it was probably too involved to begin with.  The meat of the question is in bold below.I'd like to know more about the object that is actually created when using  or :Some background: consider the oft-used alternative with .  This code snippet itself isn't important, but its result is my reference point in asking this question.Here  will take a 1d or 2d  and build rolling "blocks" equal to the specified window size (as below).  How does a  object compare to the  output below?  Is it an iterator, with certain attributes stored for each block?  Or something else entirely?  I've tried playing around with tab completion on the object with attributes/methods such as  and  and they're not telling me much.  I've also seen a  method in pandas--does it at all resemble the  method?Part 2, extra creditUsing the NumPy approach above (OLS implementation here) is necessitated by the fact that  within pandas.core.window.Rolling.apply mustproduce a single value from an ndarray input *args and **kwargs are  passed to the functionSo the argument can't be another rolling object.  I.e.So this is really from where my question above stems.  Why is it that the passed function must use a NumPy array and produce a single scalar value, and what does this have to do with the layout of a  object?
I suggest you have a look at the source code in order to get into the nitty gritty of what rolling does. In particular I suggest you have a look at the  functions in generic.py and window.py. From there you can have a look at the  class which is used if you specify a window type or the default  class. The last one inherits from  and ultimately  and .That said, I'll give my two cents: Pandas' whole rolling mechanism relies on the numpy function . In particular it is used here in pandas. It is used in conjunction with the  cython module. In goes your series, out comes the aggregated rolling window. For typical aggregation functions it handles them for you efficiently, but for custom ones (using ) it uses a  in .The rolling function in pandas operates on pandas data frame columns independently. It is not a python iterator, and is lazy loaded, meaning nothing is computed until you apply an aggregation function to it. The functions which actually apply the rolling window of data aren't used until right before an aggregation is done.A source of confusion might be that you're thinking of the rolling object as a dataframe. (You have named the rolling object  in your last code snippet). It really isn't. It is an object which can produce dataframes by applying aggregations over the window logic it houses.The lambda you are supplying is applied for each cell of your new dataframe. It takes a window backwards (along each column) in your old dataframe, and it aggregates it to one single cell in the new dataframe. The aggregation can be things like , , something custom you've made, etc., over some window size, say 3. Here are some examples:... which can also be done by:... and produces:(The first column is the index value and can be ignored here, and for the next examples.)Notice how we supplied an existing numpy aggregation function. That's the idea. We're supposed to be able to supply anything we want as long as it conforms to what aggregation functions do, i.e., take a vector of values and produce a single value from it. Here is another one where we create a custom aggregation function, in this case the L2 norm of the window:if you're not familiar with lambda functions this is the same as:... yielding:Just to make sure, we can manually check that  is indeed .[In your original edit, in the] last code snippet, your code is probably failing early than you expect. It is failing before the invocation of  You are trying to add a rolling object named  to the number 2 before it is passed to . The rolling object isn't something you do operations on. The aggregation function you have supplied also doesn't conform to an aggregation function in general. The  is a list with the values of a window,  would be a constant extra parameter you pass in. It can be a rolling object if you want, but it wouldn't typically be something you would like to do. To make it more clear, here is something which is similar to what you were doing in your original edit but works:It is a contrived example, but I'm showing it to make the point that you can pass in whatever you want as a constant, even the rolling object you are using itself. The dynamic part is the first argument  in your case or  in my case. All defined windows, in the form of individual lists, are passed into that function one by one.Based on your followup comments this might be what you're looking for:which adds arrays/vectors to each rolling block thus producing:Note that it only works if you do it on a column at a time. If you want to do some math on the window before you store it away in  that is fine too.That said, without more input on exactly what you are trying to achieve it is hard to construct an example which suits your needs.If your ultimate goal is to create a dataframe of lagging variables then I'd go for using real columns using :... giving: (There might be some more beautiful way of doing it, but it gets the job done.)Regarding your variable  in your first code snippet, remember DataFrames in pandas aren't typically handled as tensors of arbitrary dimensions/object. You can probably stuff whatever you want into it, but ultimately strings, time objects, ints and floats is what is expected. That might be the reasons the designers of pandas haven't bothered with allowing rolling aggregation to non-scalar values. It doesn't even seem like a simple string is allowed as output of the aggregation function.Anyway, I hope this answer some of your questions. If not let me know, and I'll try to help you out in the comments, or an update.Final note on the  function of rolling objects. The  function handles the reindexing and binning when you use the  argument of . If you use freq with, say, weeks such that :... then we get the binned (not rolling) original data week-by-week:Notice that this isn't the output of the aggregated rolling. This is simply the new blocks it works on. After this. We do an aggregation like  and get:... which checks out with a test summation: 50 = 2 + 9 + 16 + 23.If you don't use  as an argument it simply returns the original data structure:... which produces ...... and is used for rolling window aggregation.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
