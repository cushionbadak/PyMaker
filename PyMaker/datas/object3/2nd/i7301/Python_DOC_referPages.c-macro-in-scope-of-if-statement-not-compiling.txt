Natural Text
I have some code which is supposed to be a thread-safe python/c++ api. I am using the macros  and , which expand to create save thread state and create a lock. I am releasing the lock just before method exit; once inside of  statement scope, and once at method scope.Why does this not compile? It generates the error:  at the second  macro.I have also tried putting the  statement inside of the  directive scope, and this generates the same error. However, this works:Edit: I'm aware that the second example does not do thread clean-up; however, it compiles.Edit2: expands to  expands to NOTE the scoping braces prepending  and appending . Why is it the logical choice for the macro expansion to include scoping?
The preprocessor expands the macro, , into code that creates a local object named .The preprocessor expands the macro, , into code that uses  to do thread clean-up tasks.If you put  inside the else block, the code created by  can't see the local  object, so you get an error message.On a related topic, I recommend putting  and  where if the first one executes, then so does the second one. Your second version of the function will not do the thread clean-up tasks for  if you have an array type or a priority-queue type.Try this:In this version, the default response is FAIL, so you don't even need the final else section. The other if statements only set the response to SUCCESS if all goes well.
From [Python 3]: Py_BEGIN_ALLOW_THREADS (emphasis is mine):This macro expands to . Note that it contains an opening brace; it must be matched with a following Py_END_ALLOW_THREADS macro. See above for further discussion of this macro.So, the answer to the compile error is pretty clear:After preprocessing, the 2nd Py_END_ALLOW_THREADS produces invalid code (and the enclosing in  is irrelevant, as it will never work when UBUNTU is defined, and it will always work when it isn't):Referencing (inexistent) "_save" An extra closing brace ("}")The common usecase for the 2 macros is also exemplified int he above page:Why it was designed this way (to include scoping)? Probably to fail when used like you did, because that can cause hard to find errors (your example is pretty simple, but in a more complex piece code with many branches requiring just as many Py_END_ALLOW_THREADS, imagine what would mean to miss one, or to call it twice).In order to fix your problem, you must redesign your code to either:Not directly return on failure, but flag it, return (in one place) at the end, and place the Py_END_ALLOW_THREADS, just before returningCall the macro pair inside each (or where required) of the if branches (ARRAY, PRIORITY_QUEUE, ...)Use (the dreaded) goto


Answer URL
https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
