Natural Text
I'm reading Fluent Python chapter 19 > A Proper Look at Properties, and I'm confused about the following words:Properties are always class attributes, but they actually manage attribute access in the instances of the class.The example code is:From my previous experiences, class attributes are belong to the class itself and shared by all the instances. But here, weight, the property, is an instance method and the value returned by it is different between instances. How is it eligible to be a class attribute? Doesn't it that all the class attributes should be the same for any instances?I think I misunderstand something, so I hope to get a correct explanation. Thanks!
A distinction is made because when you define a  on a class, that property object becomes an attribute on the class. Whereas when you define attributes against an instance of your class (in your  method), that attribute only exists against that object. This might be confusing if you do:Notice how both  and  exist as attributes on your class.I think it's also worth noting that when you define a class, code under that class is executed. This includes defining variables (which then become class attributes), defining functions, and anything else.A  is just "syntactic sugar". Meaning  over a function if the same as . This applies to functions defined inside a class as well, but now the function is part of the class's namespace.A good explanation of  in Python can be found here: https://stackoverflow.com/a/17330273/7220776
From my previous experiences, class attributes are belong to the class itself and shared by all the instances.That's right.But here, weight, the property, is an instance methodNo, it's a  object. When you do:it's actually syntactic sugar forIOW the  statement is executed, the function object created, but instead of beeing bound to it's name, it's passed to the  callable, and the name is bound to whatever  returned. In this case the decorator is the  class itself, so the  attribute is a  instance. You can check this out by yourself by inspecting  (which will return the  object itself).and the value returned by it is different between instances. Well yes of course, how is this surprising ?  is a class attribute also (like all methods), yet it returns values from the instance it's called on (which is passed to the function as the  param). How is it eligible to be a class attribute? Doesn't it that all the class attributes should be the same for any instances?The class attributes ARE the same for all instances of a class, yes. There's only one single  function for all instances of . A  is mainly a shortcut to make a function (or a pair of functions if you specify a setter) look like it's a plain attribute, so when you type , what is really executed is , where  is the getter function you decorated with . The mechanism behind this is known as the "descriptor protocol", which is also used to turn  into  (python functions implement the descriptor protocol to return "method" objects, which are themselves wrappers around the function and the current instance and insert the instance as first argument to the function call). So it's not suprising that properties are class attributes - you only need one  instance to "serve" all instances of the class -, and moreover, properties - like all descriptors FWIW - MUST actually be class attributes to work as expected, since the descriptor protocol is only invoked on class attributes (there's no use case for a "per instance" computed attribute since the function in charge of the "computation" will get the instance as parameter). 
You didn't misunderstand. Don't worry, just read on. It will become clear in the next chapter. The same book explains in chapter 20 that they can be a class attributes because of the descriptor protocol. The documentation explains how properties are implemented as descriptors.As you see from the example, properties are really class attributes (methods). When called, they get a reference to the instance, and writes/reads to its underlying .
I think the example is wrong, the init shoul look like this:self.__weight and self.__price are the internal attributes hidden in the class by the properties
I finally understand the descriptor and property concept through Simeon Franklin's excellent presentation, the following contents can be seen as a summary on his lecture notes. Thanks to him!To understand properties, you first need to understand descriptors, because a property is implemented by a descriptor and python's decorator syntactic sugar. Don't worry, it's not that difficult.What is a descriptor: a descriptor is any object that implements at least one of methods named __get__(), __set__(), and __delete__(). Descriptor can be divided into two categories: A data descriptor implements both __get__() and __set__().A non-data descriptor implements only __get__().According to python's HowTo:a descriptor is an object attribute with “binding behavior”, one whose attribute access has been overridden by methods in the descriptor protocol. Then what is the descriptor protocol? Basically speaking, it's just says that when Python interpreter comes across an attribute access like ，it will search in some order to resolve this  , and if this  is a descriptor attribute, then this descriptor will take some precedence in this specific order and this attribute access will be translated into a method call on this descriptor according to the descriptor protocol, possibly shadowing a namesake instance attribute or class attribute.  More concretely, if  is a data descriptor, then  will be translated into the calling result of this descriptor's __get__ method; if  is not a data descriptor and is an instance attribute, this instance attribute will be matched; if  is not in above, and it is a non-data descriptor, we get the calling result of this non-data descriptor's __get__ method. Full rules on attribute resolution can be found here .Now let's talk about property.  If you have looked at Python' descriptor HowTo, you can find a pure Python version implementation of property:Apparently，property is a data descriptor! @property just uses python's decorator syntactic sugar. is equivalent to:So,  is no longer an instance method as I posted in thie question, but is translated into a class attribute by the decorator syntactic sugar as the author said. It's a descriptor object attribute.  How is it eligible to be a class attribute?OK, we solved it now.Then:Doesn't it that all the class attributes should be the same for any instances?No!I steal an example from Simeon Franklin's excellent presentation .Pay attention to  and its output. The second element in its output is  . It's the specific instance  . Shortly speaking, because this attribute access has been translated into a __get__ method call, and this __get__ method get the specific instance argument as its method signature  demands, it can return different values according to which instance it is been called by.Note: my English explanation maybe not clear enough, so I highly recommend you to look at Simeon Franklin's notes and Python's descriptor HowTo.


Answer URL
https://docs.python.org/3/reference/datamodel.html#implementing-descriptors
https://docs.python.org/3/howto/descriptor.html#properties
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/howto/descriptor.html
https://docs.python.org/3/reference/datamodel.html#descriptors
