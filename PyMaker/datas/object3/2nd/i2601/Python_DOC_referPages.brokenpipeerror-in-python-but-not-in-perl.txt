Natural Text
Consider this Python script:and this Perl script: produces an error:but produces no error (in Perl v5.26.1).Why such a discrepancy between Python and Perl? How to make Perl to produce a similar error message?
What's going on here is that in both cases you have a process writing to a pipe whose read end was closed (by  exiting after a certain number of bytes).This causes a  signal to be sent to the writing process. By default this kills the process. The process can ignore the signal if it wants to, which just makes the  call fail with an  error.Starting with version 3.3, Python raises a  exception in this case, so it looks like Python 1) ignores  by default and 2) translates  to a  exception.Perl does not ignore or handle signals by default. That means it gets killed by  in your example, but because it is not the last command in a pipeline (that would be  here), the shell just ignores it. You can make it more visible by not using a pipeline:This piece of bash trickery makes perl write to a pipe, but not as part of a shell pipeline. I can't test it now, but at minimum this will set  (the command exit status) to  in the shell (128 + signal number, which for  is 13), and it may also report a .You can deal with it manually in the Perl code, though:Variant 1: Throw an error from the signal handlerVariant 2: Ignore the signal, handle write errorsNote that in this case you have to think about buffering, however. If you don't enable autoflush (as in ) and output is going to a pipe or file, Perl will collect the text in an internal buffer first (and the  call will succeed). Only when the buffer gets full (or when the filehandle is closed, whichever happens first) is the text actually written out and the buffer emptied. This is why  can also report write errors.
The python exception is raised since the reading process () closes its end so the script receives  the next time it attempts to write; see this post. This involved decisions in Python community, to change defaults so to inform the user (see the linked post).This is not seen in Perl because it gets killed by that signal (what is its disposition) without saying anything. So you could override that(without the  I need more than  above for it to happen.)Or, rather issue a ing (instead of ) so that the program continuesUpdate Â  Given the clarification provided in a comment I'd recommend this handler to be global in fact. It can still be overriden with a  one in particular scopes. Besides, there is nothing wrong with surviving a  instead of being terminated, as long as there is a warning.Note that even without that the exit status of the Perl process will show the problem. Run  after the process "completes" (is quietly terminated); I get  on my system.To mimic Python's behavior further you could issue a  in the signal handler and handle that exception, by putting it all in .Thanks to melpomene and ikegami for comments.


Answer URL
https://docs.python.org/3/whatsnew/3.3.html#pep-3151
