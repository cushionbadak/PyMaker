Natural Text
I'm trying to create a Python function that uses the Caesar cipher to encrypt a message.   So far, the code I have isWhen I try to run my code, it will ask for the letter but it doesn't return anything after that Please help if you have any suggestions.
you would need to access your dictionary in a different way:and then you can finally call the function.
You can define two dictionaries, one the reverse of the other. You need to be careful on a few aspects:Whether case is important. If it's not, use  as below.What happens when you roll off the end of the alphabet, e.g. 13th letter after "z". Below we assume you start from the beginning again.Don't type out the alphabet manually. You can use the  module.Here's a demo:
If you need a entirely new encoded dictOutput:
The code you have only maps letters to a position.  We'll rewrite it and make a  function.CodeTestsDemoHere we rotated the letter  13 positions, got a letter and then determined the position of this resultant letter in the normal string of abc's.DetailsThis function was rewritten to lookup the position of a letter.  It merges two dictionaries:one that enumerates a lowercase ascii lettersone that enumerates a uppercase ascii lettersThe  module has this letters already.This function only rotates lowercase letters; uppercase letters are translated from the lowercase position. The string of letters is rotated by making an infinite  (an iterator) of lowercase letters.The cycle is first advanced to  at the desired letter.  This is done by dropping all letters that don't look like the one passed in.  Then it is advanced in a loop some number of times equal to .  The loop is just one way to consume or move the iterator ahead.  We only care about the last letter, not the ones in between.  This letter is returned, either lower or uppercase.  Since a letter is returned (not a position), you can now use your  function to find it's normal position.AlternativesOther rotation functions can substitute :However, these options are constrained to rot13, while  can be shifted  by any number.  Note: rot26 will cycle back to the beginning, e.g. .See also this post on how to make true rot13 cipher.See also docs on  and .
You can do it with quick calculations from  and  functions instead:so that:outputs:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.cycle
https://docs.python.org/3/library/itertools.html#itertools.dropwhile
