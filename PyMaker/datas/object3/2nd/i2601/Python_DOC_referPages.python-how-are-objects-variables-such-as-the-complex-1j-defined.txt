Natural Text
And how can I define my own types of variables/objects to behave with the provided operations in python?Can I do this without having to create my own object classes and operators as a separate and distinct entity? I dont mind having to create my own object class (thats a given), but I want it to integrate flawlessly with the already existing constructs. So emphasis on my wish to avoid "separate and distinct".Im trying to create a quaternion object class.  I want to define a 1i and 1k that are distinct from 1j.And yes, a package might already exist; this is purely academic and for my own programming practice and understanding.  Im trying to extend what is already there, and not build something that is distinct and separate.I already do class objects but unfortunately they require a redefinition of the basic operations in order to make use of them, and even then I have to "declare" these objects before I can use them, quite unlike '1j'.I hope I am clear with my intent.  The end result of a quaternion is not my intent; it is the types of methods and objects and generalizations Im trying to figure out how to do, to extend and make use of what is already built into python.It seems to me whoever built numpy and cmath have already been able to achieve this endeavor.Thanks to the commentary below. I now have the vocabulary to express my intent better.Im trying to add new features to Pythons SYNTAX.If anyone can offer resources on how to do this, Id appreciate it.
I see two options for you here:Change the Python syntax (fork CPython), there's a surprising amount of articles about how to do that.Build some kind of preprocessor like Mypy.Either way it seems like too much trouble just to have a new literal value.
Python does not support custom operators nor custom literals.A language that supports custom literals is C++ (since C++11 I believe), but it does not support custom operators.A language that supports custom operators is, for example, Haskell.If you want to add this feature to Python you'll have to take the Python sources, modify its grammar, modify the lexer/parser and more importantly the compiler.However at that point you just create a new language, which means you broke compatibility with python.The easiest solution would simply be to write a simple preprocessor that replaces some simple syntax with an expanded equivalent. For example:Then you can execute the preprocessor in the build step of your library/application.This has the advantage of letting you write the code you want, but when you ship it/use it it is translated into normal python, keeping 100% compatibility with existing installations.I believe using import hooks it would be possible to avoid having to ship the preprocessed version of your library... basically the preprocessor could be included in the import step and done on the fly. This would avoid having to deal with temporary preprocessed files.The only requirement would be that people that need to use your library will have to install the import hook someway.


Answer URL
https://docs.python.org/3/reference/import.html#import-hooks
