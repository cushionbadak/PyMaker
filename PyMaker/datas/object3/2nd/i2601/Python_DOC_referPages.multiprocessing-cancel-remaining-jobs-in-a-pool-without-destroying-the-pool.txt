Natural Text
I'm using map_async to create a pool of 4 workers. And giving it a list of image files to process [Set 1].At times, I need to cancel the processing in between, so that I can instead get a different set of files processed [Set 2].  So an example situation is, I gave map_async 1000 files to process. And then want to cancel the processing of remaining jobs after about 200 files have been processed.Additionally, I want to do this cancellation without destroying/terminating the pool. Is this possible?I do not want to terminate the pool, because recreating the pool is a slow process on Windows (because it uses 'spawn', instead of 'fork'). And I need to use this same pool for processing a different set of image files [Set 2]..Now in between, I need to cancel the processing on this set 1. And move onto a different set (waiting for all 1000 images to complete processing is not an option, but I can wait for the current image being processed to finish)
It's time for the fundamental theorem of software engineering: while  doesn't supply cancellation as a feature, we can add it by having a  read from a carefully crafted iterable.  It's not enough, however, to have a generator that s values from a list but stops short on some signal, because the  eagerly drains any generator given to it.  So we need a very carefully crafted iterable.A lazy The generic tool we need is a way to construct tasks for a  only when a worker becomes available (or at most one task ahead, in case constructing them takes significant time).  The basic idea is to slow down the thread collecting work for the  with a semaphore upped only when a task is finished.  (We know such a thread exists from the observable behavior of .)The  in  prevents failures in the children from breaking the semaphore's count, but note that it does not protect against failures in the parent.A cancelable iteratorNow that we have real-time control over the  input, making whatever scheduling policy is straightforward.  For example, here's something like  but with the ability to asynchronously discard any remaining elements from one of the input sequences:This is thread-safe (in CPython at least) despite the lack of locking because operations like  are atomic with respect to Python inspection (and we don't separately check whether  is empty).UsageMaking one of these looks likewhere of course the s and  could themselves be in the loop.
The  module doesn't seem to have the concept of cancellation. You can use the  wrapper and cancel the pending futures when you have enough results.Here's an example that picks out 10 JPEGs from a set of paths, and cancels pending futures while leaving the process pool usable afterwards:Note that picking how to break up work into futures is still tricky, a bigger set is more overhead but can also mean less wasted work. This can also be adapted to Python 3.6 async syntax easily enough.


Answer URL
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor
