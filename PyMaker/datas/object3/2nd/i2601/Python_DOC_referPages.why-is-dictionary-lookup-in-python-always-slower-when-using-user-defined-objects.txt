Natural Text
I noticed that when I use user-defined objects (that override the  method) as keys of my dicts in Python, lookup time increases by at least a factor 5. This behaviour is observed even when I use very basic hash methods such as in the following example:If I time the access through the two different keys I observe a significant difference in performanceresults in ~ 100 ns. Whereasresults in ~ 600 ns. If I remove the overwriting of  and  methods, performance is at the same level as for a default objectIs there a way to avoid this loss in performance and still implement a customised hash calculation ?
The default CPython  implementation for a custom class is written in C and uses the memory address of the object. Therefore, it does not have to access absolutely anthing from the object and can be done very quickly, as it is just a single integer operation in CPU, if even that.The "very basic"  from the example is not as simple as it may seem:This has to read the attribute  of , which I'd say in this case will call , and that will look for the value of 'a' in . This already involves calculating  and looking it up. Then, the returned value will be passed to .To answer the additional question:Is there a way to implement a faster  method that returns  predictable values, I mean that are not randomly computed at each run  as in the case of the memory address of the object ?Anything accessing attributes of objects will be slower than the implementation which does not need to access attributes, but you could make attribute access faster by using , or implementing a highly optimized C extension for the class.There is, however, another question: is this really a problem? I cannot really believe that an application is becoming slow because of slow .  should still be pretty fast unless the dictionary has trillions of entries, but then, everything else would become slow and ask for bigger changes...I did some testing and have to make a correction. Using  is not going to help in this case at all. My tests actually showed that in CPython 3.7 the above class becomes slightly slower when using .


Answer URL
https://docs.python.org/3/reference/datamodel.html#slots
