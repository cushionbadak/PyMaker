Natural Text
Say I want to implement a metaclass that should serve as a class factory. But unlike the  constructor, which takes 3 arguments, my metaclass should be callable without any arguments:For this purpose I defined a custom  method with no parameters:But the problem is that python automatically calls the  method with the same arguments as the  method, so trying to call  ends up throwing an exception:Which makes sense, since  can be called with 1 or 3 arguments. But what's the correct way to fix this? I see 3 (4?) options:I could add an empty  method to my metaclass, but since I'm not sure if  does anything important, this might not be a good idea.I could implement an  method that calls .I could use a meta-metaclass and override its  method, rather than messing with  and .Bonus option: Maybe I shouldn't try to change the signature?So my question is: Are the 3 solutions I listed correct or are there any subtle bugs hidden in them? Which solution is best (i.e. the most correct)?
An interface deviating from the parent signature is a questionable design in regular classes too.  You don't need the extra complexity of metaclasses to get into this kind of mess - you can cause the same new/init jumble by subclassing a  or whatever. I want to have a metaclass and an easy way to create instances of that metaclass. The usual pattern in Python is to write a factory using a  classmethod.  To take the example of creating datetime instances from a different init signature, there is for example , but you have many other examples too (, , ...)There is nothing specific to metaclasses here, so use the same pattern:Usage:


Answer URL
https://docs.python.org/3/library/functions.html#type
https://docs.python.org/3/reference/datamodel.html#object.__new__
https://docs.python.org/3/reference/datamodel.html#object.__init__
https://docs.python.org/3/library/datetime.html#datetime.date.fromtimestamp
