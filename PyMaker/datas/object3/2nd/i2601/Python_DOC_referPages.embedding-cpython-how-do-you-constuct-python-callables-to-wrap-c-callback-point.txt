Natural Text
Suppose I am embedding the CPython interpreter into a larger program, written in C.  The C component of the program occasionally needs to call functions written in Python, supplying callback functions to them as arguments.Using the CPython extending and embedding APIs, how do I construct a Python "callable" object that wraps a C pointer-to-function, so that I can pass that object to Python code and have the Python code successfully call back into the C code?Note: this is a revised version of a question originally posted by user dhanasubbu, which I answered, but which was then deleted.  I think it was actually a good question, so I have converted what I wrote into a self-answer to my own statement of the question.  Alternative answers are welcome.
To define an extension type that is “callable” in the sense Python uses thatterm, you fill the  slot of the type object, which is the C equivalent of the  special method.  The function that goes in that slot will be a glue routine that calls the actual C callback.  Here’s code for the simplest case, when the C callback takes no arguments and returns nothing.Instantiate the type object with  as usual.  Don’t put it in any module visible to Python, though, because Python code can’t correctly create instances of this type.  (Because of this, I haven’t bothered with a  function; just make sure you always initialize  after creating instances from C, or  will crash.)Now, suppose the actual function you need to call is named , and the Python function that you want to pass it to is named .  First you create one of the callback objects, bycalling the type object, as usual, and initialize its  field:Then you put  into an argument tuple, and call the Python functionobject with that, as usual.Extending this to more complex cases, where the C callback needs to take arguments and/or return values and/or raise Python exceptions on error and/or receive “closure” information from the outer context, is left as an exercise.  
I'd be tempted to use the standard library ctypes module since it already contains appropriate wrappers for C function pointers, and can automatically deal with conversions from Python types to C types for wide variety of arguments.I've written a working example in Cython since it's an easy way of mixing Python and C, but it should show how to use these objects:I define an example function  (in the docstring, which Cython incorporates directly into the compiled file).This is a Cython (pretty close to Python syntax) version of the creation of a ctypes pointer to . I define the arguments of the function, convert the  pointer to an appropriately sized integer, then initialize the wrapper object with that integer.The code above is a C translation of the Pythony code above - it does exactly the same thing but is a bit more convoluted since it uses the C API. It just uses the ctypes module through its Python interface. Once again the C code is embedded in a Cython file through a docstring; however similar code could be used in a directly written C API module.(All these Cython snippets combine to form one long working example)


Answer URL
https://docs.python.org/3/extending/
https://docs.python.org/3/library/ctypes.html
