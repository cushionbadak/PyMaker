Natural Text
There are a couple of ways to construct a dictionary in python, for example:andWhen you benchmark theseyou see that the first method is almost 3x slower than the second. Why is this?
 passes in a ready-made dictionary, so Python can just copy an already existing internal structure.A list of tuples, on the other hand, requires iteration, validation, hashing and slotting the results into a fresh, empty table. That's not nearly as fast.A Python dictionary is implemented as a hash table, and is grown dynamically as keys are added over time; they start small and as the need arises a new, larger hash table is constructed, data (keys, values and hashes) are copied across. That’s all invisible from Python code but resizing takes time. But when you use  (or  CPython (the default Python implementation you used to test with) can take a shortcut: start with a hash table that’s big enough immediately. You can’t do that same trick with a sequence of tuples, because you can’t know up front if there won’t be duplicate keys in the sequence.For more details, see the C source code of the  type, specifically  implementation (which is called from ); this calls either  for the sequence-of-tuples case, or calls  when keyword arguments are passed in.The  function iterates over the sequence, tests each result to make sure there are two elements, then essentially calls  on the dictionary. This may need to resize the dictionary at some point!The  function (via ) specifically detects if a regular dictionary was passed in, then executes a fast path that resizes the internal structures once, and then copies across the hashes and structure from the original dictionary directly using  calls (follow the  path, as  has been set to  when the target dictionary is empty, which is always the case for ). Just resizing once and using internal data directly is a lot faster, far less work needs to be done!All of this is an implementation detail specific to CPython. Other Python implementations such as Jython, IronPython and PyPy can make their own decisions on how the internals of the  type work, and will show different performance differences for the same operations. 
Short answer (TL;DR)This is because in the first test the CPython implementation of  will create a new dict from the list, but the second only copies the dictionary. Copying takes less time than parsing the list. Additional infoConsider this code:Where The dis module supports the analysis of CPython bytecode by  disassembling it.Which lets us see the bytecode operations performed. Output showsFrom the output you can see:Both calls need to load the  name that is going to be called.After that, the first method loads a list to memory () whereas the second builds a dictionary () (see here)For that reason, when the dict function is called (the  step (see here)), it takes much shorter in the second case, because the dictionary has been already created so it simply makes a copy instead of having to iterate over the list to create a hash table.Note: with the bytecode you can't conclusively decide that  does that, since its implementation is written in C and only by reading it you can actually know that (see Martijn Pieters' answer for an accurate explanation on how this part works). However, it helps see how the dictionary object is already created outside  (step-wise, not syntactically-wise in the example), while as for the list, this is not the case.EditTo be clear, when you sayThere are a couple of ways to construct a dictionary in pythonIt is true that by doing:You are creating a dictionary, in the sense that the interpreter transforms an expression into a dictionary object stored in memory, and makes the variable  point to it. However, by doing:  or if you prefer , you are not really creating a dictionary, but just copying an already existing object (and it's important to emphasise copying):  forces Python to create a new object; however, that does not mean it has to re-build the object. In fact, that operation is useless because in practice they are equal objects (though not the same object).Where id:Return the “identity” of an object. This is an integer which is guaranteed to be unique and constant for this object during its lifetime [...]CPython implementation detail: This is the address of the object in memory.Unless, of course, you want to specifically duplicate the object in order to modify one so edits are not linked to the other reference.
dkwargs is already a dictionary so you basically make a copy of it. That is why it is so much faster.


Answer URL
https://docs.python.org/3/library/dis.html#opcode-BUILD_CONST_KEY_MAP
https://docs.python.org/3/library/dis.html#opcode-CALL_FUNCTION
