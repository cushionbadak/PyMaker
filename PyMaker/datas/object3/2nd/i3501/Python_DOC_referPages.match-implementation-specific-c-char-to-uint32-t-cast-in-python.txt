Natural Text
Consider the following C++ program:which printsHow can I replicate the casting behavior in Python? Ie. how can I obtain a numpy array of type uint32_t containing the 3 numbers? 1For examplewill result inwhich is not sufficient. I have also looked into the functionality provided by the ctypes module but could not find a working solution.Motivation: I would like to apply a Fowler–Noll–Vo hash function, which relies on bit-wise operations, matching an existing C++ implementation that operates by casting the elements of a  to .1While output of the C++ version depends on the architecture / compiler, I am looking for an implementation that either matches the behavior described in this question, or the behavior of the C++ program when compiling it with the same compiler as the python interpreter is compiled with on.
The problem here is that your C++ implementation (as many do and as unfortunately allowed - but not mandated - by the standard) has  as a signed type, while Python rightly consider  elements as non-negative values.The correct solution IMO would be as @Scheff shows in his answer - fix the C++ program, which relies on implementation-defined behavior which generates disputable output. OTOH, if you are forced to match an existing C++ program that cannot be altered, you can easily reproduce this behavior in Python.In your C++ program when a byte value beyond 127 (and hence negative) gets converted to , it gets wrapped around 2³², hence all those  values.To obtain the same result in Python you can manually cast to  (i.e.  in your C++ implementation) first:which outputs:
According to Python doc.:The bytearray type is a mutable sequence of integers in the range 0 <= x < 256.IMHO, the conversion in C++ should hence handle the characters as . This can be achieved by a "two-step" cast:Output:Live Demo on coliruNotes:I consider the initialization  as a bit critical. So, this depends on the source code encoding. (I'm on Windows. Using Windows-1252 encoding as it is usual for a lot of Windows applications would break this program as the string would have two elements only. I just realized that Window-1252 doesn't even encode  but this doesn't make it better.)Forcing the characters to , should make the application independent from the signed-ness of the specific  type of the C++ compiler.
The fact that you got  for the first character is implementation dependent and a valid C++ implementation could return also  because the difference depends on the default  type being signed or unsigned (some compilers provide a command line switch to change the behavior so it's not even just platform-dependent, but compile-options dependent).That said you can fix an unsigned character converted to uint32 to the same result of a conversion of a signed one by simply extending the 8th bit or by converting to the corresponding signed value before doing the casting... for example
One way to get a numpy array of uint32 is to pass it through an int8 array first:


Answer URL
https://docs.python.org/3/library/ctypes.html
