Natural Text
We have two arrays of equal length,  and . also, for every :  for some . We want to check if a single swap between some term of  and some term of  will make the sums of the arrays be equal. Consider the following solution:I'd be glad if you could explain the reasoning behind the last  clause.Source of the problem
If there is such a swap, then the difference between the two values must be half that of the difference in the sums. Swapping two values means that the sum of both lists will change, one going up, the other down, by the same amount. The two changes must add up to the difference between the sums before the swap, and both sums change by the same value ( and , or value delta, which is the difference between the two swapped values).First, the function calculates  as a delta between the sums, the sum delta. Note that  could be larger than , at which point the result  is negative. This simply means that there must be a value in  that is smaller than the target value in , a swap then would decrease  and increase  to make them equal. If the parity of the sum delta is odd rather than even, you'll never find a value delta that is half the sum delta so the function returns  at this point. The final value of  is the value delta, the amount of difference between the two swapped values. Remember, the value delta is half the sum delta.The algorithm counts all values in , then tests all values in . It would only be possible to swap two values between  and  if there is a value in  that differs by  from a value in . The value in  to swap with  would need to be equal to . For a negative  () that would make  smaller, for a positive  that would require  to be the bigger number.The  test looks to see if there is a value in  available in , but it first tests if  is still within the range of [0-m]: test if the number sought for in A is still a positive number. tests  if the number sought is still no larger than ; it could be if  was close and  is negative. contains counts for the numbers in ; if  is true, then there is at least one such number in A. This is a number that can be swapped.The range test is needed because the  list only holds counts for the numbers from 0 through to m (inclusive), not for negative numbers or for numbers larger than .The function can be improved by using a set instead of a counting function. There is no need to know how many times a number appears in , just that it exists. This would make boundary checks obsolete, because numbers out of bound are simply not going to be present in a set of the values of .Once we have a set of values of A, we can test if this set is disjoint from the set of b values with the delta applied, using :This returns True if there is a value in  that is equal to a value in  minus the delta. Python will only loop over the  loop until a match is found (at which point the sets are not disjoint, and  inverses that result to True), or the loop has been exhausted and so no such value is found in  and the sets are found to be disjoint.The  function shown has another issue: it requires way more memory than is needed, and it is very slow compared to a  object which has an optimised loop implemented in to do the counting. A  uses a dictionary (hash map) to store counts only for counts greater than 0.The set solution above beats the 'fast solution' hands down:Not using a counter, and using Python's set functionality made that about 17 times faster for inputs of length 1000!The moral of the story: use the best tools available in your language of choice, and think critically about what is actually needed to solve the problem. Python's built-in types and operations often can let you avoid running the critical loops in Python bytecode, significantly reducing the constant-time factors of an algorithm.
This for-loop at the end searches each element of the  array. To be the swapped element at index , it has to satisfy two conditions: must be between  and . You can imagine  as how much  is larger than , so by swapping  with , array  with gain  and array  will lose it, increasing the difference by  must exist in AIt's not good for understanding though to redefine  in the middle of the code :)


Answer URL
https://docs.python.org/3/library/stdtypes.html#frozenset.isdisjoint
https://docs.python.org/3/library/collections.html#collections.Counter
