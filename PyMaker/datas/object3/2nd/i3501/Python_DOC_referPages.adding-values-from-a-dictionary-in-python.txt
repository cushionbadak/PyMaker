Natural Text
For example, the user will enter four colors (duplicates allowed) where . I will assign values to each of these colors.If the user were to enter in , the program works fine and outputs a value of 18. However, if the user entered one duplicate, such as , the program outputs 16, which is not the correct output. How would I make my program able to recognize these duplicates?
You are only testing for each character once. Loop over the input string, and use each character as a key for your dictionary:or, using the  function, and  to return a default colour score of 0 for any unrecognised character:The above passes a generator expression to the  function, which will loop over each result of the expression. So for each  in the string  (each character), the  expression fetches the value for the given key or 0 if the key is missing, and  adds up all those results. 
For each character in , look up its score in the dictionary, and add up those values.
Probably the fastest and more readable solution is with list comprehension:
Because you didn't iterate over each character from the string input:Try this while loop:Or if you look for an smaller code:Or even smaller:sum(iterable[, start]): This function iterate over all the iterable items (e.g: items from a list, tuple, set) and sum their values.dictionary.get(key[, default]): This function return the value of a key in a given dictionary. In the case it doesn't exist that value return a default one (instead of raise an exception).generator expression: The sum function will iterate over the result of the generator expression. So for each letter in the string input, the dictColor.get(letter, 0) expression will look for the value of that key in the dictColor.


Answer URL
https://docs.python.org/3/glossary.html#term-generator-expression
https://docs.python.org/3/library/stdtypes.html#dict.get
https://docs.python.org/3/glossary.html#term-generator-expression
https://docs.python.org/3/library/stdtypes.html
https://docs.python.org/3/glossary.html#term-generator-expression
