Natural Text
I have a bit of code that tries to parse an object as an integer:Here  is a vanilla , and  raises a very generic  if  is not an integer.I would like to transform the error message into something a bit more informative, so I would like to either modify the existing error object, or to reraise it.My current solution is to do this:Is this the proper way to reraise an error? Specifically,Do I need to call  at all? I suspect that it properly decrefs the existing exception object, but I'm not sure.Can I modify the message of the error that has already been thrown at that point without re-raising it?Is there an option to do the equivalent of ?I am not sure how to use  for this situation, although my gut tells me it may be relevant somehow.
Your existing code is fine, but if you want to do the equivalent of exception chaining, you can. If you want to skip to how to do that, jump to point 3 near the end of the answer.To explain how to do things like modify a propagating exception or perform the equivalent of , first, we'll have to explain how exception state works at C level.A propagating exception is represented by a per-thread error indicator consisting of a type, value, and traceback. That sounds a lot like , but it's not the same.  is for exceptions that have been caught by Python-level code, not exceptions that are still propagating.The error indicator may be unnormalized, which basically means that the work of constructing an exception object hasn't been performed, and the value in the error indicator isn't an instance of the exception type. This state exists for efficiency; if the error indicator is cleared by  before normalization is needed, Python gets to skip much of the work of raising an exception. Exception normalization is performed by , with a bit of extra work in  to set the exception object's  attribute. is sort of like the C equivalent of an  block, but it just clears the error indicator, without letting you inspect much of the exception information. To catch an exception and inspect it, you'd want .  is like catching an exception and examining , but it doesn't set  or normalize the exception. It clears the error indicator and gives you the raw contents of the error indicator directly.Explicit exception chaining () works by going through  to set the new exception's  to the existing exception. This requires exception objects for both exceptions, so if you want to do the equivalent from C, you'll have to normalize the exceptions and call  yourself.Implicit exception chaining ( in an  block) works by going through  to set the new exception's  to the existing exception. Similar to , this requires exception objects and exception normalization.  inside an  block actually sets both  and , and if you want to perform explicit exception chaining at C level, you should usually do the same.Technically not necessary, as far as I can tell, but it's probably a good idea to do it anyway. It looks like  and other functions that set the error indicator will clear the error indicator first if it's already set, but this isn't documented for most of them.Sort of, but it's probably a bad idea. You can normalize the error indicator and set the exception object's  attribute, but this won't affect  or anything else the exception class might do with its arguments, and that could lead to weird problems. Alternatively, you could fetch the error indicator with  and restore it with a new string for the value with , but that will throw away an existing exception object if there is one, and it makes assumptions about the exception class's signature.Yeah, that's possible, but doing it through public C API functions is pretty awkward and manual. You'd have to manually do a lot of normalization, unraising, and raising exceptions.There are efforts to make C-level exception chaining more convenient, but so far, the more convenient functions are all considered internal. For example,  is like , but it chains the new exception off of an existing, propagating exception (through both  and .I wouldn't recommend calling it directly for now; it's very new (3.6+), and it's very likely to change (specifically, I would be unsurprised to see it lose its leading underscore in a new Python version). Instead, copying the implementation of / (and respecting the license) is a good way to make sure you have the fiddly bits of normalization and chaining right.It's also a useful reference to work from if you want to perform implicit (-only) exception chaining at C level - just remove the part that handles .


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_AsLong
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_SetExcInfo
https://docs.python.org/3/c-api/exceptions.html#exception-handling
https://docs.python.org/3/library/sys.html#sys.exc_info
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_NormalizeException
https://docs.python.org/3/c-api/exceptions.html#c.PyException_SetTraceback
https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Fetch
https://docs.python.org/3/c-api/exceptions.html#c.PyException_SetCause
https://docs.python.org/3/c-api/exceptions.html#c.PyException_SetContext
https://docs.python.org/3/license.html
