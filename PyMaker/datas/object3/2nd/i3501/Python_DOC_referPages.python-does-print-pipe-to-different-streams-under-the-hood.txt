Natural Text
I encountered a bit weird (to me) behavior upon running the following script.As you can see it seems as though  is called multiple times and I wonder why this is, as I have explicitly overridden the  behavior.How exactly does print pipe streams under the hood, does it pipe to all channels? Does it have some default behavior, the docs are not very specific except for the following:The file argument must be an object with a write(string) method; if it  is not present or None, sys.stdout will be used.Test scriptOutput:What I expected:What I tried:I tried to use  module to get the caller, maybe see who does the actual call to write but I get , idk why :( is this obvious?Further questions:Is there any way to debug a function beyond  and go into the underlying  call? Because well the main  distribution, is , and if my understanding is correct,  is just an  for the underlying  code. A call in  gets translated to a  call under the hood eventually. So for instance I found out that the  is defined as follows in C, but it's tough for me to understand what's going on there (because, erm, I don't know ) but maybe by going with a debugger I could print stuff out, see what is what and figure out maybe at least the flow if not everything. I'd very much like to understand what's going on under the hood in general instead of taking stuff for granted.Thx in advance for your time!
You're looking for something really complicated when the answer is dead simple.I don't even know what "pipe to all channels" would mean, but  does nothing of the sort. All it does is call  on the  object you passed it.However, it calls  once for each argument, once for each , and once for the .So, this line:… is roughly equivalent to:… which of course means you get your extra  message twice.By the way, for debugging or understanding things like this in the future: If you changed the extra  to include, say, , what's happening would have been obvious:The output is then:Not very mysterious anymore, right?And of course  and  are separate streams, with their own buffers. (By default, when talking to a TTY,  is line-buffered, and  is unbuffered.) So the ordering isn't what you'd naively expect, but it makes sense. If you just add in es, the output turns into:(with a blank line at the end).For your bonus questions:I tried to use inspect module to get the caller, maybe see who does the actual call to write but I get module, idk why :( is this obvious?I'm assuming you did something like ? If so, the code you're inspecting is the top-level code in the module, so  shows it as a fake function named .Is there any way to debug a function beyond Python and go into the underlying C call?Sure. Just run CPython itself under lldb, gdb, Microsoft's debugger, or whatever else you usually use for debugging binary programs. You can put breakpoints in the  loop or in a particular C API function or wherever you want. You may want to make a debug build of CPython (do  to see the options) to make this even better.Because well the main Python distribution, is CPython, and if my understanding is correct, Python is just an api for the underlying C code.Well, not quite. It's a compiler and a bytecode interpreter. That bytecode interpreter largely uses the same C API that's exposed for the extending/embedding interface, but the overlap isn't 100%; there are places where it deals with the structures below the C API level.A call in Python gets translated to a C call under the hood eventually. So for instance I found out that the print is defined as follows in C, but it's tough for me to understand what's going on there (because, erm, I don't know C) but maybe by going with a debugger I could print stuff out, see what is what and figure out maybe at least the flow if not everything. I'd very much like to understand what's going on under the hood in general instead of taking stuff for granted.Yes, you can do that, but you will need to understand both C and the CPython API (e.g., things like how to find the C slot equivalent to ) to figure out where to put your breakpoints and start tracing.And for cases like these, it's a lot easier to just write wrappers in Python and debug them in Python. For example:Or, if you're worried about  being called in other modules, not just in yours, you can even shadow it in :Now you can just use  to break on every call to  at the Python level, without worrying about the C.And of course you can even debug this code in PyPy or Jython or whatever to see if it's any different from CPython above the "builtin" level.
You get the result you see because  calls  twice, once in order to print the argument, and again to print the EOL. They are out of order because by default stderr is unbuffered and stdout is line-buffered.


Answer URL
https://docs.python.org/3/library/functions.html#print
