Natural Text
I've recently stumbled upon a weird behavior of the mutable class attributes.Theoretically (and practically), a mutable argument defined on a class level will be shared within all instances until any instance will overwrite the reference.  In our project, we have directory structure similar to below:  common_cache.py:cache_user.py:main.py:Result of running main.py:All ID's are the same as expected which proves, that all instances and classes are sharing common reference to the same dictionary. However, when we add  directory into  and slightly change imports, something weird will happen.  cache_user.py:main.pyResult of running main.py:Now,  (and instances) have their own  dictionary, different from  (and instances). What happened? The only thing that changes is the method how we do imports. If we will put breakpoint in  class we can clearly see, that  is executed twice - once per import. If we would have more than one class that does import of , only the distinct import methods will trigger .  Solving this issue in our project wasn't just unifying import method since the project is too big to do that. Our solution is to create  class that is imported only by , and the real  dict is stored within .  So, why is it happening? I can't find any explanation for this situation.Also, how to deal with that? Is there any better solution than creating a  object?This was tested in Python3.6 on CentOS and Windows.
This suggests that modules are identified by their "import" name rather than the absolute file of the module file. In your case, a module  is found in  while another module  in .When a new module is imported, each statement get executed. Therefore, there are two distinct modules imported (what the Python interpreter think):one  defined in the module one  defined in the module .This assertion also show both  are not refered to the same class.


Answer URL
https://docs.python.org/3/tutorial/modules.html
