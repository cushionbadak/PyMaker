Natural Text
Environment: cooperative RTOS in C and micropython virtual machine is one of the tasks.To make the VM not block the other RTOS tasks, I insert  in  so that after every bytecode is executed, the VM relinquishes control to the next RTOS task.I created a uPy interface to asynchronously obtain data from a physical data bus - could be CAN, SPI, ethernet - using producer-consumer design pattern.Usage in uPy:The implementation in C is such that  does NOT block the RTOS: it polls a C-queue and if message is not received, it calls  to give another task the chance to fill the queue. Things are synchronized because the C-queue is only updated by another RTOS task and RTOS tasks only switch when  is called i.e. cooperativeThe C-implementation is basically:Although the Python statement  does not block the RTOS, it does block the uPy script.I'd like to rewrite it so I can use it with  i.e. coroutine and have it not block the uPy script.Not sure of the syntax but something like this:QUESTIONHow do I write a C-function so I can  on it?I would prefer a CPython and micropython answer but I would accept a CPython-only answer.
Note: this answer covers CPython and the asyncio framework. The concepts, however, should apply to other Python implementations as well as other async frameworks.How do I write a C-function so I can  on it?The simplest way to write a C function whose result can be awaited is by having it return an already made awaitable object, such as an . Before returning the , the code must arrange for the future's result to be set by some asynchronous mechanism. All of these coroutine-based approaches assume that your program is running under some event loop that knows how to schedule the coroutines.But returning a future isn't always enough - maybe we'd like to define an object with an arbitrary number of suspension points. Returning a future suspends only once (if the returned future is not complete), resumes once the future is completed, and that's it. An awaitable object equivalent to an  that contains more than one  cannot be implemented by returning a future, it has to implement a protocol that coroutines normally implement. This is somewhat like an iterator implementing a custom  and be used instead of a generator.Defining a custom awaitableTo define our own awaitable type, we can turn to PEP 492, which specifies exactly which objects can be passed to . Other than Python functions defined with , user-defined types can make objects awaitable by defining the  special method, which Python/C maps to the  part of the  struct.What this means is that in Python/C, you must do the following:specify a non-NULL value for the  field of your extension type.have its  member point to a C function that accepts an instance of your type and returns an instance of another extension type that implements the iterator protocol, i.e. defines  (trivially defined as ) and .the iterator's  must advance the coroutine's state machine. Each non-exceptional return from  corresponds to a suspension, and the final  exception signifies the final return from the coroutine. The return value is stored in the  property of .For the coroutine to be useful, it must also be able to communicate with the event loop that drives it, so that it can specify when it is to be resumed after it has suspended. Most of coroutines defined by asyncio expect to be running under the asyncio event loop, and internally use  (and/or accept an explicit  argument) to obtain its services.Example coroutineTo illustrate what the Python/C code needs to implement, let's consider simple coroutine expressed as a Python , such as this equivalent of : creates a , arranges for it to complete (its result to become set) in n seconds, and suspends itself until the future completes. The last part uses , where  means "allow  to decide whether we will now suspend or keep executing". An incomplete future always decides to suspend, and the asyncio  coroutine driver special-cases yielded futures to suspend them indefinitely and connects their completion to resuming the task. Suspension mechanisms of other event loops (curio etc) can differ in details, but the underlying idea is the same:  is an optional suspension of execution. that returns a generatorTo translate this to C, we have to get rid of the magic  function definition, as well as of the  suspension point. Removing the  is fairly simple: the equivalent ordinary function simply needs to return an object that implements :The  method of the  object returned by  will be automatically called by the  operator to convert an awaitable object (anything passed to ) to an iterator. This iterator will be used to ask the awaited object whether it chooses to suspend or to provide a value. This is much like how the  statement calls  to convert the iterable  to a concrete iterator.When the returned iterator chooses to suspend, it simply needs to produce a value. The meaning of the value, if any, will be interpreted by the coroutine driver, typically part of an event loop. When the iterator chooses to stop executing and return from , it needs to stop iterating. Using a generator as a convenience iterator implementation,  would look like this:As  maps to , our generator must exhaust the iterator returned by . The iterator returned by  will yield if the future is incomplete, and return the future's result (which we here ignore, but  actually provides) otherwise. that returns a custom iteratorThe final obstacle for a C implementation of  in C is the use of generator for . Fortunately, any generator can be translated to a stateful iterator whose  executes the piece of code up to the next await or return.  implements a state machine version of the generator code, where  is expressed by returning a value, and  by raising .  For example:Translation to CThe above is quite some typing, but it works, and only uses constructs that can be defined with native Python/C functions.Actually translating the two classes to C quite straightforward, but beyond the scope of this answer.


Answer URL
https://docs.python.org/3/library/asyncio-task.html
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/c-api/typeobj.html#c.tp_as_async
https://docs.python.org/3/c-api/typeobj.html#c.PyAsyncMethods.am_await
https://docs.python.org/3/c-api/iter.html#iterator-protocol
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iter
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
