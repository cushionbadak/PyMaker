Natural Text
Is it possible to implement custom automatic/implicit conversion (aka coercion) in Python 3.6+ that won't make  and other static analyzers sad? An example would be a , and given , is there a way I could potentially write  (where  ) instead of ? I think there are definitely some good ways to do this in the dynamics of Python (tacking on members to classes that include converters, for instance), or even tacking on such converters to the function object itself so that it can handle conversion for selected types, but my current understanding of Python types makes me thing it would not satisfy  and the like.For comparison, see Scala's implicit conversions.
Here's an implementation of this feature I came up with.  We keep a dictionary of single-dispatch converters for types we know the "implicit" conversions for.  We add converters to this using the  decorator.We then have a  decorator that can inspect the function annotations at runtime, get the appropriate converters and apply the conversions.  Below is the framework: And an example:
It sounds like you may be looking for something like the Protocol types proposed in PEP 544. That PEP isn't approved yet (and may not have a complete implementation yet either), so it may be a while before you get the feature you need (Python 3.8 at the earliest).Anyway, according to the PEP, Protocols would let you describe a kind of abstract type based on what methods and attributes it has, without the concrete types needing to know about the Protocol or do anything in particular (it doesn't need to inherit from an abstract base class, just have the required methods). It's similar to how you can customize how  and  work using metaclasses, but it works with static type checking, not only at runtime.For instance, iterators in Python are an existing protocol that many unrelated classes implement. If the PEP is approved and implemented, you won't need to declare a custom iterator type as inheriting from  any more, it would figure it out automatically, just because the class has  and  methods.In your example, you could make an  protocol that requires a  method:Then you'd implement  with a simple , while  does the appropriate conversion. Both classes will be seen as matching the  protocol type, so  would satisfy type checkers (with the body of the class needing to do  before calling any  specific methods).You can do this now with inheritance from a common abstract base class (which can be a simple mixin), but it's definitely not as elegant as it will be with Protocols. Another option if you don't have many classes you need to convert is to just use  types declarations: 
I don't think this is a conversion problem. But it looks like a annotation problem.First, if  can only handle , how could it accept ? And if  can handle  too, why it should only accpet ?Second, if you want to annotate that  accept  or , you can use .Finally, if you mean  should have some methods that make it can be handled by function which can only handle . It is still an instance of . Without right annotation, your static analyzers will still warn you.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/abc.html#abc.ABCMeta.__subclasshook__
