Natural Text
I am curious what the fastest way to consume an iterator would be, and the most Pythonic way.For example, say that I want to create an iterator with the  builtin that accumulates something as a side-effect. I don't actually care about the result of the , just the side effect, so I want to blow through the iteration with as little overhead or boilerplate as possible. Something like:In this example, I just want to blow through the iterator to accumulate things in , and  is just an empty set until I actually run through . Something like:or a nakedworks, but they both feel clunky. Is there a more Pythonic way to make sure an iterator iterates quickly so that you can benefit from some side-effect?BenchmarkI tested the two methods above on the following:with  and  as defined above. I got the following results with timeit:No real difference between the two, and they both feel clunky.Note, I got similar performance with , which was a suggestion in the comments.
While you shouldn't be creating a map object just for side effects, there is in fact a standard recipe for consuming iterators in the  docs:For just the "consume entirely" case, this can be simplified toUsing  this way avoids storing all the elements (because ) and iterates at C speed, without bytecode interpretation overhead. There's even a dedicated fast path in the deque implementation for using a  deque to consume an iterator.Timing:Of course, this is all based on CPython. The entire nature of interpreter overhead is very different on other Python implementations, and the  fast path is specific to CPython. See abarnert's answer for other Python implementations.
If you only care about CPython,  is the fastest way, as demonstrated in user2357112's answer.1 And the same thing has been demonstrated in 2.7 and 3.2, and 32- vs. 64-bit, and Windows vs. Linux, and so on.But that relies on an optimization in CPython's C implementation of . Other implementations may have no such optimization, which means they end up calling an  for each element.In PyPy in particular, there is no such optimization in the source,2 and the JIT cannot optimize that no-op  out. (And it's hard to see how it couldn't require at least a guard test each time through the loop.) Of course compared to the cost of looping in Python… right? But looping in Python is blazing fast in PyPy, almost as fast as a C loop in CPython, so this actually makes a huge difference.Comparing the times (using identical tests as in user's answer:3There's no 3.x versions of the other major interpreters, and I don't have IPython for any of them, but a quick test with Jython shows similar effects.So, the fastest portable implementation is something like:This of course gives me 12.7us in CPython, and 1.41us in PyPy.1. Of course you could write a custom C extension, but it's only going to be faster by a tiny constant term—you can avoid the constructor call and the test before jumping to the fast path, but once you get into that loop, you have to do exactly what it's doing.2. Tracing through PyPy source is always fun… but I think it ends up in the  class that's, which is part of the builtin  module.3. CPython 3.6.4; PyPy 5.10.1/3.5.3; both from the respective standard 64-bit macOS installers.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
