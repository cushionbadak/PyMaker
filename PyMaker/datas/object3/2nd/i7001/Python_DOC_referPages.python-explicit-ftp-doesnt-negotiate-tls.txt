Natural Text
I'm trying to transfer a file to a host over FTP TLS explicit, but don't know how to handle the certificate.  A WinSCP log of the transaction shows that the TLS negotiation is handled and the certificate is verified.  But my Python script fails to do this.  I know the certificate fingerprint and the cipher, but don't know how to implement it.My script:Here is my output, the last line is the Python error:
A WinSCP log of the transaction shows that the TLS negotiation is handled and the certificate is verified. But my Python script fails to do this. I know the certificate fingerprint and the cipher, but don't know how to implement it.Your Python script does not fail in the TLS negotiation as you assume.An upgrade from a plain connection to TLS is requested by the client with the  command which is accepted by the server which can be seen in the log:After that the TLS negotiation (i.e. TLS handshake) is done. If the handshake would fail the client would abort. But the handshake succeeds so that the client can continue with more command which also get accepted by the server:Thus, there is no problem in the TLS negotiation. It is also not a problem with the data transfer itself which can be seen in that the client succeeds in transferring data from the server, i.e. the directory listing:It only fails when transferring a file to the server because the server does not reply within the expected time:It is unclear why the server fails to respond. One possible reason might be that the file needs to be processed by some application (like an antivirus) before the server will respond with success and that this processing takes too long.
The issue turned out to be with the unwrapping of the socket after the file is transmitted.  More specifically, the shutdown() method appears to wait for the server to see if it's okay to close the socket.  In this case the server doesn't answer.  The file does indeed get transmitted, but the socket issue throws an error before a "File transfer complete" response can be received.It seems to go like this (sending file to server):1. Establish FTP TLS2. Client issues STOR command3. A secure socket is created4. The file is transferred5. The socket is unwrapped and disposed of.6. The "transfer complete" response is received from the server.But an issue with step 5 prevents 6 from happening.I'm not sure if this is a bug or not.  A little bit of research shows that sockets can be closed instead of shutdown and that servers may not respond to socket shutdown requests.My solution was to modify my local python libraries to deal with it.
Comment: results in an error: "[SSL: CERTIFICATE_VERIFY_FAILED]"  ssl.create_default_context(purpose=Purpose.SERVER_AUTH,  cafile=None, capath=None, cadata=None)  Return a new SSLContext object with default settings for the given purpose.  cafile, capath, cadata represent optional CA certificates to trust for certificate verification, as in SSLContext.load_verify_locations(). If all three are None, this function can choose to trust the system’s default CA certificates instead.Use as follows:Question: don't know how to handle the certificateUse ,you already have a .class ftplib.FTP_TLS(host=”, user=”, passwd=”, acct=”, keyfile=None, certfile=None, context=None, timeout=None, source_address=None) A FTP subclass which adds TLS support to FTP as described in RFC 4217. is a ssl.SSLContext object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. and  are a legacy alternative to context – they can point to PEM-formatted private key and certificate chain files (respectively) for the SSL connection.Deprecated since version 3.6:keyfile and certfile are deprecated in favor of . Please use ssl.SSLContext.load_cert_chain() instead, or let ssl.create_default_context() select the system’s trusted CA certificates for you.


Answer URL
https://docs.python.org/3/library/ssl.html#ssl.create_default_context
https://docs.python.org/3/library/ftplib.html#ftplib.FTP_TLS
https://docs.python.org/3/library/ssl.html#ssl.SSLContext.load_cert_chain
