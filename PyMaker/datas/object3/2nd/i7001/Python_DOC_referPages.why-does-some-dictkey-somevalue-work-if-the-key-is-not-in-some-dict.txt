Natural Text
I know that I can add a new key/value in a python dict by doing But I don't really understand the internals work.I used to think dictionaries behaved like C++ maps. Where the  operator would create the element for the given key if it does not already exist, then return a reference to it so that it can be assigned a value in the same line with operator .But that behavior in C++ has the consequence that if we query from a map the value for a key that does not exist, then the element is created for that key, and the default value for the value type will be returned instead of an error. In python, this throws a .So what I don't understand is: How, since  operator must be evaluated before  in python too (I think?), does it behave differently depending if the result will be read or assigned a value (which it should not know about at that point of the expression evaluation)?Is there a difference in the order in which python evaluates expressions? Or is the interpreter simply smarter since dictionaries hare a hardcoded type so it knows more precisely how it behaves, while std::map are in a 'library' so the compiler can assume less? Or some other reason?
The operations:and and use different special methods of the object: ,  and . So it's not just one operator () that implements them all.Maybe an example can illustrate that:Test:So it depends on how they are implemented. In plain Python s  just returns the value for the key or throws if it's not present. But subclasses could also implement the  method - in case they want to customize the behavior if the key wasn't present in the dict (during lookup).
What's going on behind the scenes?In Python, When you assign a value to a key:Python translates the above syntactic sugar into:As you can see, behind the scenes Python calls the  method. The  method corresponds directly to the operation of indexing a data structure and assigning a new value to said index. It can be overloaded to  customize it's behavior.The default behavior with  for Python dictionaries is to change the key's value if it exists, and if not raise a . To prove this, you can subclass the  class and overload  to display it's arguments:Does Python have an std::map equivalent?Like @MSeifert said, you can customize what happens when a key is not present by overloading the  method.That is what the  class does in the standard library. It overloads  to create a missing  and map a default value of your choice to it. Here's the relevant snippet from the CPython source:Note that  is implemented in C. Here's an example of the usage: pretty much matches the  behavior of the std::map::operator[]. If a key is not present when using std::map::operator[], the operator calls a "factory function" that matches the key's value's expected types, and assigns that to the missing key.So if you want something that behaves like std::map, use . Note I said "like", though. That's because C++ and Python are two complete different languages. Saying a data structure in one language has an exact equivalent in another is very rarely correct.
The  notation is just sugar for:That function does all the work of storing the data. It can be implemented, however, you want. The underlying mechanism python interpreters and libraries use is most often from a faster compiled language like C.There are more functions like this like, , , and  which handle all the other dict like operations.


Answer URL
https://docs.python.org/3/library/collections.html?highlight=collections#collections.defaultdict
