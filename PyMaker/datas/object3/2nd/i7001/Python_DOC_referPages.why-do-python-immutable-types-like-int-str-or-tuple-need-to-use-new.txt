Natural Text
This question is related to, but not a duplicate of, this, this, this, and this. Those links don't answer my question here. This though, almost answers my questions but doesn't, because the code in the answer doesn't run in Python 3.6 and in any case the question there isn't specifically about what I'm asking here. (See my own answer below.From the Python documentation page, I find the following text. is intended mainly to allow subclasses of immutable types (like int, str, or tuple) to customize instance creation. It is also  commonly overridden in custom metaclasses in order to customize class  creation.But why? Why can't we just override  instead of having to override ? Apparently, , for example, doesn't even implement ; why is that? I understand from here that in some rare cases,  and  are required to do different things, but as far as I can see that's only during pickling and unpickling. What is it about immutable types in particular that requires the use of  instead of ?
I'm the question OP and I'm going to answer my own question because I think I found out the answer half-way through typing it. I'm not going to mark it as correct until others have confirmed it to be correct.This question here is particularly relevant, but the question wasn't the same as this question, and although the answer was very enlightening (though the comments turned into enlightening but esoteric arguments about C and Python and "pythonic"), it should be set out more clearly here to specifically address this question. I hope this will help future readers. The code in this answer has been verified in Python 3.6.1.The thing about an immutable object, is that you don't want to set its members once it's been created, obviously. The way you do that in Python is to override the  special method to  an error (), so that people can't do things like . Take the following custom immutable class for example.Let's try using it.Output:"But what!?", I hear you ask, "I didn't set any of its attributes after it's been created!" Ah but yes you did, in the . Since  is called after the object is created, the lines  and  are setting the attributes  and  after the creation of . What you really want is to set the attributes  and  before the immutable object is created. An obvious way to do that is to create a mutable type first (whose attributes you are allowed to set in ), and then make the immutable type a subclass of it, and make sure you implement the  method of the immutable child class to construct a mutable version first, and then make it immutable, like the following.Now let's try running it.Output:"WTF!? When did  get called this time?" The thing is,  is a subclass of , and without explicitly implementing its , the parent class's  is automatically called after the creation of the  object, so in total the parent's  is called twice, once before the creation of  (which is OK) and once after (which is not OK). So let's try again, this time overriding .Now it should work.Output:Good, it worked. Oh, don't worry about the , that's just a PyCharm hack to stop PyCharm from complaining that I didn't call the parent's , which obviously is what we intend here. And finally just to check that  really is immutable, verify that  will give you .


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
