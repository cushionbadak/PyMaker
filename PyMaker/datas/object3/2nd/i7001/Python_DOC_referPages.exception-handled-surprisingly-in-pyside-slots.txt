Natural Text
Problem: When exceptions are raised in slots, invoked by signals, they do not seem to propagate as usual through Pythons call stack. In the example code below invoking:: Will handle the exception as expected.: Will print the exception and then unexpectedly print the success message from the  block.Question: What is the reason behind the exception being handled surprisingly when raised in a slot? Is it some implementation detail/limitation of the PySide Qt wrapping of signals/slots? Is there something to read about in the docs?PS: I initially came across that topic when I got surprising results upon using try/except/else/finally when implementing a  virtual methods  and .
As you've already noted in your question, the real issue here is the treatment of unhandled exceptions raised in python code executed from C++. So this is not only about signals: it also affects reimplemented virtual methods as well.In PySide, PyQt4, and all PyQt5 versions up to 5.5, the default behaviour is to automatically catch the error on the C++ side and dump a traceback to stderr. Normally, a python script would also automatically terminate after this. But that is not what happens here. Instead, the PySide/PyQt script just carries on regardless, and many people quite rightly regard this as a bug (or at least a misfeature). In PyQt-5.5, this behaviour has now been changed so that  is also called on the C++ side, and the program will abort like a normal python script would. (I don't know what the current situation is with PySide2, though).So - what should be done about all this? The best solution for all versions of PySide and PyQt is to install an exception hook - because it will always take precedence over the default behaviour (whatever that may be). Any unhandled exception raised by a signal, virtual method or other python code will firstly invoke , allowing you to fully customise the behaviour in whatever way you like.In your example script, this could simply mean adding something like this:and now the exception raised by  can be handled in the same way as all other unhandled exceptions.Of course, this does imply that best practice for most PySide/PyQt applications is to use largely centralised exception handling. This often includes showing some kind of crash-dialog where the user can report unexpected errors.
According to the Qt5 docs you need to handle exceptions within the slot being invoked.Throwing an exception from a slot invoked by Qt's signal-slot connection mechanism is considered undefined behaviour, unless it is handled within the slotIf the slot was invoked directly, like a regular function call,  exceptions may be used. This is because the connection mechanism is  bypassed when invoking slots directlyIn the first case you call  directly, so this is fine. In the second case you are invoking it via the  signal, so the exception will only propagate up to the point where  is called. You need to place the  inside  for the exception to be handled correctly.
Thanks for answering guys. I found ekhumoros answer particularly useful to understand where the exceptions are handled and because of the idea to utilize .I mocked up a quick solution via context manager to temporarily extend the current  to record any exception in the realm of "C++ calling Python" (as it seems to happen when slots are invoked by signals or virtual methods) and possibly re-raise upon exiting the context to achieve expected control flow in try/except/else/finally blocks.The context manager allows  to maintain the same control flow as  with the surrounding try/except/else/finally block.


Answer URL
https://docs.python.org/3/library/sys.html?#sys.excepthook
