Natural Text
I am working on a genetic algorithm, and I found a code that works, and now I am trying to understand, but I saw this return statement:What does it do?Here is the full code:main.py:population.py:This is the full code of an working genetic algorithm. I modified some parts to make it more readable for me.The return statement is in the population.py file, in the get_fitness function.
Let's break that down:could be written as: makes a list of pairs of items from  and , like:yields . So the  expression returns a list of the first item from  and the first item of , then the second item from  and the second from , and so on.The  bit unpacks the pairs of values from the output of , so the first of the pair (from ) goes to the variable , and the second of the pair (from ) goes to the variable .The  bit says "emit a value of 1 for every item from  if the value in  equals the value in . adds up the number of  values from the for loop.Ta-da! Now you have the count of items where the expected and actual values are the same. There are a couple of reasons to write it this way:It's very terse but expressive. People who write a lot of Python can glance at that and understand it.It's potentially very fast, as the Python interpreter is handling the looping, conditionals, etc. and improvements to the Python interpreter could make the code faster without it having to understand the whole program. Basically you're telling Python "I want this thing done" instead of "here are 100 little steps to do this thing".
I think it returns the total number of matches where actual= expected. Essentially I think it is checking how many times the algorithms model was able to correctly predict 
It is a type of List Comprehension that makes use of the zip() function.Basically, the code is saying:Create a list.   Retrieve variables "expected" and "actual" from zip(target, guess). If they are equal, add 1 to the list. Repeat for next values from zip(target, guess). Sum all the 1's. Return this summation.
There are several things going on:this means that you are returning a number.The inner part of the  is a  which creates and runs an implicit loop.In this case,  creates a sequence of  values, with one entry created each time the guard condition is true (). So this line is effectively creating code like: Within the generator expression, you have a  call. The zip expression will take the two (or more!) sequences, and convert them into a single sequence with tuples of two (or more!) values. That is,  will produce as its output a sequence like .So if your  is  and your  is , you will get a zip result like:The generator expression contains a  which uses what was once called "tuple unpacking" to assign multiple targets in its  from a single aggregate (tuple) value.So when the zip expression produces  the  unpacks that into .Thus, the  takes two equal-length sequences and pairs their corresponding elements: a[0] with b[0], a[1] with b[1], etc. The  generator expression assigns those elements into variables called  and . The  generator conditional part compares the  values, and either generates a value or does not generate a value. Thus, the length of the resulting sequence is guaranteed to be less than or equal to the length of the input sequences, but you don't know how long it will be. The expression part of the generator is simply . So you have a variable-length sequence of 1's. It's not 1 or 0. It's 1 or no-entry. Add up all the 1's, and that's the result.


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/reference/simple_stmts.html#assignment-statements
