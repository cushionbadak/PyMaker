Natural Text
Python 3.6I'm trying to modify the behavior of a third party library.I don't want to directly change the source code.Considering this code below:I'd like to substitute my own class for  I'd like to know if using a metaclass in my module to intercept the creation of  is a valid idea?EDITThis answer posted by Ashwini Chaudhary on the same question, may be of use to others. As well as the below answer.P.S. I also discovered that 'module' level  does't work in python 3. So my initial question of it 'being a valid idea' is False
FWIW, here's some code that illustrates Rawing's idea.outputWe can even use this technique if  needs to inherit . If we change the definition of  to:we get this output:This works because the name  has its old definition when the  class definition is executed. 
This is not a job for metaclasses.  Rather, Python allows you to do this through a technique called "Monkeypatching", in which you, at run time, substitute one object for another in run time. In this case, you'd be changing the  for  before calling The way to do that is a simple assignment. So, supposing the example snippet you gave on the question is the trirdyparty module, on the library, your code would look like:Things you have to take care of: that you change the object pointed by   in the way it is used in your target module.If for example, your PretendedClassDef and UselessObject are defined in different modules, you have to procees in one way if UselessObject is imported with  (in this case the example above is fine), and  and later uses it as  - in this second case, you have to patch it on the  module. Also, Python's  has a nice  callable that can properly perform a monkeypatching and undo it if by some reason you want the modification to be valid in a limited scope, like inside a function of yours, or inside a  block.  That might be the case if you don't want to change the behavior of the thirdyparty module in other sections of your program.As for metaclasses, they only would be of any use if you would need to change the metaclass of a class you'd be replacing in this way - and them they only could have any use if you'd like to insert behavior in classes that inherit from . In that case it would be used to create the local  and you'd still perform as above, but taking care that you'd perform the monkeypatching before  Python would run the class body of any of the derived classes of , taking extreme care when doing any imports from the thirdparty library (that would be tricky if these subclasses were defined on the same file)
This is just building on PM 2Ring's and jsbueno's answers with more contexts:If you happen to be creating a library for others to use as a third-party library (rather than you using the third-party library), and if you need CoolObject to inherit UselessObject to avoid repetition, the following may be useful to avoid an infinite recursion error that you might get in some circumstances:module1.pymodule2.pyJust be careful that the user knows not to set a different value for parent_class with different subclasses of Actor. I mean, if you make multiple kinds of Actors, you'll only want to set parent_class once, unless you want it to change for all of them.


Answer URL
https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch
