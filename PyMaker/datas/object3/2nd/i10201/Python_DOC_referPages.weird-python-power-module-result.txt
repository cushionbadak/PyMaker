Natural Text
This question already has an answer here:Difference between the built-in pow() and math.pow() for floats, in Python?                    3 answers                According to these answers there is not difference between  and . However,  returns a float value. Now, when running the following python code something strange happens:These statements should give the same value but don't. Any clue as to why this happens?
The  type looses precision. They are represented by the nearest binary fraction and from the docs Floating Point Arithmetic: Issues and LimitationsInterestingly, there are many different decimal numbers that share the  same nearest approximate binary fraction.You can see the problem clearly with the result of  where multiple integers map to the same float.Since python can handle very large integers, try to stay away from floats!
As you say  returns a float value and  does not.  Calling the modulo operator on a float will round it to an integer. Rounding floating point to integer will cause loss of precision.
 converts its arguments to :but the built-in  does not:Also check: Difference between the built-in pow() and math.pow() for floats, in Python?


Answer URL
https://docs.python.org/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations
