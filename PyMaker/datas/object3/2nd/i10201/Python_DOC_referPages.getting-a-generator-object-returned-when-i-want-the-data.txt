Natural Text
I am very very new to Python 3, so please be nice.I have looked at all the documentation I could find regarding this - there does seem to be a lot, it's just I still cannot figure out what to do.This is my code:It is running without any errors but I am getting a return of:How do I make it so that it gives me the value/answer?I am really not sure what is going on.
Wrapping an  construct in parentheses makes it a lazy generator expression, which has the appearance you see. Now, the reason it does this instead of giving you an error that you would get from trying to send a non-iterable to  is because it doesn't evaluate anything. If you sent this generator expression to  to evaluate it, you would get an error.You need to move some parentheses around:Now you have  rather than .Small test:
The first problem is that you have your parentheses in the wrong places. You want to call  on a generator expression, but instead you have written a generator expression using . So you might try this:(I have also taken out your  calls, since squaring a number will make it positive, making  irrelevant, and deleted some unnecessary parentheses.)But this still doesn't work: now you get .This is because you are trying to unpack four values from each element of the list, but each element contains only two. Python unpacks each element to two floats, then tries to unpack each float to two variables. This is where the error message rears its ugly head.So you need to change  to return a list of a list of lists of lists. That is, each item in the list is a list, which contains two lists, each containing the coordinates of a point (a given point and its successor). One way to do this is to use the built-in  function with an offset or rotated copy of the list.Finally, you don't really need the separate function â€”it can go right in the  function. And you should pass  into .You could do this without the extra copy of the list by iterating over the coordinates in  and keeping track of the last items you saw. But you couldn't write it as a generator expression. Instead you'd use a regular  loop.Not quite as succinct, and not as fast either, but doesn't use as much memory.
Your code has two problems. One is due to parentheses as @TigerhawkT3 pointed out, and the other is you're not iterating through the points properly. The code below addresses both these issues.Also note that you could simplify (and speed up) the calculation you're doing by using the built-in  function:
I would try something a bit more explicit like this, this matches your expected answer
I am also a little confused about your question, it seems that you are not intentionally using the generator and just wants to get the perimeter?I think it would be better to clean up the function  a little bit and not use a generator there, and simply iterate through the list  and taking every adjacent pair and calculate it this way.I used a generator function for  function, but you can also do it with a loop or some other way. It basically just returns a new pair in the list every time you call it.


Answer URL
https://docs.python.org/3/library/math.html#math.hypot
