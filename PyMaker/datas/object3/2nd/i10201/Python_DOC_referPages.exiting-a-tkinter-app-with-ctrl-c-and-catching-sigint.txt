Natural Text
Ctrl-C/SIGTERM/SIGINT seem to be ignored by tkinter. Normally it can be captured again with a callback. This doesn't seem to be working, so I thought I'd run tkinter in another thread since its mainloop() is an infinite loop and blocks. I actually also want to do this to read from stdin in a separate thread. Even after this, Ctrl-C is still not processed until I close the window. Here's my MWE:Results:Run the appCtrl-C in the terminal (nothing happens)Close the window"Exiting..." is printed and I get an error about the loop already having exited.What's going on here and how can I make Ctrl-C from the terminal close the app?Update: Adding a poll, as suggested, works in the main thread but does not help when started in another thread...
Since your tkinter app is running in another thread, you do not need to set up the signal handler in the main thread and just use the following code block after the  statement:You can then use Ctrl-C to raise the  exception to close the tkinter app and break the while loop.  The while loop will also be terminated if you close your tkinter app.Note that the above code is working only in Python 2 (as you use  in your code).
Proper CTRL-C & SIGINT Usage in PythonThe problem is that you are exiting the main thread, so the signal handler is  basically useless.  You need to keep it running, in a while loop, or my personal preference, Events from threading module.  You can also just catch the  exception generated by the CTRL-C event, rather than dealing with signal handlers.SIGINT in TkinterUsing tkinter, you must have the tkinter app run in a separate thread, so that it doesn't interfere with the signal handler or  exception.  In the handler, to exit, you need to destroy then update tkinter root.  Update allows the tkinter to update so that it closes, without waiting for mainloop.  Otherwise, user has to click on the active window to activate mainloop.Note: SIGINTs can also be caught if you set handler in same thread as tkinter mainloop, but you need to make tkinter window active after the signal so that it's mainloop can run.  There is no way around this unless you run in new thread.More Information on Tkinter & Command Line CommunicationFor more on communicating between tkinter and the command line, see Using Tkinter Without Mainloop.  Basically, you can use update method in your loop, and then communicate with other threads and processes, etc.  I would personally NOT recommend this, as you are essentially doing the job of the python thread control system, which is probably opposite of what you want to do. (python has a process that runs all internal threads in one external thread, so you are not taking advantage of multitheading, unless using multiprocessing module)


Answer URL
https://docs.python.org/3/library/threading.html#event-objects
https://docs.python.org/3/library/threading.html
https://docs.python.org/3/library/multiprocessing.html
