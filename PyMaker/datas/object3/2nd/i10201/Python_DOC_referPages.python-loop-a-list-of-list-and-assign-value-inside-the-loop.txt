Natural Text
I have the following code, why the first one doesn't change  while the second changes it?
This is a somewhat unintuitive behavor of variables. It happens because, in Python, variables are always references to values.Boxes and tagsIn some languages, we tend to think about variables as "boxes" where we put values; in Python, however, they are references, and behave more like tags or "nicknames" to values. So, when you attribute 1 to , you are changing only the variable reference, not the list it is pointing to.A graphic representation can help. The image below represents the list created by Given that, let's see what happens when we execute your first loop.The first loopWhen you execute , you are asking the interpreter to take each value from the list, one per time, put it on the variable  and do some operation in it. In the first operation, for example, we have this new schema:Note that we do not copy the sublist to ; instead, we point to it through . Then, we execute  — but what does it mean? It mean that we are making  point to the value , instead of pointing to the sublist:Note that the old reference is lost (it is the red arrow) and now we have a new. But we just changed a variable pointing to a list — we did not alter the list itself.Then, we enter to the second iteration of the loop, and now  points to the second sublist:When we execute , again, we just make the variable point to aonther value, without changing the list:Now, what happens when we execute the second loop?The second loopThe second loop starts as the first one: we make  refer to the first sublist:The first difference, however, is that we call .  is a method, so it can change the value of the object it is calling. As we use to say, we are sending a message to the object pointed by  to append the value 10. In this case, the operation is not being made in the variable , but directly in the object it refers! So here is the result of calling :However, we do not only append a value to the list! We also assign the value returned by . This will sever the  reference to the sublist, but here is a catch:  returns .The  value is a value that represents, basically, the unavailability of a relevant value. When a function returns , it is saying, most of the time, "I have nothing relevant to give you back."  does change its list directly, so there is nothing it needs to return.It is important because you probably believed  would point to the appended list , right? No, now it points to . So, you would expect the code below...To print something like this:But this does not happen. This is what happens:Yet, as we commented, the  method changed the lists themselves. So, while the  variable was useless after the assignment, the final list is modified!If you want to use the appended list inside the loop, just do not assign the method returned value to . Do this:This works because  will still point to the list.ConclusionReferences are somewhat complex to understand at first, let alone master. Yet, they are really powerful and can be learned if you follow examples etc. Your example is a bit complicated because there is more happening here.The Python Tutor can help you understand what is going on, because it executes each step graphically. Check your own code running there!
In the first example  is bound to each element in list , and then  is rebound to the integer . This does not change the element of the list - it merely rebinds the name  to the  object .In the second example the list element (itself a list) is mutated by .  is still bound to the sub-list so  mutates the sub-list.
Are you forgetting that  does not return the list itself but actually modifies the list in place? does as expected. For the rest of the for-loop, item is now , and not the list it originally was. It won't reassign what  is, that's not what for-loops do.However, in your second loop, you're now assigning , because the append function does not return anything but it appends the item to the list in place:Thus, your code is basically saying "go through each sublist in my main list and append  to it".
The  operator does not make any change in the second code, using  causes changes in . Use following line as the third line in the second code. You will see the same result:In the first code  point to another object by , so  does not change. In the second code you make change on  by calling  method of it.
It's pointer variable in python.The first example:each item is pointing to each _item in alist but suddenly you change the item value, not the of the value of the _item in alist, as a result nothing change to alistThe second example: each item is pointing to each _item in alist and then you append something to the item sharing the same memory location of _item, as a result value of _item in alist are changed and alist is changed too.
Referencing the document: The for-loop makes assignments to the variables(s) in the target list.  This overwrites all previous assignments to those variables including  those made in the suite of the for-loop:So your second example is identical to:That is to say,  is a new variable in every iteration. As a result, assigning values to it in any specific iteration is pointless, because its value will be overridden by the reference to the next item in  at the very beginning of the next iteration.
When you writeYou are actually creating a copy of each item in  in the  variable, and you are not getting a reference to .However,  changes the list in-place and doesn't return a value, and that's why you're getting the values changed to  (due to the assignment - if you remove it you'll get the appending working fine).


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
