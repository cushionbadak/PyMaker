Natural Text
Note: while the accepted answer achieves the result I wanted, and @ecatmur answer provides a more comprehensive option, I feel it's very important to emphasize that my use case is a bad idea in the first place. This is explained very well in @Jason Orendorff answer below.Note: this question is not a duplicate of the question about . It has nothing to do with ; even in python 2 where  is available, it does NOT represent largest integer (see the accepted answer).I need to create an integer that's larger than any other integer, meaning an  object which returns  when compared to any other  object using . Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.In python 2, I can use  (edit: I was wrong). In python 3,  is the closest equivalent, but I can't convert it to .
Since python integers are unbounded, you have to do this with a custom class:Here I've used a mix-in class  rather than direct decoration of , because on Python 3 the action of  would have been prevented by existing ordering methods inherited from .  Usage demo:Note that in python2,  is bigger than , so you can't rely on that.  Disclaimer: This is an integer in the OO sense, it is not an integer in the mathematical sense.  Consequently, arithmetic operations inherited from the parent class  may not behave sensibly.  If this causes any issues for your intended use case, then they can be disabled by implementing  and friends to just error out.
Konsta Vesterinen's  would work (pypi), except that it doesn't inherit from , but you can subclass it:Another package that implements "infinity" values is Extremes, which was salvaged from the rejected PEP 326; again, you'd need to subclass from  and .
Use case: library function expects an integer, and the only easy way to force a certain behavior is to pass a very large integer.This sounds like a flaw in the library that should be fixed in its interface. Then all its users would benefit. What library is it?Creating a magical int subclass with overridden comparison operators might work for you. It's brittle, though; you never know what the library is going to do with that object. Suppose it converts it to a string. What should happen? And data is naturally used in different ways as a library evolves; you may update the library one day to find that your trick doesn't work anymore.
It seems to me that this would be fundamentally impossible. Let's say you write a function that returns this RBI ("really big int"). If the computer is capable of storing it, then someone else could write a function that returns the same value. Is your RBI greater than itself?Perhaps you can achieve the desired result with something like @wim's answer: Create an object that overrides the comparison operators to make "<" always return false and ">" always return true. (I haven't written a lot of Python. In most object-oriented languages, this would only work if the comparison puts your value first, IF RBI>x. If someone writes the comparison the other way, IF x>RBI, it will fail because the compiler doesn't know how to compare integers to a user-defined class.)
In Python 3.5, you can do:And then:Will always be true. Unless of course, as pointed out, x is also infinity or "nan" ("not a number").How can I represent an infinite number in Python?Answered by @WilHall
You should not be inheriting from  unless you want both its interface and its implementation.  (Its implementation is an automatically-widening set of bits representing a finite number.  You clearly dont' want that.)  Since you only want the interface, then inherit from the ABC .  Thanks to @ecatmur's answer, we can use  to deal with the nitty-gritty of infinity (including negation).  Here is how we could combine  with the ABC :This can be run with  to verify the required invariants.
Another way to do this (very much inspired by wim's answer) might be an object that isn't infinite, but increases on the fly as needed. Here's what I have in mind: Something like this might avoid a lot of weird behavior that one might not expect. Note that with this kind of approach, if two  instances are involved in an operation, the LHS would be considered bigger than the RHS. EDIT: currently this is not working- I'll fix it later. it seems I am being bitten by the special method lookup functionality. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__radd__
