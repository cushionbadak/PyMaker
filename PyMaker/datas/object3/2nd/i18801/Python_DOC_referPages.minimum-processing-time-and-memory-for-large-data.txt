Natural Text
I am fairly new programmer. So I am looking at data that is coming from files and I have to order data in a manner that takes up least processing time and memory. One of the methods that I was thinking of was to implement a balanced binary to store data in a ordered manner so that I can retrieve the same in a very efficient manner. For sake of testing, I am generating my log files in this manner.Is balanced binary tree the best method to implement such a program. Are there better ways of doing the same? Thanks.
I'm assuming the main things you want to do are:Add a new log line to the end.Add a new log line very near to the end (if your program is multithreaded or otherwise asynchronous).Search for the line nearest a given timestamp.Search for all lines within a given time range.A binary search tree is O(log N) for all of these. So is a skip list or a B-tree, or a number of other data structures.So, how do you choose between them?Well, unless you really need to build this yourself, you probably care more about the interface than the exact performance characteristics, as long as they're all "fast enough", which they probably are. For example,  is a carefully-designed class that's as close to a drop-in replacement for  as anything sorted could be.  has some cool features like key slicing that you might not even think to look for, but might use all the time once you find them.  can be trivially backed to disk, and can be searched by nice tools you already have on your system. Likely one of these will be more important to you than the differences between a B+Tree, a red-black tree, and an array with a B-tree index.If squeezing out the last bit of performance does matter, you probably want to test with realistic data sets on characteristic systems, rather than try to guess. There are some good rules of thumb: B-trees are good if you may have enough data to swap to memory; skiplists are good for fine-grained locking; skiplists are good for reading large ranges; binary trees are good for quickly approximating by position instead of key; etc. But you'll still want to test your guess anyway, so don't put too much effort into guessing.


Answer URL
