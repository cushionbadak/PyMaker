Natural Text
This question seems to come up regularly both on StackOverflow and elsewhere, yet I wasn't able to find a completely satisfactory solution anywhere.There seem to be two types of common solutions. The first one (from e.g. http://article.gmane.org/gmane.comp.python.general/630549) uses a function decorator:This is probably the most straightforward approach, but it requires repeating the parent class name at least once, and also becomes a lot more complicated if the docstring can not be found in the direct ancestor.The second approach uses a metaclass or class decorator (cf. Inheriting methods' docstrings in Python, Inherit a parent class docstring as __doc__ attribute, http://mail.python.org/pipermail/python-list/2011-June/606043.html) and looks like this:However, with this approach the docstring is only set after class creation and thus not accessible to decorators, so the following won't work:A third interesting idea has been discussed in Inherit docstrings in Python class inheritance. Here, the function decorator actually wraps the method and turns it into a method descriptor rather than merely updating its docstring. However, this seems like  using sledgehammer to crack a nut because it turns the method into a method descriptor (which may have performance implications as well, though I did not check), and also does not make the docstring available to any other decorators (and in the above example will actually make them crash because the method descriptor doesn't have  attribute).Is there a solution that avoids all the above drawbacks, i.e. does not require me to repeat myself and assigns the docstring immediately using a decorator?I'm interested in a solution for Python 3.
Use a class decorator instead:where  is defined as:Demo:This sets the docstring after defining the whole class, without having to create an instance first.If you need the docstring available to method decorators, you are, unfortunately, wholly stuck with your decorator that duplicates the parent class.The reason for this is that you cannot introspect what the superclass is going to be while defining the class body. The local namespace during class definition does not have access to the arguments passed to the class factory.You could use a metaclass to add the base classes to the local namespace, then use a decorator to pull those out again, but in my opinion that gets ugly, fast:Demo usage:
I think the metaclass'  method can be used for this by injecting a decorator that knows about the class hierarchy:Prints:Of course, this approach has some other issues:  - Some analysis tools (e.g. pyflakes) will complain about the use of the (apparently) undefined  name  - It doesn't work if the parent class already has a different metaclass (e.g. ).
Starting in Python 3.5,  searches the inheritance tree for a docstring.  So if you leave the docstring for the child empty, it will retrieve it from the parent.  That avoids the need for code repetition, and automatic code generators like sphinx will do the right thing.


Answer URL
https://docs.python.org/3/library/inspect.html#inspect.getdoc
