Natural Text
For example, I have a basic method that will return a list of permutations.Now I understand, that in its current state this code won't run because the second  isn't defined, but is there and elegant way to accomplish what I'm trying to do here? If that's still not clear, I want to make the default  value equal to the first argument passed in. Thanks.
No, function keyword parameter defaults are determined when the function is defined, not when the function is executed.Set the default to  and detect that:If you need to be able to specify  as a argument, use a different sentinel value:Now callers can set  to  and it won't be seen as the default.
Because of the way Python handles bindings and default parameters...The standard way is:And another option is:Although this requires you to explicitly use  if you don't want a default...
You should do something like :
Answer 1:The solution from above looks like this:While this approach will solve a myriad of potential problems, (and maybe yours)! I wanted to write a function where a possible input for variable "" is indeed the singleton , so I had to do more digging. To explain that further, calling the function with the following variables:Yields:Whereas the user might expect that since they called the function with three variables, then it should print the three variables, like this:So, this implementation ignores the third variable, even when it was declared, so this means the function no longer has the ability to determine whether or not variable "" was defined. So, for my use case, a default value of  would not quite do the trick. For the answers that suggest this solution, read these:Is there a way to set a default parameter equal to another parameter value?Python shortcut for variable default value to be another variable value if it is NoneFunction argument's default value equal to another argumentWhat is the pythonic way to avoid default parameters that are empty lists?But, if that doesn't work for you, then maybe keep reading!A comment in the first link above mentions using a  defined by . So this solution removes the use of a None, and replaces it with the  through using the implied private .Answer 2:So this is pretty awesome! It correctly handles the above edge case! See for yourself:So, we're done, right? Is there any plausible way that this might not work? Hmm... probably not! But I did say this was a three-part answer, so onward! ;)For the sake of completeness, let's imagine our program operates in a space where every possible scenario is indeed possible. (This may not be a warranted assumption, but I imagine that one could derive the value of  with enough information about the computer's architecture and the implementation of the choice of the object. So, if you are willing, let us assume that is indeed possible, and let's imagine we decide to test that hypothesis referencing  as defined above.Wait a minute! I entered three arguments, so I should see the string concatenation of the three of them together! *queue entering the land of unforeseen consequences*I mean, not actually. A response of: "That's negligible edge case territory!!" or its ilk is perfectly warranted.And that sentiment is right! For this case (and probably most cases) this is really not worth worrying about! But if it is worth worrying about, or if you just want the mathematical satisfaction of eliminating all edge cases you're aware of ... onward!Exercise left to reader: Deviating from this technique, you can directly assert , however, in honesty, I haven't gotten that way to work for me. My investigation shows  is , and  is also , and that's why I'm using the implementation from Martin Pieters.Okay, after that long exercise, we're back!Recall the goal is to write a function that could potentially have  inputs, and only when one variable is not provided - then you will copy another variable in position . Instead of defining the variable by default, what if we change the approach to allow an arbitrary number of variables?So if you're looking for a solution that does not compromise on potential inputs, where a valid input could be either , , or  ... then (and only then), at this point, I'm thinking my solution will be helpful. The inspiration for the technique came from the second part of Jon Clements' answer.Answer 3:My solution to this problem is to change the naming of this function, and  wrap this function with a a function of the previous naming convention, but instead of using variables, we use . You then define the original function within the local scope (with the new name), and only allow the few possibilities you desire.In steps:Rename function to something similarRemove the default setup for your optional parameterBegin to create a new function just above and tab the original function in.Determine the the arity of your function - (I found that word in my search... that is the number of the parameters passed into a given function)Utilize a case statement inside that determines if you entered a valid number of variables, and adjust accordingly!So, in summary:Answer 1 - the simplest answer, and works for most cases.Answer 2 - use if  does not actually signify an empty parameter by switching to  , through  .Answer 3 seeks out a general solution utilizing a wrapper function with arbitrary arity using , and handles the acceptable cases inside:Use what works for you! But for me, I'll be using Option 3 ;)


Answer URL
