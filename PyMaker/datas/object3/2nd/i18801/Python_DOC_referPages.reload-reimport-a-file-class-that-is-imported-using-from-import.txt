Natural Text
well, as the title say, i got a group of import, all import a class, all in the same folder as the script running it:python3 doesn't have reload iirc but there is imp.reload() but it doesn't seem to work,it just throw a error saying it not a module (it a class so it doesn't work)after every little edit in those class that are imported, i would need to restart the scriptisn't there a way to reload/reimport the class to show the effect of the edit without needing to start the script or rewriting most of the script so that imp.reload() works?python3, linux (but prefer if it also work on window)edit1:example: if i use:it return:if i change it to show °F and reload it using imp.reloadit return:so, it works BUT if i useit return:then i change it to show °F and reload it using imp.reloadit still returnBUT again, if i call it this way:it returnidk why it that but it is cause it happen in a while loop?edit2:file name: system.py:before changing for test:after changing for test:
You can only  a module:The argument must be a module object, so it must have been successfully imported before.In your case, you don't have any reference to the module object. You will have to  it, even if you don't want to use it for anything else, just for the sake of calling  later.Also, after the , you have re- the names:Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired.When you do , that  is a "name external to the module", so you have to rebind it explicitly.If you think about it, it has to work this way. There's no way  can enumerate all objects whose definition is dependent on the previous version of the module to update them. Even if it could, there could be infinite cycles. And what would happen if the new version didn't even have a definition for a class that was in the old one? Or if the class were defined dynamically?Looking at it another way,  is very similar to .  is a name in your namespace, not 's namespace, so  will not touch it; you need to copy the new  over again.The easy way to solve all of these problems is to just repeat all of your  lines after the .For simple cases:However, most of your examples have an obvious naming conflict: once you , you can no longer . So, you need another reference to the  module object.Python keeps one around for you, which you can use:Or, alternatively, you can use an  clause, or just an  assignment, to give it whatever name you want.From your comments and your edited question, it sounds like you have a further problem. Let's use one of the simple non-colliding cases to discuss it.I believe you're actually doing something like this:The first line will successfully reload the  module, and the second will copy its  class into your globals, so any new  instances you created will be of the new type.But that doesn't affect any existing  instances, like . Just like  was,  is one of those "names external to the module". But it's actually even worse. In order to adjust it,  would have to figure out what its state would have been, had the new version of the code been in effect from the time it was created. It should be obvious that this is an unsolvable problem.If you know the instances you want to patch up, you can deal with them in effectively the same way you dealt with the classes: just create them again:If that's not good enough, there are three hacky possibilities that may be what you want:Monkeypatch the methods, attributes, etc. into the instance(s) and their (es).Patch the instances'  attribute directly, so anything that was inherited from the class will now be inherited from the new class.Serialize the instances with  before the , then deserialize after.For very simple cases, all three of these will work. For more complex cases, you will have to understand what you're doing.Note that you can wrap a lot of this stuff up in a function, but you have to understand how locals and globals work (and how import and reload work) or you're going to end up confusing yourself.A simpler solution is to just create "dump all state" and "load all state" functions. Then you can dump everything, quit, relaunch, and restore. The Python tutorial and the ipython docs both describe a few different ways to do this in place of using ; it's probably worth going back and rereading those.
Access the module through , reload that, then reassign the imported names:etc.All the  syntax does is import  then bind  to the same object  refers to.By using  you don't have to explicitly import the module again, and can reach the new definitions of the objects for rebinding after reloading.


Answer URL
