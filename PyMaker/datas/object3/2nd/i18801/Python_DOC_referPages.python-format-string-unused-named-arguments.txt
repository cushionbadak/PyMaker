Natural Text
Let's say I have:this wil output:Next we have:this will output:Is there some workaround to prevent this error to happen, something like:if keyrror: ignore, leave it alone (but do parse others)compare format string with available named arguments, if missing then add
If you are using Python 3.2+, use can use str.format_map().For :For :In Python 2.6/2.7For :For :
You could use a template string with the  method.
You can follow the recommendation in PEP 3101 and subclass Formatter:Now try it:You can change how key errors are flagged by changing the text in  to what you would like to show for KeyErrors:The code works unchanged on Python 2.6, 2.7, and 3.0+
One can also do the simple and readable, albeit somewhat silly:I know that this answer requires knowledge of the expected keys,but I was looking for a simple two-step substitution (say problem name first, then problem index within a loop) and creating a whole class or unreadable code was more complex than needed.
falsetru's answer has a clever use of a defaulting dictionary with , and dawg's answer is perhaps more in-line with Python's documentation, but neither handle compound field names (e.g., with explicit conversion () or format specs ().For example, using falsetru's SafeDict:And using dawg's MyFormatter:Neither work well in the second case because the value lookup (in ) has already stripped out the formatting specifications. Instead, you can redefine  or  so these specifications are available. My solution below does this by redefining  so it performs the key lookup and, if the key is missing, escapes the format string with double braces (e.g. ) and then performs the normal .Here's it in action:This solution is a bit too hacky (maybe redefining  would have fewer kludges), but should work for more formatting strings.
Here's another way to do it using python27:
Needing to partially fill format strings is a common problem when progressively filling the format strings, e.g. for SQL queries. method uses the  from  and  to parse the format string and also find out whether the named parameter hash has all the values needed to partially evaluate the format: will leave the unresolved portion of the format string, so subsequent calls can be used to resolve those parts as the data is available.goodmami's and dawg's answers seem cleaner, but they both fail to capture the format mini-language completely as in ;  will have no problem resolving any format string that  resolves:It is even easier to extend the functionality to old style format strings using regex instead of the string formatter, as the old style format substrings were regular (ie. no nested markers).
For Python 3, taking the approved answer, this is a nice, tight, Pythonic implementation:
Based on some of the other answers, I expanded the solutions.This will handle strings with formatting spec .I found that some strings from selenium logging were causing vformat (and format_map) to hit a recursion limit.  I also wanted to ensure I could handle strings where empty curly braces exist as well.output:


Answer URL
