Natural Text
The two classes represent excellent abstractions for concurrent programming, so it's a bit disconcerting that they don't support the same API.Specifically, according to the docs: is almost compatible with .Differences: and  do not take a timeout argument and raise an exception when the future isnâ€™t done yet.Callbacks registered with  are always called via the event loop's .This class is not compatible with the  and  functions in the  package.The above list is actually incomplete, there are a couple more differences: method is absent and  may raise  if called too earlyAre any of these due to the inherent nature of an event loop that makes these operations either useless or too troublesome to implement?And what is the meaning of the difference related to ? Either way, the callback is guaranteed to happen at some unspecified time after the futures is done, so isn't it perfectly consistent between the two classes?
The core reason for the difference is in how threads (and processes) handle blocks vs how coroutines handle events that block.  In threading, the current thread is suspended until whatever condition resolves and the thread can go forward.  For example in the case of the futures, if you request the result of a future, it's fine to suspend the current thread until that result is available.  However the concurrency model of an event loop is that rather than suspending code, you return to the event loop and get called again when ready.  So it is an error to request the result of an asyncio future that doesn't have a result ready.You might think that the asyncio future could just wait and while that would be inefficient, would it really be all that bad for your coroutine to block?  It turns out though that having the coroutine block is very likely to mean that the future never completes.  It is very likely that the future's result will be set by some code associated with the event loop running the code that requests the result.  If the thread running that event loop blocks, no code associated with the event loop would run.  So blocking on the result would deadlock and prevent the result from being produced.So, yes, the differences in interface are due to this inherent difference.  As an example, you wouldn't want to use an asyncio future with the concurrent.futures waiter abstraction because again that would block the event loop thread.The  difference guarantees that callbacks will be run in the event loop.  That's desirable because they will get the event loop's thread local data.  Also, a lot of coroutine code assumes that it will never be run at the same time as other code from the same event loop.  That is, coroutines are only thread safe under the assumption that two coroutines from the same event loop  do not run at the same time.  Running the callbacks in the event loop avoids a lot of thread safety issues and makes it easier to write correct code.
 provides a way to share results between different threads and processes usually when you use Executor. solves same task but for coroutines, that are actually some special sort of functions running usually in one process/thread asynchronously. "Asynchronously" in current context means that event loop manages code executing flow of this coroutines: it may suspend execution inside one coroutine, start executing another coroutine and later return to executing first one - everything usually in one thread/process.These objects (and many other threading/asyncio objects like , ,  etc.) look similar because the idea of concurrency in your code with threads/processes and coroutines is similar.I think the main reason objects are different is historical:  was created much later then  and . It's probably impossible to change  to work with  without breaking class API.Should both classes be one in "ideal world"? This is probably debatable issue, but I see many disadvantages of that: while  and  look similar at first glance, they're very different in many ways, including internal implementation or way of writing asyncio/non-asyncio code (see / keywords).I think it's probably for the best that classes are different: we clearly split different by nature ways of concurrency (even if their similarity looks strange at first).


Answer URL
https://docs.python.org/3/library/asyncio-task.html#future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor
https://docs.python.org/3/library/asyncio-task.html#coroutines
https://docs.python.org/3/library/threading.html#lock-objects
https://docs.python.org/3/library/asyncio-sync.html
