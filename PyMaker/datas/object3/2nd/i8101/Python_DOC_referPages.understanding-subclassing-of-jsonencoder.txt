Natural Text
I am trying to subclass  such that named tuples (defined using the new Python 3.6+ syntax, but it probably still applies to the output of ) are serialised to JSON objects, where the tuple fields correspond to object keys.For example:My understanding is that I subclass  and override its  method to provide serialisations for new types. The rest of the class will then do the right thing with respect to recursion, etc. I thus came up with the following:This works when it tries to serialise (i.e., as the  parameter to ) a  value -- to at least partially prove my hypothesis -- but the check for named tuples is never hit and it defaults to serialising it as a tuple (i.e., to a JSON array). Weirdly, I had presumed that I should call the superclass'  method on my transformed object, but this then raises an exception when it tries to serialise a : "TypeError: Object of type 'str' is not JSON serializable", which frankly makes no sense!I get the same behaviour if I make the named tuple type check more specific (e.g., ). I did find, however, that I can almost get the behaviour I'm looking for if I also override the  method, by moving the named tuple check to there:This works, but not recursively: It successfully serialises top-level named tuples into JSON objects, per my requirement, but any named tuples that exist within that named tuple will be serialised with the default behaviour (JSON array). This is also the behaviour if I put the named tuple type check in both the  and  methods.The documentation implies that only the  method should be changed in subclasses. I presume, for example, that overriding  in  will cause it to break when it's doing chunked encoding. However, no amount of hackery has so far yielded what I want (or expect to happen, given the scant documentation).Where is my misunderstanding?EDIT Reading the code for  explains why the  method raises a type error when you pass it a string: It's not clear (at least to me) from the documentation, but the  method is meant to transform values of some unsupported type into a serialisable type, which is then returned; if the unsupported type is not transformed into anything in your overridden method, then you should call  at the end to invoke a type error. So something like this:I believe the problem I'm experiencing is that the  method is only called by the encoder when it can't match any supported types. A named tuple is still a tuple -- which is supported -- so it matches that first before delegating to my overridden  method. In Python 2.7, the functions that did this matching are part of the  object, but in Python 3, they seem to have been moved outside into the module namespace (and, thus, not accessible to userland). I thus believe it is not possible to subclass  to serialise named tuples in a generic way without doing a lot of rewriting and hard-coupling to your own implementation :(EDIT 2 I submitted this as a bug.
What are you doing wrong is this thisYour object  is not of type . Not even . It is of type  or whatever definitions you have of .So, in order to do what you want, you have to change that  intoOr, if you have multiple models/classes defined from Also, don't forget about the "super" . Like in the docs.Complete code:


Answer URL
https://docs.python.org/3/library/json.html#json.JSONEncoder.default
