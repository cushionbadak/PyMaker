Natural Text
I understand there are at least 3 kinds of methods in Python having different first arguments:instance method - instance, i.e. class method - class, i.e. static method - nothingThese classic methods are implemented in the  class below including an usual method:In Python 3, the  can be called safely, yet it raises an error in Python 2: This error suggests such a method was not intended in Python 2.  Perhaps its allowance now is due to the elimination of unbound methods in Python 3 (REF 001). Moreover,  does not accept args, and it can be bound to called by a class like a staticmethod, .  However, it is not an explicit staticmethod (no decorator).QuestionsWas making a method this way (without args while not explicitly decorated as staticmethods) intentional in Python 3's design?  UPDATEDAmong the classic method types, what type of method is ?Why can  be called by the class without passing an argument?Some preliminary inspection yields inconclusive results:The first set of type inspections suggests  is something similar to a staticmethod. The second suggests it resembles an instance method.  I'm not sure what this method is or why it should be used over the classic ones.  I would appreciate some advice on how to inspect and understand it better.  Thanks.REF 001: What's New in Python 3: “unbound methods” has been removed REF 002: How to distinguish an instance method, a class method, a static method or a function in Python 3?REF 003: What's the point of @staticmethod in Python?
Some background: In Python 2, "regular" instance methods could give rise to two kinds of method objects, depending on whether you accessed them via an instance or the class.  If you did  (where  is an instance of the class), you got a bound method object, which keeps track of which instance it is attached to, and passes it as .  If you did  (where  is the class), you got an unbound method object, which had no fixed value of , but still did a check to make sure a  of the appropriate class was passed when you called it.In Python 3, unbound methods were removed.  Doing  now just gives you the "plain" function object, with no argument checking at all.Was making a method this way intentional in Python 3's design?If you mean, was removal of unbound methods intentional, the answer is yes.  You can see discussion from Guido on the mailing list.  Basically it was decided that unbound methods add complexity for little gain.Among the classic method types, what type of method is unknown_mthd?It is an instance method, but a broken one.  When you access it, a bound method object is created, but since it accepts no arguments, it's unable to accept the  argument and can't be successfully called.Why can unknown_mthd be called by the class without passing an argument?In Python 3, unbound methods were removed, so  is just a plain function.  No wrapping takes place to handle the  argument, so you can call it as a plain function that accepts no arguments.  In Python 2,  is an unbound method object, which has a check that enforces passing a  argument of the appropriate class; since, again, the method accepts no arguments, this check fails.
@BrenBarn did a great job answering your question. This answer however, adds a plethora of details: First of all, this change in bound and unbound method is version-specific, and it doesn't relate to new-style or classic classes:2.X classic classes by default3.X new-style classes by default You've already mentioned this in your question, it doesn't hurt to mention it twice as a reminder. Moreover,  does not accept args, and it can be bound to a class like a , . However, it is not an explicit  (no decorator) doesn't accept args, normally because you've defined the function without so that it does not take any parameter. Be careful and cautious, static methods as well as your coded  method will not be magically bound to a class when you reference them through the class name (e.g, ). Under Python 3.X  returns a simple function object in 3.X, not a method bound to a class.  1 - Was making a method this way (without args while not explicitly decorated as staticmethods) intentional in Python 3's design? UPDATEDI cannot speak for CPython developers nor do I claim to be their representative, but from my experience as a Python programmer, it seems like they wanted to get rid of a bad restriction, especially given the fact that Python is extremely dynamic, not a language of restrictions; why would you test the type of objects passed to class methods and hence restrict the method to specific instances of classes? Type testing eliminates polymorphism. It would be decent if you just return a simple function when a method is fetched through the class which functionally behaves like a static method, you can think of  to be static method under 3.X so long as you're careful not to fetch it through an instance of  you're good to go. 2- Among the classic method types, what type of method is ?Under 3.X: It's simply a function in 3.X as you could see. Continuing the previous session under 2.X: is a simple function that lives inside , really just a simple function which lives inside the namespace dictionary of . Then, when does it become an instance of ? Well, it becomes an instance of  when you fetch the method attribute either from the class itself which returns an unbound method or its instances which returns a bound method. In 3.X,  is a simple function--instance of , and  is an instance of  that retains the original instance of class  and adds it as the first argument implicitly on function calls. 3- Why can  be called by the class without passing an argument?Again, because  is just a simple function under 3.X. Whereas in 2.X,  not a simple function and must be called be passed an instance of  when called. 
Are there more than three types of methods in Python?Yes. There are the three built-in kinds that you mention (instance method, class method, static method), four if you count , and anyone can define new method types.Once you understand the mechanism for doing this, it's easy to explain why  is callable from the class in Python 3.A new kind of methodSuppose we wanted to create a new type of method, call it  so that we could do something like this:The usage is like this: works like a normal instance method when called on an instance, but when called on the class, it always receives  for the first parameter. If it were a normal instance method, you would always have to pass an explicit value for the  parameter in order for it to work.So how does this work? How you can you create a new method type like this?The Descriptor ProtocolWhen Python looks up a field of an instance, i.e. when you do , it check in several places. It checks the instance's  of course, but it also checks the  of the object's class, and base classes thereof. In the instance dict, Python is just looking for the value, so if  exists, that's the value. However, in the class dict, Python is looking for an object which implements the Descriptor Protocol.The Descriptor Protocol is how all three built-in kinds of methods work, it's how  works, and it's how our special  will work.Basically, if the class dict has a value with the correct name1, Python checks if it has an  method, and calls it like  Then, the value returned from  is used as the field value.So for example, a trivial descriptor which always returns 3:Usage is like this:Notice that the descriptor is called with both the instance and the class type. It can also be used on the class:When a descriptor is used on a class rather than an instance, the  method gets None for self, but still gets the class argument.This allows a simple implementation of methods: functions simply implement the descriptor protocol. When you call  on a function, it returns a bound method of instance. If the instance is , it returns the original function. You can actually call  yourself to see this: and  are similar. These decorators create proxy objects with  methods which provide different binding. Class method's  binds the method to the instance, and static method's  doesn't bind to anything, even when called on an instance.The Optional-Self Method ImplementationWe can do something similar to create a new method which optionally binds to an instance.When you decorate a function with , the function is replaced with our proxy. This proxy saves the original method and supplies a  method which returns a . When we create a , we tell it both the function to call and the value to pass as . Finally, calling the  calls the original function, but with the instance or  inserted into the first parameter.Specific QuestionsWas making a method this way (without args while not explicitly  decorated as staticmethods) intentional in Python 3's design? UPDATEDI believe this was intentional; however the intent would have been to eliminate unbound methods. In both Python 2 and Python 3,  always creates a function (you can see this by checking a type's : even though  comes back as ,  is still ).In Python 2, 's  method always returns a , even when accessed through the class. When accessed through an instance, the method is bound to that instance. When accessed through the class, the method is unbound, and includes a mechanism which checks that the first argument is an instance of the correct class.In Python 3, 's  method will return the original function unchanged when accessed through the class, and a  when accessed through the instance.I don't know the exact rationale but I would guess that type-checking of the first argument to a class-level function was deemed unnecessary, maybe even harmful; Python allows duck-typing after all.Among the classic method types, what type of method is unknown_mthd? is a plain function, just like any normal instance method. It only fails when called through the instance because when  attempts to call the   with the bound instance, it doesn't accept enough parameters to receive the  argument.Why can unknown_mthd be called by the class without passing an  argument?Because it's just a plain , same as any other . I just doesn't take enough arguments to work correctly when used as an instance method.You may note that both  and  work the same whether they're called through an instance or a class, whereas  will only work correctly when when called through the class and fail when called through an instance.1. If a particular name has both a value in the instance dict and a descriptor in the class dict, which one is used depends on what kind of descriptor it is. If the descriptor only defines , the value in the instance dict is used. If the descriptor also defines , then it's a data-descriptor and the descriptor always wins. This is why you can assign over top of a method but not a ; method only define , so you can put things in the same-named slot in the instance dict, while  define , so even if they're read-only, you'll never get a value from the instance  even if you've previously bypassed property lookup and stuck a value in the dict with e.g. .


Answer URL
https://docs.python.org/3/howto/descriptor.html
