Natural Text
I am coding a Caesar cipher. The key is an integer from 1 to 25. This cipher rotates the letters of the alphabet (A to Z). The encoding replaces each letterwith the 1st to 25th next letter in the alphabet (wrapping Z to A). So key 2 encrypts “HI” to “JK”, but key 20 encrypts “HI” to “BC”.But If I put in "I am super" it will output "k kc oouwrgt" when it should be "k co uwrgt" with a key of 2. It will also not go back to the beginning of the alphabet e.g 'x' will not go to 'a' with a key of 2. I use python 3.4.1
When you encounter a space, you append the last letter again, instead of :This causes  and  to appear twice when the key is ; you re-appended the encoded  ->  and  ->  results.You need to use the  modulo operator to make your index 'wrap round':I removed the  call, you already turned  to an integer earlier.Other tips:You don't need to turn  into a list; strings are sequences too and support indexing and the method directly. The same applies to ; just loop over the string itself.You are not using  in the  loop; drop  altogether: .You could just print your encoded characters directly in that loop, no need to use an  list and a separate loop.The  method would let you print your encoded text all on one line:   instead of your last  loop.The absolute fastest method of encoding a string is to use a translation table, a dictionary mapping input characters to output characters, and the  method. You can use the  function to make that table:The trick lies in creating the second string for ; using slicing it is easy to create a rotated string, by taking everything from position  onwards, and the first  characters at the end:
One obvious solution would be to use modulo for the alphabet index:The % (modulo) operator yields the remainder from the division of the  first argument by the second.As a bonus, you wouldn't need to check the key is lower than 25, and you'll never get an .A few notes:a string is already an iterable of characters. No need to convert it to a list wasn't defined in to iterate over a list, you don't need the length or the index.to decode the message, just change the sign of the key. It should work just like encode, thanks to modulo : As an example:and


Answer URL
https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations
https://docs.python.org/3/library/stdtypes.html#str.join
https://docs.python.org/3/library/stdtypes.html#str.translate
https://docs.python.org/3/library/stdtypes.html#str.maketrans
