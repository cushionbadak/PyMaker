Natural Text
Declarative usage of Python's  requires values to be provided, when in the most basic use case for an enum we don't actually care about names and values.  We only care about the sentinels themselves.  After reading a related Q&A recently, I realised it is possible to use the  method of the enum's metaclass to get this kind of declaration:And the implementation to make things so dry is actually fairly easy:  In Python 3.6, there was provided  to help with that issue of omitting values, but the interface is still strange - you're required to specify the  value for each member, and inherit from a different base which fixes up the :  Knowing that many man-hours and great care has gone into the implementation chosen for the standard library, there must be some reason why the arguably more Pythonic version of a declarative enum demonstrated earlier doesn't work properly.  My question is, what are the problems and failure modes of the proposed approach, and why was this (or something similar) decided against - with the  feature being included in Python 3.6 instead?
There are several pitfalls to having a  be the Enum's namespace:unable to access anything but other enum members/methodstypos create new memberslose protections form  namespace:overwriting membersoverwriting methodsthe newer  methodAnd the most important:it will not workWhy won't it work?  Not only can  set attributes on the namespace dict, so can the namespace dict itself -- and  does: , a list of all the attributes that should be members.However, the goal of declaring a name without a value is not impossible -- the 1 package allows it with a few safeguards:magic auto behavior is only present while defining members (as soon as a normal method is defined it turns off), , and  are excluded by default, but one can include them and/or exclude other global namesThis behavior was deemed too magical for the stdlib, though, so if you want it, along with some other enhancements/improvements2, you'll have to use .An example:The  still shows the created values, though.--1 Disclosure:  I am the author of the Python stdlib , the  backport, and the Advanced Enumeration ()  library.2  (just like it says ;),  (metaclass based, default values, etc.), plus some built-in Enums:  --> several values can map to one name (not aliases) --> names with the same value are not aliases (think playing cards) --> members are order-comparable by definition --> no aliases allowed
You may be interested that you can create enums using multiple arguments:That way you don't have to use  or anything else (like ).why was this (or something similar) decided against - with the auto feature being included in Python 3.6 instead?This has been discussed at length on the Python issue tracker (especially bpo-23591) and I'll include the (summarized) arguments against it:Vedran Čačić:This is something fundamental: it is breaking the promise that class body is a suite of commands, where Python statements (such as assignment) have their usual semantics.Raymond Hettinger:As long as [auto] has been defined somewhere (i.e. from enum import [auto]), it is normal Python and doesn't fight with the rest of language or its toolchains.In short: class definitions interpret these "variables" as lookups:but for  they should be interpreted as assignments? That use-case simply wasn't considered "special enough to break the rules".


Answer URL
https://docs.python.org/3/library/enum.html
https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace
https://docs.python.org/3/library/enum.html#using-auto
https://docs.python.org/3/library/enum.html#omitting-values
https://docs.python.org/3/library/enum.html
