Natural Text
I am learning python, but I'm a bit confused by the following result.According to the documentation,  has a truth value of True.But I still feel the above code a bit inconsistent....And something more interesting:
You're mixing two concepts: equality testing and truth-value testing. They are not the same in Python.I think what triggered the question is that Python does an implicit casting when you do  (it casts the something to ) but it does not do implicit casting when you do .Pythons data model actually explains how these operations are done:Truth-value testingIt starts by checking if the object implements the  method and if it does it uses the returned boolean. If it doesn't define a  method it looks at the  method. If it's implemented it will use the result of . If it doesn't have either the object is considered .For integers the  method returns  except when the integer value is  (then it's ).The Ellipsis object ( is the Ellipsis object) on the other hand doesn't implement  or  so it's always .Equality testingEquality testing relies on the  method of both arguments. It's more a chain of operations:It checks if the first operand implements  when the second operand is passed as argument.If it doesn't then it checks if the second operand implements  when the first operand is passed as argument.If it doesn't then Python checks for object identity (if they are the same object - similar to pointer comparisons in C-like languages)The order of these operations may vary.1 For built-in Python types these operations are explicitly implemented. For example egers implement  but the  makes sure that it returns  if the other one isn't an eger.The  object doesn't implement  at all.So when you compare integers and Ellipsis Python will always fallback to object identity and so it will always return .On the other hand eans are a subclass of egers so they actually compare with  (they are another  after all). The booleans are implemented as  () and  (). So they compare equal:Even though the source code is probably hard to understand I hope I explained the concepts well enough (the source code is for the CPython implementation, the implementation in other Python implementations like PyPy, IronPython may differ!). The important take-away message should be that Python doesn't do implicit conversions in equality checks and equality testing is not related to truth value testing at all. The built-in types are implemented that they almost always give senseable results:all number-types implement equality in some way (floats compare to integers, complex compare to integers and floats) and everything not-zero and not-empty is . However if you create your own classes you can override equality and truth value testing as you like (and then you can spread a lot of confusion)!1 In some cases the order is changed:If the second operand is a subclass of the first operand the first two steps are reversed. For some implicit equality checks the object identity is checked before any  methods are called. For example when checking if some item is in a list, i.e. .
Any object can be tested for "truthiness":Any object can be tested for truth value, for use in an if or while condition or as operand of the Boolean operations below. The following values are considered false:NoneFalsezero of any numeric type, for example, 0, 0.0, 0j.any empty sequence, for example, '', (), [].any empty mapping, for example, {}.instances of user-defined classes, if the class defines a bool() or len() method, when that method returns the integer zero or bool value False. [1]All other values are considered true â€” so objects of many types are always true.Operations and built-in functions that have a Boolean result always return 0 or False for false and 1 or True for true, unless otherwise stated. (Important exception: the Boolean operations or and and always return one of their operands.)So it's not hard to see that  will enter the branch. The  object is considered . However that doesn't mean it has to be equal to . Just the !The  will implicitly call  on the condition, so:will be evaluated as if you had written:and:However there's one catch here.  is equal to  and  equal to , but that's just because  subclasses eger in python.
In python most (all?) objects have a  value. The meaning behind "has a truth value of True" means that  evaluates to True.On the other hand,  is treated as  in many cases (and  as ) which you can see when you do stuff like:That is why you get  -->  There is a more explicit explanation in the documentation:Boolean values are the two constant objects False and True. They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectivelyFrom the type-hierarchy itself in the docs:These represent the truth values False and True. The two objects representing the values False and True are the only Boolean objects. The Boolean type is a subtype of the integer type, and Boolean values behave like the values 0 and 1, respectively, in almost all contexts, the exception being that when converted to a string, the strings "False" or "True" are returned, respectively.
I believe it's  here is that's weird, not that . equals with  because in Python booleans are subclass of integers (because of PEP-285). See yourself:


Answer URL
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
https://docs.python.org/3/library/stdtypes.html#boolean-values
https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy
https://docs.python.org/3/c-api/object.html#c.PyObject_IsTrue
https://docs.python.org/3/c-api/object.html#c.PyObject_Not
