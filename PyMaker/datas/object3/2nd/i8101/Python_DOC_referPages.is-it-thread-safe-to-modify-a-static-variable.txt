Natural Text
Since C++11, static variable initialization is guaranteed to be thread safe. But how about modifying a static variable in multiple threads? like belowThe reason I ask this question is that I am reading the source code for , I am trying to embed Python in a multithreaded C++ application, I am wondering if it is safe to call  multiple times in several threads? The implementation of  boils down to function , which is like belowAnd is the conclusion for C the same as C++?EDITSo all the answers are good, I chose the one which clears my head most.
 is not thread-safe. You can call it from multiple threads only if you know that the Python interpreter has already been initialized, but if you can prove that it would be silly to call the function.Indeed, most Python C-API calls are not thread-safe; you need to acquire the Global Interpreter Lock (GIL) in order to interact with the Python interpreter. (See the Python C-API docs for more details. Read it carefully.)However, as far as I know you cannot use the standard API to acquire the GIL until the interpreter has been initialized. So if you have multiple threads, any of which might initialize the same Python interpreter, you would need to protect the calls to  with your own mutex. You might well be better off doing the initialization once before you start up any threads, if that is possible with your program logic.The code you cite:is clearly not threadsafe in any language, even if  is an atomic type. Suppose two threads were simultaneously executing this code before any initialization happened: both of them see  as false, so both of them proceed with the initialization. (If you don't have two cores, you could imagine that the first process is task switched between the test of  and the assignment.)
No, static in this context is only about the storage duration (see http://en.cppreference.com/w/c/language/static_storage_duration). The variable has no extra thread safety at all over some other variable.Try using std::call_once for this, see http://en.cppreference.com/w/cpp/thread/call_once
It's not thread safe to modify a static variable, but initializing a static variable is thread safe. So you can do:That's it. You can now call  from as many threads as you want and  will only ever get called once.
Modifying a static variable across multiple threads is not safe, since if the variable is put into a register, then other cores' information in the same registers will be different (modifying the variable in another thread would be the same as attempting to access that core's version of the register, which contains completely different data).
The first code sample is the typical starting point for what is referred to as 'lazy-initialisation'. It's useful for guaranteeing once-only initialisation of "expensive objects"; but doing so only if needed just before any use of the object.That specific example doesn't have any serious problems, but it's an oversimplification. And when you look more holistically at lazy-initialisation, you'll see that multi-threaded lazy-initialisation is not a good idea.The concept of "Thread Safety" goes way beyond just a single variable (static or otherwise). You need to step back and consider things happening to the same1 resources (memory, objects, files, ...) at the same time.1: Different instances of the same class are not the same thing; but their static members are.Consider the following extract from your second example.In the first 3 lines, there's no serious harm if multiple threads execute that code approximately concurrently. Some threads might return early; others might be a little "too quick" and all perform the task of setting . However, that wouldn't be a concern, since no matter how many threads set the shared variable, the net effect is always the same.The problem comes in with the fourth line. The one almost nonchalantly brushed aside as "a bunch of other stuff". That "other stuff" is the really critical code, because if it's possible for  to be called multiple times, you need to consider the impact of calling "other stuff" multiple times and concurrently.Now, in the unlikely event you satisfy yourself that "other stuff" can be called multiple times, there's another concern...Consider the client code that might be using Python.If 2 threads call the above simultaneously; with 1 'returning early' and the other actually performing the initialisation. Then the 'early-returning thread' would start (or try to start) using Python before it's fully initialised!As a bit of a hack, you might try blocking at the  line for the duration of the initialisation process. But this is undesirable for 2 reasons:Multiple threads are likely to be stuck waiting in the early stages of their processing.Even after initialisation is complete you'd have a small (but totally wasteful) overhead of checking the lock each time you 'lazy-initialise' the Python framework.ConclusionLazy-initialisation has its uses. But you're much better off not trying to perform the lazy initialisation from multiple threads. Rather have a "safe thread" (main thread is usually good enough) that can perform the lazy-initialisation before even creating any threads that would try to use whatever has been initialised. Then you won't have to worry about the thread-safety at all.


Answer URL
https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock
