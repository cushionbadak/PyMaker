Natural Text
Is it possible to construct a unicode string that the  codec cannot encode?From the documentation (https://docs.python.org/2/library/codecs.html), it appears that the  codec can encode a symbol in "any language". The docs also note when a codec can only encode certain characters or only the Basic Multilingual Plane. I don't know whether this is equivalent to saying "it is impossible to construct a  value that cannot be converted to a bytestring using the  codec", however.Here's the table entry for the  codec.Codec   Aliases          Purpose utf_8   U8, UTF, utf8  all languagesThe motivation here is that I have a utility function that takes either a unicode string or a byte string and converts it to a byte string. When given a byte string it is a no-op. This function is not supposed to throw an exception unless it is called with a non-string type and in that case it's supposed to fail informatively with a TypeError that will be caught later and logged. (We can still run into problems if the repr of the item we attempted to insert into the exception message is too big, but let's ignore that for now).I'm using the  setting because I want this function to throw an exception in the event that it encounters a unicode object that it cannot encode, but am hoping that that isn't possible.
UTF-8 is designed to encode all of the Unicode standard. Encoding Unicode text to UTF-8 will not normally throw an exception.From the Wikipedia article on the codec:UTF-8 is a character encoding capable of encoding all possible characters, or code points, defined by UnicodeThe Python 2 UTF-8 encoding has no edge-cases that I know of; non-BMP data and surrogate pairs are handled just the same:Note that  is the default encoding mode. You don't need to use the  module either, just use the  method on the  object:In Python 3, the situation is slightly more complicated. Decoding and encoding surrogate pairs is restricted; the official standard states such characters should only ever appear in UTF-16 encoded data, and then only in a low and high pair.As such, you need to explicitly state that you want to support such codepoints with the  error handler:Allow encoding and decoding of surrogate codes. These codecs normally treat the presence of surrogates as an error.The only difference between  and  is that  will allow you to encode any surrogate codepoints in your Unicode text to UTF-8. You'd only get such data in rare circumstances (defined as literals, or when accidentally leaving such codepoints unpaired in UTF-16 and then decoding using ).So, in Python 3, only if you there is a chance your Unicode text could have been produced with a  decode or from literal data, you'd need to use  to be absolutely certain all possible Unicode values can be encoded.


Answer URL
https://docs.python.org/3/library/codecs.html#error-handlers
