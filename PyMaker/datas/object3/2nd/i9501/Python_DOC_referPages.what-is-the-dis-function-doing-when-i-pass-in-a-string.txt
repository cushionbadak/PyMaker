Natural Text
I would like to understand how to use dis (the dissembler of Python bytecode). Specifically, how should one interpret the output of  (or )?.Here is a very specific example (in Python 2.7.3):I see that  etc. are bytecode instructions (although interestingly,  does not appear in this list, though I expect it works as ). I think the numbers on the right-hand-side are memory allocations, and the numbers on the left are goto numbers... I notice they almost increment by 3 each time (but not quite).If I wrap  inside a function:
You are trying to disassemble a string containing source code, but that's not supported by  in PythonÂ 2. With a string argument, it treats the string as if it contained byte code (see the function  in ). So you are seeing nonsensical output based on misinterpreting source code as byte code.Things are different in Python 3, where  compiles a string argument before disassembling it:In Python 2 you need to compile the code yourself before passing it to :What do the numbers mean? The number  on the far left is the line number in the source code from which this byte code was compiled. The numbers in the column on the left are the offset of the instruction within the bytecode, and the numbers on the right are the opargs. Let's look at the actual byte code:At offset 0 in the byte code we find , the opcode for , with the oparg ; then (at offset 3)  is the opcode , with  the oparg, and so on. Note that the opargs are in little-endian order, so that  is the number 1. The undocumented  module contains tables  giving you the name for each opcode, and  giving you the opcode for each name:The meaning of the oparg depends on the opcode, and for the full story you need to read the implementation of the CPython virtual machine in . For  and  the oparg is an index into the  property of the code object:For  it is an index into the  property of the code object:For , it is the number of arguments to pass to the function, encoded in 16 bits with the number of ordinary arguments in the low byte, and the number of keyword arguments in the high byte.
I am reposting my answer to another question, in order to be sure to find it while Googling .To complete the great Gareth Rees's answer, here is just a small column-by-column summary to explain the output of disassembled bytecode.For example, given this function:This may be disassembled into (Python 3.6):Each column has a specific purpose:The corresponding line number in the source codeOptionally indicates the current instruction executed (when the bytecode comes from a frame object for example)A label which denotes a possible  from an earlier instruction to this oneThe address in the bytecode which corresponds to the byte index (those are multiples of 2 because Python 3.6 use 2 bytes for each instruction, while it could vary in previous versions)The instruction name (also called opname), each one is briefly explained in the  module and their implementation can be found in  (the core loop of CPython)The argument (if any) of the instruction which is used internally by Python to fetch some constants or variables, manage the stack, jump to a specific instruction, etc.The human-friendly interpretation of the instruction argument


Answer URL
https://docs.python.org/3/library/inspect.html#the-interpreter-stack
