Natural Text
How do I convert an unsigned integer (representing a user ID) to a random looking but actually a deterministically repeatable choice? The choice must be selected with equal probability (irrespective of the distribution of the the input integers). For example, if I have 3 choices, i.e. , the user ID 123 may always be randomly assigned choice 2, whereas the user ID 234 may always be assigned choice 1.Cross-language and cross-platform algorithmic reproducibility is desirable. I'm inclined to use a hash function and modulo unless there is a better way. Here is what I have:I'm using the latest stable Python 3. Please note that this question is similar but not exactly identical to the related question to convert a string to random but deterministically repeatable uniform probability.
Using hash and moduloNotes:The built-inmethod must not be used because it can preserve the input'sdistribution, e.g. with . Alternatively, it can return values that differ when Python is restarted, e.g. with .For converting an int to bytes,  works but is grossly inefficient as it returns an array of null bytes, and so it must not be used. Using  is better. Using  works but wastes a few bytes.Admittedly, using modulo doesn't offer exactly uniform probability,[1][2] but this shouldn't bias much for this application because  is expected to be very large and  is assumed to be small.Using randomThe  module can be used with  as its seed, while addressing concerns surrounding both thread safety and continuity. Using  in this manner is comparable to and simpler than hashing the seed and taking modulo.With this approach, not only is cross-language reproducibility a concern, but reproducibility across multiple future versions of Python could also be a concern. It is therefore not recommended.
An alternative is to encrypt the user ID.  If you keep the encryption key the same, then each input number will encrypt to a different output number up to the block size of the cipher you use. DES uses 64 bit blocks which cover IDs 000000 to 18446744073709551615.  That will give a random appearing replacement for the user ID, which is guaranteed not to give two different user IDs the same 'random' number because encryption is a one-to-one permutation of the block values.
I apologize I don't have Python implementation but I do have very clear, readable and self evident implementation in Java which should be easy to translate into Python with minimal effort. The following produce long predictable evenly distributed sequences covering all range except zeroXorShift ( http://www.arklyffe.com/main/2010/08/29/xorshift-pseudorandom-number-generator )or XorShift128Plus (need to re-seed state0 and state1 to non-zero values before using, http://xoroshiro.di.unimi.it/xorshift128plus.c)or XorOshiro128Plus (http://xoroshiro.di.unimi.it/)or SplitMix64 (http://xoroshiro.di.unimi.it/splitmix64.c)or XorShift1024Mult (http://xoroshiro.di.unimi.it/xorshift1024star.c) or Pcg64_32 (http://www.pcg-random.org/, http://www.pcg-random.org/download.html)
The simplest method is to modulo  by number of options:It's very easy and fast. However if you know user_id's you may to guess an algorithm. Also, pseudorandom sequences can be obtained from  seeded with user constants (e.g. ):


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__hash__
