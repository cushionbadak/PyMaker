Natural Text
My current understanding (based on these answers: one, two, three; and Python documentation) of how import in Python works is (just in case it matters: all the code snippets are tested on Python 3.6.1):Say we have a module , which has submodules  and ; , in turn, has a function ; then we can (given that  installed in current environment, of course):Recently, while playing with  and , in Python console, I have noticed that:results in .Though, the following works fine:this (of course) too:as well as this:and, a bit surprisingly (at least for me), this one:My questions are:Am I wrong (or lacking details) in some of my notions, concerning how  works in Python?Why  won't give me access to ? My understanding is — it should import , along with all of it's submodules/attributes.Why  +  allows access to ? My understanding: it should bind two separate names (with no connections between them), as follows:  to  (i.e.  module) and  to  (i.e.  submodule of  module.
I'm not sure I'm able to give a good answer to all your questions, but I found it interesting and took a look and here is my result.In general,  or  assumes that  is a sub-module in a  package. However, it could also mean that  is a field/variable declared in a  module. The presence of an __init.py__-file will denote that a folder is a package:The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package (...).I believe that,  and  both imports a module , thus  is a known and valid attribute. Basically,  imports that very attribute directly via the valid import statement.In the Werkzeug Quickstart docs, I found the following:Make sure to import all objects from the places the documentation suggests. It is theoretically possible in some situations to import objects from different locations but this is not supported.Further, Werkzeug transition to 1.0 states:Werkzeug originally had a magical import system hook that enabled everything to be imported from one module and still loading the actual implementations lazily as necessary. Unfortunately this turned out to be slow and also unreliable on alternative Python implementations and Google’s App Engine.Starting with 0.7 we recommend against the short imports and strongly encourage starting importing from the actual implementation module. Werkzeug 1.0 will disable the magical import hook completely.It appears that Werkzeug modifies how modules are loaded. (I speculate that this is not uncommon in big packages with contrib-content, e.g. Flask, Django; motivated by ability to lazy-load, improve performance, or manage contributed module content spread across packages.)As you've discovered,  does not import  from the  module, because (as far as I understand), the only submodules that will be imported as attributes are those defined on line 100 of the __init__.py:In the same file, when looking at the Werkzeug's -class, and its -method:It seems that module names in the  dictionary, via definition in , must be imported separately, and  is one of them.Lastly, I think the reason for why the: combination works, is that the first line does not import security, but the second one does, AND the -method will return modules that are explicitly imported. Edit: this last section is not correct, tested by Filipp:I expect that by simply doing only  that still  would work. (I have not tested or confirmed this)
TL;DR: import any attribute, contained in  dictionary, directly from , i.e. .Inspired by/ based on Thomas's answer, I will try to summarize answers to my own questions:Am I wrong (or lacking details) in some of my notions, concerning how  works in Python?From where I currently stand, the short answer is NO. Though, it's good to keep in mind that import rules/mechanics could be customized on package level via . Further reading on topic: Python import system, official docs on , Importing Python Modules article.Why  won't give me access to ? My understanding is — it should import , along with all of it's submodules/attributes.As Thomas Fauskanger, correctly pointed out in his answer:  does not import  from the  module, because the only submodules that will be imported as attributes — are those defined on line 100 of the Werkzeug's  (which are  and ). This assumption, could be verified by the following:Why  +  allows access to ? My understanding: it should bind two separate names (with no connections between them), as follows:  to  (i.e.  module) and  to  (i.e.  submodule of  module.That's a tricky one. As it is indicated in Werkzeug's , by the docstring for module's  function:Just show what we want to show.That's (probably) why:I think, Thomas right here as well, and:... method will return modules that are explicitly imported.Conclusion (or what I have learned =): As stated in the docstring for Werkzeug's :...  The majority of the functions and classes provided by Werkzeug work on the HTTP and WSGI layer. There is no useful grouping for those which is why they are all importable from "werkzeug" instead of the modules where they are implemented.  ...  The implementation of a lazy-loading module in this file replaces the werkzeug package when imported from within.  Attribute access to the werkzeug module will then lazily import from the modules that implement the objects.What this means is, instead of:You can simply do:You can import & use any attribute contained in  dictionary, in the same fashion.


Answer URL
https://docs.python.org/3/reference/import.html#submodules
https://docs.python.org/3/tutorial/modules.html#packages
https://docs.python.org/3/reference/import.html
https://docs.python.org/3/library/importlib.html#module-importlib
