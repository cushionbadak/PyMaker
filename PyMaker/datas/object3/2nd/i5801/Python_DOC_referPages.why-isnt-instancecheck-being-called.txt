Natural Text
I have the following python3 code:and when I run it on  I get the following outputWhy isn't it outputting ? The documentation says the  method needs to be defined on the metaclass and not the class itself, which I have done here. I even verify the metaclass is being used since  is printed. However, when I call  it appears to be using the default implementation and not the one I defined in the metaclass.I'm probably not using metaclasses correctly, but I can't figure out where I made my mistake.
The  function makes a quick check to see if the type of the instance supplied as an argument is the same as that of the class. If so, it returns early and doesn't invoke your custom . This is an optimization used in order to avoid an expensive call to  (it's Pythonland code) when it isn't required. You can see the specific test in , the function that handles the  call in the CPython implementation:Of course, your  fires correctly when that test isn't :I am not certain if this is implementation specific, I would of thought so, though, since there's no reference to this in the corresponding PEP section nor in the documentation on .Interesting aside:  actually doesn't behave this way. Due to its implementation it always calls . I had opened an issue on this a while back which is still pending. 
Jim's answer seems to nail it.But for whoever needs for some weid reason a fully customizedinstancheck (ok, now that I am writing this, there seems to beno correct reason for one to want that, let s hope I am wrong), a metaclass can getaway with it, but it is tricky. This one dynamically replaces the actual class of the object being instantiated by a "shadow class", thatis a clone of the original. This way, the native "instancheck" alwaysfail, and the metaclass one is called.It even has a mechanism do sync attributes in the shadow class and actual class. The one thing it does not support is if classes handled in this way do implement a custom . If such a   makes use of parameterless , it starts to become tricky, as the parameter to super would not be the shadow class. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks
https://docs.python.org/3/reference/datamodel.html#customizing-instance-and-subclass-checks
