Natural Text
TL;DR is what I'm trying to do too complicated for a yield-based generator?I have a python application where I need to repeat an expensive test on a list of objects, one at a time, and then mangle those that pass.  I expect several objects to pass, but I do not want to create a list of all those that pass, as mangle will alter the state of some of the other objects. There is no requirement to test in any particular order. Then rinse and repeat until some stop condition.My first simple implementation was this, which runs logically correctlyunfortunately,  always restarts at the beginning of the list, where the objects probably haven't been changed, and there are objects at the end of the list ready to test. Picking them at random would be slightly better, but I would rather carry on where I left off from the previous for/in call. I still want the for/in call to terminate when it's traversed the entire list.This sounded like a job for yield, but I tied my brain in knots failing to make it do what I wanted. I can use it in the simple cases, iterating over a range or returning filtered records from some source, but I couldn't find out how to make it save state and restart reading from its source.I can often do things the long wordy way with classes, but fail to understand how to use the alleged simplifications like yield. Here is a solution that does exactly what I want.which demonstrates the desired behaviourFinally, the question. Is it possible to do what I want with the simplified generator syntax using yield, or does maintaining state between successive for/in calls require the full class syntax?
Your use of the  method causes your iterator to be reset. This actually goes quite counter to regular behaviour of an iterator; the  method should just return , nothing more. You rely on a side effect of  applying  to your iterator each time you create a  loop. This makes your iterator work, but the behaviour is surprising and will trip up future maintainers. I'd prefer that effect to be split out to a separate  method, for example.You can reset a generator too, using  to signal it to reset:Now you can 'reset' your count back to zero:This is however, rather.. counter to readability. I'd instead use an infinite generator by using  that is limited in the number of iterations with : will produce values from  in an endless loop.  cuts off iteration after  elements. But because  is reused, it is still maintaining the iteration state.If you must have a dedicated iterator, stick to a class object and make an iterable, so have it return a new iterator each time  is called:This keeps state in the  iterator still, but simply creates a new  object each time you create an iterator for this. It basically encapsulates the  approach above.


Answer URL
https://docs.python.org/3/library/stdtypes.html#iterator-types
https://docs.python.org/3/reference/expressions.html#generator.send
https://docs.python.org/3/library/itertools.html#itertools.cycle
https://docs.python.org/3/library/itertools.html#itertools.islice
