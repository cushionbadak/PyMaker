Natural Text
I want to store an array of epoch time as numpy array of dtype32. I expect to lose accuracy, but not 30 seconds difference!Can someone explain what is happening? How can I store epoch time as float32 without losing accuracy?
Seconds since epoch is a big number. Currently, it's about 1.5e9. You get precision errors that are in the 10s at this range.First off, you're calling  twice, which is exacerbating the time difference---the methods obviously take time to call. The better way to see your error would be to store the time:You can see the actual decimal number stored by getting the string representation from numpy:Remember, a digit is not a bit---just 0s and 1s are bits. In a 32-bit float, you're storing the number in scientific notation, but in binary. This kills the accuracy. The range of values expressible as a 32-bit float is -3.4e38 to +3.4e38. There are 2^32 numbers expressible with 32 bits...so clearly, you're missing a ton of (infinitely many...) possible numbers in the 32-bit float range.There are two super easy solutions. First, if you don't care about sub-seconds...then just store it as an integer. Epoch time won't even hit 32-bit max until 2038. (Hello to SO users in 2037 worried about the Year 2038 Problem. Is Wikipedia still a thing?)Of course if you want some more decimal precision...multiply by 10, or 100, or 1000 before casting as an int. Well, you can accumulate errors doing this but with 64-bit floats you should be okay.The second way to deal with this is to just store a new epoch time, and take the difference with the times you want to save in the array. The error with these smaller numbers will be far into the decimal range.Then just save  in 64-bit glory along with your 32-bit float array of times so you know how to convert back.However, do note that, from the Python  module docs:even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second.Also I do highly recommend David Goldberg's famous article What every computer scientist should know about floating-point arithmetic. Even just the first few pages give a great overview on floating-point arithmetic and how to calculate the size of your approximation errors!


Answer URL
https://docs.python.org/3/library/time.html#time.time
