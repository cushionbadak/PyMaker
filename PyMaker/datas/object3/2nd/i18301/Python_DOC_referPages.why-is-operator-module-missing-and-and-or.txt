Natural Text
operator module makes it easy to avoid unnecessary functions and lambdasin situations like this:Well, now I need to do , but to my surprise, I can't find  in the operator module!  And the same applies to !  I know,  is not exactly operator, it's a keyword, but , along with  and even , are all keywords and all are included.So what's the story?  Why are they missing?
Because you cannot convert boolean operators into python functions. Functions always evaluate their arguments, and boolean operators do not. Adding  and  to the operators module would also require adding a special kind of functions (like lisp "macros") that evaluate their arguments on demand. Obviously, this is not something python designers ever wanted. Consider:you cannot write this in a functional form. An attempt likewill fail if  is actually .
You can write these yourself, but you'll need to pass a function (e.g. lambda) for the second argument to prevent it from being evaluated at call time, assuming that the usual short-circuiting behavior is important to you.Usage:
The reason there's no  is that  is a keyword, so that would be a . As tgh435 explained, the reason there's no renamed  function in  is that it would be misleading: a function call always evaluates its operands, but the  operator doesn't. (It would also be an exception to an otherwise consistent and simple rule.)In your case, it looks like you don't actually care about short-circuiting at all, so can build your own version trivially:Or, if you're just using it once, even inline:In some cases, it's worth looking at  (and, for , ). It is effectively short-circuited  expanded to arbitrary operands. Of course it has a different API than the  functions, taking a single iterable of operands instead of two separate operands. And the way it short-circuits is different; it just stops iterating the iterable, which only helps if you've set things up so the iterable is only evaluating things as needed. So, it's usually not usable as a drop-in replacementâ€”but it's sometimes usable if you refactor your code a bit.
Python's  and  syntaxes cannot directly be mapped to functions. These syntaxes are lazy evaluated: If the result of the left part of the expression allows to know the value of the whole expression, the right part is skipped. Since they introduce flow control, their behavior cannot be reproduced using an operator.To reduce confusion, python have chosen to simply not provide these methods.georg gives a good example of a situation where  laziness matters:Now, if you don't need lazy evaluation, you can use abarnert's answer implementation:Usage:If you need lazy evaluation, you can use kindall's answer implementation:Usage:Note:As mentioned in the comments, the functions  and  correspond to the bitwise operators  and . See: https://docs.python.org/3/library/operator.html#mapping-operators-to-functionsNote that the names  and  aren't used:  and  are Python keywords so it would be a syntax error.


Answer URL
https://docs.python.org/3/library/operator.html#mapping-operators-to-functions
