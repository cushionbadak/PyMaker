Natural Text
I am having a hard time keeping track of the tiles generated by . I have identified the performance issue of my A* implementation below is that I do not keep track of the tiles that have seen before, every call to  returns new tiles ('s) and not any of the tiles in  or . I decided to use a list of Node objects as all of the tiles created so far, and pass that to  to determine if a tile it produces has already been visited. My problem is, that I cannot seem to keep track of these tiles properly. Whenever my A* needs to take more than about 4 movements to get to the  location it craps out. Which I am sure has to do with how I am trying to keep track of the tiles (again 's that have been visited) I would have to suspect the issue is with my knowledge of python, am I allowed to do  like I do in  when looping through the  set?Here's a link to the question that led me to this oneThe error generated (sometimes, only when the A* path is longer than about 3 steps..)Source
Let's fire up the interactive interpreter and see what we can find. (You didn't give the name of your class in the question, so I've called it .)OK, the first problem is that these  instances are not self-explanatory. We can't do anything with "Node instance at 0x104895518", so let's add a  method to the  class:and try again:OK, that's more informative. Let's fire up the Python debugger and do a postmortem:So the node has already been closed. How could this have happened? Well, it could happen if the node had been added to  and  twice. It would then be popped from  twice (because heaps can have multiple identical items), but it can only be removed from  once. The code in question looks like this:The first problem with this, is that you push the pair  even though you've gone to the trouble to give your  objects  and  methods. Instead, just push  onto the heap:This requires a couple of changes elsewhere: instead ofyou'll have to writeNow, the second problem (which is my faultâ€”sorry), is that if  is already in  then we shouldn't add it to the heap again. Instead, we should re-heapify:Going back to the debugger output, recall this:That  should be worrying you: shouldn't the cost always be an integer? It looks as though the cost calculation is still wrong. It says:but that third line should say:So, with all those fixes in place, let's try again:Replies to comments"How did you call  from the interpreter?" I ran the interpreter and then typed in that line of code at the interpreter prompt. See the tutorial."So the Euclidean distance will always be one." Yes, if you're searching for paths in a uniform-cost grid, then the Euclidean distance between neighbours will always be the same."Now that I think about it,  is always equal to zero." That's not right. In your implementation, the  of a search node is (i) the cost of reaching that node from the start, plus (ii) an admissible estimate of the cost of reaching the end from that node. So if you subtract the admissible estimate then you should get back to (i) again.


Answer URL
