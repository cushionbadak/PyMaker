Natural Text
I have spent the past 3 hours reading posts here explaining exactly the problem I am having, but none of the solutions are working.These posts did NOT work:Changing one list unexpectedly changes another, tooChanging One dict value changes all valuesI have a python module where I have have a specific shape of 2D array I need to initialize the entries in a dictionary with. Here is how I have done it:(Shape of list simplified for example)This prints:As you can see, setting one of the lists values changes all of the lists. I do not want this, I want them to be separate lists (in one dictionary) with different values. Initially, I thought I had done the old  blunder where I set newlist to the same object as oldlist, but nope. As you can see in my code, I am making separate lists using . I have also tried , , etc etc.What am I missing? Thank you so much for taking the time to look this question over, I appreciate any input.
you were close with the copy, but you actually neeed a deepcopy
As I said earlier,  does create a new list, but the inner lists of that new list are just references to the same list objects in .You can use , but I think it's simpler just to build new lists when you need them. The  function jumps through various hoops that are required to copy arbitrarily deep nested objects that can contain anything. But why bother going through all that stuff when you have a structure that's simple to just build from scratch?Using a list comprehension, your code can be written like this:It's safe to do  for the innermost lists: it's always safe to share immutable objects (booleans, integers, strings, etc). The problem only arises when you unexpectedly share a mutatable object and you mutate its value instead of replacing it with a new object. To avoid re-writing that list comp, you can use a function to build the lists for you. Eg,output
You can see that the first element of your  list is shared across all the values in your dictionary:They each share the same memory location.  The same is also true for the second item in the empty list, The reason for this is your assignment of your  list to each value.  You can either perform a deep copy this empty, nested list, or else use a list comprehension to generate new ones for each key in your dictionary.  This list comprehension for the empty list creation is itself done within a dictionary comprehension to generate your  variable for all the required keys.Now you can change any element without it affecting the others.
I think what you need is a deep copy, see documentation of copy.deepcopy()


Answer URL
https://docs.python.org/3/library/copy.html#copy.deepcopy
https://docs.python.org/3/library/copy.html
