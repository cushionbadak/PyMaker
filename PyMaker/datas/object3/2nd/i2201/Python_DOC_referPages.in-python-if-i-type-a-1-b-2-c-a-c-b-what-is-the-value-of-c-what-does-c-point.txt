Natural Text
Python variables are for the most part really easy to understand, but there is one case I have been struggling with. If I want to point my variable to a new memory address, how do I do this? Or, if Python does this by default (treating variables like pointers), then how do I literally assign the value from a new variable to the memory address of the old variable?For example, if I typeWhat is the value of ? And what does it point to? Is the statement replacing the pointer  with pointer  or grabbing the value from  and overwriting  with 's value?  is ambiguous.In other words, if you start with this:is it re-pointing  like this:or copying  like this?
Well, in your code:Before you assign  to 's value and after you assign  to 's value,  will be .And after, at the end of the code,  will be , because you're reassigning the variable.The second assignment, basically creates new variable, without knowing that the variable is there already, so it will just do it but no way of accessing previous holding-value of the varaible
There are no pointers to variables in Python. In particular, when you say this:Is the statement replacing the pointer  with pointer ...Python does not have any such thing as "the pointer ", so it is not doing that....or grabbing the value from b and overwriting a with b's valuebut there is no assignment to , so it's not doing that either.Instead, Python keeps a symbol table1 that maps each name (, , , etc.) to a pointer to an object. In your code sample, after you assign to  and , it would look like this (obviously I have made up the memory addresses):and then after you assign , it would look like this:Note that  is entirely independent of . When you run , it replaces the pointer associated with  in the symbol table with the pointer that was associated with , but  is not affected:In this case that's pretty much all there is to it because the objects in question, namely the integer constants  and , are immutable. However, if you use mutable objects, they do start to act a bit more like pointers in the sense that changes to the object when it's stored in one variable are reflected in other variables that refer to the same object. For example, consider this sample of code:Here, the symbol table might look something like this:If you now runthen it doesn't actually change the pointer associated with  in the symbol table, but it does change the object pointed to by that pointer, so you wind up withand you'll see that your assignment to  has affected  as well. Contrast this withwhich actually makes  point at an entirely different object, and is more akin to what you were doing before with , , and .1Actually there are several symbol tables, corresponding to different scopes, and Python has an order in which it checks them, but that detail isn't particularly relevant here.
 doesn't "Point at  or "... it points at the  or  objects.This can be proven somewhat with  -  and  point at the same "thing":
Answering both of your question at once What is the value of c? What does c point to?, I've added an step by step execution with the  of each variable with proper comment. Hope this helps you understand properly what is happening under the hood.
Well my friend, in this example if  is pointing to , it'll appear like they are pointing at the same value but not, for example if you're pointingthen after this declaration, if you change the value of ,  will change it's value to  also.Imagine those variables values  in boxes and the variables  are just pointing to those boxes.If one variable  is pointing to one box, and the other variable  is pointing to the variable  that is pointing to the box , the last variable  is just following the first variable , not the value , hope this explanation gets you happy.
So to summarize a few of the really good answers I saw from others,Values are objects at a memory location without a name.Variables (variable names/labels) have no intrinsic value. They are separate objects with their own space in memory, and they can point to any value objects.The Assignment operator points a label object to a value object.Let's inaccurately go step by step through the assignment operation from the point of view of the Python interpreter:First, we create a value.Note: [ ] denotes a physical memory location. This means the value has its own unique memory address.Next, we create a label.Last, we assign the label to its value.So,is the same asandis same as 
Basically, in the fourth line c variable is being overwritten by the value of b. As this is the last statement, c will hold the value of 2. 
What you've encountered is reference duplication in Python. To quote from copy module documentation:Assignment statements in Python do not copy objects, they create bindings between a target and an objectYou can observe how that  works in practice if you think in terms of objects and their values, and use  operator and  built-in function:Among other things you can verify exactly the same via references count:Tangentially, this is related to deep and shallow copying. Again from copy documentation:The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.Your example uses simple variables and they will always default to reference duplication - no new objects no matter if you try to deep copy them:However, if you try to assign tuples or lists, the story is different:In the above example, you get an entirely different object. Why this might be useful ? The fact that simple assignment just makes two variables reference same object also implies that if you change one , changes get reflected in the other. This can be impractical when you want to keep original data. When you want to have two same objects initially, but then let them change in their own way - that's where you want to have either shallow copy for just object itself or deep copy for all objects that are contained within the object:And just for demo purposes, shallow copy:See also grc's excellent answer on the same topic with better examples.


Answer URL
https://docs.python.org/3/reference/executionmodel.html
https://docs.python.org/3/library/functions.html#id
