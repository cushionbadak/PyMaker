Natural Text
How do I get it to pick 5 random numbers between (0,50), then 2 random numbers between(0,12)?
You can vary the second argument to  based on the value of :The  expression will change what is passed to  for the last two iterations.There are many more variations you can spell this in. List comprehensions are a bunch of loops and  filters that repeatedly execute the expression at the front. There are lots of ways to spell vary the arguments to a function call based on the iteration values in expressions.For example, you could record those arguments in  objects:The possibilities are endless. Lambdas, , , a function that'll vary its results depending on how often it has been called, etc. But I wouldn't argue that any of these are actually more readable or understandable.For this case, with just 7 values, I'd just concatenate the two lists:as it's just cleaner and more readable. The small performance cost of creating a 3rd list that contains the results of the two list comprehensions is negligible here.
Something like this maybe, concatenating 2 lists:
Don't reuse the name .  One way would be to loop through an iterable of the bounds, and send those to You could also use  and  to avoid building that list of bounds

Here's another variation that avoids doing an  test on every iteration. It also uses , which is slightly more efficient than .typical outputThis is equivalent toThe outer loop selects , the number of items in the sublist, and  the size of the random range for that sublist; the inner loop generates the required amount of random numbers in the desired range.FWIW, here's some  code comparing the various algorithms that have been submitted. It also verifies that they produce the same results when given the same random seed. My simple verification code uses , so it can only test expressions, not statements, so it can't test jpp's or Abhishek's code; besides, jpp's Numpy code gives different results anyway, since it uses a different seeding algorithm. Please see the  docs for info on what  does, and how to interpret the results.typical outputAs you can see, jpp's Numpy code is the fastest. I expect that the speed difference would be even more apparent if we were generating a longer list of numbers.These timing were performed on an ancient 32 bit single core 2GHz machine, running Python 3.6.0 on a Debian derivative distro. YMMV.Here are timings for the production of lists (or arrays) of 50 + 20 = 70 values in the same ranges.
If you are happy using a 3rd party library, you can via NumPy:The benefit of this method, memory pre-allocation, will be evident with larger arrays.

You can do this using list-comprehensions and only built-ins, some monstrosity like:Perhaps, if you want to use itertools, you can do something like:Both of these approaches are hardly readable and simple. Instead, I would personally go with two for-loops, the naive approach. It would be efficient, simple, and readable. Other than showboating, I see no advantage to the above approaches in production code.


Answer URL
https://docs.python.org/3/library/functools.html#functools.partial
https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat
