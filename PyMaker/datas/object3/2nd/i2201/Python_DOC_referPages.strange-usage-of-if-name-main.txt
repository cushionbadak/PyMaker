Natural Text
What does the  do?
Whenever the Python interpreter reads a source file, it does two things:it sets a few special variables like , and thenit executes all of the code found in the file.Let's see how this works and how it relates to your question about the  checks we always see in Python scripts.Code SampleLet's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called .Special VariablesWhen the Python interpeter reads a source file, it first defines a few special variables. In this case, we care about the  variable.When Your Module Is the Main ProgramIf you are running your module (the source file) as the main program, e.g.the interpreter will assign the hard-coded string  to the  variable, i.e.When Your Module Is Imported By AnotherOn the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:In this case, the interpreter will look at the filename of your module, , strip off the , and assign that string to your module's  variable, i.e.Executing the Module's CodeAfter the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.AlwaysIt prints the string  (without quotes).It loads the  module and assigns it to a variable called . This is equivalent to replacing  with the following (note that  is a low-level function in Python that takes a string and triggers the actual import):It prints the string .It executes the  block, creating a function object, then assigning that function object to a variable called .It prints the string .It executes the second  block, creating another function object, then assigning it to a variable called .It prints the string .Only When Your Module Is the Main ProgramIf your module is the main program, then it will see that  was indeed set to  and it calls the two functions, printing the strings  and .Only When Your Module Is Imported by Another(instead) If your module is not the main program but was imported by another one, then  will be , not , and it'll skip the body of the  statement.AlwaysIt will print the string  in both situations.SummaryIn summary, here's what'd be printed in the two cases:Why Does It Work This Way?You might naturally wonder why anybody would want this.  Well, sometimes you want to write a  file that can be both used by other programs and modules as a module and can be run as the main program.  Examples:Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing  files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. "Running" the script is a side effect of importing the script's module.Food for ThoughtQuestion: Can I have multiple  checking blocks?  Answer: it's strange to do so, but the language won't stop you.Suppose the following is in .  What happens if you say  on the command-line? Why?Now, figure out what will happen if you remove the  check in :What will this do when used as a script?  When imported as a module?
When your script is run by passing it as a command to the Python interpreter,all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no  function that gets run automatically - the  function is implicitly all the code at the top level.In this case, the top-level code is an  block.   is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in  above), then  instead is set to the string .  Thus, you can test whether your script is being run directly or being imported by something else by testingIf your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the  clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:Now, if you invoke the interpreter asThe output will beIf you run  instead:You getThus, when module  gets loaded, its  equals  instead of .
The simplest explanation for the  variable (imho) is the following:Create the following files.andRunning them will get you this output:As you can see, when a module is imported, Python sets  in this module to the module's name. Also, upon import all the code in the module is being run. As the  statement evaluates to  this part is not executed.As you can see, when a file is executed, Python sets  in this file to . This time, the  statement evaluates to  and is being run.
What does the  do?To outline the basics:The global variable, , in the module that is the entry point to your program, is . Otherwise, it's the name you import the module by.So, code under the  block will only run if the module is the entry point to your program.It allows the code in the module to be importable by other modules, without executing the code block beneath on import.Why do we need this?Developing and Testing Your CodeSay you're writing a Python script designed to be used as a module:You could test the module by adding this call of the function to the bottom:and running it (on a command prompt) with something like:The ProblemHowever, if you want to import the module to another script:On import, the  function would be called, so you'd probably comment out your function call, , at the bottom. And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.A Better WayThe  variable points to the namespace wherever the Python interpreter happens to be at the moment. Inside an imported module, it's the name of that module. But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its .So if you check before executing:With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script). An Even Better WayThere's a Pythonic way to improve on this, though. What if we want to run this business process from outside the module?If we put the code we want to exercise as we develop and test in a function like this and then do our check for  immediately after:We now have a final function for the end of our module that will run if we run the module as the primary module. It will allow the module and its functions and classes to be imported into other scripts without running the  function, and will also allow the module (and its functions and classes) to be called when running from a different  module, i.e.This idiom can also be found in the Python documentation in an explanation of the  module. That text states:This module represents the (otherwise anonymous) scope in which the  interpreter’s main program executes — commands read either from  standard input, from a script file, or from an interactive prompt. It  is this environment in which the idiomatic “conditional script” stanza  causes a script to run:
 is the part that runs when the script is run from (say) the command line using a command like .
What does  do? is a global variable (in Python, global actually means on the module level) that exists in all namespaces. It is typically the module's name (as a  type).As the only special case, however, in whatever Python process you run, as in mycode.py:the otherwise anonymous global namespace is assigned the value of  to its . Thus, including the final linesat the end of your mycode.py script,when it is the primary, entry-point module that is run by a Python process, will cause your script's uniquely defined  function to run. Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:
There are lots of different takes here on the mechanics of the code in question, the "How", but for me none of it made sense until I understood the "Why". This should be especially helpful for new programmers.Take file "ab.py":And a second file "xy.py":What is this code actually doing?When you execute , you . The import statement runs the module immediately on import, so 's operations get executed before the remainder of 's. Once finished with , it continues with .The interpreter keeps track of which scripts are running with . When you run a script - no matter what you've named it - the interpreter calls it , making it the master or 'home' script that gets returned to after running an external script.Any other script that's called from this  script is assigned its filename as its  (e.g., ). Hence, the line  is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or  - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:Open xy.py as the 'home' file; call it  in the  variable.Import and open file with the .Oh, a function. I'll remember that.Ok, function ; I just learned that. Printing 'A function in ab file'.End of file; back to !Oh, a function. I'll remember that.Another one.Function ; ok, printing 'peripheral task: might be useful in other projects'.What's this? An  statement. Well, the condition has been met (the variable  has been set to ), so I'll enter the  function and print 'main function: this is where the action is'.The bottom two lines mean: "If this is the  or 'home' script, execute the function called ". That's why you'll see a  block up top, which contains the main flow of the script's functionality.Why implement this?Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the  function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.Again, there will be exceptions, but common practice is that  doesn't usually get called externally. So you may be wondering one more thing: if we're not calling , why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:But the code works without itYes, that's right. These separate functions can be called from an in-line script that's not contained inside a  function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, "example.py" might import "xy.py" and call , making use of the 'x' function from "xy.py". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)(As an aside, this question contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of this one, which I think is a mistake.)
When there are certain statements in our module () we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this  block.As by default (when module running as main, not imported) the  variable is set to , and when it'll be imported the  variable will get a different value, most probably the name of the module ().This is helpful in running different variants of a modules together, and separating their specific input & output statements and also if there are any test-cases.In short, use this ' ' block to prevent (certain) code from being run when the module is imported.
Let's look at the answer in a more abstract way:Suppose we have this code in x.py:Blocks A and B are run when we are running "x.py".But just block A (and not B) is run when we are running another module, "y.py" for example, in which x.y is imported and the code is run from there (like when a function in "x.py" is called from y.py).
Put simply,  is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.So if we have two scripts;andThe output from executing script1 isAnd the output from executing script2 is:As you can see,  tells us which code is the 'main' module.This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the   context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:You write a module, and if someone wants to use your code they just import it and the  variable can help to separate the executable portion of the program from the library part.
When you run Python interactively the local  variable is assigned a value of . Likewise, when you execute a Python module from the command line, rather than importing it into another module, its  attribute is assigned a value of , rather than the actual name of the module. In this way, modules can look at their own  value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:
Consider:It checks if the  attribute of the Python script is . In other words, if the program itself is executed, the attribute will be , so the program will be executed (in this case the  function).However, if your Python script is used by a module, any code outside of the  statement will be executed, so  is used just to check if the program is used as a module or not, and therefore decides whether to run the code.
Before explaining anything about  it is important to understand what  is and what it does.What is ? is a DunderAlias - can be thought of as a global variable (accessible from modules) and works in a similar way to .It is a string (global as mentioned above) as indicated by  (yielding ), and is an inbuilt standard for both Python 3 and Python 2 versions.Where:It can not only be used in scripts but can also be found in both the interpreter and modules/packages.  Interpreter:Script:test_file.py:Resulting in Module or package:somefile.py:test_file.py:Resulting in Notice that when used in a package or module,  takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias , that allows for this.You should see that, where , where it is the main file (or program) will always return , and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.Practice:Being a variable means that it's value can be overwritten ("can" does not mean "should"), overwriting the value of  will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.It is always assumed that the value of  to be  or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.example:It is considered good practice in general to include the  in scripts.Now to answer :Now we know the behaviour of  things become clearer:An  is a flow control statement that contains the block of code will execute if the value given is true. We have seen that  can take either  or the file name it has been imported from.  This means that if  is equal to  then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.If indeed  does take the value of  then whatever is in that block of code will execute.This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be .Modules: can also be used in modules to define the name of a moduleVariants: It is also possible to do other, less common but useful things with , some I will show here:Executing only if the file is a module or package:Running one condition if the file is the main one and another if it is not:You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.It also allows modules to be run from the command line as main scripts, which can be also very useful.
I think it's best to break the answer in depth and in simple words:: Every module in Python has a special attribute called .It is a built-in variable that returns the name of the module.: Like other programming languages, Python too has an execution entry point, i.e., main.  is the name of the scope in which top-level code executes. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its  is set to .Thus, the value of the  attribute is set to  when the module is run as the main program. Otherwise the value of   is set to contain the name of the module.
It is a special for when a Python file is called from the command line. This is typically used to call a "main()" function or execute other appropriate startup code, like commandline arguments handling for instance.It could be written in several ways. Another is:I am not saying you should use this in production code, but it serves to illustrate that there is nothing "magical" about . It is a good convention for invoking a main function in Python files.
There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the __name__ variable/attribute:When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)Before the interpreter executes the source code file though, it defines a few special variables for that file; __name__ is one of those special variables that Python automatically defines for each source code file.If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special __name__ variable for this file to have a value "__main__".If this is being imported from another module, __name__ will be set to that module's name.So, in your example in part:means that the code block:will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of __name__ will not equal to "main" in that particular instance.Hope this helps out.
 is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first'). is the name of the scope in which top-level code executes. A module’s  is set equal to  when read from standard input, a script, or from an interactive prompt.
The reason foris primarily to avoid the import lock problems that would arise from having code directly imported. You want  to run if your file was directly invoked (that's the  case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using  as the entry point, but you don't have to. While  expects , other tools use alternate entry points. For example, to run your file as a  process, you define an  function instead of a . Just as with ,  imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).
I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.To be short, you need to know several points: action actually runs all that can be ran in "a"Because of point 1, you may not want everything to be run in "a" when importing itTo solve the problem in point 2, python allows you to put a condition check is an implicit variable in all .py modules; when a.py is imported, the value of  of a.py module is set to its file name "a"; when a.py is run directly using "python a.py", which means a.py is the entry point, then the value of  of a.py module is set to a string Based on the mechanism how python sets the variable  for each module, do you know how to achieve point 3? The answer is fairly easy, right? Put a if condition: ; you can even put if  depending on your functional needThe important thing that python is special at is point 4! The rest is just basic logic.
You can make the file usable as a script as well as an importable module.fibo.py (a module named )Reference: https://docs.python.org/3.5/tutorial/modules.html
Consider:The output for the above is .The above statement is true and prints "direct method". Suppose if they imported this class in another class it doesn't print "direct method" because, while importing, it will set .
This answer is for Java programmers learning Python.Every Java file typically contains one public class. You can use that class in two ways: Call the class from other files. You just have to import it in the calling program.Run the class stand alone, for testing purposes. For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label .
If this .py file are imported by other .py files, the code under "the if statement" will not be executed.If this .py are run by  under shell, or double clicked in Windows. the code under "the if statement" will be executed.It is usually written for testing.
Create a file, a.py: is always equal to  whenever that file is run directly showing that this is the main file.Create another file, b.py, in the same directory:Run it. It will print a, i.e., the name of the file which is imported.So, to show two different behavior of the same file, this is a commonly used trick:
if name == 'main':We see if  quite often.It checks if a module is being imported or not.In other words, the code within the  block will be executed only when the code runs directly. Here  means .Let's see what it does using a simple code that prints the name of the module:If we run the code directly via , the module name is :
All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the "import b.py" code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely.In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it.So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed.
Simply it is the entry point to run the file like the  function in the C programming language.


Answer URL
https://docs.python.org/3/library/__main__.html
https://docs.python.org/3/tutorial/controlflow.html#if-statements
