Natural Text
Is output buffering enabled by default in Python's interpreter for ?If the answer is positive, what are all the ways to disable it?Suggestions so far:Use the  command line switchWrap  in an object that flushes after every writeSet  env varIs there any other way to set some global flag in / programmatically during execution?
From Magnus Lycka answer on a mailing list:You can skip buffering for a whole  python process using "python -u"   (or#!/usr/bin/env python -u etc) or by  setting the environment variable  PYTHONUNBUFFERED.You could also replace sys.stdout with  some other stream like wrapper which  does a flush after every call.
I would rather put my answer in How to flush output of Python print? or in Python's print function that flushes the buffer when it's called?, but since they were marked as duplicates of this one (what I do not agree), I'll answer it here.Since Python 3.3 print() supports the keyword argument "flush" (see documentation):
Credits: "Sebastian", somewhere on the Python mailing list.3rd Party EDITUnsupported in recent versions of Python 3
Yes, it is.You can disable it on the commandline with the "-u" switch.Alternatively, you could call .flush() on sys.stdout on every write (or wrap it with an object that does this automatically)
Without saving the old sys.stdout, disable_stdout_buffering() isn't idempotent, and multiple calls will result in an error like this:Another possibility is:(Appending to gc.garbage is not such a good idea because it's where unfreeable cycles get put, and you might want to check for those.)
This relates to  Cristóvão D. Sousa's answer, but I couldn't comment yet.A straight-forward way of using the  keyword argument of Python 3 in order to always have unbuffered output is:afterwards, print will always flush the output directly (except  is given).Note, (a) that this answers the question only partially as it doesn't redirect all the output. But I guess  is the most common way for creating output to / in python, so these 2 lines cover probably most of the use cases.Note (b) that it only works in the module/script where you defined it. This can be good when writing a module as it doesn't mess with the .Python 2 doesn't provide the  argument, but you could emulate a Python 3-type  function as described here https://stackoverflow.com/a/27991478/3734258 .
The following works in Python 2.6, 2.7, and 3.2:
Yes, it is enabled by default. You can disable it by using the -u option on the command line when calling python.
You can also run Python with stdbuf utility:
You can also use fcntl to change the file flags in-fly.
Variant that works without crashing (at least on win32; python 2.7, ipython 0.12) then called subsequently (multiple times):
(I've posted a comment, but it got lost somehow. So, again:)As I noticed, CPython (at least on Linux) behaves differently depending on where the output goes. If it goes to a tty, then the output is flushed after each 'If it goes to a pipe/process, then it is buffered and you can use the  based solutions or the -u option recommended above.Slightly related to output buffering:If you iterate over the lines in the input with...then the for implementation in CPython will collect the input for a while and then execute the loop body for a bunch of input lines. If your script is about to write output for each input line, this might look like output buffering but it's actually batching, and therefore, none of the , etc. techniques will help that.Interestingly, you don't have this behaviour in pypy.To avoid this, you can use...
It is possible to override only  method of  with one that calls . Suggested method implementation is below.Default value of  argument will keep original  method reference. After  is defined, the original  might be overridden.The code assumes that  is imported this way .
You can create an unbuffered file and assign this file to sys.stdout.You can't magically change the system-supplied stdout; since it's supplied to your python program by the OS.
One way to get unbuffered output would be to use  instead of  or to simply call  to explicitly force a write to occur.You could easily redirect everything printed by doing:Or to redirect just for a particular  statement:To reset stdout you can just do:
In Python 3, you can monkey-patch the print function, to always send flush=True:


Answer URL
