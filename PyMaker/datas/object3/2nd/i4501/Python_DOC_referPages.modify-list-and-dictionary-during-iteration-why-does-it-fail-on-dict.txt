Natural Text
Let's consider this code which iterates over a list while removing an item each iteration:It will print . Only the first three elements are printed since the last two elements in the list were removed by the first two iterations.But if you try something similar on a dict:It will print , then raise , because we are removing a key from the dictionary while iterating over it.Of course, modifying a list during iteration is bad. But why is a  not raised as in the case of dictionary? Is there any good reason for this behaviour?
I think the reason is simple. s are ordered, s (prior to Python 3.6/3.7) and s are not. So modifying a s as you iterate may be not advised as best practise, but it leads to consistent, reproducible, and guaranteed behaviour.You could use this, for example let's say you wanted to split a  with an even number of elements in half and reverse the 2nd half:Of course, there are much better and more intuitive ways to perform this operation, but the point is it works.By contrast, the behaviour for s and s is totally implementation specific since the iteration order may change depending on the hashing.You get a  with , presumably for consistency with the  behaviour. I don't think any change in the  behaviour is likely after Python 3.6 (where s are guaranteed to maintain insertion ordered) since it would break backward compatibility for no real use cases.Note that  also raises a  in this case, despite being ordered.
It wouldn't have been possible to add such a check to lists without breaking backward compatibility. For dicts, there was no such issue.In the old, pre-iterators design,  loops worked by calling the sequence element retrieval hook with increasing integer indices until it raised IndexError. (I would say , but this was back before type/class unification, so C types didn't have .)  isn't even involved in this design, and there is nowhere to check for modification.When iterators were introduced, the dict iterator had the size change check from the very first commit that introduced iterators to the language. Dicts weren't iterable at all before that, so there was no backward compatibility to break. Lists still went through the old iteration protocol, though.When  was introduced, it was purely a speed optimization, not intended to be a behavioral change, and adding a modification check would have broken backward compatibility with existing code that relied on the old behavior.
Dictionary uses insertion order with an additional level of indirection, which causes hiccups when iterating while keys are removed and re-inserted, thereby changing the order and internal pointers of the dictionary.And this problem is not fixed by iterating  instead of , since in Python 3,  returns a dynamic view of the keys in the  which results in the same problem. Instead, iterate over  as this will produce a list from the keys of the dictionary that will not change during iteration


Answer URL
https://docs.python.org/3/reference/compound_stmts.html#for
