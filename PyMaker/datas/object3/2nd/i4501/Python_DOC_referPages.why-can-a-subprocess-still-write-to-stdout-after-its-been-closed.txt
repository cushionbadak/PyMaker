Natural Text
I found this piece of code in the  documentation, where one process's stdout is being piped into another process:And I'm confused by that  call. Surely closing the stdout handle prevents the process from producing any output?So I ran an experiment, and to my surprise the process wasn't affected by it at all:What's going on here? Why can the process write to a closed pipe?
Closing a file decriptor just means decrementing a reference count (inside the operating system kernel). The descriptor number becomes invalid, but nothing happens to the object it refers to unless the reference count hits zero.Inside the  calls, operations are taking place which duplicate the file descriptor, thereby increasing the reference count: operations like / and .If we  a child process which receives a file descriptor from the parent, that file descriptor is a duplicate which points to the same object. If the parent closes its original copy of that descriptor, that doesn't affect the one in the child. And vice versa. Only if both the parent and child close that descriptor does the underlying open file/device object go away; and only if there are no additional descriptors referencing it.This is true even though the descriptors have the same number; each process has its own table of file descriptor numbers. File descriptor 3 in a child is  different from the 3 in the parent.
Each process has its own set of file descriptors.  You can (and should) close the parent’s copy once you don’t need it; the actual pipe (endpoint) survives until the last process (presumably ) closes it.  Only then does a process trying to write to the (other end of the) pipe get .If you don’t close it, the possibility remains that the parent will read from it even after  exits, which will needlessly keep  alive (and can cause deadlock if the parent s on it).


Answer URL
https://docs.python.org/3/library/subprocess.html#replacing-shell-pipeline
