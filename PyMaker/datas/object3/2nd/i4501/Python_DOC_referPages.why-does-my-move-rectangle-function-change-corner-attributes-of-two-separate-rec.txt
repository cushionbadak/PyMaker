Natural Text
Disclaimer: This is not homework or anything related to a school assignment. This is purely me trying to better understand how programming with classes (and making shallow/ deep copies of class instances) works. So I wrote two classes:  and . Here I'm creating two Rectangle objects:  and .When I invoke the  method and run my code (which I will attempt to post here), it's supposed to return a deep copy of  (the returned value of which is assigned to ). When I check if: , it returns  (which I expected), but when I check the x-coordinates of both  and , both of their x-values were changed. This is what I expected:Instead, I got: How can that be if box is supposed to be a separate object from ? Any help/ tips/ advice is greatly appreciated!Here's my code: 
The  function only knows how to deep-copy types that implement the copying protocol (or the pickling protocol). Built-in containers like lists and dicts of course implement it, but your  does not.Often, the "default" behavior just works. But it won't work for you, because you're not actually using an instance attribute for ; instead, you're relying on the class attribute providing a default value. Which works great for immutable values like , but not so much for mutable values like .So that  returns a new  with the same :So, you have two choices:Implement the copy or pickle protocol, as described in the  docs.Don't use , just do it manually.The second one is simpler:While we're at it, you're doing some odd things with classes here.First, naming the  parameter something other than , like , violates a pretty major idiom. Anyone familiar with Python will do a double-take, start reading the code, and then do another double-take before they even get to parsing out what your code does.Second, for types like this, you usually want to be able to pass values in to the constructor, like this:If you design things that way, your  method becomes a lot simpler:Finally, you have a method named  that grows  in-place, but another one named  that leaves  alone and instead returns a different rectangle. That's confusing; there's no obvious reason to anyone reading those names that one should mutate and the other copy.In Python 3.7, it might be even nicer to use the new  feature. 3.7 is still in beta right now, but you can get similar functionality with the third-party  library, or, if you want these objects to be immutable after construction, by just using .


Answer URL
https://docs.python.org/3/library/copy.html
https://docs.python.org/3/library/collections.html#collections.namedtuple
