Natural Text
I have a somewhat complex class , and an associated mixin  (to make the class iterable)...and a  method elsewhere in the codebase which receives an instance of my class as an argument.In fact, I'm attempting to bundle up a bunch of parameters as single object to be passed to multiple external functions beyond the  function below. A parameter object design pattern of sorts...With regard to the  function, in a completely different module, via the  class, I want to pass 's attributes (, , and ) to the  function as one argument...like so:PROBLEM:If I do not make the setters for the attributes  and  private (for example, via )--i.e., by way of an underscore--then I evoke  infinite recursion during class initialization ...as the  and setters for these attributes loop over and over and repeatedly call themselves. To avoid that, I used the decorator and "privatized" the foo and bar while setting them.However, when I pass an instance of the  class, and unpack its attributes as args in the  function via a splat or asterick, if I introspect the resultant keys for those attributes, I still get  and . I can't seem to get rid of the underscores. (In other words, I get the "privatized" attribute names of .)The biz logic of  needs the unpacked values to not have any underscores.Why is this happening (the underscores upon unpacking)? How can I fix this? Is there a more elegant way to either initialize the foo and bar attributes without privatizing anything? Or perhaps a more Pythonic way to pass all the attributes in the  class to my  function?
First, you've got a major problem that will prevent you from even seeing the problem you've asked for help with: Your  class defines an  method that doesn't , and doesn't  or  anything. Hopefully that part is just some typo and you know how to fix it to do whatever you actually wanted there.No, onto the problem you're asking about:Try printing out the  of your instances. Or, better, instances of a minimal example like this:The output is .You've tried to hide the attributes by giving them private names and putting them behind properties, but then you've gone around behind the properties' backs and looked directly into the  where the real attributes are.And what else could be there? Your actual  has to be stored somewhere on each instance. That , on the other hand, isn't really a value, it's a getter/setter that uses that private attribute, so it isn't stored anywhere.If you really want to use reflection to find all of the "public values" on an instance, you can do something like this:However, I think it would be much better to not do this reflectively. Simpler and cleaner options include:Add a  and have the base class iterate .Write a decorator that registers a property, and have the base class iterate that registry.Build something that lets you specify the attributes more declaratively and writes the boilerplate for you. See , , and  for some inspiration.Just use  (or, if you're not the OP but someone reading this from the future who can rely on 3.7+, ) to do that work for you.Rethink your design. A class whose instances iterate name-value pairs of their public attributes is weird in the first place. A "parameter object" that acted like a mapping to be used for keyword-splatting could be useful; one that acted like a normal iterable could be useful; one that acts as an iterable of name-value pairs is useless for anything except for passing to a  construct (at which point it's, again, simpler to be a mapping). Plus, a mixin is really not helping you with the hard part of doing it. Whatever you actually need to do, ask for help on how to do that, instead of how to make this code that shouldn't work work anyway.


Answer URL
https://docs.python.org/3/library/collections.html#collections.namedtuple
