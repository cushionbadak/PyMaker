Natural Text
Since some days ago I was unaware of the  method until reading this question. After that, I have been reading about it in the documentation, PEP and in other SO questions.I understood that whenever the  operator was used in objects that could be sliced (in my case I'm interested in lists, numpy arrays and pandas), the value either for slicing or for indexing was obtained so that  was fulfilled. However, as in one of the questions, the result depended on whether PyPy or CPython was used, so I decided to check when was slicing actually done with  and when it was not. I have done the following (in CPython 2.7.14):And defined the following classes:Then I tried to acces the defined objects with this used defined objects, obtaining the following:Note: I am not posting the complete error message for readability purposes. For  class, expected output 2:For  class, expected output 3:For  class, expected output 4:I'm really puzzled by this, mainly by the following points:With lists the  method is used but not for  and its childrens. Numpy uses  like lists, but in the last case  raises an error. Am I missing something or in this case  is only used when  is an empty string?Pandas slicing is a whole world and even accepts slicing for ordered string index, so it is a relieve that  is not used. Thus, my only question about pandas is if the output of a code could be different depending on the python implementation.My question is basically the one in the title:When is  called for lists and numpy arrays? Why are there some exceptions?Having said that, I will be happy to recieve any extra information I may have missed about this method.
First, quoting the docs for :Called to implement operator.index(), and whenever Python needs to  losslessly convert the numeric object to an integer object (such as in  slicing, or in the built-in bin(), hex() and oct() functions).  Presence of this method indicates that the numeric object is an  integer type. Must return an integer.Note: In order to have a coherent integer type class, when   is defined  should also be defined, and both should return  the same value. usually isn't called if an object is already an int, since no conversion is needed. Also, you need an  method to go with ; some of your problems come from that. (Your  inherits , but its  behavior isn't consistent with what it inherits from , so that's also a problem.)In CPython, lists implement the C-level sequence protocol, and CPython automatically calls  for non-ints before invoking the sequence protocol. Ints just get their int value used, and your  has an int value of 0. You can trace the call chain for  through , , and  if you want.NumPy arrays don't use the sequence protocol for indexing. They implement it, but they also implement the mapping protocol, which takes priority. NumPy arrays handle index processing themselves.One of the things they try is , which is why they behave like lists for most of your tests. However, NumPy arrays support a lot more complex indexing than lists, and one part of the NumPy array indexing implementation is a weird special case where certain non-tuple sequences get treated as index tuples.Your  objects are sequences, and  triggers the special case. It gets treated as , or , which isn't a valid indexing tuple.As for Pandas,  implements  at Python level. It also has to process indexes manually.For , it looks like it tried to call  on your  object, which failed because you don't have an  method. The error would normally have been a TypeError, which Pandas would probably handle differently, but you forgot to inherit from , so you got a classic class, and those are weird.Your  objects are ints and were used as ints, same as with the list and array tests.Your  objects are strings, and Pandas treated them as strings instead of trying to interpret them as ints.


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__index__
https://docs.python.org/3/reference/datamodel.html#object.__index__
