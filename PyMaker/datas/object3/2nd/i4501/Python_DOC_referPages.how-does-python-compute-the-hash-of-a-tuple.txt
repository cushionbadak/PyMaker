Natural Text
In python, if I have a tuple with many elements, is its hash calculated from its elements' s or its elements' content? In this example,It errors out saying list is unhashable. So I guess it's not computed by id, or probably there is a check on whether the element is mutable.Now see this exampleHere it turns out the hash of  does not change with the modification of its element, i.e., . So maybe 's id is used for the hash calculation? Is  somehow considered as immutable? How does python know if a type is mutable?Now consider this caseIt seems the content of  and  are used for the hash calculation.How should I understand these examples?
Neither. It is calculated on the basis of the hashes of these elements, not their "contents" (values/attributes).Take a look at this paragraph in python's documentation glossary. Whether something is hashable or not, and how it is hashed, depends on the implementation of its  method. Python itself has no idea about mutability of an object.In your first example,  happens to hash itself on the basis of its elements, while a  doesn't have a hash at all - the  method is not implemented for it (and for a good reason). That's why a  with a  object inside of it is not hashable.Now, having that in mind, let's have a look at python data model documentation, and what it has to say on the topic:User-defined classes have  and  methods by default; with them, all objects compare unequal (except with themselves) and  returns an appropriate value such that  implies both that  and .That's why you don't have to define  for your classes - python does it for you in this case. The default implementation doesn't take instance fields into account though. That's why you can change the values inside your object without changing its hash.In this regard you're right - the default (CPython's) implementation of the hashing function for custom classes relies on the  of an object, and not on the values inside of it. It is an implementation detail, and it differs between Python versions though. In more recent versions of Python the relation between  and  involves some randomization.But how does it actually hash itself?While the details are quite complicated and probably involve some advanced math, the implementation of the hash function for tuple objects is written in C, and can be seen here (see .The calculation involves XORing a constant with the hashes of each of the tuple's elements. The line responsible for hashing of the elements is this one:So, to answer your original question: it does a bunch of XOR hokus-pocus with the hashes of each of its elements. Whether or not the contents of these elements are used depends on their specific hash functions.
The core contract of hashing is that equal objects have equal hashes. In particular, hashing does not directly care about mutability or mutation; it only cares about mutation that affects equality comparisons.Your first tuple is unhashable because mutating the nested list would change how the tuple behaves in equality comparisons.Mutating  in your second example doesn't affect the hash of the tuple because it doesn't affect equality comparisons.  is still only equal to itself, and its hash is unchanged. and  in your third example have equal hashes because they are equal tuples, regardless of whether their elements are the same objects.This all means that tuples cannot (directly) use  for hashes. If they did, equal tuples with distinct but equal elements could hash differently, violating the contract of hashing. Without special-casing element types, the only things tuples can use to compute their own hashes are their elements' hashes, so tuples base their hashes on their elements' hashes.
The answer to the question "Is the tuple's hash calculated based on the identity or the value?" is: Neither.The correct answer is that the tuple's hash is calculated from the elements' hashes. How those hashes are calculated is (more or less) irrelevant.An easy way to prove this is to see what happens when you put a list into a tuple:Because lists aren't hashable, a tuple containing a list isn't hashable either.Let's take a closer look at this example you brought:Why doesn't setting  affect the tuple's hash? Well, if we modify this code to output the hash of , you'll see that setting  has no effect on 's hash value:The reason for this is that python implements a default hash function for you. From the docs:User-defined classes have  and  methods by default;  with them, all objects compare unequal (except with themselves) and   returns an appropriate value such that  implies  both that  and .The default hash function ignores the object's attributes and calculates the hash based on the object's id. No matter what changes you make to , its hash will always stay the same. (Though it is possible to define a custom hash function for instances of your  class by implementing a custom  method.)Addendum: The reason why lists aren't hashable is because they're mutable. From the docs:If a class defines mutable objects and implements an  method,  it should not implement , since the implementation of  hashable collections requires that a key’s hash value is immutable (if  the object’s hash value changes, it will be in the wrong hash bucket).Lists fall into this category.
the hash of a  is based on the contents, not on the _id_s of the tuples. And the hashes are computed recursively: if one element isn't hashable (like a  element), then the tuple itself isn't hashable.That's perfectly normal that if  and  are tuples and , then  (if hashes can be computed of course), even if .(on the contrary  doesn't mean that )The information conveyed by  is often not very useful, because of python object interning for example.


Answer URL
https://docs.python.org/3/glossary.html#term-hashable
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/library/functions.html#id
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
https://docs.python.org/3/reference/datamodel.html#object.__hash__
