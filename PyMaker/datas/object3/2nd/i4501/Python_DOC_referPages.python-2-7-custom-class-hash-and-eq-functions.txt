Natural Text
I'm having an issue which I believe is related to improper implementation of custom class / functions. I created a custom  class, where a line holds a slope and y intercept which are calculated from 2 Points. I'm running a test on equality between 2 lines, which is producing unexpected results as shown below. I'm looking for an explanation of why the first 2 lines in the test code I've included below are not equal, but the 2nd set of 2 lines are equal, despite both sets of lines having matching values for slope and y intercept?test code:This test produces output:
Your original  and  are not equal, because of rounding errors.They're close, close enough that your output is hiding the difference, but if you try printing the  of the numbers (e.g., replacing each  with ), or just specifying a whole mess of digits in your format, you will see that they're the y-intercept values are actually  and .There's a famous paper called What Every Computer Scientist Should Know About Floating Point that's so important it's been incorporated by reference into various standards documents. (I've seen a few answer link to a similarly-named site, What Every Programmer Should Know About Floating Point, which looks like it might be friendlier, but I can't vouch for its accuracy.)Anyway, in general, the right way to deal with this is to use . Of course if you want to learn Python 2.7 even though it's 2018, you can't do that, because it doesn't have such a thing. PEP 485 includes a pseudocode description of the algorithm, and links to a pure-Python implementation.But in this specific case, there's an issue you have to think through: the values aren't actually equal, so they shouldn't hash the same. Does that break your intended design? Usually, the answer is that your design shouldn't be using lines, or anything else with  values, as dict keys, or whatever you were intending. But occasionally, it's worth building a wrapper that handles both equality and hashing by rounding things off to a fixed number of bits or digitsâ€”although that doesn't actually make rounding errors impossible; it just makes it possible to deal with them for some sets of input, so it only works if you know your input set.
Computing the same logical result in different ways with floating point numbers doesn't get consistent results. For highly precise values like this, you likely want to use an infinite precision numeric type, like .If you create your s with  with equivalent but (unlike ) 100% precise values:then your code works as expected:which prints: uses a normalized form of the  too (as you can see, it's always , even with distinct s as input), so your hashing code will "just work".


Answer URL
https://docs.python.org/3/library/fractions.html#fractions.Fraction
