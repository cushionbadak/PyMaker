Natural Text
If within an instance, I have , what is the difference between these (or other more complicated examples):I'm currently looking at a code base where all the  variables are reassigned to something else. Just wondering if there is any reason to do so and would like to hear both from an efficiency standpoint and a code clarity standpoint.
Consider these possibilities:The local variable  gets rebound in the middle of the loop. (That's not possible with the specific code you've given, but a different loop could conceivably do it.) In that case, #1 will see the new 's  attribute, while #2 will not. Although, of course, you could just as easily rebind the local variable  as the local variable … is mutable, and  is rebound to a different value in the middle of the loop. (That could happen more easily with, e.g., another thread operating on the same object.) Again, #1 will see the new value of the  attribute, but #2 will not. is itself mutable, and its value is mutated in the middle of the loop (e.g., it's a list, and some other thread calls  on it). Now both #1 and #2 will see the new value.Everything is immutable, or there's just no code (including on other threads) to mutate anything. Now both #1 and #2 are going to see the original value, because there is no other value to see.If any of those semantic differences are relevant, then of course you want to use whichever one gives you the right answer.Meanwhile, every time you access , that requires doing an attribute lookup. In the most common case, this means looking up  in , which is pretty quick, but not free. And you can easily create pathological cases where it goes through 23 base classes in MRO order before calling a  that creates the value on the fly and returns a descriptor whose  method does some non-trivial transformation.Accessing , on the other hand, is going to be compiled into just loading a value out of an array on the frame using a compiled-in index. So it will almost always be faster, and in some cases it can be a lot faster.In most real-life cases, this doesn't matter at all. But occasionally, it does. In which case copying the value to a local outside the loop is a worthwhile micro-optimization. This is a little more common with bound methods than with normal values (because they always have a descriptor call in the way); see the  recipe in the  docs for an example.Of course you could contrive a case where this optimization actually made things slower—e.g., make that loop really tiny, but put the whole thing inside an outer loop. Now the extra  copy each time through the outer loop (and the fact that the bytecode involved in the loop is longer and may spill onto another cache line) could cost a lot more than it saves.If there's no semantic difference that matters, and the performance difference doesn't matter, then it's just a matter of clarify.If the expression is a lot more complicated than , it may well be clearer to pull out the value and give it a name.But for a trivial case like this, it's probably clearer to just use . By taking the extra step of copying it to a local variable, you're signaling that you had some reason to do so. So a reader will wonder whether maybe  can get rebound in a different thread, or maybe this loop is a major bottleneck in your code and the  access is a performance issue, etc., and waste time dealing with all of those irrelevancies instead of just reading your code as intended.


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
