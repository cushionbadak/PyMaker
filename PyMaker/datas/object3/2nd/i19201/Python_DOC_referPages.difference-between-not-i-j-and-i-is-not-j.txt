Natural Text
My Google-fu has failed me.In Python, are the following two tests for equality equivalent?Does this hold true for objects where you would be comparing instances (a  say)?Okay, so this kind of answers my question:So  tests value where  tests to see if they are the same object?
 will return  if two variables point to the same object,  if the objects referred to by the variables are equal.In your case, the second test only works because Python caches small integer objects, which is an implementation detail. For larger integers, this does not work:The same holds true for string literals:Please see this question as well.
There is a simple rule of thumb to tell you when to use  or . is for value equality. Use it when you would like to know if two objects have the same value. is for reference equality. Use it when you would like to know if two references refer to the same object.In general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use . For example, the intention of your example is probably to check whether x has a value equal to 2 (), not whether  is literally referring to the same object as 2.Something else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use  to compare for reference equality on integers:That's pretty much what we expected:  and  have the same value, but are distinct entities. But what about this?This is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this:This is another obvious reason not to use : the behavior is left up to implementations when you're erroneously using it for value equality.
 determines if the values are equal, while  determines if they are the exact same object and equal. 
Is there a difference between  and  in Python?Yes, they have a very important difference.: check for equality - the semantics are that equivalent objects (that aren't necessarily the same object) will test as equal. As the documentation says:The operators <, >, ==, >=, <=, and != compare the values of two objects.: check for identity - the semantics are that the object (as held in memory) is the object. Again, the documentation says:The operators  and  test for object identity:  is true  if and only if  and  are the same object. Object identity is  determined using the  function.  yields the inverse  truth value.Thus, the check for identity is the same as checking for the equality of the IDs of the objects. That is,is the same as:where  is the builtin function that returns an integer that "is guaranteed to be unique among simultaneously existing objects" (see ) and where  and  are any arbitrary objects.Other Usage DirectionsYou should use these comparisons for their semantics. Use  to check identity and  to check equality.PEP 8, the official Python style guide for the standard library also mentions two use-cases for :Comparisons to singletons like  should always be done with  or  , never the equality operators.Also, beware of writing  when you really mean  --  e.g. when testing whether a variable or argument that defaults to   was set to some other value. The other value might have a type (such  as a container) that could be false in a boolean context!Inferring equality from identityIf  is true, equality can usually be inferred - logically, if an object is itself, then it should test as equivalent to itself. In most cases this logic is true, but it relies on the implementation of the  special method. As the docs say, The default behavior for equality comparison ( and ) is based on  the identity of the objects. Hence, equality comparison of instances  with the same identity results in equality, and equality comparison of  instances with different identities results in inequality. A  motivation for this default behavior is the desire that all objects  should be reflexive (i.e. x is y implies x == y).and in the interests of consistency, recommends:Equality comparison should be reflexive. In other words, identical  objects should compare equal: implies We can see that this is the default behavior for custom objects:The contrapositive is also usually true - if somethings test as not equal, you can usually infer that they are not the same object. Since tests for equality can be customized, this inference does not always hold true for all types.An exceptionA notable exception is  - it always tests as not equal to itself:Checking for identity can be much a much quicker check than checking for equality (which might require recursively checking members). But it cannot be substituted for equality where you may find more than one object as equivalent.Note that comparing equality of lists and tuples will assume that identity of objects are equal (because this is a fast check). This can create contradictions if the logic is inconsistent - as it is for :A Cautionary Tale:The question is attempting to use  to compare integers. You shouldn't assume that an instance of an integer is the same instance as one obtained by another reference. This story explains why.A commenter had code that relied on the fact that small integers (-5 to 256 inclusive) are singletons in Python, instead of checking for equality.Wow, this can lead to some insidious bugs. I had some code that checked if a is b, which worked as I wanted because a and b are typically small numbers. The bug only happened today, after six months in production, because a and b were finally large enough to not be cached. – gwgIt worked in development. It may have passed some unittests. And it worked in production - until the code checked for an integer larger than 256, at which point it failed in production. This is a production failure that could have been caught in code review or possibly with a style-checker.Let me emphasize: do not use  to compare integers.
What's the difference between  and ? and  are different comparison! As others already said: compares the values of the objects. compares the references of the objects.In Python names refer to objects, for example in this case  and  refer to an  instance storing the value :Because  refers to the same object  and  will give :In the following example the names  and  refer to different  instances, even if both store the same integer:Because the same value (integer) is stored  will be , that's why it's often called "value comparison". However  will return  because these are different objects:When to use which?Generally  is a much faster comparison. That's why CPython caches (or maybe reuses would be the better term) certain objects like small integers, some strings, etc. But this should be treated as implementation detail that could (even if unlikely) change at any point without warning.You should only use  if you:want to check if two objects are really the same object (not just the same "value"). One example can be if you use a singleton object as constant.want to compare a value to a Python constant. The constants in Python are:11classes (for example  or )there could be additional constants in built-in modules or 3rd party modules. For example  from the NumPy module)In every other case you should use  to check for equality.Can I customize the behavior?There is some aspect to  that hasn't been mentioned already in the other answers: It's part of Pythons "Data model". That means its behavior can be customized using the  method. For example:This is just an artificial example to illustrate that the method is really called:Note that by default (if no other implementation of  can be found in the class or the superclasses)  uses :So it's actually important to implement  if you want "more" than just reference-comparison for custom classes!On the other hand you cannot customize  checks. It will always compare just if you have the same reference.Will these comparisons always return a boolean?Because  can be re-implemented or overridden, it's not limited to return  or . It could return anything (but in most cases it should return a boolean!). For example with NumPy arrays the  will return an array:But  checks will always return  or !1 As Aaron Hall mentioned in the comments: Generally you shouldn't do any  or  checks because one normally uses these "checks" in a context that implicitly converts the condition to a boolean (for example in an  statement). So doing the  comparison and the implicit boolean cast is doing more work than just doing the boolean cast - and you limit yourself to booleans (which isn't considered pythonic).Like PEP8 mentions:Don't compare boolean values to  or  using .
They are completely different.   checks for object identity, while  checks for equality (a notion that depends on the two operands' types).It is only a lucky coincidence that "" seems to work correctly with small integers (e.g. 5 == 4+1).  That is because CPython optimizes the storage of integers in the range (-5 to 256) by making them singletons. This behavior is totally implementation-dependent and not guaranteed to be preserved under all manner of minor transformative operations.For example, Python 3.5 also makes short strings singletons, but slicing them disrupts this behavior:
https://docs.python.org/library/stdtypes.html#comparisons tests for identity tests for equalityEach (small) integer value is mapped to a single value, so every 3 is identical and equal. This is an implementation detail, not part of the language spec though
Your answer is correct. The  operator compares the identity of two objects.  The  operator compares the values of two objects.An object's identity never changes once it has been created; you may think of it as the object's address in memory.You can control comparison behaviour of object values by defining a  method or a rich comparison method like .
Have a look at Stack Overflow question Python's “is” operator behaves unexpectedly with integers.What it mostly boils down to is that "" checks to see if they are the same object, not just equal to each other (the numbers below 256 are a special case).
The  operator compares the values of both the operands and checks for value equality. Whereas  operator checks whether both the operands refer to the same object or not.But if we doBasically,  can be thought of as shorthand for . However, Beyond this, there are quirks of the run-time environment that further complicate things. Short strings and small integers will return  when compared with , due to the Python machine attempting to use less memory for identical objects.
As John Feminella said, most of the time you will use == and != because your objective is to  compare values. I'd just like to categorise what you would do the rest of the time:There is one and only one instance of NoneType i.e. None is a singleton. Consequently  and  mean the same. However the  test is faster and the Pythonic convention is to use .If you are doing some introspection or mucking about with garbage collection or checking whether your custom-built string interning gadget is working or suchlike, then you probably have a use-case for  is .True and False are also (now) singletons, but there is no use-case for  and no use case for . 
Most of them already answered to the point. Just as an additional note (based on my understanding and experimenting but not from a documented source), the statement == if the objects referred to by the variables are equalfrom above answers should be read as == if the objects referred to by the variables are equal and objects belonging to the same type/class. I arrived at this conclusion based on the below test:Here the contents of the list and tuple are same but the type/class are different. 
In a nutshell,  checks whether two references point to the same object or not. checks whether two objects have the same value or not.
Actually I wanted to add this as a comment but could not beautify it easily hence adding as an answer, please do not consider this as an answer. This is what I did to understand --execute following one by one and understand output on every step
As the other people in this post answer the question in details, I would emphasize mainly the comparison between  and  for strings which can give different results and I would urge programmers to carefully use them.For string comparison, make sure to use  instead of :Out:But in the below example  and  will get different results:Out:Conclusion:Use  carefully to compare between strings 
Python difference between is and equals(==)The is operator may seem like the same as the equality operator but  they are not same.The is checks if both the variables point to the same object whereas  the == sign checks if the values for the two variables are the same.So if the is operator returns True then the equality is definitely  True, but the opposite may or may not be True.Here is an example to demonstrate the similarity and the difference.
"==" compares values"is" compares underlying objects
o1 is o2 => compares if o1 and o2 both points to same physical location in memory (in other words if they are same object)o1 == o2 => here python call the o1's __cmp __(o2) method, which ideally should compares the value and return True or False. (In other words it compares value)For JAVA people: In Java, to determine whether two string variables reference the samephysical memory location by using str1 == str2. (called objectidentity, and it is written in Python as str1 is str2). To compare string values in Java, usestr1.equals(str2); in Python,use str1 == str2.Example:Python Shell output: o = A(2)  o1 = oo == o1   2   2   Trueo is o1  Trueo1 = A(2)o is o1  False
While all these answers that rely on the implementation of objection pointer comparison vs value comparison are likely correct, there is a deeper syntactical reason for using  to determine if a variable value is  (in boolean logic often represented as ).  In relational database and other logic systems,  implies that the actual value is "unknown".  Thus the logical expression  must always evaluate to  itself, as it is impossible to ever know if , whatever value it may have, is the same as the unknown value.  In programming languages that adhere more strictly to the rules of boolean logic,  (or Pythonically ) correctly evaluates to , and alternative means must be provided to determine if a variable value is .  Python is an outlier in this regard, due to the unitary nature of the object reference to .  But for clarity and logical correctness, using the Python  comparison operator seems to me much sounder practice.
Yes, there is difference between both.  '==' : compares object by value.  'in' : compares object by reference.Now let's consider this case:


Answer URL
https://docs.python.org/3/reference/expressions.html#value-comparisons
https://docs.python.org/3/reference/expressions.html#is-not
https://docs.python.org/3/reference/expressions.html#value-comparisons
https://docs.python.org/3/reference/datamodel.html#data-model
