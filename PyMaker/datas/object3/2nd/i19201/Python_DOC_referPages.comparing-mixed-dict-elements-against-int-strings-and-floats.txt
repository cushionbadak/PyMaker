Natural Text
I would like to be able to make comparisons in a mixed-type dictionary (containing int, floats, strings, numpy.arrays). My minimal example has a list of dictionaries and I would like a function (or generator) to iterate over that list and pick out the elements (dicts) that contain key-value pairs as specified by **kwargs input to that function (or generator).  My two problems with the above are:If the function asks for a a comparison that is a string, I would like to switch to regex matching (re.search or re.match) instead of plain string comparison. In the above code this is accomplished through the reviled type checking and it doesn't look all that elegant. Are there better solutions not involving type checking? Or maybe, this is a case where type checking is allowed in python? can of course contain more than one comparison. Currently I can only think of a solution involving some flags ( switched to a  and evaluated at the end of each iteration of ). Is there some clever way to accumulate the comparison results for each s before deciding on whether to yield it or not?Are there ways to make this whole walk through this collection of dicts prettier?PS: The actual use case for this involves the representation of acquired MRI datasets (BRUKER). Datasets are characterized through parameter files that I have converted to dicts that are part of the objects representing said scans. I am collecting these datasets and would like to further filter them based on certain criteria given by these parameter files. These parameters can be strings, numbers and some other less handy types.UPDATE and Distilled AnswerIf I head to come up with a consensus answer derived from the input by @BrenBarn and @srgerg it would be thisNow the only challenge would be to come up with a pain-free strategy of creating .
It seems okay to me to use type-checking in this situation, as you really do want totally different behavior depending on the type.  However, you should make your typecheck a bit smarter.  Use  rather than a direct check for  type.  This way, it will still work for unicode strings.The way to avoid typechecking would be to pre-specify the comparison type for each field.  Looking at your sample data, it looks like each field always has a consistent type (e.g., s1 is always a string).  If that's the case, you could create an explicit mapping between the field names and the type of comparison, something like:Then in your code, instead of the type check, do  to see if the field is one that should be compared with a regex.  If you have more than just two types of comparison, you could use a dict mapping field names to some kind of ID for the comparison operation.The advantage of this is that it encodes your assumptions more explicitly, so that if some weird data gets in (e.g., a string where you expect a number), an error will be raised instead of silently applying the type-appropriate comparison.  It also keeps the relationship between fields and comparisons "separate" rather than burying it in the middle of the actual comparison code.This might especially be worth doing if you had a large number of fields with many different comparison operations for differnet subsets of them.  In that case, it might be better to predefine which comparisons apply to which field names (as opposed to which types), rather than deciding on-the-fly for each comparison.  As long as you always know based on the field name what type of comparison to do, this will keep things cleaner.  It does add maintenance overhead if you need to add a new field, though, so I probably wouldn't do it if this was just a script for a private audience.
Here's how I would implement your  function. It still uses The Reviled Type Checking (TM), but it looks a little more eloquent IMHO:(I'm using Python 3, by the way, though the code works in Python 2.7 but should use  rather than  as BrenBarn has already pointed out).Note that I have used Python's all function to avoid having to accumulate the comparison results.
You can see my code below which solves the need for more than one comparisons:O/P:I have not included the code for regex comparision!Cheers!


Answer URL
