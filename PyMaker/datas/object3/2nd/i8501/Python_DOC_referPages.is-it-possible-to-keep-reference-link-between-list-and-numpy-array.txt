Natural Text
If I create a list in python, and assign a different list to it, changes of the first list are reflected in the second list:Is it possible to achieve this behavior when creating a numpy array from a list?What I want:But what actually happens is that b is . I realize that this is difficult due to dynamic resizing of the list. But if I could tell numpy that this list is never resized, it should work somehow.Is this behavior achievable? Or am I missing some really bad drawbacks?
Fundamentally the issue is that Python lists are not really arrays. OK, CPython lists are ArrayLists, but they are arrays of Py_Object pointers, so they can hold heterogenous data. See here for an excellent exposition on the implementation details of CPython lists. Also, they are resizable, and all the  and  gets taken care of under the hood. However, you can achieve something like what you want if you use vanilla Python arrays available in the  module.Let's make a real array:We can use  if we want our  to share the underyling memory of the buffer:EDIT: WARNINGAs stated by @user2357112 in the comments:Watch out -  is still using the old buffer protocol  (or on Python 3, the compatibility functions that wrap the new buffer  protocol in an old-style interface), so it's not very memory-safe. If  you create a NumPy array from an  or  with  , you must not change the size of the underlying array.  Doing so risks arbitrary memory corruption and segfaults when you  access the NumPy arrayNote, I had to explicitly pass  because I initialized my  with the  signed int typecode, which on my system corresponds to a 32 bit int. Now, presto:Now, if we use , we actually can share the underlying objects. However, with numerical types, we can't mutate, only replace. However, we can wrap a Python  in a class to make a mutable object:Now, we create an array that consists of the same objects:Now, we can mutate the int wrapper in the list:And the effects are visible in the  array!:Note, though, you've now essentially created a less useful version of a Python , one that isn't resizable, and doesn't have the nice O(1) amortized  behavior. We also lose any memory efficiency gains that a  array might give you!Also, note that in the above the  and  are not sharing the same underlying buffer, they are making *two different arrays of holding the same Py_Obj pointer values:We cannot access the underlying buffer to a python  because this is not exposed. Theoretically, they could if they exposed the buffer protocol: https://docs.python.org/3/c-api/buffer.html#bufferobjectsBut they don't.  and  objects do expose the buffer protocol.  are essentially Python 2 , and  is a mutable version of , so they are essentially mutable  arrays like in C:Now, let's make a  array that shares the underlying buffer:Now, we will see changes reflected across both objects:Now, before you think you can use this to subvert the immutability of Python  objects, think again:
A list contains pointers to objects (in this case integers) elsewhere in memory. points to the same list as .  It's just another name is new, but it contains the same pointers as  has the same numeric values as , but it stores those values in its own databuffer.  It has, in effect, evaluated , and made a new object.  There is no connection, other than by value, with .a new array, but with a shared data buffer, a .a new array with its own data buffer.is a number, created from .  It's equal in value to  but does not reference the same numeric object.


Answer URL
https://docs.python.org/3/library/array.html
https://docs.python.org/3/c-api/buffer.html#bufferobjects
