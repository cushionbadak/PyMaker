Natural Text
Imagine this simple function creating a modified value of a variable , :disassembled:I can't change the function , but I know what's in it either directly (I can see the code) or indirectly (disassembly). What I need it is to get a value of the  variable, so I though maybe there is a way how to remove specific parts () of the function through  module, but I didn't find anything.Is there any way how to remove probably everything except  after  and replace it with e.g. ? Or is there any other way how to pull a local variable out without actually executing the last line(s)?As a possible solution I see 3 ways:pulling disassembled codes and creating my own function (or inplace) according to them with removing the code I don't want (everything after )modifying the function's return value, so that it returns  (that unfortunately calls the OS function)manually recreating the function according to the source codeI'd like to avoid the second way, which is probably easier than the first one, but I must avoid the third way, so... is there any way how to solve my problem?
There is a 4th option: replace the  global:It is otherwise possible to produce modified bytecode, but this can easily lead to bugs that blow up the interpreter (there is zero protection from invalid bytecode), so be warned.You can create a new function object with a new code object with updated bytecode; based on the offsets in the dis you showed, I manually created new bytecode that would return the local variable at index 0: returns the object at the top of the stack; all I did was inject a  opcode to load what  references onto the stack.You'd have to create a new  object, then a new  object wrapping the code object, to make this callable:This does, obviously, require some understanding of how Python bytecode works in the first place; the  module does contain descriptions of the various codes, and the  dictionary lets you map back to byte values.There are a few modules out there that try to make this easier; take a look at , the  module of the  project or several others, if you want to explore this further.I can also heartily recommend you watch the Playing with Python Bytecode presentation given by Scott Sanderson, Joe Jevnik at PyCon 2016, and play with their  module. Highly entertaining and very informative.


Answer URL
https://docs.python.org/3/library/dis.html#dis.opmap
