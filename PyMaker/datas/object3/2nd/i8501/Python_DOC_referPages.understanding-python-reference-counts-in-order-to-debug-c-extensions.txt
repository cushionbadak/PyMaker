Natural Text
I am writing a c-extension and want to test it in pytest.Part of what I am testing is whether the reference counts are correct on my objects. Thus I build a small test in pure python that puzzles me...from Ipython i get:So fare so good, 1 reference from assignment and 1 from the caller.However the following script (stackoverflow_test.py) gives the following resultswhen I run it as a normal python scriptWhy 4 and not 2?. When I run it with pytestWhy 3 and not 2?Question: How come thatpython = 4 ref countspytest = 3 ref countsipython session = 2 ref countsI would expect it to behave like in ipython in all 3 cases, can anybody explain what is going on, and give me some hints how to best test the objects I am creating.
Literals in your code are stored in a code object. The bytecode stack is another reference:The  opcodes load the object from the  tuple attached to the code object; that tuple is one reference.  then puts that into a local variable, that's the second reference.Then there's the  opcode, this takes a name from local storage and puts it on the stack, again incrementing the reference count.Last but not least, you pass that value to the  call.If you want to learn about what references your objects, you may want to look at ; this function excludes itself and the stack when called, so you can mentally add +2:That prints 2 objects; the  tuple, and the current call frame (for the locals). does some additional import-time magic which rewrites  statements, and as a result the reference count is different again.You may also want to read the Reference Counts section of the Extending Python with C or C++ documentation, the Objects, Types and Reference Counts section of the C API Reference Manual, and last but not least the Debugging Builds section of the same same, to learn how to create a Python build that helps you trace reference counts in detail.You should never rely on a specific number of references to an object. I can trivially add more references to you objects by reaching into the function object, for example ( would increment the reference count before even running the function). What exactly requires the reference count to go up is an implementation detail. Just make sure your own code handles references correctly.


Answer URL
https://docs.python.org/3/library/gc.html#gc.get_referrers
https://docs.python.org/3/extending/extending.html#reference-counts
https://docs.python.org/3/c-api/intro.html#objects-types-and-reference-counts
https://docs.python.org/3/c-api/intro.html#debugging-builds
