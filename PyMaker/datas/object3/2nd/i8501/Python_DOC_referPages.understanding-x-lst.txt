Natural Text
I'm going through some old code trying to understand what it does, and I came across this odd statement: is a list in this context. I've been trying to figure out what this statement does. As far as I can tell, it just sets  to the value of . For example:Just givesSo is this any different than ? Any idea what this syntax is doing?
 is basically an obfuscated version of  using extended iterable unpacking. The comma after  is required to make the assignment target a tuple (it could also be a list though). is different from  because the former creates a copy of  (i.e. a new list) while the latter creates a reference to the original list. To illustrate:
It's a feature that was introduced in Python 3.0 (PEP 3132). In Python 2, you could do something like this:Python 3 extended this so that one variable could hold multiple values:This, therefore, is what is being used here. Instead of two variables to hold three values, however, it is just one variable that takes each value in the list. This is different from  because  just means that  is another name for . In this case, however, it is a new list that just happens to have the same values in it. (You may be interested in "Least Astonishment" and the Mutable Default Argument)Two other common ways of producing this effect are:andSince Python 3.3, the list object actually has a method intended for copying:The slice is actually a very similar concept. As nneonneo pointed out, however, that works only with objects such as lists and tuples that support slices. The method you mention, however, works with any iterable: dictionaries, sets, generators, etc.
You should always throw these to  and see what it throws back at you; you'll see how  is actually different from :While, the simple assignment statement:(Stripping off unrelated  returns)As you can see  is the different op-code between these; it's documented as:Implements assignment with a starred target: Unpacks an iterable in TOS (top of stack) into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.Which is why, as Eugene noted, you get a new object that's referred to by the name  and not a reference to an already existing object (as is the case with ).  does seem very odd (the extra comma there and all) but it is required here. The left hand side must either be a tuple or a list and, due to the quirkiness of creating a single element tuple in Python, you need to use a trailing :If you like confusing people, you can always use the  version of this:which does exactly the same thing but doesn't have that extra comma hanging around there.


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/dis.html#opcode-UNPACK_EX
