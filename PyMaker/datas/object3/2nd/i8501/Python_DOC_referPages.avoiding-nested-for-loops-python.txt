Natural Text
I have a function which takes in expressions and replaces the variables with all the permutations of the values that I am using as inputs. This is my code that I have tested and works, however after looking through SO, people have said that nested for loops are a bad idea however I am unsure as to how to make this more efficient. Could somebody help? Thanks. 
ForewordNested loops are not a bad thing per se. They are only bad, if there are used for problems, for which better algorithm have been found (better and bad in terms of efficiency regarding the input size). Sorting of a list of integers for example is such a problem.Analyzing the ProblemThe sizeIn your case above you have three lists, all of size 4. This makes 4 * 4 * 4 = 64 possible combinations of them, if a comes always before b and b before c. So you need at least 64 iterations!Your approachIn your approach we have 4 iterations for each possible value of a, 4 iterations for each possible value of b and the same for c. So we have 4 * 4 * 4 = 64 iterations in total. So in fact your solution is quite good!As there is no faster way of listening all combinations, your way is also the best one.The styleRegarding the style one can say that you can improve your code by better variable names and combining some of the for loops. E.g. like that:Notice however that the amount of iterations remain the same!ItertoolsAs Kevin noticed, you could also use  to generate the cartesian product. Internally it will do the same as what you did with the combined for loops:
here are some ideas: as yours list a, b and c are hardcoded, harcode them as strings, therefore you don't have to cast every element to string at each step use list comprehension, they are a little more faster than a normal for-loop with appendinstead of .replace, use .format, it does all the replace for you in a single stepuse itertools.product to combine a, b and cwith all that, I arrive to thisthe speed gain is marginal, but is something, in my machine it goes from 148 milliseconds to 125Functionality is the same to the version of R.Q.
So, your current structure addresses one of the inefficiencies that the solutions with  will not address. Your code is saving the intermediately substituted expressions and reusing them, rather than redoing these substitutions with each  tuple. This is good and I think your current code is efficient.However, it is brittle and only works when substituting in exactly three variables. A dynamic programming approach can solve this issue. To do so, I'm going to slightly alter the input parameters. The function will use two inputs: - The expressions to be substituted into - A dictionary which provides the values to substitute for each variableThe dynamic programming function is given below:With the example usage:Note that if you're using Python 3.X, you can use the  construct instead of reiterating over  twice in . This function would look like:
"The problem" with nested loops is basically just that the number of levels is hard coded.  You wrote nesting for 3 variables.  What if you only have 2?  What if it jumps to 5?  Then you need non-trivial surgery on the code.  That's why  is recommended.Relatedly, all suggestions so far hard-code the number of  calls.  Same "problem":  if you don't have exactly 3 variables, the replacement code has to be modified.Instead of doing that, think about a cleaner way to do the replacements.  For example, suppose your input string were:instead of:That is, the variables to be replaced are enclosed in curly braces.  Then Python can do all the substitutions "at once" for you:That hard-codes the names and number of names too, but the same thing can be accomplished with a dict:Now nothing about the number of variables, or their names, is hard-coded in the  call.The tuple of values () is exactly the kind of thing  returns.  The list of variable names () can be created just once at the top, or even passed in to the function.You just need a bit of code to transform your input expressions to enclose the variable names in curly braces.


Answer URL
https://docs.python.org/3/library/string.html#formatstrings
