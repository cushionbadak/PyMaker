Natural Text
What's a correct and good way to implement ?I am talking about the function that returns a hashcode that is then used to insert objects into hashtables aka dictionaries.As  returns an integer and is used for "binning" objects into hashtables I assume that the values of the returned integer should be uniformly distributed for common data (to minimize collisions).What's a good practice to get such values? Are collisions a problem?In my case I have a small class which acts as a container class holding some ints, some floats and a string.
An easy, correct way to implement  is to use a key tuple. It won't be as fast as a specialized hash, but if you need that then you should probably implement the type in C.Here's an example of using a key for hash and equality:Also, the documentation of  has more information, that may be valuable in some particular circumstances.
John Millikin proposed a solution similar to this:The problem with this solution is that the . In other words, the hash collides with that of the tuple of its key members. Maybe this does not matter very often in practice?The Python documentation on  suggests to combine the hashes of the sub-components using something like XOR, which gives us this:Bonus: more robust  thrown in there for good measure.Update: as Blckknght points out, changing the order of a, b, and c could cause problems. I added an additional  to capture the order of the values being hashed. This final  can be removed if the values being combined cannot be rearranged (for example, if they have different types and therefore the value of  will never be assigned to  or , etc.).
Paul Larson of Microsoft Research studied a wide variety of hash functions. He told me that worked surprisingly well for a wide variety of strings. I've found that similar polynomial techniques work well for computing a hash of disparate subfields.
I can try to answer the second part of your question.The collisions will probably result not from the hash code itself, but from mapping the hash code to an index in a collection. So for example your hash function could return random values from 1 to 10000, but if your hash table only has 32 entries you'll get collisions on insertion.In addition, I would think that collisions would be resolved by the collection internally, and there are many methods to resolve collisions. The simplest (and worst) is, given an entry to insert at index i, add 1 to i until you find an empty spot and insert there. Retrieval then works the same way. This results in inefficient retrievals for some entries, as you could have an entry that requires traversing the entire collection to find!Other collision resolution methods reduce the retrieval time by moving entries in the hash table when an item is inserted to spread things out. This increases the insertion time but assumes you read more than you insert. There are also methods that try and branch different colliding entries out so that entries to cluster in one particular spot. Also, if you need to resize the collection you will need to rehash everything or use a dynamic hashing method. In short, depending on what you're using the hash code for you may have to implement your own collision resolution method. If you're not storing them in a collection, you can probably get away with a hash function that just generates hash codes in a very large range. If so, you can make sure your container is bigger than it needs to be (the bigger the better of course) depending on your memory concerns. Here are some links if you're interested more: coalesced hashing on wikipediaWikipedia also has a summary of various collision resolution methods: Also, "File Organization And Processing" by Tharp covers alot of collision resolution methods extensively. IMO it's a great reference for hashing algorithms. 
Depends on the size of the hash value you return. It's simple logic that if you need to return a 32bit int based on the hash of four 32bit ints, you're gonna get collisions.I would favor bit operations. Like, the following C pseudo code:Such a system could work for floats too, if you simply took them as their bit value rather than actually representing a floating-point value, maybe better.For strings, I've got little/no idea.


Answer URL
