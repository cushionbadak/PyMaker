Natural Text
I was writing a metaclass and accidentally did it like this:...instead of like this:What exactly is the difference between these two metaclasses?  And more specifically, what caused the first one to not work properly (some classes weren't called into by the metaclass)?
In the first example you're creating a whole new class:while in the second case you're calling parent's :
The first thing you need to figure out is how  works.Here it is from the documentation:Called to create a new instance of class .  is a static  method (special-cased so you need not declare it as such) that takes  the class of which an instance was requested as its first argument.  The remaining arguments are those passed to the object constructor  expression (the call to the class). The return value of   should be the new object instance (usually an instance of ).Typical implementations create a new instance of the class by invoking  the superclass’s  method using  with appropriate arguments and then modifying  the newly-created instance as necessary before returning it.If  returns an instance of , then the new instance’s  method will be invoked like , where  is the new instance and the remaining arguments are the same as  were passed to .If  does not return an instance of , then the new instance’s  method will not be invoked. is intended mainly to allow subclasses of immutable types (like , , or ) to customize instance creation. It is also  commonly overridden in custom metaclasses in order to customize class  creation.So in mg.'s answer, the former doesn't call function  while the latter calls function  after calling .
Please refer to the annotation below, hope this helpful.
What you get back from this is a new , and not a  instance at all. Consequently, your methods defined in  (including ) can't ever be called. will be called as part of creating that new type, yes, but the value of  going into that function is going to be  and not .
Another way to achieve the same result: is a callable so Python will use the special method .Python will look for  in the 's type (which is  in our case)"For new-style classes, implicit invocations of special methods are  only guaranteed to work correctly if defined on an object’s type, not  in the object’s instance dictionary" is interpreted as:Inside the  I imagine something like this: will decide how the  is built: will set the correct metaclass (which is ) for  will set the default metaclass (which is type) for 
It's all described pretty well here.If you don't return the right type of object, there's no point to defining a custom metaclass. 


Answer URL
https://docs.python.org/3/reference/datamodel.html#object.__new__
