Natural Text
I wanto to match the last occurence of a simple pattern in a string, e.g.however, if the string is very long, a huge list of matches is generated. Is there a more direct way to match the second occurence of "AAAA" or should I use this workaround?
you could use  that denotes end of the line character:Also, note that  is a bad name for your variable, as it shadows built-in type. To access the last element of a list you could just use  index:
You can avoid the building of a list just by iterating over all matches and keeping the last match:After this,  holds the last match, and works for all combinations of pattern and searched string. You might want to set  to  first, because if there's no match,  won't be set to any value.
I wasn't sure if your original regex would give you what you wanted.So sorry if I'm late to party.. But others may find this useful too.Outputs:The reason you get two results here instead of one in original is the  special sauce.It's called a positive lookahead. It does not 'consume' (i.e. advance the cursor), when the match is found during the regex evaluation. So, it comes back after matching.Although positive lookaheads are in parenthesis, they also act as a non-capture group. So, although a pattern is matched, the results omit the surrounding sequence of alphanumeric characters represented by the  and the intervening spaces,  in my example -representing . (More here)So I only get back AAAA each time. here, represents the original pattern of the code of @SDD, the person posing the question. is consumed, with that pattern so second AAAA would not match, as the cursor had advanced too far, when the regex engine recommences on it's second iteration of matching.I recommend taking a look at Moondra's Youtube videos if you want to dig in deeper.He has done a very thorough 17 part series  on Python Regex's, beginning here Here's a link to an online Python Interpreter
There is no built-in  library feature that supports right-to-left string parsing, the input string is only searched for a pattern from left to right.There is a PyPi regex module that supports this feature, however. It is  flag, or its inline variation, :With  module, there is a way to quickly get to the end of string using  construct and let backtracking find the pattern that you'd like to caputure into a separate group. However, backtracking may gobble part of the match (as it will stop yielding more text once all subsequent patterns match), and in case the text is too large and there is no match, backtracking may become catastrophic. Only use this trick if your input string always matches, or if it is short and the custom pattern is not relying on backtracking much:Here,  matches an optional sequence of a start of string, any 0 or more chars followed with a non-word char (). It is necessary to add  to make backtracking get back to the non-word char, and it must be optional as the match might start at the start of the string.See the Python demo.
Another fast way is using , and :What it does:It uses the pattern of , which get's the last occurrence of  with there be-siding words alongside of them, all using  (twice), and  (once).After the process of the pattern matching, you will have to use the  method to get the belonging value of the  object, and of course get the zeroth (first) group, as know that  only retains one match (the zeroth).Here is the regex101 of it.Here are the timings for all of the answers (except for JGFMK's answer, since it is hard):I am testing all the timings using  module, and also i am making  so it takes much longer.


Answer URL
https://docs.python.org/3/library/re.html#regular-expression-syntax
