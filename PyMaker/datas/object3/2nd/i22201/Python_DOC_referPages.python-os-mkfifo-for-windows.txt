Natural Text
Short version (if you can answer the short version it does the job for me, the rest is mainly for the benefit of other people with a similar task):In python in Windows, I want to create 2 file objects, attached to the same file (it doesn't have to be an actual file on the hard-drive), one for reading and one for writing, such that if the reading end tries to read it will never get EOF (it will just block until something is written). I think in linux os.mkfifo() would do the job, but in Windows it doesn't exist. What can be done? (I must use file-objects).Some extra details:I have a python module (not written by me) that plays a certain game through stdin and stdout (using raw_input() and print). I also have a Windows executable playing the same game, through stdin and stdout as well. I want to make them play one against the other, and log all their communication.Here's the code I can write (the  function is not implemented, because that's what I don't know to do it Windows):
Following the two answers above, I accidentally bumped into the answer. os.pipe() does the job. Thank you for your answers.I'm posting the complete code in case someone else is looking for this:
For a cross-platform solution, I'd recommend building the file-like object on top of a socket on localhost (127.0.0.1) -- that's what IDLE does by default to solve a problem that's quite similar to yours.
On Windows, you are looking at (Named or Anonymous) Pipes.A pipe is a section of shared memory that processes use for communication. The process that creates a pipe is the pipe server. A process that connects to a pipe is a pipe client. One process writes information to the pipe, then the other process reads the information from the pipe.To work with Windows Pipes, you can use Python for Windows extensions (pywin32), or the Ctypes module. A special utility module, win32pipe, provides an interface to the win32 pipe API's. It includes implementations of the  convenience functions.See how-to-use-win32-apis-with-python and similar SO questions (not specific to Pipes, but points to useful info).
 returns an anonymous pipe, or a named pipe on Windows, which is very lightweight and efficient.TCP sockets (as suggested by user1495323) are more heavyweight: you can see them with netstat for example, and each one requires a port number, and the number of available ports is limited to 64k per peer (e.g. 64k from localhost to localhost). On the other hand, named pipes (on Windows) are limited because:You can't use select() for nonblocking I/O on Windows, because they're not sockets.There's no apparent way to  with a timeout, and Even making them non-blocking is difficult.And sockets can be wrapped in Python-compatible filehandles using , which allows them to be used to redirect stdout or stderr. This makes this an attractive option for some use cases, such as sending  from one thread to another.A socket can be constructed with an automatically-assigned port number like this (based on the excellent Python socket HOWTO):The user of  (e.g. another thread) can then do:


Answer URL
https://docs.python.org/3/howto/sockets.html#socket-howto
https://docs.python.org/3/howto/sockets.html#socket-howto
