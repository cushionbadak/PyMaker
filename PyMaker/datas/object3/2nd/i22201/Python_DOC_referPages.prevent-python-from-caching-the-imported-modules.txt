Natural Text
While developing a largeish project (split in several files and folders) in Python with IPython, I run into the trouble of cached imported modules.The problem is that instructions  only reads the module once, even if that module has changed! So each time I change something in my package, I have to quit and restart IPython. Painful.Is there any way to properly force reloading some modules? Or, better, to somehow prevent Python from caching them?I tried several approaches, but none works. In particular I run into really, really weird bugs, like some modules or variables mysteriously becoming equal to ...The only sensible resource I found is Reloading Python modules, from pyunit, but I have not checked it. I would like something like that.A good alternative would be for IPython to restart, or restart the Python interpreter somehow.So, if you develop in Python, what solution have you found to this problem?EditTo make things clear: obviously, I understand that some old variables depending on the previous state of the module may stick around. That's fine by me. By why is that so difficult in Python to force reload a module without having all sort of strange errors happening?More specifically, if I have my whole module in one file  then the following works fine:This piece of code works beautifully and I can develop without quitting IPython for months.However, whenever my module is made of several submodules, hell breaks loose:Why is that so different for Python whether I have my module in one big file or in several submodules? Why would that approach not work??
Quitting and restarting the interpreter is the best solution. Any sort of live reloading or no-caching strategy will not work seamlessly because objects from no-longer-existing modules can exist and because modules sometimes store state and because even if your use case really does allow hot reloading it's too complicated to think about to be worth it.
 checks to see if the module is in , and if it is, it returns it. If you want import to load the module fresh from disk, you can delete the appropriate key in  first.There is the  builtin function which will, given a module object, reload it from disk and that will get placed in . Edit -- actually, it will recompile the code from the file on the disk, and then re-evalute it in the existing module's . Something potentially very different than making a new module object.Mike Graham is right though; getting reloading right if you have even a few live objects that reference the contents of the module you don't want anymore is hard. Existing objects will still reference the classes they were instantiated from is an obvious issue, but also all references created by means of  will still point to whatever object from the old version of the module. Many subtly wrong things are possible.Edit: I agree with the consensus that restarting the interpreter is by far the most reliable thing. But for debugging purposes, I guess you could try something like the following. I'm certain that there are corner cases for which this wouldn't work, but if you aren't doing anything too crazy (otherwise) with module loading in your package, it might be useful.Which I very briefly tested like so:printing:
With IPython comes the autoreload extension that automatically repeats an import before each function call. It works at least in simple cases, but don't rely too much on it: in my experience, an interpreter restart is still required from time to time, especially when code changes occur only on indirectly imported code.Usage example from the linked page:
There are some really good answers here already, but it is worth knowing about dreload, which is a function available in IPython which does as "deep reload". From the documentation:The IPython.lib.deepreload module allows you to recursively reload a  module: changes made to any of its dependencies will be reloaded  without having to exit. To start using it, do:http://ipython.org/ipython-doc/dev/interactive/reference.html#dreloadIt is available as a "global" in IPython notebook (at least my version, which is running v2.0).HTH
You can use import hook machinery described in PEP 302 to load not modules themself but some kind of proxy object that will allow you to do anything you want with underlying module object — reload it, drop reference to it etc.Additional benefit is that your currently existing code will not require change and this additional module functionality can be torn off from a single point in code — where you actually add finder into .Some thoughts on implementing: create finder that will agree to find any module, except of builtin (you have nothing to do with builtin modules), then create loader that will return proxy object subclassed from  instead of real module object. Note that loader object are not forced to create explicit references to loaded modules into , but it's strongly encouraged, because, as you have already seen, it may fail unexpectably. Proxy object should catch and forward all ,  and  to underlying real module it's keeping reference to. You will probably don't need to define  because of you would not hide real module contents with your proxy methods. So, now you should communicate with proxy in some way — you can create some special method to drop underlying reference, then import module, extract reference from returned proxy, drop proxy and hold reference to reloaded module. Phew, looks scary, but should fix your problem without reloading Python each time.
I am using PythonNet in my project. Fortunately, I found there is a command which can perfectly solve this problem.
Think twice for quitting and restarting in production The easy solution without quitting & restarting is by using the reload from imp 
For Python version 3.4 and aboveRefer below documentation for details.


Answer URL
https://docs.python.org/3/library/importlib.html#importlib.reload
