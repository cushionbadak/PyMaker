Natural Text
I have small set of color data that I want to investigate. It is in the form of a list of RGB data. The image uses a restricted palette, and I would like to see how these colors are "distributed" by plotting them along the color wheel. As alternative, I tried histogram of individual channels, but this did not give me the insight I am interested in. I googled and learned that HSL color more accurately maps to color wheel. However, after converting to HSL, I'm still confused. 3 pieces of data still make up the color: Hue, saturation, and luminosity. How do you map 3 piece of data onto a 2d plane? I read about polar coordinates here: https://www.mathsisfun.com/polar-cartesian-coordinates.html. I try ignoring luminosity and plotting by treating HSL data as Polar coordinate (hue = angle, saturation = length of radius (scaled by some factor))This is not correct result. As it shows same red color hue in multiple places like this example: bad chartWhat is the correct way to translate from RGB to a position on color wheel? 
The problem of mapping a 3D (H, S, V) colour onto a 2D plane is a tough one to solve objectively, so I thought I'd give a crack at it and come up with results that I find pleasing.My approach is as follows:For every (R, G, B) pixel in the image, convert it to (H, S, V).Convert the (H, S, V) colour to a 2D vector using the H value as the angle and the S value as the magnitude.Find the position of that vector in our 2D output image, and only write the pixel if the value (V) is greater than the value of what was previously in that pixel. (My reasoning is that since an image is likely to have multiple pixels of similar enough colours that they appear in the same place on our colour wheel, since we are not plotting using the value, we should give higher value pixels precedence to be shown.)Now, in code: (Entire file)Create a table to store the largest value in every particular positionConvert RGB to HSVConvert that to a vectorConvert that to a point on our imageIf the value is higher, return the point, otherwise I called all that the  function, now we will use it for every pixel in our image: determines whether the value was higher, since c is  when it wasn't.Here's the results:Note: Part of the reason I am dealing with value like this is because the alternatives I thought of were not as good. Ignoring value completely lead to darker pixels turning up on the output image, which usually lead to an ugly wheel. Turning the value up to 1 for every output pixel lead to very generic looking wheels that didn't really give a good idea of the original input image.


Answer URL
https://docs.python.org/3/library/colorsys.html#module-colorsys
