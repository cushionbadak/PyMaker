Natural Text
I was going through the documentation on pickle (python pickle) and in the comparison with marshal section I found out that in case of multiple references to an object, pickle serializes only one instance of the object and all the other references are pointed to the master copy of the serialized object.But i want to know how pickle serializes object in case of recursive objects.
If you already understand how it's replacing repeated references with pointers to the master, there's really nothing different happening for recursive objects, except for one minor twist.Let's just step through some simple examples, using a simplified version of what pickle actually does.To dump , you need to:step into the listdump that 1dump that second 1dump a list-build(2) instructionIf you keep a memo dictionary of elements you've seen, you can:look for  in memo—not seen, so step into the listlook for  in memo—not seen, so dump the 1, and add it to look for  in memo—already there, so just dump a referencedump a list-build(2) instructionadd the list to memoNow, what if we have something like  and try to dump that?look for  in memo—not seen, so step into the listlook for  in memo—not seen, so step into the list… oops, that will hit a .So, what you do instead is to add the target for  to memo as soon as you see it—before you actually emit the code that builds the list. That's fine; references only need to know the position, not what's there. So:look for id([...]) in memo—not seen, so add it to memo, then step into the listlook for id([...]) in memo—seen, so just put a referenceput a list-build(1) instructionThis does make things slightly slower, and can generate larger pickles, so  has a  option to not pass down a memo dict. If you use that option, you will get a . And the option is deprecated anyway. As the docs say, the way to get smaller pickles is to build the pickle normally, then call  on it, which will filter out any unnecessary PUTs that got created.Of course the real pickle doesn't dump things like  and —but it's actually not that different. You can use the  module to see what it really does generate:As you can see, the  is basically just , and it didn't bother making a shared reference because  is a simple object that's just as small as the reference would be. But, rather than a  it actually creates an  and then calls and  to add the elements to the list.And if you dump the recursively self-including list:… it's just appending the list to itself. The same way you build it in Python.


Answer URL
https://docs.python.org/3/library/pickle.html
https://docs.python.org/3/library/pickle.html#pickle.Pickler.fast
https://docs.python.org/3/library/pickletools.html#pickletools.optimize
https://docs.python.org/3/library/pickletools.html#pickletools.optimize
