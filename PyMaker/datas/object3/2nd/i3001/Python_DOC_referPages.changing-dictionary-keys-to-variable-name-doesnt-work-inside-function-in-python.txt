Natural Text
First of all, let me say that I read the many threads with similar topics on creating dynamically named variables, but they mostly relate to Python 2 or they assume you are working with classes. And yes, I read Behavior of exec function in Python 2 and Python 3. I'm also aware that creating dynamically named variables is a bad idea in 99% of time and dictionaries are the way to got, but I just want to know whether it is still possible and how exactly exec and locals work in python 3.I'd like to show a bit of sample code illustrating my question (fibonacci calculates fibonacci numbers, ListOfLetters provides ["A", "B", ...]):So at least at my current understanding, there is some inconsistency in the behaviour of , since it contains the variable names added by  but the variables are not available in the function.I would be greatful if someone could explain this and tell whether this is by design or if it is a real inconsistency in the language. Yes, I know that  should not be modified , but I'm not modifying it, I'm calling ... 
When you're not sure why something works the way it does in Python, it often can help to put the behavior that you're confused by in a function and then disassemble it from the Python bytecode with the  module.Lets start with a simpler version of your code:If you run , you'll get the same exception you're seeing with your more complicated function:Lets disassemble it and see why:The operation that you need to pay attention to is the one labeled "13". This is where the compiler handles looking up  within the last line of the function (). It is using the  opcode, which fails because "K" is not a global variable name, rather it's a value in our  dict (added by the  call).What if we persuaded the compiler to see  as a local variable (by giving it a value before running the ), so it will know not to look for a global variable that doesn't exist?This function won't give you an error if you run it, but you won't get the expected value printed out:Lets disassemble to see why:Note the opcodes used at "3" and "19". The Python compiler uses  and  to put the value for the local variable  into slot 0 and later fetch it back out. Using numbered slots is significantly faster than inserting and fetching values from a dictionary like , which is why the Python compiler does it for all local variable access in a function. You can't overwrite a local variable in a slot by modifying the dictionary returned by  (as  does, if you don't pass it a dict to use for its namespace).Indeed, lets try a third version of our function, where we peek into  again when we have  defined as a regular local variable:You won't see  in the output this time either!The reason you see the old  value in  is explained in the function's documentation:Update and return a dictionary representing the current local symbol table.The slot that the local variable 's value is stored in was not changed by the  statement, which only modifies the  dict. When you call  again, Python "update[s]" the dictionary with the value from the slot, replacing the value stored there by .This is why the docs go on to say:Note: The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.Your  call is modifying the  dict, and you're finding how its changes are not always seen by your later code.
On the exec/eval/locals questionAt least on the CPython implementation modifications to the  dictionary do not actually change the names in the local scope, which is why it's meant to be used read-only. You can change it, and you can see your changes in the dictionary object, but the actual local scope is not changed. takes two optional dictionary arguments, a global scope and a local scope. It defaults to  and , but since changes to  aren't "real" outside of the dictionary,  only affects the "real" local scope when , i.e. in a module outside of any function. (So in your case it's failing because it's inside a function scope).The "better" way to use  in this case is to pass in your own dictionary, then operate on the values in that.In this case,  is used as the global and local scope for the , and after the  it will contain  (the builtins are inserted for you if not present)If you want access to more globals you could do .Passing in different global and local scope dictionaries can produce "interesting" behavior.If you pass the same dictionary into successive calls to  or , then they have the same scope, which is why your  worked (it implicitly used the  dictionary).On dynamic variable namesIf you set the name from a string, what's so wrong about getting the value as a string (i.e. what a dictionary does)? In other words, why would you want to set  and then access ? If  is in your source it's not really a dynamically set name... hence, dictionaries.


Answer URL
https://docs.python.org/3/library/functions.html#locals
