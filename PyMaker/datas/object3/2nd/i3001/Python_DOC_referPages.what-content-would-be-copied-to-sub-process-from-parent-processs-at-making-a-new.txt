Natural Text
Some articles told me that making an new sub process, the operation system will almost copy all data from partent, including process's struct, stack, heap and so on. So, i think the global variables, static variables may be copied to sub process, whose contens are equal to the parent's values at the monment of invoking the fork(). But following python code's result make me confusion:the executing results of above codes:The results i expected:I don't know why the changes of  in function  are not copied to sub process, but the changes in global section  are visible to sub process.thanks for every reponse.
As explained in the docs,  has three different ways of starting processes. The two main ones are  and .1 copies your parent process. You were right on the nose about what this does:2 the children start with copies of the parent's globals, and so on. creates a brand new process, starts the Python interpreter, and s your module.On Unix,  is the default, but  and  are available as options. On Windows,  is the default, and the only option, because Windows doesn't provide a  API.Since you're on Windows, the children don't get a copy of  from the parent—but the  and  code gets run on , so they all end up with equal values anyway. But any code protected by a  guard doesn't get run by , so they don't call , so no , so no .The  library is designed so you can use it in a way that works the same on all platforms.3 Most of the details are covered pretty well in the Programming guidelines section of the docs, but the basic idea is: Don't assume that globals are copied, or that they aren't copied. This means you generally won't have any code outside a  guard at the top level, except for , , and  statements, and maybe a few simple global constant assignments.Any complicated setup you need to do, you do in each child process.4 Anything you want to share between processes (like a , or a ), you create inside the  guard and pass to the children as arguments.1. For , see the docs for details; it's mainly there for programs that use libraries that expect to do fancy things with threads that don't work well with , which is a common thing on macOS—although it can be useful in some other cases.2. There are some complexities about things like open files, but they're not important here.3. You could just specify  and then treat every platform like Windows. But on some Unix platforms, it can be slow to  processes. Also, getting things like shared files to work can be painful on Unix, so it's sometimes easier to write code that works with  or , than to write code that works with  on Unix or  on Windows. Using  on Unix and  on Windows can, however, be a good compromise/4. If you're using s, use an  function.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
https://docs.python.org/3/library/multiprocessing.html#programming-guidelines
