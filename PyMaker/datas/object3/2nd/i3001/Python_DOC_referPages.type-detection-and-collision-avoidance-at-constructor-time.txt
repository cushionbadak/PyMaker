Natural Text
Thanks everyone for your help so far. I've narrowed it down a bit. If you look at HERE in both the script and the class, and run the script, you'll see what is going on. The ADD line print "789 789"when it should be printing "456 789" What appears to be happening, is in new the class is detecting the type of the incoming argument. However if the incoming object, has the same type as the constructor it appears to be paging the incoming object, into itself (at the class level) instead of returning the old object. That is the only thing I can think of that would cause 456 to get creamed. So how do you detect something that is the same type of a class, within a constructor and decide NOT to page that data into the class memory space, but instead return the previously constructed object? testfoo.py:
How do I, at constructor time, return a non-new object?By overriding the constructor method, , not the initializer method, .The  method constructs an instance—normally by calling the super's , which eventually gets up to , which does the actual allocation and other under-the-covers stuff, but you can override that to return a pre-existing value.The  method is handed a value that's already been constructed by , so it's too late for it to not construct that value.Notice that if  returns a  instance (whether a newly-created one or an existing one),  will be called on it. So, classes that override  to return references to existing objects generally need an idempotent —typically, you just don't override  at all, and do all of your initialization inside .There are lots of examples of trivial  methods out there, but let's show one that actually does a simplified version of what you're asking for:Now:Notice that I made sure to use  rather than , and 1 rather than . So:However, it may be a better option to use a classmethod alternate constructor, or even a separate factory function, rather than hiding this inside the  method.For some types—like, say, a simple immutable container like —the user has no reason to care whether  returns a new tuple or an existing one, so it makes sense to override the constructor. But for some other types, especially mutable ones, it can lead to confusion. The best test is to ask yourself whether this (or similar) would be confusing to your users:If that can't happen (e.g., because  is immutable), override .If that exactly what users would expect (e.g., because  is a proxy to some object that has the actual , and two proxies to the same object had better see the same ), probably override .If it would be confusing, probably don't override .For example, with a classmethod:… it's a lot less likely to be surprising if  turns out to be true.1. Even though you define  like an instance method, and its body looks like a class method, it's actually a static method, that gets passed the class you're trying to construct (which will be  or a subclass of ) as an ordinary first parameter, with the constructor arguments (and keyword arguments) passed after that.
Thanks everyone who helped! This answer was saught out to understand how to refactor an existing program that was already written, but that was having scalability problems. The following is the completed working example. What it demonstrates is: The ability to test incoming types and avoid unneccessary object duplication at constructor time, given incoming types that are both user-defined and built-in. The ability to construct on the fly from a redefined operator or method. These capabilities are neccessary for writing scalable supportable API code. YMMV.Foo.pytestfoo.py


Answer URL
https://docs.python.org/3/reference/datamodel.html#basic-customization
