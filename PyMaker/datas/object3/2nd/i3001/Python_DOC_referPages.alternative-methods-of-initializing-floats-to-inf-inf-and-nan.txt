Natural Text
To initialize float constants to +inf, -inf, nan I always use float() called with a string:This prints:1.) Does there exist in Python an alternative method of initializing these constants (not calling float with a string)?2.) Can I produce these constants (+/-inf, nan) with some mathematical operation?E.g. for setting the variable  to , by writing something like  (obviously, this is a division by zero error).
Technically, yes, there are other ways of initializing such values, but they're all either less obvious, or much less convenient.If your platform uses IEEE floating point,1 any  arithmetic  that overflows, without raising any other flags besides overflow, is guaranteed to give you . This means  probably won't work (Python will detect that this is a division by zero), but the even simpler  will.2Once you have , you can just do  and  to get the negative infinity and NaN values.But would someone reading your code understand  as readily as ? Probably not.Meanwhile, you can always do something like , which unpacks the well-defined bit pattern for an IEEE big-endian double  value as a , whether your  is that type under the covers or not. But why would you want to write (or read) that?3But, if you're using Python 3.5 or later, you don't need to initialize those values; you can just use the constants in the  module:And if you're using Python 2.7 or 3.4 or something, you can always just define your own constants and use them over and over:1. Technically, Python doesn't require IEEE floating point. In fact, what it requires are something that acts like the platform's C —which C doesn't require to be an IEEE type, and only if that makes sense for the implementation (e.g., Jython is obviously going to use the relevant Java type without caring what the C compiler used to compile the JVM thinks), and it doesn't clarify exactly what it means to act like a C double. However, the  type—not to mention things like the  module—really isn't going to work unless  is something reasonably close to an IEEE float type, like maybe the pre-IEEE IBM and Intel types or the not-quite-IEEE Motorola compat types. Also, as of 2018, the only supported platforms by any of the three existing Python 3.x implementations all give you either IEEE 754-1985  or IEEE 754-2008 . But, if this is really a potential issue for your code, you should check  to verify whatever assumptions are relevant.2. It's conceivable that some platform might use an IEEE 754-1985  or an IEEE 754-2008  or something. If you're worried about that, just use a bigger number. Or, say, .3. Well, if you specifically need a quiet or signaling NaN, or one with a custom bit pattern instead of the default one… but anyone who needs that presumably already knows they need that.
You can access those mathematical constants from the  module:Behind the scenes, in the CPython inplementation,  and  are generated using the same technique as that which  and  use; both approaches invoke the API functions  and  respectively.
Not sure if this is what you want, but numpy has variables built in for that.
 constant was introduced in python3.5, you can read more about in https://docs.python.org/3/library/math.html#constants:math.inf A floating-point positive infinity. (For negative infinity,  use -math.inf.) Equivalent to the output of float('inf').New in version 3.5.As you can see below, they're both identical ones:In case you're also interested about how infinity is checked under the curtains you can take a look to the Py_IS_INFINITY macro.
If you are looking to get these values through mathematical operations:Output:This result is consistent with the IEEE 754 floating point behavior.In IEEE 754 arithmetic, a ÷ +0 is positive infinity when a is  positive, negative infinity when a is negative, and NaN when a = ±0.


Answer URL
https://docs.python.org/3/library/math.html#constants
https://docs.python.org/3/library/sys.html#sys.float_info
https://docs.python.org/3/library/math.html#constants
