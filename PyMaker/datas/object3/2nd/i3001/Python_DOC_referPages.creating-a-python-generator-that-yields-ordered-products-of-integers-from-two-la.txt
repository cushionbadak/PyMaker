Natural Text
So, I have two very large lists of numbers  and .  I'd like to multiply each element of  with each element of  without explictly creating a new list of products.  Thus, I'd like a generator.  This part is easy.  I can just do something likeHowever, I also need these products to be ordered by their magnitude.  I am wondering if there is some clever trick to order the yield statements so that this can also be done with a generator.  In Python 3, if possible.  Thanks.
I'll call the lists  and , and assume they're sorted.  As you noted in a comment, the smallest product is necessarily  - but only if you're also assuming that all numbers are non-negative, so I'll assume that too.After the first product, it gets messier - else you already would have solved it ;-)  The next two to consider are  and .  Easy enough, but then the next to consider depends on which of those won.  If  won, you only need to replace it with , but if  won then both  and  come into play.  And so on.The following keeps track of the growing set of possibilities with a heap.  The heap never holds more than  items, so the code first arranges to make  the shorter list:I'd be pleasantly surprised if an essentially more efficient solution existed.  If someone thinks they have one, please try it first using this randomized tester:EDIT - THEORETICALLY BETTER IN SOME SENSE ;-)The above doesn't fully exploit the partial ordering we can deduce from indices alone:  ifthen we knowbecause sorting implies  and .So, for example, if the index pairs  and  are on the heap, and the second one wins,  needs to be added to the heap but  doesn't:  from the indices alone, we know that the product from the  remaining in the heap is no larger than the product from .  It's only when  is also removed that  needs to be added.In general, each pair of the form  has a single immediate predecessor , and  the single , and all other  have two immediate predecessors:   and .  There's no need to put a pair on the heap until all its predecessors have been taken off the heap.Which leads to this code, which is seemingly "more elegant" because more symmetric:Compared to the first code, it keeps the heap somewhat smaller in many cases.  But heap operations take time logarithmic in the number of heap entries, and the heap can still grow to  entries, so that's not much of a win.  It's probably lost to the overhead of the two new function calls (while inlining those is too ugly to bear).
My solution is to create a list of generators, one generator for each row in the product matrix, and then to use  to sort the outputs of those generators. Each generator has a size of 44 bytes on a 32 bit machine, so the whole list of generators only consumes a modest amount of RAM.  (when no sorting key function is supplied) works by creating a 3-tuple of each of the iterables you pass it. That tuple contains the next value from the iterable, an index number for the iterable, and a reference to the iterable's  method. It places those tuples onto a heap to perform a mergesort of the iterables' values. You can see the details in its Python source code.Thus my approach is not quite as frugal as Tim Peters' solutions, but it's not too shabby, IMHO. ;)Here's some  code which shows the running time of , Tim Peters' solutions, plus a few other versions of mine. I've used Tim's variable names to keep the code uniform. It's interesting to note that Tim's 1st version is roughly twice as fast as his more advanced solution. My  runs quite quickly, but it's a terrible RAM hog.The  code uses a technique given in the  recipes to exhaust an iterator: we feed it to a zero-length deque. The  code sorts the 3 results from each  run. That's because the minimum result is the important one, the other values just give an indication of the variance in the system at the time the test ran. See the note in the docs for  for details.Here's the output on my ancient 2GHz 32 bit single core machine, running Python 3.6.0 on an old Debian derivative distro of Linux. YMMV.
It doesn't seem like there is any other way to order these outputs without creating a list, because the outputs cannot be sorted without being stored. Here's how you could do that.Hope that helps.


Answer URL
https://docs.python.org/3/library/heapq.html#heapq.merge
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/library/timeit.html#timeit.Timer.repeat
