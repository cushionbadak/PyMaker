Natural Text
I'm new with Python language and a I'm a little bit frustrated.Till today, I thought that passing parameter names in a function call was not mandatory; for example, if you have the following function:I thought that you can call like this  only to make clearer the meaning of the parameters, but actually keywords of input arguments were not needed, so you can call the same function in this way also:  Today, while using '', I realized that 'fill_type' keyword is a necessary when calling this function. Suppose that you call the function in this way: , then the interpretation of the input parameter will be wrong.I have some experience with OOP language (Java, C#) and these thing doesn't exist there. It seems an inconsistent behaviour to me that some parameter names (like 'start_color' and 'end_color' in the example above) are optional, while others (like 'fill_type') must be specified before their values.Can someone explain me why this apparently strange policy? In addition, I will be glad if someone can point me out some useful resource to understand the way it is implemented.
Positional and keyword parameters work just as they do in the languages you know better.  You need to go to the documentation of the method you're using and look at the signature.  For creating a  object, go to the class's  method.You may specify arguments without the keyword as long as you supply them all in order, without skipping any.  For instance, your failing call can be legally given as:These will match the first four parameters.  Any time you supply an argument out of order, then you must supply the keyword for that argument and all later arguments in that invocation.  For instance, with the above call, if you want to let they style default to , then you must supply the keywords for the three arguments you do supply.  If you simply omit the , then the parser still tries to match them up sequentially from the front:... and your call fails to pass parsing.Does that clear things up a little?
Can someone explain me why we need this "headache"…For your specific example, it doesn't appear that there are any keyword-only parameters. Rather, you're trying to pass arguments for the first, second, and fourth parameters, without having to pass an argument for the one in between that you don't care about.In other words, it's not a headache at all. It's a convenience (and sanity check) you could quite easily ignore—but probably don't want to.Instead of this:… you could write this:… but in order to know that's what you'd need to send, you need to read the source or docs to see the whole parameter list, and see what the default values are for the parameters you want to skip over, and explicitly add them to your call.I doubt anyone would find that better.Also, as multiple people pointed out in comments, this is pretty much exactly how named arguments work in C#.And this class is, accidentally, a great example of why Python actually does allow keyword-only parameters, even though they aren't being used here.The fact that you can write  and not get a  for bad arguments to , but instead a mysterious error about  not working as a color, is hardly a good thing. And (at least without type hinting annotations, which this type doesn't have) there's no way your IDE or any other tool could catch that mistake.And, in fact, by not using keywords, you've even gotten the initial arguments wrong, without realizing it. You almost certainly wanted to do this:… but you got away with this without a visible error:… which means you're passing your foreground color as a pattern type and your background color as a foreground color and leaving the default background color.That could be solved by making all or most parameters keyword-only. But without keyword-only params, the only option would be , and that tradeoff is usually not worth it.Quoting from the Rationale of PEP 3102, the proposal that added keyword-only parameters to the language:There are often cases where it is desirable for a function to take a variable number of arguments. The Python language supports this using the 'varargs' syntax (*name), which specifies that any 'left over' arguments be passed into the varargs parameter as a tuple.One limitation on this is that currently, all of the regular argument slots must be filled before the vararg slot can be.This is not always desirable. One can easily envision a function which takes a variable number of arguments, but also takes one or more 'options' in the form of keyword arguments. Currently, the only way to do this is to define both a varargs argument, and a 'keywords' argument (), and then manually extract the desired keywords from the dictionary.If it isn't obvious why using  and  isn't good enough:The actual signature of the function is not visible when looking at the function definition in the source, or the inline , or auto-generated docs.The signature is also not available to dynamic reflective code using the  module or similar.The signature is also not available to static reflective code—like that used by many IDEs to do completion and suggestions.The implementation of the function is less clear, because at best it's half boilerplate for extracting and testing the parameters, and at worst the  and  access are scattered throughout the body of the function.For an example of what this feature allows, consider the builtin  function, which you can call like this:This works because  is defined like this:If it weren't for keyword arguments, there'd be no way to pass that  as something different from the actual values to print.You could force the user to pass all of the objects in a tuple instead of as separate arguments, but that would be a lot less friendly—and even if you did that, there'd be no way to pass  without passing values for all of , , and .And, even with keyword arguments, if it weren't for keyword-only parameters, the function signature would have to look like this:… which would make it a lot harder to figure out what keyword arguments you could pass.


Answer URL
https://docs.python.org/3/library/functions.html#print
