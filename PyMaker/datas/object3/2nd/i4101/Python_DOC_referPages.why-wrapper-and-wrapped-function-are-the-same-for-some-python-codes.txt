Natural Text
I was reading Ian Goodfellow's GAN source code in Github (link https://github.com/goodfeli/adversarial/blob/master/deconv.py). In particular, at line 40/41, the code is:It's a rather unfamiliar way of using , and it seems the goal is to replace the  with a user defined function. But in that case, we don't really need a wrapper for that, right? I don't really know the purpose of  in this case.
 copies a number of attributes from another function onto this function—by default, , , ,  and .The most obviously useful one to copy over is the . Consider this simpler example:1Now if someone wants to use , they'll get the 29 lines of useful information. (Or, if they autocomplete  in PyCharm, it'll pop up the overlay with the documentation, etc.) All without me having to manually copy and paste it. And, even better, if  came from some framework that I didn't write, and my user upgrades from 1.2.3 to 1.2.4 of that framework, and there's a better docstring, they'll see that better docstring.In the most common case,  would be a subclass of , and  would be an override.2 But that isn't actually required— doesn't care whether you're subtyping via inheritance, or duck typing by just implementing an implicit protocol; it's equally useful for both cases. As long as  is intended to implement the  protocol from , it makes sense for  to have the same docstring (and maybe other metadata attributes).Others attributes probably aren't quite as useful as docstrings. For example, if you're using type annotations, their benefit in reading the code is probably at least as high as their benefit in being able to run Mypy for static type checking, so just copying them over dynamically from another method often isn't all that useful. And  and  are primarily used for reflection/inspection, and are more likely to be misleading than helpful in this case (although you could probably come up with an example of a framework where you'd want people to read the code in  instead of the code in , that isn't true for the default obvious example). But, unless they're actively harmful, the readability cost of using  instead of just the defaults may not be worth it.1. If you're using Python 2, change these classes to inherit from ; otherwise they'll be old-style classes, which just complicates things in an irrelevant way. If Python 3, there are no old-style classes, so this issue can't even arise.2. Or maybe a "virtual subclass" of an ABC, declared via a  call, or via a subclass hook.
The purpose of  is to copy meta information of one function to another function. This is usually done when replacing the original function by wrapping it, which is often done by decorators.But in general case, here is what it does in an example:Now, you can test what happened:When you call , it is obvious that it is actually , but when you inspect it, it behaves like  - it has the same doc string and the same name.What is that good for? For this:Now the original f1 is replaced with a new functionality, but it still looks like  from the outside.It is usually done in a decorator:And it behaves like this:


Answer URL
https://docs.python.org/3/library/functools.html#functools.wraps
