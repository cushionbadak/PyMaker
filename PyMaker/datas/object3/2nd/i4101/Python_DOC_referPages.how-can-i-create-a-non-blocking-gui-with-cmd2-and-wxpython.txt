Natural Text
How can I create non-blocking  GUI windows from a  interpreter command even though both the interpreter and  must be run on the main thread?I am creating a command-line interpreter in Python 3.x using the  module. One command in my interpreter will allow me to create a "non-blocking"  GUI window with a countdown timer that runs in a separate thread. It needs to run separately from the main interpreter thread because otherwise it will prevent entering additional commands while the timer runs.When I try to use the  object to allow my GUI to update its progress bar and check the remaining time, I get the following error:Any attempt to start the timer breaks the code. For example, the following simple code does not work:Note that commenting out the line containing  allows windows to be created in separate threads successfully, but they lack the necessary  functionality.Other things I have tried that do not work:Creating the  in the new thread instead of passing it (results in the same error but for the  rather than )Creating the  in the main thread and running its  there (blocks the command line from accepting further commands)Running the interpreter command loop in a separate thread (complains that the  must be run from the main thread)
The docs have a section on Integrating cmd2 with event loops:Many Python concurrency libraries involve or require an event loop which they are in control of such as , , , etc.While this is specifically talking about networking-focused event loops, it's actually the same issue with GUI event loops like wx's.The tl;dr is that instead of calling , blocking the entire main thread until the interpreter exits, you just call , and then you repeatedly call  (or  or , as appropriate) from a  callback.In other words, you drive the  event loop from the  one, so the  loop can just take over the thread. also has a way of driving its event loop manually. See  and related classes. (There's probably some good example code out there similar to the code in the  docs, but you'd have to search for it.) The idea is pretty much the same: instead of running the  loop and blocking the thread forever, you manually create a  and , and then you repeatedly call  (and probably ) from the  event loop.In other words, you drive the  event loop from the  one, so the  loop can just take over the thread.If neither of those work for you, you can probably use  instead of . That way, both event loops are running in the main thread—but one of them is just running in the main thread of a child process.That can be a problem for GUI apps, so putting  in the child process may not work (or, worse, may work on some platforms/setups but not others, or may work but mysteriously fail every so often…), but  presumably only needs to see stdin/stdout/tty, so it probably will work.


Answer URL
https://docs.python.org/3/library/multiprocessing.html
