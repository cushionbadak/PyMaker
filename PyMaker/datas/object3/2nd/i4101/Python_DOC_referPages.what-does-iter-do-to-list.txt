Natural Text
I have this code:and output is:I do not understad, why the zip works differently with  than . What does  do, list is iterable, so why use ? Could anybody explain me this with some nice example? I googled about it but I still do not understand it.
 returns an iterator object for . Together with  it can be used for iterating the elements of .The code:is equivalent to this code explicitly using the iterator:Note that an iterator can also be traversed with a for loop: consumes one element from ,  at a time.When the argument of zip is a sequence, it will create its own iterator for it.When the argument is an iterator, it will just consume elements from it.When it is the same iterator in both arguments, each iteration of zip will consume one element of the iterator for the first argument, and one element for the second argument.
 does nothing to a list; the  object has an  method that  uses to produce an iterator object. That object has a reference to the original list and an index; every time you ask for the next value in the iterator, the value at the current index is retrieved and returned, and the index is incremented.You can use the  function to get the next value from an iterator:Notice how calling  again gives you a new value. You can do so until the iterator is done:List iterator objects keep hold of the original list object; changing the list object will reflect in the iterator values produced on : asks for the next value in each of its arguments, which are assumed to be iterables;  calls  on them all. For iterator objects such as ,  returns the iterator itself (it's already an iterator, after all):Since  will yield values from the original list, in order, that means that you get paired-up elements in a dictionary, because  has two references to the same object; you effectively creating  as the iterator step values for . If you pass in two references to , on the other hand,  will call  twice, creating two separate iterator objects, and each have their own index to track.Let's look at that in detail. Note that  also produces an iterator object, so we can verify that calling  on  in turn causes  to step forward twice:Iterators are independent objects, they each have their own index:So when you use , what really happens is that  calls  two times, creating two new iterators, and both are used to create the output:
iter() function return a instance of iterator on which we can iterate for getting all the value one by one.It is memory efficient function because it stores only current element value.


Answer URL
https://docs.python.org/3/library/functions.html#iter
https://docs.python.org/3/library/functions.html#next
