Natural Text
I have a function let's say .i am mocking it the following way:Its a huge project so cant post the details here.But what's happening is the function  does get mocked and i do get the correct message but later on i get  and the program fails.Is there any workaround here,which somehow disables the  of  or any other method.i guess the contents is somehow insufficient to create the whole scenario but that's d best i can do.Also,what happens if i dont provide  to function .What does the patch work on in that case?EDIT:I have got a workaround wherein i have defined my patch as follows:Now the question is 1)When i used  or  i had to provide a  to the function following the decorator.2)When i just used a function instead of ,i need not provide a mock_object to the function following the decorator..So,(P.S is this something to do with  thing in the definition of .)
First base things about :Inside the body of the function or with statement, the target is  patched with a new object. When the function/with statement exits the  patch is undone.If  is omitted, then the target is replaced with a . If   is used as a decorator and new is omitted, the created mock is  passed in as an extra argument to the decorated function. If   is used as a context manager the created mock is returned by the  context manager.The first one tell us that patch act as context manager in the body of the function (decorator case). The second one tell if you don't specify  argument (the first after targeting arguments in  class function) patch create a new  object to patch the target and the created mock is passed in as an extra argument to the decorated function.That explain the last section of the question because byyou replace  by  object and  decorator doesn't need to pass it to . Now come back to the root of the question: the  error message.That means you try to remove the patch more that once. How could it possible? If you took a look to  code you can easily understand that patch doesn't support stack of patches and it was designed to be executed just one time per context. In other words if you try to patch something that is already patched in your context you will get the same error. At the end of the answer I provided a synthetic example that generate the error.Without saw your code I can just do some guess and speculations about why your issue seams fixed if you don't use mock but patch your method by a function. IMHO it work just by chance and you playing with some kind of race condition.What I can do is give you a way to catch your problem and a good work around.To catch if you are calling  more that once in your patch simply use  as a contex manager and override . An untested way to do it could be:Finally the workaround (to use just if you don't find any way to fix the double call)It easy to extend it and write the decorator too... but I think it is enough for a workaround.That is a synthetic example that generate  error message. To generate it we must call patch one more time while we are just in patch context. We can do it by recursion or by threads, recursion is something really strange in this context. call patched method and start a new thread that call  too. I used an  to force the error and make the race condition always true. 


Answer URL
https://docs.python.org/3/library/unittest.mock.html#patch
