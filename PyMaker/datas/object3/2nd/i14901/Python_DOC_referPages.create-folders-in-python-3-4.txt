Natural Text
What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:Somehow, I missed  (thanks kanja, Blair, and Douglas). This is what I have now:Is there a flag for "open", that makes this happen automatically?
I see two answers with good qualities, each with a small flaw, so I will give my take on it:Try , and consider  for the creation.As noted in comments and elsewhere, there's a race condition – if the directory is created between the  and the  calls, the  will fail with an . Unfortunately, blanket-catching  and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.One option would be to trap the  and examine the embedded error code (see Is there a cross-platform way of getting information from Python’s OSError):Alternatively, there could be a second , but suppose another created the directory after the first check, then removed it before the second one – we could still be fooled. Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.Modern versions of Python improve this code quite a bit, both by exposing  (in 3.3+)......and by allowing a keyword argument to  called  (in 3.2+).
Python 3.5+: as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the  argument.Python 3.2+:Using :If you can, install the current  backport named . Do not install the older unmaintained backport named . Next, refer to the Python 3.5+ section above and use it the same.If using Python 3.4, even though it comes with , it is missing the useful  option. The backport is intended to offer a newer and superior implementation of  which includes this missing option.Using : as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional  argument only if using Python 3.2+, with a default value of . This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.Python 2.7+:Using :If you can, install the current  backport named . Do not install the older unmaintained backport named . Next, refer to the Python 3.5+ section above and use it the same.Using :While a naive solution may first use  followed by , the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.Note that capturing the exception and using  is of limited usefulness because , i.e. , is raised for both files and directories. It is more reliable simply to check if the directory exists.Alternative: creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3.Per Bug 10948, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use  again to recreate the same directory,  will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast,  doesn't rely on any such cache. This limitation may be okay for some applications.With regard to the directory's mode, please refer to the documentation if you care about it.
Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an  raised with  (Permission denied, error 13).
I would personally recommend that you use  to test instead of .If you have:And a foolish user input:... You're going to end up with a directory named  when you pass that argument to  if you test with .
Check os.makedirs:  (It makes sure the complete path exists.) To handle the fact the directory might exist, catch OSError.(If exist_ok is False (the default), an OSError is raised if the target directory already exists.)
Starting from Python 3.5,  has an  flag:This recursively creates the directory and does not raise an exception if the directory already exists.(just as  got an  flag starting from python 3.2 e.g )
Insights on the specifics of this situationYou give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:We want to avoid overwriting the builtin function, . Also,  or perhaps  is probably a better semantic name than  so this would be better written:Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for reading:Assuming opening for readingWhy would you make a directory for a file that you expect to be there and be able to read? Just attempt to open the file.If the directory or file isn't there, you'll get an  with an associated error number:  will point to the correct error number regardless of your platform. You can catch it if you want, for example:Assuming we're opening for writingThis is probably what you're wanting.In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the  mode (or  to append). It's also a Python best practice to use the context manager for opening files.However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the  call in a try-except block.
Try the  function
I have put the following down. It's not totally foolproof though.Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.
Check if a directory exists and create it if necessary?The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:or if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via :Here's the essentials from the online doc:New in Python 3.5:  with There's a new  object (as of 3.4) with lots of methods one would want to use with paths - one of which is .(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)First the relevant imports:We don't have to deal with  now - just join path parts with a :Then I idempotently ensure the directory exists - the  argument shows up in Python 3.5:Here's the relevant part of the documentation:If  is true,  exceptions will be ignored (same behavior as the  command), but only if the last path component is not an existing non-directory file.Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory.  objects have to be coerced to  before other APIs that expect  paths can use them.Perhaps Pandas should be updated to accept instances of the abstract base class, .
In Python 3.4 you can also use the brand new  module:
The relevant Python documentation suggests the use of the EAFP coding style (Easier to Ask for Forgiveness than Permission). This means that the codeis better than the alternativeThe documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.
In Python3,  supports setting . The default setting is , which means an  will be raised if the target directory already exists. By setting  to ,  (directory exists) will be ignored and the directory will not be created.In Python2,  doesn't support setting . You can use the approach in heikki-toivonen's answer:
You can use Note that it will create the ancestor directories as well. It works for Python 2 and 3.
For a one-liner solution, you can use :From the documentation: Ensure that a directory exists. If it doesn’t exist, try to create it and protect against a race condition if another process is doing the same.
I use , here is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).It prompts users for input of the directory and can be easily modified.
You can use  for this:
I found this Q/A and I was initially puzzled by some of the failures and errors I was getting. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).Consider this directory structure:Here are my experiments/notes, which clarifies things:Conclusion: in my opinion, "Method 2" is more robust.[1] How can I create a directory if it does not exist?[2] https://docs.python.org/3/library/os.html#os.makedirs
I saw Heikki Toivonen and A-B-B's answers and thought of this variation.
When working with file I/O, the important thing to consider isTOCTTOU (time of check to time of use)So doing a check with  and then reading or writing later may end up in an unhandled I/O exception. The best way to do it is:
If you consider the following: means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.
Call the function  at the entry point of your program/project.
Why not use subprocess module if running on a machine that supports shell languages? Works on python 2.7 and python 3.6Should do the trick on most systems.
Use this command check and create dir
Where your code here is use the (touch) commandThis will check if the file is there if it is not then it will create it.


Answer URL
https://docs.python.org/3/library/os.html#os.makedirs
https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir
https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs
https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir
https://docs.python.org/3/library/pathlib.html
https://docs.python.org/3/library/os.html#os.makedirs
