Natural Text
I recently wrote a Python program that used:orbut nothing worked correctly until I used:That's the only way I could get an accurate True decision in my program.It seems -1 result wasn't recognized as False. Successful finds weren't recognized as True either. So looking for -1 (False) or a positive number >0 (True) was the only thing that worked for me.What was I doing wrong? This can't be the way Python works, can it?
You are interpreting the return value of  incorrectly. The documentation states:Return the lowest index in the string where substring  is found, such that  is contained in the slice . Optional arguments start and end are interpreted as in slice notation. Return  if  is not found.Of all numbers, Python considers only 0 to be false; -1 is true. As  returns the index of the beginning of the match, and 0 is a valid index to a string, -1 is returned when no match was found.Thus your code should rather* be:or Though they're not the most Pythonic either, if you just want to see if  contains  - see below.Now, about your second example: the  constant  compares equal to :and  constant  only equal to number :Thus the expression  would be totally equivalent with ; and the whole expression would evaluate to  only if the  would be of form , with a match for  starting at the 2nd character (index 1).The documentation for  continues with the following note:NoteThe  method should be used only if you need to know the position of . To check if  is a substring or not, use the  operator:Thus the form that is the most Pythonic for the problem in your question isAs suggested by @myaut, if you need the position of  within  and expect it to contain the value, you should use  instead, which will throw an exception if the  was not found within the string.
Python thinks  is , not .As you can see in the Python documentation, Python tries hard to have many different kinds of  values: of any numeric type: , , , .any empty sequence: , , .any empty mapping: .Your intuitive notion that  should be  in Python makes some sense, but that is just not how Python was designed. Zeros and empties are falsey in Python.
If you only want to check wether a string is contained in another, use:
The quickest way to verify what is the bool value of it;and so on, 
 as an error code came from C, but that leads to spaghetti code of checking return values.Python has more reliable way to report an error: raise an Exception. I.e.  does that:And of course to check if string contains substring you should use  operator:Speaking of  statements you should note that comparing to boolean is a bad idea (check for example PEP-8). Every type in Python defines its own rules which values are considered "True": Truth value testing
You are not doing something wrong.In python  inherit from .  is  and  is . You can try  and . If you try  you will get , but if you write  or  you always will get . If you use  you will get  so you need to use . You can find  inside .You can write . I think that find is deprecated.


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.find
https://docs.python.org/3/library/stdtypes.html#truth-value-testing
https://docs.python.org/3/library/stdtypes.html#str.index
