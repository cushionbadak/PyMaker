Natural Text
This question already has an answer here:Is floating point math broken?                    28 answers                I know these are float point division. But why did these two formula behave differently?And I did some more investigation, the result confusing me even more:What's the logic here to decide whether the result is printed with one decimal place or more?PS: I used python3.4 to do the experiment above.
Because the exact values of the floating point results are slightly different.As you can see, the result that is printed as "0.2" is indeed slightly closer to 0.2. I added the bit at the end to show you what the exact value of the difference between these two numbers is. (In case you're curious, the above representations are the exact values - adding any number of digits beyond this just adds more zeroes).
Check out the documentation on floating point numbers in python.Most specifically:Interestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers 0.1 and 0.10000000000000001 and 0.1000000000000000055511151231257827021181583404541015625 are all approximated by 3602879701896397 / 2 ** 55. Since all of these decimal values share the same approximation, any one of them could be displayed while still preserving the invariant eval(repr(x)) == x.Historically, the Python prompt and built-in repr() function would choose the one with 17 significant digits, 0.10000000000000001. Starting with Python 3.1, Python (on most systems) is now able to choose the shortest of these and simply display 0.1.
Floating point numbers are implemented as  according to IEEE 754 (as in virtually all programming languages).This standard gives 52 bits to the "significand / fraction" (approximately 16 decimal digits of accuracy), 11 bits to the exponent and 1 bit to the sign (plus or minus):In particular, a number like  can not be represented asfor some fraction in base 2 and an exponent that can be represented with 11 bits (-1022 through 1023).Viewing  in hex for example:we see the best approximation in our set of numbers isTrying to represent this in base 2, we havebut  written in base 2 has a repeating string of four binary digitsso can never be represented using a finite number of binary digits.A bit more in depthSo we can "unpack" as 8 bytes (1 byte is 8 bits)or as 16 hex digits (1 hex digit is 4 bits, since )or as all 64 bits in their gloryFrom there, the first bit is the sign bit:The next 11 bits are the exponent (but shifted by 1023, a conventionof ):The final 52 bits are the fractional partPutting it all together


Answer URL
https://docs.python.org/3/whatsnew/3.1.html#other-language-changes
