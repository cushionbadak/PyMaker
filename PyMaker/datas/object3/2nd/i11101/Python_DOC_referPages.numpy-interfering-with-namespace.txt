Natural Text
Output on my system (debian 8, Python 2.7.9-1, numpy 1:1.8.2-2)Normally I would expect  to stay untouched when passing it to a function as this has its own separate namespace. But when the data is a numpy array the function changes  globally.Is this a feature, a bug or am I maybe missing something? How should I avoid this behavior when using a custom plot function to scale my data automatically?UPDATE(See Kevin J. Chase's answer for more details)Output on my system (debian 8, Python 2.7.9-1, numpy 1:1.8.2-2)Using  instead of  solves the problem for me. The behaviour of the nice and short  statement actually depends heavily on the type of x. It rebinds if x is immutable and mutates otherwise.It is not equivalent to  which always rebinds.A numpy array is a mutable object.
Normally I would expect data to stay untouched when passing it to a function as this has its own separate namespace. in the function and  at the module level are two names for the same object.  Since that object is mutable, any changes made to it will be "seen" regardless of which name is used to refer to the object.  Namespaces can't protect you from that. divides every element of the NumPy array by 10.  The original data is gone after this line executes.  If you were to run  a few more times, you'd find the contents draw closer to 0.0 each time.Lists are a more familiar example of the same effect:For a good overview of this sort of thing (including related issues) I recommend Ned Batchelder's “Facts and Myths about Python Names and Values” (26 minute video from PyCon US 2015).  His example of list "addition" starts about 10 minutes in.Behind the Scenes and  (and similar pairs of operators) do different things.  Tutorials often claim that these two operations are the same:...but they're not.  Full details can be found in The Python Language Reference, 3.3.7.  Emulating Numeric Types. calls the  (or maybe  --- a topic for another day) method on one of the two objects, feeding the other object as the argument:Typically, these methods return some new value without altering the old one.  This is why  was unchanged by , but  changed ---  now referred to a new object, and was no longer an alias for . calls a completely different method,  for the "in-place" operation:These methods typically modify the object, which then returns .  This explains why  was unchanged and why 's contents had changed ---  and  were still the one and only object.  From the docs I linked above:These methods should attempt to do the operation in-place (modifying ) and return the result (which could be, but does not have to be, ).  If a specific method is not defined, the augmented assignment falls back to the normal methods  [meaning  and family --- KJC].If you look at the methods of different data types, you'll find that they don't support all of these. shows that integers lack the in-place methods, which shouldn't be surprising, because they're immutable. reveals only two in-place methods:  and  --- you can't divide or subtract from a list, but you can in-place add another list, and you can multiply it by an integer.  (Again, those methods can do whatever they want with their arguments, including refuse them...   won't take an integer, while  will reject a list.) shows basically all of the arithmetic, logic, and bitwise methods, with normal and in-place for each.  (It could be missing some --- I didn't count them all.)Finally, to re-reiterate, what namespace these objects are in when their methods get called makes absolutely no difference.  In Python, data has no scope... if you have a reference to it, you can call methods on it.  (From Ned Batchelder's talk:  Variables have a scope, but no type; data has a type, but no scope.)


Answer URL
https://docs.python.org/3/reference/
https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types
