Natural Text
I'm trying to understand Python's approach to variable scope. In this example, why is  able to alter the value of , as perceived within , but not the value of ?Output:
Some answers contain the word "copy" in a context of a function call. I find it confusing.Python doesn't copy objects you pass during a function call ever.Function parameters are names. When you call a function Python binds these parameters to whatever objects you pass (via names in a caller scope).Objects can be mutable (like lists) or immutable (like integers, strings in Python). Mutable object you can change. You can't change a name, you just can bind it to another object.Your example is not about scopes or namespaces, it is about naming and binding and mutability of an object in Python. Here are nice pictures on the difference between variables in other languages and names in Python.
You've got a number of answers already, and I broadly agree with J.F. Sebastian, but you might find this useful as a shortcut:Any time you see , you're creating a new name binding within the function's scope.  Whatever value  was bound to before is lost within this scope.Any time you see  you're calling a method on .  The method may alter varname (e.g. ).   (or, rather, the object that  names) may exist in more than one scope, and since it's the same object, any changes will be visible in all scopes.[note that the  keyword creates an exception to the first case]
 doesn't actually alter the value of  (which is always the same reference to an instance of a list). Rather, it alters the contents of this list.In both cases, a copy of a reference is passed to the function. Inside the function, gets assigned a new value. Only the reference inside the function is modified, not the one outside it. does not get assigned a new value: neither the reference inside nor outside the function are modified. Instead, ’s value is modified.Since both the  inside the function and outside it refer to the same value, both see the modification. By contrast, the  inside the function and outside it refer to different values after  was reassigned inside the function.
I will rename variables to reduce confusion.  n -> nf or nmain.  x -> xf or xmain:When you call the function f, the Python runtime makes a copy of xmain and assigns it to xf, and similarly assigns a copy of  nmain to nf.In the case of n, the value that is copied is 1.In the case of x the value that is copied is not the literal list [0, 1, 2, 3].  It is a reference to that list.  xf and xmain are pointing at the same list, so when you modify xf you are also modifying xmain.If, however, you were to write something like:you would find that xmain has not changed.  This is because, in the line xf = ["foo", "bar"] you have change xf to point to a new list.  Any changes you make to this new list will have no effects on the list that xmain still points to.Hope that helps.  :-)
It´s because a list is a mutable object. You´re not setting x to the value of [0,1,2,3], you´re defining a label to the object [0,1,2,3].You should declare your function f() like this:
n is an int (immutable), and a copy is passed to the function, so in the function you are changing the copy.X is a list (mutable), and a copy of the pointer is passed o the function so x.append(4) changes the contents of the list.  However, you you said x = [0,1,2,3,4] in your function, you would not change the contents of x in main().
If the functions are re-written with completely different variables and we call id on them, it then illustrates the point well. I didn't get this at first and read jfs' post with the great explanation, so I tried to understand/convince myself:z and x have the same id. Just  different tags for the same underlying structure as the article says.
Python is a pure pass-by-value language if you think about it the right way.  A python variable stores the location of an object in memory.  The Python variable does not store the object itself.  When you pass a variable to a function, you are passing a copy of the address of the object being pointed to by the variable.  Contrasst these two functionsNow, when you type into the shellCompare this to goo.In the first case, we pass a copy the address of cow to foo and foo modified the state of the object residing there.  The object gets modified.In the second case you pass a copy of the address of cow to goo. Then goo proceeds to change that copy. Effect: none.I call this the pink house principle.  If you make a copy of your address and tell a painter to paint the house at that address pink, you will wind up with a pink house.If you give the painter a copy of your address and tell him to change it to a new address,the address of your house does not change.The explanation eliminates a lot of confusion.  Python passes the addresses variables store by value.   
Python is copy by value of reference.  An object occupies a field in memory, and a reference is associated with that object, but itself occupies a field in memory. And name/value is associated with a reference. In python function, it always copy the value of the reference, so in your code, n is copied to be a new name, when you assign that, it has a new space in caller stack. But for the list, the name also got copied, but it refer to the same memory(since you never assign the list a new value). That is a magic in python!
My general understanding is that any object variable (such as a list or a dict, among others) can be modified through its functions. What I believe you are not able to do is reassign the parameter - i.e., assign it by reference within a callable function.That is consistent with many other languages.Run the following short script to see how it works:y = 10list1 = ["meaning"]func1(y, list1)print(y)print(list1)


Answer URL
https://docs.python.org/3/library/functions.html#id
