Natural Text
I have a bit of  Python code that looks a bit like this:After reading answers about how memory works in other StackOverflow answers such as this one Python multiprocessing memory usage I was under the impression that this would not use memory in proportion to how many processes I used for multiprocessing, since it is copy-on-write and I have not modified any of the attributes of . However, I do see high memory for all processes when I run top it says most of my processes are using a lot of memory (this is top output from OSX, but I can replicate on Linux). My question is basically, am I interpreting this correctly in that my instance of  is actually duplicated across the pool? And if so, how can I prevent this; should I just not use a construction like this? My goal is to reduce memory usage for a computational analysis. 
Anything sent to  (and related methods) isn't actually using shared copy-on-write resources. The values are "pickled" (Python's serialization mechanism), sent over pipes to the worker processes and unpickled there, which reconstructs the object in the child from scratch. Thus, each child in this case ends up with a copy-on-write version of the original data (which it never uses, because it was told to use the copy sent via IPC), and a personal recreation of the original data that was reconstructed in the child and is not shared.If you want to take advantage of forking's copy-on-write benefits, you can't send data (or objects referencing the data) over the pipe. You have to store them in a location that can be found from the child by accessing their own globals. So for example:By not passing , you avoid making copies, and just use the single global object that was copy-on-write mapped into the child. If you needed more than one object, you might make a global  or  mapping to instances of the object prior to creating the pool, then pass the index or key that can look up the object as part of the argument(s) to . The worker function then uses the index/key (which had to be pickled and sent to the child over IPC) to look up the value (copy-on-write mapped) in the global dict (also copy-on-write mapped), so you copy cheap information to lookup expensive data in the child without copying it.
Alternatively, to take advantage of forking's copy-on-write benefits, while preserving some semblance of encapsulation, you could leverage class-attributes and @classmethods over pure . Note 1: Yes, I admit that  and  are glorified globals. But it buys a bit of encapsulation...Note 2: Rather than explicitly creating your  above, you can implicitly pass the instance (self) to each task created by , by passing the bound-instance method  to , and shoot yourself in the foot even easier!


Answer URL
https://docs.python.org/3/library/pickle.html
