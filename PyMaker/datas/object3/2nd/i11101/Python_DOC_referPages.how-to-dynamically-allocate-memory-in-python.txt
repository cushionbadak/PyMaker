Natural Text
Is there any method in python, that I can use to get a block of memory from the heap ,and use a variable to reference it. Just like the keyword "new" , or the function  in other languages:In the project, my program is waiting to receive some data in uncertain intervals and with a certain length of bytes when correct.I used to it like this:Now, I want to migrate these old project to python, and I tried to do it like this:However, I get the all item in the list are same, and equal to the latest received item. It is obvious that all the list items are point to the same memory adress, and I want to get a new memory adress each the function is called.
You should read the Python tutorial.You can create lists, dictionaries, objects and closures in Python. All these live in the (Python) heap, and Python has a naive garbage collector (reference counting + marking for circularity).(the Python GC is naive because it does not use sophisticated GC techniques; hence it is slower than e.g. Ocaml or many JVM generational copying garbage collectors; read the GC handbook for more; however the Python GC is much more friendly to external C code)
The equivalent of "new" in python is to just use a constructor eg:Since you are porting from C, some things to note.Everything is an object in python including integers, and most variables are just references, but the rules for scalar variables such as integers  and strings are different from containers, eg:However:You can pre-allocate sizes, if you'd like but it often doesn't buy you much benefit in python. The following is valid:If you want to ensure memory leaks do not occur, use local variables as often as possible, eg, within a function so as things go out of scope you don't have to worry.For efficient vectorized operations (and much lower memory footprint) use numpy arrays. My added two cents:I'd probably start by asking what your primary goal is. There is the pythonic ways of doing things, while trying to optimize for speed of program execution or minimum memory footprint. And then there is the effort of trying to port a program in as little time as possible. Sometimes they all intersect but more often, you will find the pythonic way to be quick to translate but with higher memory requirements. Getting higher performance out of python will probably take focused experience. Good luck!
Keep in mind that interpreted languages usually don't flatten the types as compiled languages do. The memory layout is (probably) completely different than in the raw data. Therefore, you cannot simply cast raw data to a class instance or vice versa. You have to read the raw data, interpret it and fill your objects manually.


Answer URL
https://docs.python.org/3/tutorial/index.html
