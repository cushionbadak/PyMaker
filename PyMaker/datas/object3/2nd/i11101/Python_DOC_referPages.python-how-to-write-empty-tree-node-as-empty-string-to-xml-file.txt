Natural Text
I want to remove elements of a certain tag value and then write out the  file WITHOUT any tags for those deleted elements; is my only option to create a new tree?There are two options to remove/delete an element:clear()  Resets an element. This function removes all subelements, clears all  attributes, and sets the text and tail attributes to None.At first I used this and it works for the purpose of removing the data from the element but I'm still left with an empty element:The problem is that  still writes out empty tags no matter what:...The keyword-only short_empty_elements parameter controls the  formatting of elements that contain no content. If True (the default),  they are emitted as a single self-closed tag, otherwise they are  emitted as a pair of start/end tags.Why isn't there an option to just not print out those empty tags! Whatever.So then I thought I might tryremove(subelement)  Removes subelement from the element. Unlike the find* methods this  method compares elements based on the instance identity, not on tag  value or contents.But this only operates on the child elements.So I'd have to do something like:But there's a big problem here: I'm invalidating the iterator by removing elements, right?Is it enough to simply check if the element is empty by adding ?:Or do I have to get a new iterator to the tree elements every time I invalidate it?Remember: I just wanted to write out the xml file with no tags for the empty elements.Here's an example.Let's say I want to remove any mention of .Ideally, I'd want this output after the removal:Problem, is when I run the code using clear() (see first code block up above) and write it to a file, I get this:Notice  still appears.I know I could easily run a regex over the output but there's gotta be a way (or another Python api) that does this on the fly instead of requiring me to touch my  file again.
Using elementTree, we need to find the  then find the  and remove them:Both will give you:Using your attribute logic and modifying the xml a bit like below:Using lxml:Would give you:The same logic in ElementTree:If you are using iter:You can see we get the exact same output:
Whenever modifying XML documents is needed, consider also XSLT, the special-purpose language part of the XSL family which includes XPath. XSLT is designed specifically to transform XML files. Pythoners are not quick to recommend it but it avoids the need of loops or nested if/then logic in general purpose code. Python's  module can run XSLT 1.0 scripts using the libxslt processor.Below transformation runs the identity transform to copy document as is and then runs an empty template match on  to remove it:XSLT Script (save as an .xsl file to be loaded just like source .xml, both of which are well-formed xml files)Python Script
The trick here is to find the parent (the country node), and delete the neighbor from there. In this example, I am using ElementTree because I am somewhat familiar with it:


Answer URL
https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.clear
https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree.write
https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.remove
https://docs.python.org/3/library/xml.etree.elementtree.html#parsing-xml
