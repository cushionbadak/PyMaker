Natural Text
Converting some code to using asyncio, I'd like to give back control to the  as quickly as possible. This means to avoid blocking waits.Without asyncio I'd use  or  to obtain e.g. the filesize. Is there a way to do this efficiently with asyncio?Can I just wrap the  call so it is a future similar to what's described here?
 translates to a  syscall:which is blocking, and there's no way to get a non-blocking  syscall. provides non-blocking I/O by using non-blocking system calls, which already exists (see , with its  flag, or ), so  is not making syscalls asynchronous, it exposes already asynchronous syscalls in a nice way.It's still possible to use the nice ThreadPoolExecutor abstraction to make your blocking  calls in parallel using a pool of threads.But you may first consider some other parameters:According to ,  is fast: , probably faster than starting and synchronizing threads. is probably in much cases IO bound, so using more CPUs won't helpDoing parallel I/O may break a nice sequential access to a random access, phisical hard drive may be slower in this context.But there's also a lot of possibilities for your s to be faster using a thread pool, like if you're hitting a distributed file system.You may also take a look at : if you're doing multiple  on the same file or directory, and you're sure it has not changed, caching the result avoids a syscall.To conclude, "keep it simple", "os.stat" is the efficient way to get a filesize.


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/asyncio-eventloop.html
https://docs.python.org/3/library/os.html?highlight=stat#os.stat
https://docs.python.org/3/library/pathlib.html?highlight=stat#pathlib.Path.stat
https://docs.python.org/3/library/asyncio-task.html#asyncio.Future
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
