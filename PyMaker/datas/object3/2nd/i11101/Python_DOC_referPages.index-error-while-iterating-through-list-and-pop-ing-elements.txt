Natural Text
This question already has an answer here:How to test multiple variables against a value?                    21 answers                In the above code, I get an index error at line 9: 'if ('inherited' or 'device-group'...etc.I really don't understand why. How can my index be out of range if it's the perfect length by using len(t) as my range?The goal is to pop any indexes from my list that contain any of those substrings. Thank you for any assistance!
This happens because you are editing the list while looping through it,you first get the length which is 10 for example, then you loop through the thing 10 times. but as soon as you've deleted one thing the list will only be 9 long.A way around this is to create a new list of things you want to keep and use that one instead.I've slightly edited your code and done something similar.
Let's say .We'll process  taking values After we process , we pop one value from .  now. This would mean error if we get to . However, we're still going to try to go up to 4 because our  is already inited to be up to 4.Next () step ensures an error on .Next () step ensures an error on , but that is already processed.Next () step yields an error.Instead, you should do something like this:On a side note, you should replace that  check with sets:And then in loop:If you need indexes you could either use one more variable to keep track of index of value we're currently processing, or use enumerate()
As many people said in the comments, there are several problems with your code.The  operator sees the values on its left and right as booleans and returns the first one that is  (from left to right). So your parenthesis evaluates to 'inherited' since any non-empty string is . As a result, even if your  was working, you would be popping elements that are equal to 'inherited' only.The  is not working though. That happens because the size of the list you are iterating over is changing as you loop through and you will get an index-out-of-range error if an element of the list is actually equal to 'inherited' and gets popped. So, take a look at this:By duplicating the original list, we can use its items as a "pool" of items to pick from and modify the list we are actually interested in.Finally, know that the  method returns the item it removes from the list and this is something you do not need in your example.  works just fine for you.As a side note, you can probably replace your first 5 lines of code with this:the advantage of using the  statement is that it automatically handles the closing of the file by itself when the reading is done. Finally, instead of reading the whole file and splitting it on linebreaks, you can just use the built-in  method which does exactly that.


Answer URL
https://docs.python.org/3/library/functions.html#enumerate
