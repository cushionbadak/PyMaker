Natural Text
I'm writing Python bindings for a C library that uses shared memory buffers to store its internal state. The allocation and freeing of these buffers is done outside of Python by the library itself, but I can indirectly control when this happens by calling wrapped constructor/destructor functions from within Python. I'd like to expose some of the buffers to Python so that I can read from them, and in some cases push values to them. Performance and memory use are important concerns, so I would like to avoid copying data wherever possible.My current approach is to create a numpy array that provides a direct view onto a ctypes pointer:As well as avoiding copies, this also means I can use numpy's indexing and assignment syntax and pass it directly to other numpy functions:However, it's also inherently dangerous:To make this safer, I need to be able to check whether the underlying C pointer has been freed before I try to read/write to the array contents. I have a few thoughts on how to do this:One way would be to generate a subclass of  that holds a reference to the  attribute of , checks whether it is  before doing any reading/writing to its underlying memory, and raises an exception if this is the case.I could easily generate multiple views onto the same buffer, e.g. by  casting or slicing, so each of these would need to inherit the reference to  and the method that performs the check. I suspect that this could be achieved by overriding , but I'm not sure exactly how.The "pointer-checking" method would also need to be called before any operation that would read and/or write to the contents of the array. I don't know enough about numpy's internals to have an exhaustive list of methods to override.How could I implement a subclass of  that performs this check? Can anyone suggest a better approach?Update: This class does most of what I want:For example:I'm sure there are other edge cases I've missed.Update 2: I've had a play around with , as suggested by @ivan_pozdeev. It's a nice idea, but unfortunately I can't see how it would work with numpy arrays. I could try to create a weakref to the numpy array returned by :I think the problem here is that the  instance returned by  immediately goes out of scope. A workaround would be for the class to instantiate the array on initialization, hold a strong reference to it, and have the  getter return a  to the array:However, this breaks if I create a second view onto the same array whilst the buffer is still allocated:This is seriously broken - after calling  not only can I read and write to  which was a numpy array view onto , but I can even read and write to , which should not be possible given that  sets  to .
You have to keep a reference to your Wrapper while any numpy array exists. Easiest way to achieve this, is to save this reference in a attribute of the ctype-buffer:This way you're wrapper is automatically freed, when the last reference, e.g the last numpy array, is garbage collected.
It's a proprietary library written by a third party and distributed as a binary. I could call the same library functions from C rather than Python, but that wouldn't help much since I still don't have any access to the code that actually allocates and frees the buffers. I can't, for example, allocate the buffers myself and then pass them to the library as pointers.You could, however, wrap the buffer in a Python extension type. That way you can expose only the interface you want to be available, and let the extension type automatically handle the freeing of the buffer. That way it's not possible for the Python API to do a free memory read/write.mybuffer.ctest.pyExample
 is a built-in mechanism for the functionality you are proposing.Specifically,  is an object with the same interface as the referred one. After the referenced object's disposal, any operation on the proxy raises . You don't even need :As you can see, in any case, you need a normal Python object over the C buffer. If an external library owns the memory, the object must be deleted before the buffer is freed on the C level. If you own the memory yourself, you just create a  object the normal way, then it will be freed when it's deleted.So, if your external library owns the memory and can free at any time (your specification is vague about this), it must tell you somehow it's about to do so - otherwise, you have no way to know about that to take necessary action.
You just need a wrapper with additional  function before passing it to the  method.To testIn fact a more easier solution is to overwrite  function
I liked @Vikas's approach, but when I tried it, I only got a Numpy object-array of a single  object. The following is much simpler and works:where  is a pointer to the data as an integer (e.g. ).This  attribute is sufficient to tell Numpy how to cast a region of memory as an array, and then the  object becomes that array's . When the array is deleted, the deletion is propagated to the  object, where you can call .I might even call this  class "", because that's its role: to track ownership.
If you can completely control the C buffer's lifetime from Python, what you essentially have is a Python "buffer" object that an  should use.Thus,there are 2 fundamental ways to connect them:buffer -> ndarrayndarray -> bufferthere's also a question how to implement the buffer itselfbuffer -> ndarrayIs unsafe: there's nothing automatically holding a reference to  for the lifetime of . Introducing a 3rd object to hold references to both isn't any better: then you just have to keep track of the 3rd object instead of the .ndarray -> buffer"Now you're talking!" Since the very task at hand is "buffer that an  should use"? this is the natural way to go.In fact,  has a built-in mechanism: any  that doesn't own its memory holds a reference to the object that does in its  attribute (thus preventing the latter from being garbage collected). For views, the attribute is automatically assigned accordingly (to the parent object if its  is  or to the parent's ).The catch is you cannot just place any old object there. Instead, the attribute is filled by a constructor and the suggested object is first put through its scrunity.So, if only we could construct some custom object that  accepts and considers eligible for memory reuse ( is actually a wrapper for  with a few sanity checks)...<...>


Answer URL
