Natural Text
This question already has an answer here:Transpose/Unzip Function (inverse of zip)?                    12 answers                Given the following list of lists:I'd like to modify this list to transpose the values (for lack of a better description) like this:I can do this with one sub-list at a time like this:but now I just need to know how to iterate through each sub-list and automatically make the new list of lists (also, I can't predict how many sub-lists there will be in my actual data, so I'd like to avoid hard-coding the current number of sub-lists in i[0].Thanks in advance!
Most concise solution is to use the  function with star unpacking:This will get almost what you want, but not quite, because it will be a  of s; if that's okay, you're done, if not, you just tweak it to convert to s:Reason this works is that star unpacking makes it as if you passed each element of  as a sequential positional argument to , e.g.:And 's whole schtick is making new s of values from matching offsets in a set of iterables, so the first  is the first element of each argument (), the second is the second element of each argument (), etc.Note: This assumes all sub-s are the same length. You'll lose data if they aren't, because  stops when the shortest iterable is exhausted. You can use  to pad out shorter iterables to the length of the longest iterable if you like.
Do you mean something like this:will output to:The function is not fixed size but id does assume that all the lists within the list are the same size.
Here's a one liner using list comprehension.Basically what you did except iterates through the indexes.
If this is the only complex operation you need to perform on the array, then one of the other solutions is probably best.  However, if you don't mind bringing in numpy, then there is a built-in routine for this called .


Answer URL
https://docs.python.org/3/library/functions.html#zip
https://docs.python.org/3/library/itertools.html#itertools.zip_longest
