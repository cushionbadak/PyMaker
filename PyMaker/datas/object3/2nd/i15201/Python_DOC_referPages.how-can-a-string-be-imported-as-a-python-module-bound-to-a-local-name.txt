Natural Text
I have some code in the form of a string and would like to make a module out of it without writing to disk.When I try using imp and a StringIO object to do this, I get:How can I create the module without having an actual file?  Alternatively, how can I wrap a StringIO in a file without writing to disk?UPDATE:NOTE: This issue is also a problem in python3.The code I'm trying to load is only partially trusted.  I've gone through it with ast and determined that it doesn't import anything or do anything I don't like, but I don't trust it enough to run it when I have local variables running around that could get modified, and I don't trust my own code to stay out of the way of the code I'm trying to import.I created an empty module that only contains the following:Then you can import  and call .  This works for me because I've ensured that the code I'm loading does not use .  Also, the  keyword is only a parser directive and can't refer to anything outside of the exec.This really is way too much work to  the module without writing to disk, but if you ever want to do this, I believe it's the best way.
Here is how to import a string as a module (Python 2.x): In Python 3, exec is a function, so this should work: Now access the module attributes (and functions, classes etc) as:To ignore any next attempt to import, add the module to :
If the code for the module is in a string, you can forgo using  and use it directly with , as illustrated below with a file named .Works in Python 2 & 3.Output:Setting the  entry to  in the  dictionary prevents the code from directly executing any built-in functions, like , and so makes running it safer. You can ease that restriction by selectively adding things to it you feel are OK and/or required.It's also possible to add your own predefined utilities and attributes which you'd like made available to the code thereby creating a custom execution context for it to run in. That sort of thing can be useful for implementing a "plug-in" or other user-extensible architecture.
You could simply create a Module object and stuff it into sys.modules and put your code inside.Something like:
you could use  or  to execute python code as a string. see here, here and here
The documentation for  says (my emphasis):The file argument is the source file, open for reading as text, from the beginning. It must currently be a real file object, not a user-defined class emulating a file.... so you may be out of luck with this method, I'm afraid.Perhaps  would be enough for you in this case?This sounds like a rather surprising requirement, though - it might help if you add some more to your question about the problem you're really trying to solve.
imp.new_module is deprecated since python 3.4but the short solution from schlenk using types.ModuleType is still working in python 3.7imp.new_module was replaced with importlib.util.module_from_specimportlib.util.module_from_spec  is preferred over using types.ModuleType to create a new module as  spec is used to set as many import-controlled attributes on the module  as possible.importlib.util.spec_from_loader  uses available loader APIs, such as InspectLoader.is_package(), to  fill in any missing information on the spec.but both, short and long version, will only set: 


Answer URL
https://docs.python.org/3/library/types.html#types.ModuleType
https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec
https://docs.python.org/3/library/importlib.html#importlib.util.spec_from_loader
