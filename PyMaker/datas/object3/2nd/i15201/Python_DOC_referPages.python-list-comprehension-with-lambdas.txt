Natural Text
This question already has an answer here:How do I create a list of Python lambdas (in a list comprehension/for loop)?                    8 answers                I'm running Python 3.4.2, and I'm confused at the behavior of my code. I'm trying to create a list of callable polynomial functions with increasing degree:But for some reason it does this:Why is  seemingly a list of the last lambda expression, in the list comprehension, repeated? 
The problem, which is a classic"gotcha", isthat the  referenced in the lambda functions is not looked up until thelambda function is called. At that time, the value of  is the last value itwas bound to when the  ended, i.e. .If you bind  to a default value in the definition of the  functions, then each  becomes a local variable, and its default value is evaluated and bound to the function at the time the lambda is defined rather than called.Thus, when the lambda is called,  is now looked up in the local scope, and its default value is used:For reference:Python scopes and namespaces
a more 'pythonic' approach:using nested functions:output:>> [1, 5, 25, 125, 625]
As an alternate solution, you could use a partial function:The only advantage of that construction over the classic solution given by @unutbu is that way, you cannot introduce sneaky bugs by calling your function with the wrong number of arguments:As suggested by Adam Smith in a comment bellow, instead of using "nested lambda" you could use  with the same benefit:
I don't think the "why this happens" aspect of the question has been answered yet.The reason that names non-local names in a function are not considered constants is so that these non-local names will match the behaviour of global names. That is, changes to a global name after a function is created are observed when the function is called.eg.You can see that in both the global and non-local contexts that if the value of a name is changed, then that change is reflected in future invocations of the function that references the name. If globals and non-locals were treated differently then that would be confusing. Thus, the behaviour is made consistent. If you need the current value of a name to made constant for a new function then the idiomatic way is to delegate the creation of the function to another function. The function is created in the creating-function's scope (where nothing changes), and thus the value of the name will not change.eg.Finally, as an addendum, functions can modify non-local names (if the name is marked as such) just as they can modify global names. eg.


Answer URL
https://docs.python.org/3/tutorial/classes.html
