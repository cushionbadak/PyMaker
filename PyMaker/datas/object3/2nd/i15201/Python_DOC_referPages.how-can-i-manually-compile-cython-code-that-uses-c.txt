Natural Text
I have exactly copied the example code given in the Cython documentation for wrapping C++ classes. I can successfully build and import the  extension using  and the  method, i.e. by:Putting the following directives at the top of :Writing a  file that contains this:CallingHowever, when I'm wrapping C code in Cython I often find it more convenient to compile individual extensions manually from the command line, i.e.:Generate the  code using the command line Cython compilerManually compile it using :I've tried applying the same process to build the  example above:Both the Cython and g++ compilation steps seem to succeed - I don't get any command line output, and at the end I have a   built. However, when I then try to import the module I get an  error:What's the correct procedure for manually compiling Cython code that wraps C++ classes?
The problem here is that you said that somewhere you will provide the definition of a class called Rectangle -- where the example code states However, when you compiled the library you didn't provide the code for Rectangle, or a library that contained it, so  has no idea where to find this Rectangle class.To run your code you must first create the Rectangle object file.Now you can either create a library to dynamically link against, or statically link the object file into . I'll cover statically linking first as it's simplest.Note that I haven't included the library for python. This is because you expect your library to be loaded by the python interpreter, thus the python libraries will already be loaded by the process when your library is loaded. In addition to providing  as a source I also provide . So lets try running a program using your module.run.pyUnfortunately, this produces another error:This is because cython needs the c++ standard library, but python hasn't loaded it. You can fix this by adding the c++ standard library to the required libraries for Run  again and all should work. However, the code for  is larger than it needs to be, especially if you produce multiple libraries that depend on the same code. You can dynamically link the Rectangle code, by making it a library as well.We compile the Rectangle code into a shared library in the current directory and provide  so gcc knows to look for libraries in the current directory and  so gcc knows to look for the Rectangle library. Finally, to be able to run your code you must tell python where the Rectangle library lives. Before running python enterYou can use a shell script to make sure this is done every time before you run your program, but it makes things messier. Best to just stick with statically linking Rectangle. 


Answer URL
https://docs.python.org/3/extending/windows.html#differences-between-unix-and-windows
