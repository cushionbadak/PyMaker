Natural Text
The following code has different output when running  on windows and linux (both with python2.7)On windows, the output is:Which is what I expectedOn linux, it is:Which not clone the global object and the passed args.My question is why they behave differently? And how to make the linux code behave the same as windows one?
Adding to @Blckknght's answer:  on Windows, each process imports the original module "from scratch", while on Unix-y systems only the main process runs the whole module, while all other processes see whatever exists at the time  is used to create the new processes (no, you're not calling  yourself -  internals call it whenever it creates a new process).In detail, for your :On all platforms, the main process calls , which sets  to 1.On Unix-y platforms, that's what all new processes see:  the  occurs after that, so 1 is the state all new processes inherit.On Windows, all new processes run the entire module "from scratch".  So they each import their own, brand new version of .  Only the main process calls , so only the main process sees  change to 1.  All other processes see the fresh  state.That's all expected, and actually easy to understand the second time ;-)What's going on with passing  is subtler, because it depends more on  implementation details.  The implementation could have chosen to pickle arguments on all platforms from the start, but it didn't, and now it's too late to change without breaking stuff on some platforms.Because of copy-on-write  semantics, it wasn't necessary to pickle  arguments on Unix-y systems, and so the implementation never did.  However, without  it is necessary to pickle them on Windows - and so the implementation does.Before Python 3.4, which allows you to force "the Windows implementation" () on all platforms, there's no mechanical way to avoid possible cross-platform surprises.But in practice, I've rarely been bothered by this.  Knowing that, for example, multiprocessing can depend heavily on pickling, I stay completely clear of getting anywhere near playing tricks with pickles.  The only reason you had "a problem" passing an  instance is that you are playing pickle tricks (via overriding the default ).
On Linux (and other Unix-like OSs), Python's  module using  to create new child processes that efficiently inherit a copy of the parent process's memory state. That means the interpreter doesn't need to pickle the objects that are being passed as the 's  since the child process will already have them available in their normal form.Windows doesn't have a  system call however, so the  module needs to do a bit more work to make the child-spawning process work. The -based implementation came first, and the non-forking Windows implementation came later.It's worth noting that the Python developers had often felt it was a bit of a misfeature for the creation of child processes to differ so much based on the platform you're running Python on. So in Python 3.4, a new system was added to allow you to select the start method that you would prefer to use. The options are ,  and . The  method remains the default on Unix-like systems (where it was the only implementation in earlier versions of Python). The  method is the default (and only) option on Windows, but now can be used on Unix-like systems too. The  method is sort of a hybrid between the two (and only available on some Unix-like systems). You can read more about the differences between the methods in the documentation.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods
