Natural Text
While using an open source Cython library I found a memory leak. The leak seems to come from a typed numpy array, which is not freed from the memory when it goes out of scope. The declaration is the following:In my understanding, this should be considered by the garbage collector like any other numpy array and the GC should free its memory as soon as the array goes out of scope -- in this case at the end of the function in which it is declared. Apparently this does not happen. If the array were created using a cython array first, and then casting it to numpy array, one could use the callback_free_data function like described here and here. However, in this case it is not possible to reach the pointers of  and it is not possible to set the callback. Any idea on why this kind of declaration could cause a memory leak and/or how to force the deallocation?Update:My question was very generic, and I wanted to avoid posting the code because it is a bit intricate, but since someone asked here we go: The  is a Cython wrapper for the c implementation. For example, the insert function looks like this:The  function works as it is supposed to, so the FiboHeap is released from the memory at the end of the function . My guess is that something is going wrong with the pointers contained in fiboheap_nodes.Any guess?
The problem (solved in the comments) turned out not to be the deallocation of the numpy array. Instead, the numpy array held a bunch of  objects, which themselves held pointers to a bunch of Python objects. It's these objects that weren't freed.When the Python object pointers in the  were acquired (in ) their reference count was incremented to ensure they were kept alive. However, when the  was destroyed (in ) the reference count of the Python objects it held was not decreased, causing the memory leak. The solution is to ensure that  is called on all the held Python objects during .There's potentially a second, more challenging problem waiting to appear: it might be possible for the objects held by the  to themselves contain a reference back to the , maybe indirectly. Python uses the function  to find these loops and  to break them. Cython will automatically generate a  for its  classes, however since it has no way of knowing about the Python object pointers hidden within the C  structure it won't handle these correctly (maybe generating another memory leak).This is a probably unlikely to happen in reality, so may not be worth worrying about, but it's something to be aware of. A newsgroup post describes a means of generating custom  functions in Cython. For most applications this should not be necessary - it's only the mixture of Cython  and  that makes it slightly possible here.


Answer URL
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse
