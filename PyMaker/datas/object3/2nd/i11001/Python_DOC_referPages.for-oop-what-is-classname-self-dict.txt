Natural Text
If I do , this goes into . What is this  found in , and when does it contain something?
First of all  is  different from , and the former doesn't exist. The latter is the  attribute that the instances of the class would have. It's a descriptor object that returns the internal dictionary of attributes for the specific instance. In short, the  attribute of an object can't be stored in object's , so it's accessed through a descriptor defined in the class.To understand this, you'd have to read the documentation of the descriptor protocol.The short version:For an instance of class , access to  is provided by  which is the same as .For the class A, access to  is provided by  (in theory) which is the same as .The long version:Both classes and objects provide access to attributes both through the attribute operator (implemented via the class or metaclass's ), and the  attribute/protocol which is used by .For normal objects, the  object creates a separate  object, which stores the attributes, and  first tries to access it and get the attributes from there (before attempting to look for the attribute in the class by utilizing the descriptor protocol, and before calling ). The  descriptor on the class implements the access to this dictionary. is equivalent to trying those in order: , ,  does the same but skips the first one for obvious reasonsAs it's impossible for the  of  to be stored in  of the instance, it is accessed through the descriptor protocol directly instead, and is stored in a special field in the instance.A similar scenario is true for classes, although their  is a special proxy object that pretends to be a dictionary (but might not be internally), and doesn't allow you to change it or replace it with another one. This proxy allows you, among all else, to access the attributes of a class that are specific to it, and not defined in one of its bases.By default, a  of an empty class carries three descriptors -  for storing the attributes of the instances,  which is used internally by , and the docstring of the class. The first two might be gone if you define . Then you wouldn't have  and  attributes, but instead you'd have a single class attribute for each slot. The attributes of the instance then wouldn't be stored in a dictionary, and access to them will be provided by the respective descriptors in the class.And lastly, the inconsistency that  is different from  is because the attribute  is, by exception, never looked up in , so what is true for it isn't true for practically any other attribute you'd use. For example,  is the same thing as . If this inconsistency didn't exist, using  would not work, and you'd have to always use  instead.
Lets do some exploring!I wonder what that is?What attributes does a  object have?By making a copy of that  we can find some interesting attributes, specifically  and .So  is a reference to  and  is just the string , name of an attribute perhaps?There we have it!   is an object that can refer back to .
Since  is a dictionary storing  attributes,  is the direct reference to that same  attribute. contains a (kind-of) reference to itself. The "kind-of" part is why the expression  returns a  instead of a normal .
You can try the following simple example to understand more of this:From the above example, it seems that class objects attributes are stored by their class, class's attributes are stored by their class, which are metaclasses. This is also validated by:


Answer URL
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
