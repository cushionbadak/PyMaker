Natural Text
I have a binary file containing a stream of 10-bit integers. I want to read it and store the values in a list.It is working with the following code, which reads  and fills  with integer values:It doesn't seem very elegant to read the bytes into bits, and read it back into "10-bit" bytes. Is there a better way to do it?  With 8 or 16 bit integers I could just use  and convert the result to an int directly. But here, as each value is stored in 1.25 bytes, I would need something like ...
Here's a generator that does the bit operations without using text string conversions. Hopefully, it's a little more efficient. :) To test it, I write all the numbers in range(1024) to a BytesIO stream, which behaves like a binary file.outputDoing  is the simplest way to turn the generator output into a list, but you can easily iterate over the values instead, eg or if you want indices as well as the data values.Here's a little-endian version of the generator which gives the same results as your code.We can improve this version slightly by "un-rolling" that for loop, which lets us get rid of the final masking and shifting operations.This should give a little more speed...
As there is no direct way to read a file x-bit by x-bit in Python, we have to read it byte by byte. Following MisterMiyagi and PM 2Ring's suggestions I modified my code to read the file by 5 byte chunks (i.e. 40 bits) and then split the resulting string into 4 10-bit numbers, instead of looping over the bits individually. It turned out to be twice as fast as my previous code.
Adding a Numpy based solution suitable for unpacking large 10-bit packed byte buffers like the ones you might receive from AVT and FLIR cameras.This is a 10-bit version of @cyrilgaudefroy's answer to a similar question; there you can also find a Numba alternative capable of yielding an additional speed increase.Reshape can be omitted if returning a buffer instead of a Numpy array:Or if image dimensions are known it can be reshaped directly, e.g.:If the use of the modulus operator appears confusing, try playing around with:Edit: It turns out that the Allied Vision Mako-U cameras employ a different ordering than the one I originally suggested above:So you might have to test different orders if images come out looking wonky initially for your specific setup.


Answer URL
https://docs.python.org/3/library/io.html#io.BytesIO
