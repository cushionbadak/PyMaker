Natural Text
Splitting on white-space can be done in two ways with . You can either issue a call with no arguments, , which defaults to using a white-space delimiter or explicitly supply the argument yourself with .But, why is it that when timed these functions perform so differently? Using a sample string with an intentional amount of white spaces:The timings for  and  are respectively: takes  while  takes , a similar scenario is present with  and  under the same conditions. Also,  seem do be affected too.The timings were performed for , on  the difference is less drastic. The docs on  don't indicate anything useful, so, why does this happen?  
In a tl;dr fashion:This is because two functions exist for the two different cases, as can be seen in ;  and  the first executing much faster than the second. Function  is for the common case  where no arguments exist and  (which wraps  ) for the case where  is called, i.e arguments are provided. just checks the separator and if it is valid and not equal to  (in which case it calls ) it calls . Both  and  follow the same logic, two counters are used, one equal to zero and the other equal to the length of the string. Using two  loops, the first counter is incremented until a value not equal to the separator is reached and the second counter is decremented until the same condition is met.The difference lies in the way checking if the current character is not equal to the separator is performed.For :In the most common case where the characters in the string to be split can be represented in  an additional small performance boost is present. Accessing the current character in the data is made quickly with by accessing the underlying array: The check if a character is a white-space is made by a simple array index into an array called . So, in short, it is quite efficient.If the characters are not in the  range, the differences aren't that drastic but they do slow the overall execution down:Accessing is done with Checking if the character is whitespace is done by the  macro (which simply calls another macro: )For :For this case, accessing the underlying data is, as it was in the previous case, done with ; the check, on the other hand, to see if the character is a white-space (or really, any character we've provided) is reasonably a bit more complex. is used, which, although efficient, is much more complex and slow compared to an array access. For each character in the string it is called to see if that character is contained in the separator(s) we've provided. As the length of the string increases, so does the overhead introduced by calling this function continuously. For those interested,  after quite some checks, will eventually call  inside  which in the case where the length of the separators is  will loop until it finds the character.Apart from this, consider the additional functions that need to already be called in order to get here. As for  and , the situation is similar. Flags for which mode of striping to perform exist, namely:  for ,  for  and  for . The logic inside  and  is performed conditionally based on the flag.
For the reasons explained in @Jims answer the same behavior is found in  objects:For  objects this doesn't happen, the functions performing the  in this case are similar for both cases.Additionally, in  the same applies to a smaller extent according to my timings.


Answer URL
https://docs.python.org/3/library/stdtypes.html#str.strip
https://docs.python.org/3/library/stdtypes.html#str.strip
https://docs.python.org/3/c-api/unicode.html#c.Py_UNICODE_ISSPACE
https://docs.python.org/3/c-api/unicode.html#c.PyUnicode_FindChar
