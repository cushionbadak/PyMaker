Natural Text
I was analysing the following code, which compiles and runs correctly, but generates a memory leak.The  is a C implementation of a Fibonacci Heap and the following code is a Cython wrapper (a part of it) for .My doubts starts on the insert function. The object  has been created somewhere and passed to the function . Since the function wants to add this object to the fiboheap it increases its reference count. But afterwards? To whom the ownership goes? In my understanding, the C function  just borrows the ownership. Then it returns a proprietary pointer that needs to be incapsulated, and then returned by . Cool. But my object  and its ref count? By creating the capsule I'm creating a new object, but I'm not decreasing the ref count of . This produces the memory leak. (Note that commenting out  or adding  before the return of  results in a segmentation fault.)My questions are:1) Why is it necessary to increment the ref count of  during the ? 2) Why is it not necessary to use a  during the ?3) More generally, how can I exactly keep track of the reference ownership when jumping between C and Python?4) How to properly deallocate an object like this FiboHeap? Should I use preventively a  in  and, if yes, how?Thanks!Note that this hasn't been written by me, but I'm using this example to better understand obj referencing and to stop the leak (since I am actually using the code).The main code that makes use of  (and where the leak happens) looks like this: is not a peek, but a proper pop, so it is deleting the C element in the C fiboheap.In conclusion: it seems clear that the ref count of  causes a memory leak, but why? And how to stop it?  
1) It is necessary to increase the reference count in  because its reference count will be automatically decreased at the end of insert. Cython does not know you are storing the object for later. (You can inspect the generated C code to see the  at the end of the function). If  is called with an object of reference count 1 (i.e. , then the object would be destroyed at the end of insert without the 2) If the object is removed from the  during  then you should do a  to acknowledge the fact that you no longer hold it. Cast it to object first (so you still hold a reference to it)3) Honestly you try not to use  if you can avoid it! It's much better to let Cython do the work. If you can't avoid it then you just need to ensure  is called once when you store the object, and  is called once when you stop storing it.4) You do need to decref the remaining objects on the heap in . A very easy way to do that might be to all  until the  is empty:A comment about the use of capsules: who owns the  that they point to (and when does this get destructed)? If it gets destructed when the  gets destructed then you have the issue of a capsule with an invalid pointer still being alive. Using this capsule somewhere might end up causing problems. If it doesn't get destructed by the  then you potentially have another memory leak.


Answer URL
https://docs.python.org/3/extending/extending.html#thin-ice
