Natural Text
Apparently xrange is faster but I have no idea why it's faster (and no proof besides the anecdotal so far that it is faster) or what besides that is different about
range creates a list, so if you do  it creates a list in memory with  elements. is a sequence object that  evaluates lazily.  It should be added from @Thiago's hint, that in python3, range does the equivalent of python's xrange  
range creates a list, so if you do  it creates a list in memory with  elements. is a generator, so it is a sequence object is a that  evaluates lazily.  This is true, but in Python 3,  will be implemented by the Python 2 . If you need to actually generate the list, you will need to do:
Remember, use the  module to test which of small snippets of code is faster!Personally, I always use , unless I were dealing with really huge lists -- as you can see, time-wise, for a list of a million entries, the extra overhead is only 0.04 seconds.  And as Corey points out, in Python 3.0  will go away and  will give you nice iterator behavior anyway.
 only stores the range params and generates the numbers on demand. However the C implementation of Python currently restricts its args to C longs:Note that in Python 3.0 there is only  and it behaves like the 2.x  but without the limitations on minimum and maximum end points.
xrange returns an iterator and only keeps one number in memory at a time.  range keeps the entire list of numbers in memory.
Do spend some time with the Library Reference. The more familiar you are with it, the faster you can find answers to questions like this. Especially important are the first few chapters about builtin objects and types.The advantage of the xrange type is that an xrange object will always   take the same amount of memory, no matter the size of the range it represents.   There are no consistent performance advantages.Another way to find quick information about a Python construct is the docstring and the help-function:
I am shocked nobody read doc:This function is very similar to , but returns an  object instead of a list. This is an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously. The advantage of  over  is minimal (since  still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the range’s elements are never used (such as when the loop is usually terminated with ).
range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.  xrange is a generator, so it evaluates lazily.This brings you two advantages:You can iterate longer lists without getting a .As it resolves each number lazily, if you stop iteration early, you won't waste time creating the whole list.
It is for optimization reasons.range() will create a list of values from start to end (0 .. 20 in your example). This will become an expensive operation on very large ranges.xrange() on the other hand is much more optimised. it will only compute the next value when needed (via an xrange sequence object) and does not create a list of all values like range() does.
You will find the advantage of  over  in this simple example:The above example doesn't reflect anything substantially better in case of .Now look at the following case where  is really really slow, compared to .With , it already creates a list from 0 to 100000000(time consuming), but  is a generator and it only generates numbers based on the need, that is, if the iteration continues.In Python-3, the implementation of the  functionality is same as that of  in Python-2, while they have done away with  in Python-3Happy Coding!! 
range(): range(1, 10) returns a list from 1 to 10 numbers & hold whole list in memory.xrange(): Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is lightly faster than range() and more memory efficient. xrange() object like an iterator and generates the numbers on demand.(Lazy Evaluation)
 returns a list of each number in between x and y if you use a  loop, then  is slower. In fact,  has a bigger Index range.  will print out a list of all the numbers in between x and y returns  but if you used a  loop, then  is faster.  has a smaller Index range.  will not only print out  but it will still keep all the numbers that are in it.If you use a  loop, then it would workThere isn't much difference when using loops, though there is a difference when just printing it!
In python 2.xrange(x) returns a list, that is created in memory with x elements.xrange(x) returns an xrange object which is a generator obj which generates the numbers on demand. they are computed during for-loop(Lazy Evaluation).For looping, this is slightly faster than range() and more memory efficient.
When testing range against xrange in a loop (I know I should use timeit, but this was swiftly hacked up from memory using a simple list comprehension example) I found the following:which gives:Or, using xrange in the for loop:Is my snippet testing properly? Any comments on the slower instance of xrange? Or a better example :-)
Some of the other answers mention that Python 3 eliminated 2.x's  and renamed 2.x's  to . However, unless you're using 3.0 or 3.1 (which nobody should be), it's actually a somewhat different type.As the 3.1 docs say:Range objects have very little behavior: they only support indexing, iteration, and the  function.However, in 3.2+,  is a full sequence—it supports extended slices, and all of the methods of  with the same semantics as a .*And, at least in CPython and PyPy (the only two 3.2+ implementations that currently exist), it also has constant-time implementations of the  and  methods and the  operator (as long as you only pass it integers). This means writing  is reasonable in 3.2+, while in 2.7 or 3.1 it would be a horrible idea.* The fact that  returns  in 2.6-2.7 and 3.0-3.1 is a bug that was fixed in 3.2 and not backported.
xrange() and range() in python works similarly as for the user , but the difference comes when we are talking about how the memory is allocated in using both the function.When we are using range() we allocate memory for all the variables it is generating, so it is not recommended to use with larger no. of variables to be generated.xrange() on the other hand generate only a particular value at a time and can only be used with the for loop to print all the values required.
range generates the entire list and returns it.  xrange does not -- it generates the numbers in the list on demand.
Read the following post for the comparison between range and xrange with graphical analysis.Python range Vs xrange
xrange uses an iterator (generates values on the fly), range returns a list.
What? returns a static list at runtime. returns an  (which acts like a generator, although it's certainly not one) from which values are generated as and when required.When to use which?  Use  if you want to generate a list for a gigantic range, say 1 billion, especially when you have a "memory sensitive system" like a cell phone.Use  if you want to iterate over the list several times.PS: Python 3.x's  function == Python 2.x's  function.
On a requirement for scanning/printing of 0-N items , range and xrange works as follows.range() - creates a new list in the memory and takes the whole 0 to N items(totally N+1) and prints them.xrange() - creates a iterator instance that scans through the items and keeps only the current encountered item into the memory , hence utilising same amount of memory all the time.In case the required element is somewhat at the beginning of the list only then it saves a good amount of time and memory.
The difference decreases for smaller arguments to  / :In this case  is only about 20% more efficient.
Everyone has explained it greatly. But I wanted it to see it for myself. I use python3. So, I opened the resource monitor (in Windows!), and first, executed the following command first:and then checked the change in 'In Use' memory. It was insignificant.Then, I ran the following code:And it took a big chunk of the memory for use, instantly. And, I was convinced.You can try it for yourself.If you are using Python 2X, then replace 'range()' with 'xrange()' in the first code and 'list(range())' with 'range()'.
Range returns a list while xrange returns an xrange object which takes the same memory irrespective of the range size,as in this case,only one element is generated and available per iteration whereas in case of using range, all the elements are generated at once and are available in the memory.
range :-range will populate everything at once.which means every number of the range will occupy the memory.xrange :-xrange is something like generator ,it will comes into picture when you want the range of numbers but you dont want them to be stored,like when you want to use in for loop.so memory efficient.
From the help docs.Python 2.7.12Python 3.5.2Difference is apparent. In Python 2.x,  returns a list,  returns an xrange object which is iterable.In Python 3.x,  becomes  of Python 2.x, and  is removed.
Additionally, if do  will be equivalent to .So  is slow.Also  really doesn't fully finish the sequenceSo that's why its not a list, it's a  object
See this post to find difference between range and xrange:To quote: returns exactly what you think: a list of consecutive  integers, of a defined length beginning with 0. , however,  returns an "xrange object", which acts a great deal like an iterator


Answer URL
https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes
