Natural Text
I want to write a function in Python that returns different fixed values based on the value of an input index.  In other languages I would use a  or  statement, but Python does not appear to have a  statement.  What are the recommended Python solutions in this scenario?
You could use a dictionary:
If you'd like defaults you could use the dictionary  method:
I've always liked doing it this wayFrom here
In addition to the dictionary methods (which I really like, BTW), you can also use if-elif-else to obtain the switch/case/default functionality:This of course is not identical to switch/case - you cannot have fall-through as easily as leaving off the break; statement, but you can have a more complicated test.  Its formatting is nicer than a series of nested ifs, even though functionally that's what it is closer to.
My favorite Python recipe for switch/case is:Short and simple for simple scenarios. Compare to 11+ lines of C code:You can even assign multiple variables by using tuples:
Usage:Tests:
There's a pattern that I learned from Twisted Python code.You can use it any time you need to dispatch on a token and execute extended piece of code. In a state machine you would have  methods, and dispatch on . This switch can be cleanly extended by inheriting from base class and defining your own  methods. Often times you won't even have  methods in the base class.Edit: how exactly is that usedIn case of SMTP you will receive  from the wire. The relevant code (from , modified for our case) looks like thisYou'll receive  (or you might get  or ). This is tokenized into  as . The actual method lookup name is taken from .(The original method is also called , because it uses the same pattern to implement a state machine, i.e. )
My favorite one is a really nice recipe. You'll really like it. It's the closest one I've seen to actual switch case statements, especially in features.Here's an example:

Let's say you don't want to just return a value, but want to use methods that change something on an object. Using the approach stated here would be:What happens here is that python evaluates all methods in the dictionary.So even if your value is 'a', the object will get incremented and decremented by x.Solution:So you get a list containing a function and its arguments. This way, only the function pointer and the argument list get returned, not evaluated. 'result' then evaluates the returned function call.
I'm just going to drop my two cents in here.  The reason there isn't a case/switch statement in Python is because Python follows the principle of 'Theres only one right way to do something'.   So obviously you could come up with various ways of recreating switch/case functionality, but the Pythonic way of accomplishing this is the if/elif construct. ieI just felt PEP 8 deserved a nod here.  One of the beautiful things about Python is its simplicity and elegance.  That is largely derived from principles laid our in PEP 8, including "There's only one right way to do something"
expanding on the "dict as switch" idea. if you want to use a default value for your switch:
If you have a complicated case block you can consider using a function dictionary lookup table... If you haven't done this before its a good idea to step into your debugger and view exactly how the dictionary looks up each function.  NOTE: Do not use "()" inside the case/dictionary lookup or it will call each of your functions as the dictionary / case block is created.  Remember this because you only want to call each function once using a hash style lookup.
If you're searching extra-statement, as "switch", I built a python module that extends Python. It's called ESPY as "Enhanced Structure for Python" and it's available for both Python 2.x and Python 3.x.For example, in this case, a switch statement could be performed by the following code:that can be used like this:so espy translate it in Python as:
I didn't find the simple answer I was looking for anywhere on Google search. But I figured it out anyway. It's really quite simple. Decided to post it, and maybe prevent a few less scratches on someone else's head. The key is simply "in" and tuples. Here is the switch statement behavior with fall-through, including RANDOM fall-through.Provides:
I found that a common switch structure:can be expressed in Python as follows:or formatted in a clearer way:Instead of being a statement, the python version is an expression, which evaluates to a value.
The solutions I use: A combination of 2 of the solutions posted here, which is relatively easy to read and supports defaults.wherelooks up  in the dict and uses it with  doesn't find it in the dict and uses the default  with .

Most of the answers here are pretty old, and especially the accepted ones, so it seems worth updating.First, the official Python FAQ covers this, and recommends the  chain for simple cases and the  for larger or more complex cases. It also suggests a set of  methods (a style used by many server frameworks) for some cases:The FAQ also mentions PEP 275, which was written to get an official once-and-for-all decision on adding C-style switch statements. But that PEP was actually deferred to Python 3, and it was only officially rejected as a separate proposal, PEP 3103. The answer was, of course, noâ€”but the two PEPs have links to additional information if you're interested in the reasons or the history.One thing that came up multiple times (and can be seen in PEP 275, even though it was cut out as an actual recommendation) is that if you're really bothered by having 8 lines of code to handle 4 cases, vs. the 6 lines you'd have in C or Bash, you can always write this:This isn't exactly encouraged by PEP 8, but it's readable and not too unidiomatic.Over the more than a decade since PEP 3103 was rejected, the issue of C-style case statements, or even the slightly more powerful version in Go, has been considered dead; whenever anyone brings it up on python-ideas or -dev, they're referred to the old decision.However, the idea of full ML-style pattern matching arises every few years, especially since languages like Swift and Rust have adopted it. The problem is that it's hard to get much use out of pattern matching without algebraic data types. While Guido has been sympathetic to the idea, nobody's come up with a proposal that fits into Python very well. (You can read my 2014 strawman for an example.) This could change with  in 3.7 and some sporadic proposals for a more powerful  to handle sum types, or with various proposals for different kinds of statement-local bindings (like PEP 3150, or the set of proposals currently being discussed on -ideas). But so far, it hasn't.There are also occasionally proposals for Perl 6-style matching, which is basically a mishmash of everything from  to regex to single-dispatch type-switching.

I liked Mark Bies's answerSince the  variable must used twice, I modified the lambda functions to parameterless.I have to run with  Edit: I noticed that I can use  type with with dictionaries. So this would emulate 
Short and easy to read, has a default value and supports expressions in both conditions and return values.However, it is less efficient than the solution with a dictionary. For example, Python has to scan through all the conditions before returning the default value.
I think the best way is to use the python language idioms to keep your code testable. As showed in previous answers, I use dictionaries to take advantage of python structures and language and keep the "case" code isolated in different methods. Below there is a class, but you can use directly a module, globals and functions. The class has methods that can be tested with isolation.Dependending to your needs, you can play with static methods and attributes too.It is possible to take advantage of this method using also classes as keys of "__choice_table". In this way you can avoid isinstance abuse and keep all clean and testable.Supposing you have to process a lot of messages or packets from the net or your MQ. Every packet has its own structure and its management code (in a generic way).With the above code it is possible to do something like this:So complexity is not spread in the code flow but it is rendered in code structure.
I made this small and clean solution where foo1(), foo2(), foo3() and default() are functions
you can use a dispatched dict:Output:
Defining:allows you to use a fairly straightforward syntax, with the cases bundled into a map:I kept trying to redefine switch in a way that would let me get rid of the "lambda:", but gave up.  Tweaking the definition:Allowed me to map multiple cases to the same code, and to supply a default option:Each replicated case has to be in its own dictionary; switch() consolidates the dictionaries before looking up the value.  It's still uglier than I'd like, but it has the basic efficiency of using a hashed lookup on the expression, rather than a loop through all the keys.
If you don't worry losing syntax highlight inside the case suites, you can do the following:Where  is the value. In C, this would be:We can also create a helper function to do this:So we can use it like this for the example with one, two and three:
Expanding on Greg Hewgill's answer - We can encapsulate the dictionary-solution using a decorator:This can then be used with the -decoratorThe good news are that this has already been done in NeoPySwitch-module. Simply install using pip:
I was quite confused after reading the answer, but this cleared it all up:This code is analogous to:Check the Source for more about dictionary mapping to functions.
A solution I tend to use which also makes use of dictionaries is : This has the advantage that it doesn't try to evaluate the functions every time, and you just have to ensure that the outer function gets all the information that the inner functions need.


Answer URL
https://docs.python.org/3/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python
https://docs.python.org/3/library/stdtypes.html#dict.get
