Natural Text
I have a method that calls 4 other methods in sequence to check for specific conditions, and returns immediately (not checking the following ones) whenever one returns something Truthy.This seems like a lot of baggage code. Instead of each 2-line if statement, I'd rather do something like:But that is invalid Python. Am I missing a simple, elegant solution here? Incidentally, in this situation, those four check methods may be expensive, so I do not want to call them multiple times.
You could use a loop:This has the added advantage that you can now make the number of conditions variable.You could use  +  (the Python 3 versions, use the  versions in Python 2) to get the first such matching value:but if this is more readable is debatable.Another option is to use a generator expression:
Alternatively to Martijn's fine answer, you could chain . This will return the first truthy value, or  if there's no truthy value:Demo:
Don't change itThere are other ways of doing this as the various other answers show. None are as clear as your original code.
In effectively the same answer as timgeb, but you could use parenthesis for nicer formatting:
According to Curly's law, you can make this code more readable by splitting two concerns:What things do I check?Has one thing returned true?into two functions:This avoids:complicated logical structuresreally long linesrepetition...while preserving a linear, easy to read flow.You can probably also come up with even better function names, according to your particular circumstance, which make it even more readable.
This is a variant of Martijns first example. It also uses the "collection of callables"-style in order to allow short-circuiting.Instead of a loop you can use the builtin . Note that  returns a boolean, so if you need the exact return value of the check, this solution will not work.  will not distinguish between , , ,  as return values, they will all be returned as .
Have you considered just writing  all on one line?This isn't any less repetitive than what you had, but IMNSHO it reads quite a bit smoother.
I'm quite surprised nobody mentioned the built-in  which is made for this purpose:Note that although this implementation is probably the clearest, it evaluates all the checks even if the first one is .If you really need to stop at the first failed check, consider using  which is made to convert a list to a simple value: : Apply function of two  arguments cumulatively to the items of iterable, from left to right,  so as to reduce the iterable to a single value. The left argument, x,  is the accumulated value and the right argument, y, is the update  value from the iterable. If the optional initializer is present, it is  placed before the items of the iterable in the calculationIn your case: is the function that checks that either the accumulator  or the current check  is . Note that if  is ,  won't be evaluated. contains check functions (the  item from the lambda) is the initial value, otherwise no check would happen and the result would always be  and  are basic tools for functional programming. I strongly encourage you to train these out as well as  which is awesome too!
If you want the same code structure, you could use ternary statements!I think this looks nice and clear if you look at it.Demo:
For me, the best answer is that from @phil-frost, followed by @wayne-werner's.What I find interesting is that no one has said anything about the fact that a function will be returning many different data types, which will make then mandatory to do checks on the type of x itself to do any further work.So I would mix @PhilFrost's response with the idea of keeping a single type:Notice that  is passed as an argument, but also  is used as a passed generator of checking functions where all of them get an  to be checked, and return  or . By using  with  as default value, you can use , or you can pass a further personalised generator via .That way, you get  as soon as one check passes, but it will always be the same type.
A slight variation on Martijns first example above, that avoids the if inside the loop:
Ideally, I would re-write the   functions to return  or  rather than a value. Your checks then becomeAssuming your  is not immutable, your function can still modify it (although they can't reassign it) - but a function called  shouldn't really be modifying it anyway. 
This way is a little bit outside of the box, but I think the end result is simple, readable, and looks nice. The basic idea is to  an exception when one of the functions evaluates as truthy, and return the result. Here's how it might look: You'll need a  function that raises an exception when one of the called function arguments evaluates as truthy: The above could be modified so as to also provide arguments for the functions to be evaluated. And of course you'll need the  itself. This exception provides the  that triggered the exception: You can turn the original function into something more general, of course: This might be a bit slower because you are using both an  statement and handling an exception. However, the exception is only handled a maximum of one time, so the hit to performance should be minor unless you expect to run the check and get a  value many many thousands of times. 
The pythonic way is either using reduce (as someone already mentioned) or itertools (as shown below), but it seems to me that simply using short circuiting of the  operator produces clearer code
I like @timgeb's. In the meantime I would like to add that expressing  in the  statement is not needed as the collection of  separated statements are evaluated and the first none-zero, none-empty, none-None is returned and if there isn't any then  is returned whether there is a  or not!So my  function looks like this:Using  with  I looked at the running time of a number of the suggestions. For the sake of comparison I just used the  function to return a string or  based on random numbers. Here is the whole code:And here are the results:
I'm going to jump in here and have never written a single line of Python, but I assume  is valid?if so:
I have seen some interesting implementations of switch/case statements with dicts in the past that led me to this answer. Using the example you've provided you would get the following. (It's madness , so  is renamed to . See (1))The select function eliminates the need to call each  twice i.e. you avoid  by adding another function layer. This is useful for long running functions. The lambdas in the dict delay execution of it's values until the while loop.As a bonus you may modify the execution order and even skip some of the tests by altering  and  e.g.  reduces the number of tests and reverses the original processing order.The  fellows might haggle over the cost of adding an extra layer or two to the stack and the cost for the dict look up but you seem more concerned with the prettiness of the code.Alternatively a simpler implementation might be the following :I mean this not in terms of pep8 but in terms of using one concise descriptive word in place of a sentence. Granted the OP may be following some coding convention, working one some existing code base or not care for terse terms in their codebase.


Answer URL
https://docs.python.org/3/library/functions.html#map
https://docs.python.org/3/library/functions.html#filter
https://docs.python.org/3/library/functions.html
https://docs.python.org/3/library/stdtypes.html#iterator-types
