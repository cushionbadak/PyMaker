Natural Text
I have a word list and some sentences I need to replicate:My expected results are:Here is my method:And I wonder if there is any way more efficient to do this because my word list and sentence list are much larger than in the example. Thanks in advance.Update: I just realized there are words that belong to more than one class and sentences that have more than one keyword, so my code doesn't work now.
First, you could "invert" the  to a dictionary mapping words to their classes. Here, I'll assume that each word is in only one class, otherwise it get's a bit more complicated.Next, you can find all the occurrences of any of the words, using the  to (a) get all the words classes, and (b) create a template for re-formatting the sentence. Note that I wrap the pattern into word boundaries  so it does not match word-fragments.Now, you can iterate the  of all the possible replacements and substitute them:This way, the result for sentence  is:This should be considerably faster than your approach (did not time it, though), as it only searches twice for the , whereas you search for each individual pattern separately. Also, this works for sentences that have more than one placeholder word.If a word can be in multiple classes, you can use this:You could also  the  entries with all the words thenselves, instead of their class names, making the  much simpler, but at the price of potentially much higher space requirements, depending on the size of the word classes and the "overlap".
Here's an alternative version that implements the following idea: have an inverted dictionary "word -> class" for a quick lookup. This assumes the mapping is invertable. Then, kick off  to print the replacement on all other words within the word class.
You can try this:Output:


Answer URL
https://docs.python.org/3/library/itertools.html#itertools.product
