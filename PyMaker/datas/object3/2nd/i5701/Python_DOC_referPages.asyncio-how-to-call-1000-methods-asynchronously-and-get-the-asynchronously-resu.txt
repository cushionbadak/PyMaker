Natural Text
I ask for your advice. I want to understand the work of an async on a simple example. According to the legend, you need to create 1000 workers who return some result. But you need to return it as soon as it is ready.Here is an example:The problem is that the result of the work of this example is not synchronous, it simply calls the function without blocking the main process, and at the end it returns the responses of all functionsBut how to achieve the result in a similarity:You can create a ThreadPoolExecutor, of course, or the ProcessPoolExecutor. But then why do you need Asyncio, you can create threads without it and work with them.
You're looking for :But then why do you need Asyncio, you can create threads without it and work with them.Sure, threads can be more efficient and you can do more things with them, but single-threaded asynchronous cooperative multi-tasking is simpler to coordinate.
it simply calls the function without blocking the main process, and at  the end it returns the responses of all functionsIt starts all workers concurrently and this is how it should be, calculates theirs results immediately (since worker doesn't contain anything actually I/O blocking) and return results same time.If you want to see workers return results in a different time you should make them execute different time - for example, by placing  instead your 0-sleep.I'm not sure I understood why you want this:Since you have  in a top of each worker (without some I/O blocking actions before it) and run all workers concurrently - you will see all theirs prints immediately, before any result.My random guess is that you may be want to limit count of workers running parallely? In this case you can use synchronization primitives like asyncio.Semaphore.Here's example contains all above:Output:


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.wait
https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore
