Natural Text
I am learning Python and right now I am on the topic of scopes and nonlocal statement.At some point I thought I figured it all out, but then nonlocal came and broke everything down.Example number 1:Running it naturally fails.What is more interesting is that ) does not get executed. Why?.My understanding was that enclosing  is not executed until  is executed, and nested  is executed only when  is called. I am confused...Ok, let's try example number 2:Aaand... it runs fine.Whaaat?! How did THAT fix it?  in function  is never executed!My understanding was that nonlocal statement is evaluated and executed at run-time, searching enclosing function's call contexts and binding local name  to some particular "outer" . And if there is no  in outer functions - raise an exception. Again, at run-time.But now it looks like this is done at the time of syntax analysis, with pretty dumb check "look in outer functions for , if there is something like this - we're fine," even if that  is never executed...Can anybody explain me when and how nonlocal statement is processed?
You can see what the scope of  knows about free variables (available for binding) from the scope of , like so:Which gives:If you comment out the  line, and remove the  statement with  inside, the you'll see the free variables available to  is just .So let's look at what bytecode instruction this generates, by putting the definition of  into IPython and then using :So then let's look at how  is processed in .So we see it must look up  from  of the enclosing scope(s). This is mentioned in the Execution Model documentation, where it says:The nonlocal statement causes corresponding names to refer to previously bound variables in the nearest enclosing function scope. SyntaxError is raised at compile time if the given name does not exist in any enclosing function scope.
First, understand that python will check your module's syntax and if it detects something invalid it raises a  which stops it from running at all. Your first example raises a  but to understand exactly why is pretty complicated although it is easier to understand if you know how  works so I will quickly introduce that first.When a class defines  it is basically saying that the instances should only have those attributes so each object is allocated memory with space for only those, trying to assign other attributes raises an errorThe reason  can't work is that there is no memory space to put a  attribute in.If you do not specify  then all instances are created with a dictionary to store the instance variables, dictionaries do not have any limitations on how many values they containPython functions work similar to . When python checks the syntax of your module it finds all variables assigned (or attempted to be assigned) in each function definition and uses that when constructing frames during execution.  When you use  it gives an inner function access to a specific variable in the outer function scope but if there is no variable defined in the outer function then  has no space to point to.Global access doesn't run into the same issue since python modules are created with a dictionary to store its attributes.  So  is allowed even if there is no global reference to 


Answer URL
https://docs.python.org/3/reference/executionmodel.html#resolution-of-names
