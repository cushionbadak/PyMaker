Natural Text
I have created a Python package which builds on the structure indicated in Kenneth Reitz' "Repository Structure and Python" (1). The main package path is:With the current structure, I must use the following module import syntax:I would prefer to type the following:I am capable of typing the same word twice, of course, but it feels wrong in a deeper sense, i.e., I am structuring my package incorrectly or misunderstanding how Python interprets that structure.The outer  is required for Python to detect this package at all, per the docs (2). But that sets up  as the top level of the package and  as a sub-package, forcing me into the unwieldy import syntax above.To avoid this, it seems that my options are to:Create a package in which the outer folder contains the top level of package modules.Add the inner folder to my  environment variable.Yet both of these seem like suboptimal workarounds for something that shouldn't be an issue in the first place. What should I do?
You've misunderstood. You have two  packages for some reason, but the source you cite never said to do that. The outer folder, with , is not supposed to be a package.It sounds like you're running Python in  and trying to import your package from there. That's not what you should be doing. You have several options to get your package into the import system. (I'll refer to the folder with  in it as , to distinguish it from the inner folder):Build your package with , for example, , and install the built package with pip.Skip the build step and just run . Building the package produces an installer useful if you want to distribute your package, but maybe you don't want to do that."Install" the package's source tree in development mode with , so the Python import system will locate the package's source tree when performing imports. This is handy because you don't have to rebuild and reinstall if you edit the source repository, although you'll still want to restart any running Python processes that are using the package.Run Python from directly inside the .Any of these options will cause your package to be importable directly as  instead of , as it should be.
While I do not entirely agree with your package structure, you can make use of  and possibly the one legitimate use for star imports I've seen so far.  can serve more purposes than just identifying your folder as a package or sub-package.Using a Star ImportIn , add a variable  that declares all the public elements you want to export:In  do . Now all the attributes that were available as  will also be available as .If you want to directly copy  to  (which is optional, but will allow you to do  properly), you can do something likeNot Using a Star ImportYou can accomplish the same thing without using  at all. Just add  directly to  and use -style imports:I would still recommend having a  variable, but it is optional for this particular purpose.Pros and ConsBoth approaches are pretty legitimate and I have seen both used in major projects. The first approach reduces redundancy. You only define the public exports in one place: . The star imports and  reference that definition directly, leading to one place that you really have to maintain. On the other hand, there are times when you want to separate the "full"  API from what you expose via  to the casual user. In that case, go with the second option. The only downside here is that you have to be more careful to keep  and the corresponding imports synchronized properly.NoteA number of projects I've seen (numpy especially comes to mind), export the attributes of the individual modules to the top level using this technique. For example, if you had a function , it would be listed in , which would be imported into , appended to , and then be referenced by the top-level package and .


Answer URL
https://docs.python.org/3/tutorial/modules.html#packages
https://docs.python.org/3/tutorial/modules.html#importing-from-a-package
