Natural Text
I need to call a pipeline realized as a Python (3.6) function from my C++ project under the Windows platform. Function “function_name” from file  "experiment_test.py" takes text string as input parameter and return another text string as the result. I try the code below but it doesn’t work properly – python functions from libraries shutil, codecs, makedirs, etc doesn’t work.C++ code (reduced):Python code (reduced):So no new files will be generated by Python. I tried to import Python modules in C++ by calling PyRun_SimpleString("import shutil"); etc after Py_Initialize(); but it doesn’t help.What do I do wrong?
I tried replicating the problem with the given intel, but it was impossible, so I created a small example (as close as possible to what's described in the question) - Also referred to as [SO]: How to create a Minimal, Complete, and Verifiable example (mcve) (that should be included in the question BTW)So, the problem that I'm illustrating here, is:C++Load the Python engineLoad a Python moduleFrom that module, load a function which:Receives a (string) argument representing a file nameReads the file contents (text) and returns itIn case of error, simply returns the file nameCall that functionGet the function call resultI am using (on Win 10 x64 (10.0.16299.125)):Python 3.5.4 x64 VStudio 2015 Community EditionThe structure consists of:A VStudio project / solutionA source file (main.cpp)A Python module (experiment_test.py)A test file (test_file.txt)main.cpp:Notes:The _DEBUG / _DEBUG_UNDEFINED stuff at the beginning - a (lame) workaround (gainarie) to link against Release Python lib (python35.lib) when building in Debug mode (as opposed to python35_d.lib) - read belowAs I said, tried to simplify the code (got rid of the PyCallable_Check test)It's easily noticeable that the code is written in C style, although it uses the C++ compilerSince Python API ([Python 3]: Embedding Python in Another Application) (both extending/embedding) uses pointers, make sure to test for NULLs, otherwise there's a high chance getting segfault (Access Violation)Added the [Python 3]: void Py_DECREF(PyObject *o) statements to avoid memory leaksBuild (compile / link) / Run options (obviously, you got past these, since you were able to run your program, but I'm going to list them anyway - for sure there are some shortcuts here, when dealing with more than one such project):Check [SO]: LNK2005 Error in CLR Windows Form (@CristiFati's answer) for details building a Win PETo speed-up process when building projects that depend on Python, I created a VStudio User Macro (called e.g. Python35Dir - like in the image below, pointing to my Python 3.5 installation dir)Notes:The path ("c:\Install\x64\Python\Python\3.5") points to the installation downloaded from the official siteObviously, for 32bit, the path isn't set accordinglyThis path contains (as expected) a Release version, and this is fine as long as I don't need to get into Python code (and as long as I don't mess around with memory - as (when building my app in Debug mode) I have 2 C runtimes in my .exe - check the links below to see what happens when tampering with MSVC runtimes (UCRTs)):[SO]: When using fstream in a library I get linker errors in the executable (@CristiFati's answer)[SO]: Errors when linking to protobuf 3 on MS Visual C (@CristiFati's answer)For exceptional cases, I have built Python in Debug mode and got the binaries, but that's not my 1st choice, since it requires settings (paths) changesCompile:Let VSTudio know about the Python include files location:Link:Let VSTudio know about the Python lib files location (if only pythonxx*.lib (%PYTHONCORE%) is required, nothing extra needed, since PYTHONCORE is included by default by Python code; otherwise, all the rest should be specified in the [MS.Docs]: .Lib Files as Linker Input:Run / Debug - let:VStudio know where Python runtime python35.dll is located (%PATH%)Loaded Python runtime know where additional modules are located (%PYTHONPATH%)experiment_test.py:Notes:An almost dummy module, as specified at the beginningWorks only with text files (decode will fail for binary files)Imports modules that aren't used, to see that they are OK (that's obvious, if one such import statement succeeds, all should)Prints some data on stdout (to be matched with what's on the C++ side)Located in a path known by Python (%PYTHONPATH% from previous step)Has 1 argument (file_name) - crucial difference compared to the one in the question which doesn't have any (don't know whether that's a logical mistake or a typo like one) test_dir\test_file.txt:Output (console from VStudio):


Answer URL
https://docs.python.org/3/extending/embedding.html
https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF
