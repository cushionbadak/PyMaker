Natural Text
I wrote the following code: returns the memory consumption of the objects using this code.I get the following prints:How come the objects consumed 20M if the process consumed only 8M more?If I exit a method shouldn't the memory decreased back to 21 as the garbage collector will clear the consumed memory?
Most likely this is because there's inaccuracy in your code. Here's a fully working (python 2.7) example that has the same problem (I've slightly updated the original code for simplicity's sake)Here's the output:The difference is ~100MbAnd here's the fixed version of the code:And here is the updated output:Did you spot the difference? You're calculating object sizes before measuring the final process size and it leads to additional memory consumption. Lets check why it might be happening - here's the sources of https://github.com/bosswissam/pysize/blob/master/pysize.py:Lots of things are happening here!The most notable one is that it holds all the objects it has seen in a set to resolve circular references. If you remove that line it won't each that much memory in either case.First of all, this behavior heavily depends on whether you use CPython or something else.  As of CPython, this may happen because it's not always possible to give memory back to the OS immediately.Here's a good article on the subject, quoting: If you create a large object and delete it again, Python has probably  released the memory, but the memory allocators involved don’t  necessarily return the memory to the operating system, so it may look  as if the Python process uses a lot more virtual memory than it  actually uses.
Why would the process need to consume an overhead greater than 8M?Garbage collection does not necessarily happen immediately. See the documentation:Objects are never explicitly destroyed; however, when they become  unreachable they may be garbage-collected. An implementation is  allowed to postpone garbage collection or omit it altogether — it is a  matter of implementation quality how garbage collection is  implemented, as long as no objects are collected that are still  reachable.CPython implementation detail: CPython currently uses a  reference-counting scheme with (optional) delayed detection of  cyclically linked garbage, which collects most objects as soon as they  become unreachable, but is not guaranteed to collect garbage  containing circular references. See the documentation of the gc module  for information on controlling the collection of cyclic garbage. Other  implementations act differently and CPython may change. Do not depend  on immediate finalization of objects when they become unreachable (so  you should always close files explicitly).


Answer URL
https://docs.python.org/3/reference/datamodel.html
https://docs.python.org/3/library/gc.html#module-gc
