Natural Text
I was reading an interesting post on Short-Circuiting in Python and wondered if this was true for the  operator. My simple testing would conclude that it does not:Is there a detailed explanation of why  takes longer than . Is the  operator like a loop?Also, is there a way to tell the  operator to "stop the loop" once the value is found (or is this the already defaulted behavior that I'm not seeing)? Lastly- Is there another operator/function that I am skipping over that does what I'm talking about in regards to "short-circuiting" ?
The implementation of  for  objects is found in . It performs a scan of the list and does exit early if the last comparison has found the element, there's no point in continuing there. The loop involved is:If  is  (the value returned from  for a match), the  loop condition () becomes false and terminates.For list objects, which are built-in, what is called for  is a  function (for CPython). For other implementations of Python, this can be a different language using different language constructs. For user-defined classes in Python, what is called is defined in the Membership test operations of the Reference Manual, take a look there for a run-down of what gets called.You could also come to this conclusion by timing:The furthest the element the more you need to scan. If it didn't short-circuit, all  operations would result in similar timings.
Short circuiting does occur. The  operator calls the  method, which in turn is implemented differently per class (in your case ). Searching for  takes around double the time as searching for , since half of the work is creating the list, and the other half is iterating through it, which is short circuited in the case of .
Here's another look with a hashed object, :Output:As others have said, the  implementation must do a sequential search.  Set inclusion uses a hashed value, and is on par with finding the item in the first element checked.


Answer URL
https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool
