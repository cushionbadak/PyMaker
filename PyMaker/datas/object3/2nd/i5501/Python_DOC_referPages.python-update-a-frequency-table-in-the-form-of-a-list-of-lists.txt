Natural Text
I have two lists of US state abbreviations (for example):What I want to end up with is this (basically an ordered frequency table):The way I came up with was:This works great - though, tbh, I don't know that this is very memory efficient.BUT... there is a catch.  ...is too big to hold in memory, so what I'm doing is appending to s1 until it reaches a length of 10K (yes, resources are THAT limited), then summarizing it (using the list comprehension step above), deleting the contents of s1, and re-filling s1 with the next chunk of data (only represented as 's2' above for purpose of demonstration).  ...and so on through the loop until it reaches the end of the data.  So with each iteration of the loop, I want to sum the 'base' list of lists 'S' with the current iteration's list of lists 's'.  My question is, essentially, how do I add these: (the current master data):(the new data):...to get (the new master data):...in some sort of reasonably efficient way.  If this is better to do with dictionaries or something else, I am fine with that.  What I can't do, unfortunately is make use of ANY remotely specialized Python module -- all I have to work with is the most stripped-down version of Python 2.6 imaginable in a closed-off, locked-down, resource-poor Linux environment (hazards of the job).  Any help is greatly appreciated!!
You can use  to chain two iterators efficiently:A  object is a  specialized for counting... if you know how to use a  you can use a . However, it allows you to write the above more succinctly as:Also note, the following construction:Happens to also be very time inefficient, since you are calling  in a loop. Although, this might not be too bad if Note, you can do the chaining "manually" by doing something like:
You can run  as many times as you like, cutting your data to fit in memory / streaming them as you like.The last line uses negated count as the sorting key to make the higher counts come first.If with that your count structure does not fit in memory, you need a (disk-based) database, such as Postgres, or likely just a machine with more memory and a more efficient key-value store, such as Redis.


Answer URL
https://docs.python.org/3/library/collections.html#collections.Counter.update
