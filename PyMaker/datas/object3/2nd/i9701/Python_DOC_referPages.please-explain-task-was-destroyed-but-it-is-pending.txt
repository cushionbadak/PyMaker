Natural Text
Python 3.4.2I am learning asyncio and I use it to continously listen IPC bus, while gbulb listens to the dbus.Some side notes:So I created a function  that continously listens for incoming messages on the IPC channel and passes the message to a .I am also listening to SIGTERM and SIGINT. So when I send a SIGTERM to the python process running the code you find at the bottom, the script should terminate gracefully.The problem… I am having is the following warning:… with the following code:I still only understand very little of asyncio, but I think I know what is going on. While waiting for  the signal handler caught the SIGTERM and in that process it calls .Question thrown in: Shouldn't this trigger the  within the  loop? (Because it is not, but that is how I understand "Calling cancel() will throw a CancelledError to the wrapped coroutine").Eventually  is called which stops the loop without waiting for either  to return a result or even the whole coroutine .Please correct me if I am wrong.I think the only thing I need to do is to make my program wait for the  to return a result and/or coroutine to break out the while-loop and finish.I believe I confuse a lot of things. Please help me get those things straight so that I can figure out how to gracefully close the event loop without warning.
The problem comes from closing the loop immediately after cancelling the tasks. As the cancel() docs state "This arranges for a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop."Take this snippet of code:Notice  cancels the tasks but does not  the loop, on the next cycle  stops it. The output if you cancel it is:Notice how  cancels and stops the loop immediately after. If you let it run until the  coroutines awakes from the sleep you can see the same warning you're getting:
The meaning of the issue is that a loop doesn't have time to finish all the tasks.This arranges for a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop.There is no chance to do a "next cycle" of the loop in your approach. To make it properly you should move a stop operation to a separate non-cyclic coroutine to give your loop a chance to finish.Second significant thing is  raising.Unlike Future.cancel(), this does not guarantee that the task will be cancelled: the exception might be caught and acted upon, delaying cancellation of the task or preventing cancellation completely. The task may also return a value or raise a different exception.Immediately after this method is called, cancelled() will not return True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even if cancel() was not called).So after cleanup your coroutine must raise  to be marked as cancelled.Using an extra coroutine to stop the loop is not an issue because it is not cyclic and be done immediately after execution.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
