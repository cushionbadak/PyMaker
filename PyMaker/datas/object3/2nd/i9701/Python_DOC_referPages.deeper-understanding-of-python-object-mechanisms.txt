Natural Text
I would like to better understand Python 3.x data model. But I do not find complete and precise explanation of Python Object behaviours.I am looking for references, it would be great if every case that I show below could be linked to a Python API reference or PEP or anything else valuable. Thank you further for your wise advises...Let say we have some complex Python structure for testing purposes:1) Immutable atomic objects are singletonsWhatever the way I create a new integer:No new copy of this number is created, instead it points towards the same object as . More conciselyThey all do have the same , I cannot create a new instance of  with value 5432, therefore it is a singleton.2) Immutable and Iterable objects might be singletons...Previous observation also works for , which are immutable and iterable. All following variables:Point towards the copy initially created . String are also singletons....but not exactly...Tuple are also immutable and iterable, but they do not behave like string. It is know that the magic empty tuple is a singleton:But other tuples are not....instead they hash equallyThey do not have the same :But all items within those two structures are atomic, so they point towards same instances. The important point is, both structures  the same way:So they can be used as dictionary keys. This is even true for nested tuples:They do have the same .3) Passing dictionary by double dereferencing works as shallow copy of itLets define the following function:Which will receive our trial dictionary by double dereferencing ( operator) first degree members will be copied, but deepest will be passed by reference.Output of this simple program, illustrates it:It returns:The dictionary  has been modified by function , but not completely. Member 'is kept back because we worked on a copy, but member  is also a dictionary and the shallow copy did not copy it, then it has been modified.This behaviour is similar to  behaviour for  object. Where we need  to have a recursive and complete copy of object.My requests are:Are my observations correctly interpreted?Immutable atomic objects are singletonsImmutable and Iterable objects might be singletons but not exactly instead they hash equallyPassing dictionary by double dereferencing works as shallow copy of itAre those behaviours well documented somewhere?For each case states correct properties & behaviours.
Immutable atomic objects are singletonsNope, some are and some aren't, this is a detail of the CPython implementation. Integers in the range  are cached and when a new request for these is made the already existing objects are returned. Numbers outside that range are subject to constant folding where the interpreter re-uses constants during compilation as a slight optimization. This is documented in the section on creating new  objects.Also, see the following for a discussion on these:  'is' operator behaves unexpectedly with non-cached integers"is" operator behaves unexpectedly with integersStrings literals are subject to interning during the compilation to bytecode as do ints. The rules for governing this are not as simplistic as for ints, though: Strings under a certain size composed of certain characters are only considered. I am not aware of any section in the docs specifying this, you could take a look at the behavior by reading here.Floats, for example, which could be considered "atomic" (even though in Python that term doesn't have the meaning you think) there are no singletons:they are still of course subject to constant folding. As you can see by reading: 'is' operator behaves unexpectedly with floatsImmutable and Iterable objects might be singletons but not exactly instead they hash equallyEmpty immutables collections are signletons; this is again an implementation detail that can't be found in the Python Reference but truly only discovered if you look at the source.See here for a look at the implementation: Why does '() is ()' return True when '[] is []' and '{} is {}' return False?Passing dictionary by double dereferencing works as shallow copy of it.Yes. Though the term isn't double dereferencing, it is unpacking.Are those behaviours well documented somewhere?Those that are considered an implementation detail needn't be documented in the way you'd find documentation for the  function for example. These are specific things that might easily change if the decision is made so.


Answer URL
https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong
