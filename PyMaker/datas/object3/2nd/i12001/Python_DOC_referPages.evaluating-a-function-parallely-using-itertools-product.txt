Natural Text
I have to evaluate a function (let's call it my_func()) that takes 8 parameters as input and returns a scalar upon different matrix computations. Since I don't have any constrains on my_func(), I have no choice but to brute force all possibilities which amounts to 8^8 = 16777216. I started off using itertools's product functions and passed the generated sequences to the my_func() sequentially. Kindly take a look at the sample of my code below, So far.....Pitfalls...Unfortunately, executing the above code sequentially takes ages to produce the output. This is because my_func is quite heavy. I have no choice but to somehow parallelize this code so that I can take advantage of multiple processors available to run my code. Questions:Since itertools.product is a generator I cannot parallelize this to evaluate my_func() simultaneously for different sets of parameters. Is there any way I can parallelize the code? if no is the asnswer, should I abondon the idea of using itertools and try someting else?Kindly help me find a solution.Thanks for suggesting any ideas.Cheers!!
You can parallelize a generator ! You can use the  library, which offers the  class which does exactly what you want. Here you can get more ample documentation, but essentially, what you want to do is :You should look into the alternatives to  to find the one which suits you most.
The number of cores you'll use is probably much smaller than  88 .This leads to the following parallallelization scheme. Call  onWithin each process, perform the parallellization on the remaining parameters, and return only a single result - the best tuple of parameters found.This will be much more efficient anyway than passing each of the 88 combinations. There's an overhead to these things.ExampleSay you decide to map over the first three parameters. Then your  is a sequence of triplets: . You use something like  on each such triplet, so let's consider it from the point of view of the function:On a separate matter - in practice, the Nelder Mead method works well on optimizing high-dimensional problems, and is much cheaper than brute force. You might wish to give an implementation of it a try.


Answer URL
https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers
