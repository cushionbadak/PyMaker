Natural Text
I am converting a shell script into Python. The shell script supports arguments like this.One or more arguments listed in the 'Commands' section may be mixed andmatched but some of them are mutually exclusive.For example, all of the following are valid command line invocations.However, , ,  and  are mutuallyexclusive. So the following are not valid.Is it possible to handle command line arguments like these using? Or am I better off looping over  myself,handling these cases with my own code, which would also mean that I haveto take care of updating the help message and any necessary validationwhenever the list of supported arguments change?Note: I don't want to rely on any internal implementation of  module to achieve this. I only want to rely on publicly documented API of . If it is not possible to solve this problem with the publicly documented API of , then that's fine and that would be the answer. In that case, I would handle the command line arguments myself by looping over  similar to how the shell script is handling the arguments by looping over .
A variation in which  and  are optionals, and the rest are subparsers fits  nicely.You can't run multiple subparsers (e.g.  and ) without some serious convolutions.  Plus  and  are conceptually very different arguments.  The others are commands - do thus-n-such.   and  are modifiers.Do  and  work with all the others, or just with  and .  They might make more sense as optionals for those subparsers.Also keep in mind that a big plus to  is that it generates usage, helps and error messages.  When you do something unusual, you need to think about those messages.  How do you clearly tell your users that they can use  with  but not with ?  Or that they can't use  and  at the same time; or that one overrides the other.But if you are stuck with these names/flags, and can't add , then don't bother with .  Don't bother changing something that already works.  The underlying philosophy in  (and  and ) is to use flagged strings ('--') where you want to match content with action, and handle the rest by order.   expects to parse your strings based on position, not content.
It can mostly handle this, just not quite the way you're doing it. You'd use subcommands/subparsers for print, search, remove and convert, and define the other "commands" (really options on the top level commands) as switches, either on the top level parser if they're common to all commands, or on the individual subparsers/subcommands if they're not common.Now, in this particular case, it seems like you don't even have unique behaviors for each subcommand, so you might just get away with a single positional argument and two switches:The positional  argument could be changed to individual subparsers if needed, but in this case, it seems like all of the possible commands would allow  or .


Answer URL
https://docs.python.org/3/library/argparse.html#sub-commands
