Natural Text
I always thought that if I use a for loop like this:I will never make my list index out of range. However, I am wrong..The purpose of my code is to output all subsets of the input set.Example:Input:Output:Here is the code:So my core concept is use a binary list to create the subset list.For example, when I read 001 in Binary list. I will keep 3 due to the third bit being 1remove 1, 2 due to the first and second bits being 0.So if I use 0-7 (Binary == 000-111) I can get all subset of [1,2,3].  But I always get . No matter if I use or
The cause of your  is that you got your indices mixed up. In your nested  loops in the  function  ranges over the number of subsets and  ranges over the number of elements in the  set. But you attempt to access  when you should be doing , so when  is greater than or equal to  you will be attempting to access beyond the end of the  list, hence the . Your code can be simplified a fair bit. There's no need to muck around with the  function: you can tell  to format an integer in binary, with the desired length.outputI admit that  is a bit cryptic, so I'll try to explain it as simply as I can, freely quoting from the official Python 3 documentation for the Format String Syntax.The expression  creates a string containing the binary representation of . The created string is  characters wide, padded on the left with zeroes, if necessary.The  part is known as a format string. Format strings contain “replacement fields” surrounded by curly braces . This is a complicated example because it has a replacement field nested inside another replacement field.   In a replacement field the item immediately following the  is called the field_name. It's used to specify which argument to  is associated with this replacement field. The field_name can be the argument's name, its position, or it can be omitted (in Python 2.7 and later) and Python will just use the  arguments in numerical order when its matching them up with replacement fields.The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec (format specification), which is preceded by a colon . These specify a non-default format for the replacement value. This particular format string doesn't have a conversion field, so the default conversion is used. A format_spec ends in a letter which specifies the type of formatting we want. Our format_spec end in a  which says that we want to format an integer as binary. The number immediately preceding the  specifies how wide the resulting bit string should be; by putting a zero in front of that we're saying that we want the string to be padded with zeroes rather than with blank spaces. So a format_spec of  would give us bit strings that are 8 chars wide (or wider if necessary to properly represent the argument), with short bit strings padded with zeroes. But we need something fancier than that because we don't have a fixed bit string width - we want our bit strings to be  characters wide. But that's ok, because the format syntax allows us to put a replacement field inside another replacement field! So instead of  we have  and now the value of the argument in position 1 is used as the bit string width.I mentioned earlier that the field_name can be the argument's name, so our original format expression can also be written as:I guess this form is a bit more readable than the original. :)I also mentioned that the field_name can be omitted (in Python 2.7 and later), which would look like this:but I don't recommend doing that because although it's shorter it's even more cryptic than the original, IMHO.However, we don't really need the bit strings in : we can just use bitwise operators on the subset's index.outputThis does produce the subsets in a different order, but it's not too hard to change that, and I think this order is more natural.We can make the last version even more compact by using a nested list comprehension:FWIW, here's another way to make subsets. It's a bit inefficient, but it's ok for small input sequences. It generates the subsets in the same order as the previous version.
You are getting an error because of the following: is being accessed in the loop where  goes from  to .The solution is probably to access  instead of  since  goes from  to .


Answer URL
https://docs.python.org/3/library/string.html#format-string-syntax
