Natural Text
As of Python 3.4, there is a descriptor called .  The documentation states:Route attribute access on a class to .This is a descriptor, used to define attributes that act differently when accessed through an instance and through a class. Instance access remains normal, but access to an attribute through a class will be routed to the classâ€™s  method; this is done by raising .This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see Enum for an example).New in version 3.4.It is apparently used in the enum module:I realise that enums are a little special, but I don't understand how this relates to the .  What does it mean that those attributes are dynamic, how is this different from a normal property, and how do I use a  to my advantage?
New Version:I was a bit disappointed with the previous answer so I decided to rewrite it a bit:First have a look at the source code of  and you'll probably notice, that it looks very much like the normal . Except for the -method:So what this means is that if you want to access a  (that isn't abstract) on the class it raises an  instead of returning . For instances  evaluates to  and the  is identical to .For normal classes that just resolves in a visible  when calling the attribute:AttributeError - Traceback (most recent call last)that for itself is not very helpful until you take a look at the "Class attribute lookup" procedure when using es (I found a nice image of this in this blog). Because in case that an attribute raises an  and that class has a metaclass python looks at the  method and sees if that can resolve the attribute. To illustrate this with a minimal example:And here comes the "dynamic" part. If you call the  on the class it will search in the meta and return the meta's :which prints:So we invoked the  and returned the original attribute (which was defined with the same name as the new property).While for instances the  of the -instance is returned:we get the overriden attribute:My conclusion from this is, that  is important if you want to allow subclasses to have an attribute with the same name as used in the metaclass. You'll shadow it on instances but it's still accessible if you call it on the class.I did go into the behaviour of  in the old version so I left it in here:Old VersionThe  is just useful (I'm not really sure on that point) if you suspect there could be naming conflicts between an attribute that is set on a subclass and a property on the base-class.You'll need to know at least some basics about metaclasses, because this will not work without using metaclasses (a nice explanation on how class attributes are called can be found in this blog post) because the attribute lookup is slightly different with metaclasses.Suppose you have:and then call:property at 0x1b3d9fd19a8and on the instance we get:'Haha, overridden it with 2'bad ... it's lost. But wait we can use the  special lookup: Let's implement an  (fallback) and implement the  as . Because according to it's documentation that's its purpose - to fallback to the  if it's called on the class:now we access the class-attribute:which prints:So we invoked the  and returned the original attribute (which was defined with the same name as the new property).And for instances:we get the overriden attribute:Well that's not too bad considering we can reroute using metaclasses to previously defined but overriden attributes without creating an instance. This example is the opposite that is done with , where you define attributes on the subclass:and want to access these afterwards defined attributes by default.but you also want to allow accessing the  attribute that was defined as  (which returns which name the variable actually has):because otherwise how could you access the name of ?See the difference? Why does the second one don't return ? That's because of this use of . So you can shadow the original property but "release" it again later. This behaviour is the reverse of that shown in my example and requires at least the usage of  and . But for that you need to know how that exactly works and is explained in a lot of blogs and stackoverflow-answers that can explain it much better than I can so I'll skip going into that much depth (and I'm not sure if I could solve it in short order).Actual use-cases might be sparse but given time one can propably think of some...Very nice discussion on the documentation of : "we added it because we needed it"


Answer URL
https://docs.python.org/3/library/types.html#types.DynamicClassAttribute
https://docs.python.org/3/library/enum.html#how-are-enums-different
https://docs.python.org/3/library/types.html#types.DynamicClassAttribute
