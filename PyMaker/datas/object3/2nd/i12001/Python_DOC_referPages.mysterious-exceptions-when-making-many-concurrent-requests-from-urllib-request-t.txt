Natural Text
I am trying to do this Matasano crypto challenge that involves doing a timing attack against a server with an artificially slowed-down string comparison function. It says to use "the web framework of your choosing", but I didn't feel like installing a web framework, so I decided to use the HTTPServer class built into the  module.I came up with something that worked, but it was very slow, so I tried to speed it up using the (poorly-documented) thread pool built into . It was much faster, but I noticed something strange: if I make 8 or fewer requests concurrently, it works fine. If I have more than that, it works for a while and gives me errors at seemingly random times. The errors seem to be inconsistent and not always the same, but they usually have , , , , or  in them.Is there some limit to the number of connections the server can handle? I don't think the number of threads per se is the problem, because I wrote a simple function that did the slowed-down string comparison without running the web server, and called it with 500 simultaneous threads, and it worked fine. I don't think that simply making requests from that many threads is the problem, because I have made crawlers that used over 100 threads (all making simultaneous requests to the same website) and they worked fine. It looks like maybe the HTTPServer is not meant to reliably host production websites that get large amounts of traffic, but I am surprised that it is this easy to make it crash.I tried gradually removing stuff from my code that looked unrelated to the problem, as I usually do when I diagnose mysterious bugs like this, but that wasn't very helpful in this case. It seemed like as I was removing seemingly unrelated code, the number of connections that the server could handle gradually increased, but there was not a clear cause of the crashes.Does anyone know how to increase the number of requests I can make at once, or at least why this is happening?My code is complicated, but I came up with this simple program that demonstrates the problem:For some reason, the program above works fine unless it has over 100 threads or so, but my real code for the challenge can only handle 8 threads. If I run it with 9, I usually get connection errors, and with 10, I always get connection errors. I tried using , , and  instead of  and none of those seemed to help. I tried using a plain  object (without the ) and that just made things run very slowly and didn't fix the problem. I tried using  and that didn't fix it either.What am I supposed to do about this? I am running Python 3.5.1 on a late-2013 MacBook Pro running OS X 10.11.3.EDIT: I tried a few more things, including running the server in a process instead of a thread, as a simple , with the , and with the . None of those helped.EDIT: This problem is stranger than I thought. I tried making one script with the server, and another with lots of threads making requests, and running them in different tabs in my terminal. The process with the server ran fine, but the one making requests crashed. The exceptions were a mix of , , , , .I tried it with a dummy server like the one above, and if I limited the number of concurrent requests to 5 or fewer, it worked fine, but with 6 requests, the client process crashed. There were some errors from the server, but it kept going. The client crashed regardless of whether I was using threads or processes to make the requests. I then tried putting the slowed-down function in the server and it was able to handle 60 concurrent requests, but it crashed with 70. This seems like it may contradict the evidence that the problem is with the server.EDIT: I tried most of the things I described using  instead of  and ran into similar problems.EDIT: I am now running OS X 10.11.4 and running into the same problems.
You're using the default  backlog value, which is probably the cause of a lot of those errors. This is not the number of simultaneous clients with connection already established, but the number of clients waiting on the listen queue before the connection is established. Change your server class to:128 is a reasonable limit. You might want to check socket.SOMAXCONN or your OS somaxconn if you want to increase it further. If you still have random errors under heavy load, you should check your ulimit settings and increase if needed.I did that with your example and I got over 1000 threads running fine, so I think that should solve your problem.UpdateIf it improved but it's still crashing with 200 simultaneous clients, then I'm pretty sure your main problem was the backlog size. Be aware that your problem is not the number of concurrent clients, but the number of concurrent connection requests. A brief explanation on what that means, without going too deep into TCP internals.In this example, the socket is now accepting connections on the given port, and the  call will block until a client connects. You can have many clients trying to connect simultaneously, and depending on your application you might not be able to call  and dispatch the client connection as fast as the clients are trying to connect. Pending clients are queued, and the max size of that queue is determined by the BACKLOG value. If the queue is full, clients will fail with a Connection Refused error.Threading doesn't help, because what the ThreadingMixIn class does is to execute the  call in a separate thread, so the server can return to the mainloop and the  call.You can try increasing the backlog further, but there will be a point where that won't help because if the queue grows too large some clients will timeout before the server performs the  call.So, as I said above, your problem is the number of simultaneous connection attempts, not the number of simultaneous clients. Maybe 128 is enough for your real application, but you're getting an error on your test because you're trying to connect with all 200 threads at once and flooding the queue.Don't worry about  unless you get a  error, but if you want to increase the backlog beyond 128, do some research on . This is a good start: https://utcc.utoronto.ca/~cks/space/blog/python/AvoidSOMAXCONN
I'd say that your issue is related to some IO blocking since I've successfully executed your code on NodeJs. I also noticed that both the server and the client have trouble to work individually.But it is possible to increase the number of requests with a few modifications:Define the number of concurrent connections:http.server.HTTPServer.request_queue_size = 500Run the server in a different process:server = multiprocessing.Process(target=RunHTTPServer)  server.start()Use a connection pool on the client side to execute the requestsUse a thread pool on the server side to handle the requestsAllow the reuse of the connection on the client side by setting the schema and by using the "keep-alive" headerWith all these modifications, I managed to run the code with 500 threads without any issue. So if you want to give it a try, here is the complete code:Update 1:Increasing the request_queue_size just gives you more space to store the requests that can't be executed at the time so they can be executed later.So the longer the queue, the higher the dispersion for the response time, which is I believe the opposite of your goal here.As for ThreadingMixIn, it's not ideal since it creates and destroy a thread for every request and it's expensive. A better choice to reduce the waiting queue is to use a pool of reusable threads to handle the requests.The reason for running the server in another process is to take advantage of another CPU to reduce the execution time.For the client side using a HTTPConnectionPool was the only way I found to keep a constant flow of requests since I had some weird behaviour with urlopen while analysing the connections.
The norm is to only use as many threads as cores, hence the 8 thread requirement (including virtual cores). The threading model is the easiest to get working, but it's really a rubbish way of doing it. A better way to handle multiple connections is to use an asynchronous approach. It's more difficult though.With your threading method you could start by investigating whether the process stays open after you exit the program. This would mean that your threads aren't closing, and will obviously cause issues.Try this...That will ensure that your threads close properly. It may well happen automatically in the thread pool but it's probably worth trying anyway.


Answer URL
https://docs.python.org/3/library/http.server.html#http.server.HTTPServer
https://docs.python.org/3/library/http.server.html
https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
