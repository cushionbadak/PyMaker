Natural Text
I have a process running with  which should run forever.I can interact with that process with a ProcessIterator, which can (left out here) send data to stdin and fetch from stdout.I can access the data with .The problem is now that the execution of this async iterator must be timelimited. If the time runs out, the  function is called,but the exception does not originate out of the  function to notify of the timeout.How can I raise this exception in the async iterator?I found no way of calling  or similar for it.The usage of the async iterator is now roughly:tl;dr: How can I throw a timed exception so it originates from a async iterator?
EDIT: Added solution 2Solution 1:Can the  callback store the ProcTimeoutError exception in an instance variable?  Then  can check the instance variable and raise the exception if it is set.Solution 2:Put the exception on the process.output_queue.If there may be entries on the queue, use a priority queue.  Assign ProcTimeoutError a higher priority than the other entries, e.g., (0, ProcTimeoutError) vs (1, other_entry).
Please check out  context manager from :It is not released yet but you can copy-paste the implementation from asyncio master branch
You could use get_nowait, which will return entry or throw  immediately. Wrapping it in  loop on  with some async sleep should do the trick. Something like:And as a hint approach that is used in Tornado's Queue.get implementation with timeout:
This is the solution I came up with by now.See https://github.com/SFTtech/kevin  for the upstream  version.It also features line counting and output timeouts, which I stripped from this example.The magic function is this:When the timeout occurs, the queue fetching is aborted reliably.


Answer URL
https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue.get_nowait
