Natural Text
I want to write a script that would work a bit like hadoop streaming: I provide a random "client" program's path, and from my host python script I "pipe" strings to the client, and I want to receive the client's stdout in my python program.So for instance if I have the following python basic python client "client.py": I want, from my python host, to be able to call the executable "python client.py", provide it with the list , and then receive  as a result.Here's what I tried in my host code:However (on windows) it executes , then open a python.exe windows that remains frozen....Does anyone know how to accomplish what I'm trying to do ? should work on windows and linux ideallyedit: in my real application the amount of data to transfer to stdin is 10000s of lines of ~1K chars each, so I can't just send it all at oncethe content from stdout should be around 10000s of lines of 10 chars each
The problem is that  tries to read the entire stream, which means it waits until the subprocess terminates.  You need to determine a way to know when a character is available.   Here are some ways to do it:Read one character at a time until the return character (end-of-line) is encoutered.The sub application can send constant length outputs. You can specify the length of characters in the read method.The sub application can announce how many characters it will print.You also need a condition to tell the subprocess to end. For example, when it receives a special string.Another problem can come from buffering: data may not be transmitted immediately after a write operation.  In this case, you can use  to guarantee delivery.  I know your code above is in python3, but to avoid the problems of unicode conversions, the following programs are in python2. You should have no problems converting them to python3.Program client.pyProgram main.pyI ran the following programs on a Raspberry Pi (Rasbian) and it worked.  However, if I commented the lines with , the program jammed.These program use the first option (read one char at a time), which is probably the slowest.  You can improve speed by using the other two, at the expense of a more complicated code.
For interacting with child processes (for instance, to read 'prompts' and react to them) pexpect is the way to go:https://pexpect.readthedocs.org/en/stable/However, if you don't care about interacting "intelligently" and just want to send a bunch of lines and echo them...in client.py:and in your host file:In light of your Edit, see new hostfile below:there are also issues with using the sys.stdin method used with Popen in the client, because the input is not there when the client launches, so we need to make it block. A (very simple) exmaple:This will not work on Windows (unless someone's implement forking there and I'm not aware). I'm not sure how to do it in windows, as I spend no time there.There are significant limitations, here. Its synchronous, for one, and os.read() is not exactly high level.


Answer URL
https://docs.python.org/3/library/selectors.html
https://docs.python.org/3/library/select.html#module-select
