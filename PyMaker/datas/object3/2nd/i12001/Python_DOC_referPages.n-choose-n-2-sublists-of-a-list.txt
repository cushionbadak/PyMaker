Natural Text
Is there an efficient way in Python to get all partitions of a list of size  into two subsets of size ? I want to get some iterative construct such that each iteration provides two non-overlapping subsets of the original list, each subset having size .For example:The subsets should be non-overlapping, e.g.  is valid but  is not.  The order of the two subsets does not matter, e.g.  does not count as different from  and thus only one of those two should appear in an iteration. The order within each subset also does not matter, so , , , etc. all count as the same and so only one of them should show up in whole iteration.
Here's an -based generator that I think yields exactly the values you want.I avoid near-duplicate outputs in two ways as compared to a  based approach in Suever's answer. First, I avoid yielding both  and  by forcing all the results to have the first value of the input sequence in the first sublist. I avoid yielding  and  by building the second sublist using set-subtraction.Note that yielding nested tuples might be a little more natural than nested lists. To do that, just change the last line to:
You will want to use  to do this. The inputs are the list you want to select items out of and the second is the number of items to select.For an input of  this yieldsAs @ShadowRanger pointed out, if order matters in your lists and you want all permutations, you'll want to substitute  into the solution.EditUpon reading your question closer it is unclear if you want all  permutations like I have shown or you want a list of lits where each element is yet another list of the two "halves" of the permutation.To accomplish this, you could do the following (incorporating some indexing help from @Blckknght)In this case, the output of  would beEdit2Since order doesn't matter but you want an approach similar to the last one (lists of lists of lists), that's a little tricky with the last approach because of the array slicing. One alternative is to use  and  to construct the initial information (rather than lists), because in a  the ordering doesn't matter when checking for equality. This will automatically allow us to remove duplicates. We can then add an extra step to convert back to a list if that's what you prefer.This will yield
Here's a solution which doesn't use itertools. It uses a trick called Gosper's hack to generate bit permutations. See HAKMEM Item 175 for an explanation of how it works; this hack is also mentioned in the Wikipedia article Combinatorial number system. And it features in the accepted answer to this SO question: Iterating over all subsets of a given size.The  function is a generator, so you can use it in a  loop, as illustrated in my test.How it works.To partiton a list of length n into pairs of sublists of length n/2 we use a binary number  consisting of n/2 zero bits and n/2 one bits. A zero bit in a given position indicates that the corresponding list element goes into the left sublist, a one bit in a given position indicates that the corresponding list element goes into the right sublist. Initially,  is set to , so if n = 6,  starts out as .The generator uses Gosper's hack to permute  in numerical order, stopping when we get a one bit in the highest position, since that's when we start getting the reversed versions of our sublist pairs.The code responsible for converting the pattern in  into the pair of sublists is:If there's a zero at bit position  in  then  gets the current item from , otherwise it's appended to . This code runs on Python 2 and Python 3.outputI admit that using something inscrutable like Gosper's hack isn't exactly Pythonic. :) Here's how you capture the output of  into a list of all the sublists. It also illustrates that  can handle string input, although it produces the output as lists of strings.outputHere's another solution, using itertools to generate the combinations. It generates the pairs in a different order to the earlier version. However, it's shorter and easier to read. More importantly, it's significantly faster, between 50 to 100 percent faster in my  tests, depending on the list length; the difference appears to get smaller for longer lists.output
Since none of the orders matter, but we're making a list of lists of lists (where order inherently matters), we can assume some invariants: in all pairs, the first element in the first pair is 1, and both lists in a pair are in sorted order.
Here's some code that performs  tests on the various solutions to this problem.To make the comparisons fair, I've commented out the argument-checking test in my functions.I've also added a function  that combines features of my combinations-based answer with that of Blckknght. It appears to be the fastest, except for very small lists.outputsThese tests were performed on a 2GHz single-core machine with 2 GB of RAM running Python 2.6.6.


Answer URL
https://docs.python.org/3/library/timeit.html?#module-timeit
