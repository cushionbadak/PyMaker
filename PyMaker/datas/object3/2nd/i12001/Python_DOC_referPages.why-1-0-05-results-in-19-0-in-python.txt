Natural Text
I'm a new to python and I found a confusing result when using Python3.5.1 on my mac, I simply ran this command in my terminal However, it printed 19.0 on my screen. From my point of view, it should be 20. Can someone explain what's happening here? I've already known that the '//' is similar to the math.floor() function. But I still can't get across to this.
Because the Python floating-point literal  represents a number very slightly larger than the mathematical value 0.05. is floor division, meaning that the result is the largest integer  such that  times the divisor is less than or equal to the dividend. Since 20 times 0.05000000000000000277555756156289135105907917022705078125 is larger than 1, this means the correct result is 19.As for why the Python literal  doesn't represent the number 0.05, as well as many other things about floating point, see What Every Computer Scientist Should Know About Floating-Point Arithmetic
0.05 is not exactly representable in floating point.  shows that 0.05 is stored as a value very slightly greater than the exact value:On the other hand  does appear to be exactly 20:However all floating point values are rounded to double when stored but calculations are done to a higher precision. In this case it seems the floor operation performed by  is done at full internal precision hence it is rounded down.
As the previous answerers have correctly pointed out, the fraction 0.05 = 1/20 cannot be exactly represented with a finite number of base-two digits.  It works out to the repeating fraction 0.0000 1100 1100 1100... (much like 1/3 = 0.333... in familiar base-ten).But this is not quite a complete answer to your question, because there's another bit of weirdness going on here:Using the “true division” operator  happens to give the expected answer . You got lucky here: The rounding error in the division exactly cancels out the error in representing the value 0.05 itself.But how come  returns 19?  Isn't  supposed to be the same as ?  Why the inconsistency between  and ?Note that the  function is consistent with the  operator:This behavior can be explained by performing computing the floating-point division with exact rational arithmetic.  When you write the literal  in Python (on an IEEE 754-compliant platform), the actual value represented is 3602879701896397 / 72057594037927936 = 0.05000000000000000277555756156289135105907917022705078125.  This value happens to be slightly more than the intended 0.05, which means that its reciprocal will be slightly less.To be precise, 72057594037927936 / 3602879701896397 = 19.999999999999998889776975374843521206126552300723564152465244707437044687...So,  and  see an integer quotient of 19.  The remainder works out to 0.04999999999999994726440633030506432987749576568603515625, which is rounded for display as .  So, the  answer above is in fact good to 53-bit accuracy, given the original incorrect value of .But what about ?  Well, the true quotient 72057594037927936 / 3602879701896397 isn't representable as a , so it must be rounded, either down to  (an error of about 2.44e-15) or up to  (an error of about 1.11e-15).  And Python correctly picks the more accurate choice, .So, it seems that Python's floating-point division is internally done with high enough precision to know that  (that's the  literal , not the exact decimal fraction 0.05), is actually less than 20, but the  type in itself is incapable of representing the difference.At this point you may be thinking “So what?  I don't care that Python is giving a correct reciprocal to an incorrect value.  I want to know how to get the correct value in the first place.”  And the answer to that is either: (and don't forget the quotes!) (Of course, you may also use the numerator-denominator arguments as , which is useful if you need to deal with non-decimal fractions like 1/3.)


Answer URL
https://docs.python.org/3/library/decimal.html
https://docs.python.org/3/library/fractions.html
