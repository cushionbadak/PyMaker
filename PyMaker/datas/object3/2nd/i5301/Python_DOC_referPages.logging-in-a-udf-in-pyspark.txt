Natural Text
What is the correct way to access the log4j logger of Spark using pyspark on an executor?It's easy to do so in the driver but I cannot seem to understand how to access the logging functionalities on the executor so that I can log locally and let YARN collect the local logs.Is there any way to access the local logger?The standard logging procedure is not enough because I cannot access the spark context from the executor.
You cannot use local log4j logger on executors. Python workers spawned by executors jvms has no "callback" connection to the java, they just receive commands. But there is a way to log from executors using standard python logging and capture them by YARN. On you HDFS place python module file that configures logging once per python worker and proxies logging functions (name it ):Then import this module inside your application:And you can use in inside your pyspark functions like normal logging library:The  will be visible on resource manager and will be collected on application finish, so you can access these logs later with .
Note that Mariusz's answer returns a proxy to the logging module. This works (upvoted) when your logging demands are very basic. Once you're interested in doing things like configuring multiple logger instances or using multiple handlers, it will be lacking. E.g. if you have a larger set of code that you only want to run when debugging, one of the solutions would be to check a logger instance's  method, like so:This would fail when the method is called on the logging module, like in Mariusz's answer, because the logging module does not have such an attribute.One way to solve this would be to create a  module in which you configure the logging and return a new instance of . The code below shows an example of this, which configures logging using . It also adds a filter so that the number of repetitions from all the worker nodes is greatly reduced when using the root logger (filter example is from Christopher Dunn (ref)).You could then import this module and alias it for  itself:Like with Mariusz's answer, logs will be accessible using the resource manager (or dumped in your temp-folder when  is not in your environment variables).The error handling done at the top of this script is added so that you could run this script locally. This approach allows more freedom: you could have the executors log to one file and all kinds of aggregation counts on the drive in another file.Note that there is slightly more work to be done in this case, compared to using a class as a proxy for the built-in logging module, as each time you request a logger on the executor instances, it will have to be configured. That likely won't be your main time-hog when doing big data analytics though. ;-) 
I have yet another approach to solve logging issue in PySpark. Idea is as follows:Use remote log management service (For example Loggly, CloudWatch on AWS, Application Insights on Azure etc)Configure logging module in both master node and worker nodes using same configuration to send logs to above sevicesThis is good approach if you are already using cloud services as many of them also have log collection/management services.I have a simple wordcount example on Github to demonstrate this approach https://github.com/chhantyal/wordcountThis Spark app sends logs to Loggly using standard  module from driver (master node) as well as executors (worker nodes).


Answer URL
https://docs.python.org/3/library/logging.html?highlight=logging#logging.Logger.isEnabledFor
