Natural Text
I am looking for a memory/cpu efficient one-liner to subsample n out of every m elements on a list. So far I have got:Breaking it down I am creating a list of sample lists and then flattening it to a one dimensional list with Alternatively, not a one liner, but easier to read, I can do:Both solutions look way too convoluted when compared, for example, with the super simple shorthand for  particular case: .Can you help me come up with a decent solution?
I moved most of the indexing into a  computation. Its faster then manifesting the indexes into a sublist - see timing down below:Output:I moved most of the work into the  call - producing list of sublists, the rest is a simple decomposition of the sublists into one list.Timing:
The following seems fairly readable to me (and is also fairly efficient):
I advise to use more clear variable names instead of comments and not to use one-liners.GivenCodeUsing the  itertools recipe:As a one-liner, it looks as follows:DetailsThe  recipe is implemented as follows:See also the  third-party library for pre-implemented recipes.
Code:Output:I recommend setting  to 0 based index to match python's syntax, but if you insist, it's simple to update the func, just replace all the  with .It's essentially the same idea as your original approach, just a bit cleaner, and it can scale to different ,  and .


Answer URL
https://docs.python.org/3/library/itertools.html#itertools-recipes
https://docs.python.org/3/reference/expressions.html#generator-expressions
