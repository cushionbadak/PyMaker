Natural Text
I need to filter rows in a  dataframe so that a specific string column contains at least one of a list of provided substrings. The substrings may have unusual / regex characters. The comparison should not involve regex and is case insensitive.For example:I currently apply the mask like this:My dataframe is large (~1mio rows) and  has length 100. Is there a more efficient way? For example, if the first item in  is found, we should not have to test any subsequent strings for that row.
If you're sticking to using pure-pandas, for both performance and practicality I think you should use regex for this task. However, you will need to properly escape any special characters in the substrings first to ensure that they are matched literally (and not used as regex meta characters).This is easy to do using :These escaped substrings can then be joined using a regex pipe . Each of the substrings can be checked against a string until one matches (or they have all been tested). The masking stage then becomes a single low-level loop through the rows:Here's a simple setup to get a sense of performance:The proposed method takes about 1 second (so maybe up to 20 seconds for 1 million rows):The method in the question took approximately 5 seconds using the same input data. It's worth noting that these times are 'worst case' in the sense that there were no matches (so all substrings were checked). If there are matches than the timing will improve. 
You could try using the Aho-Corasick algorithm. In the average case, it is  where  is length of the search strings and  is the length of the searched text and  is the number of output matches.The Aho-Corasick algorithm is often used to find multiple patterns (needles) in an input text (the haystack).pyahocorasick is a Python wrapper around a C implementation of the algorithm.Let's compare how fast it is versus some alternatives. Below is a benchmarkshowing  to be over 30x faster than the original method(shown in the question) on a 50K-row DataFrame test case:Here the setup used for the benchmark. It also verifies that the output matches the result returned by :
Using a simpler example  & ignore case (upper or lowercase)Filtering and getting a binary vector:I want to find all elements of a , , that contain "at" or "Og". And get 1 if the element contains the pattern or 0 if it doesn't.I'll use the  :My vector:I want to find all elements of v that contain "at" or "Og". This is, I can define my  as:Since I want a vector with 1s if the item contains the pattern or 0 if don't.I create an unitary vector with the same length as v:I obtain a boolenean  that is if one element of contains the or if it doesn't contain it.To obtain the binary vector I multiply the *:


Answer URL
https://docs.python.org/3/library/re.html#re.escape
