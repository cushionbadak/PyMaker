Natural Text
I have a service running on a Linux box that creates a named pipe character device-special file, and I want to write a Python3 program that communicates with the service by writing text commands and reading text replies from the pipe device.  I don't have source code for the service.I can use , and I can use  and  to read and write it, but that's a pain because I have to write my own code to convert between bytes and strings, I have to write my own  function, etc.I would much rather use a Python3  object to read and write the pipe device, but every way I can think to create one returns the same error:For example, I get that message if I try , and I get that same message if I try  followed by .Q: What is the preferred way for a Python3 program to write and read text to and from a named pipe character device?Edit:Oops! I assumed that I was dealing with a named pipe because documentation for the service describes it as a "pipe" and, because it doesn't appear in the file system until the user-mode service runs.  But, the Linux  utility says it is in fact, a character device special file.
The problem occurs because attempting to use  in read-write mode implicitly tries to wrap the underlying file in  (which is then wrapped in  if in text mode), which assumes the underlying file is not only read/write, but random access, and it takes liberties (seeking implicitly) based on this. There is a separate class, , intended for use with read/write pipes (the docstring specifically mentions it being used for sockets and two way pipes). You can mimic the effects of  by manually wrapping layer by layer to produce the same end result. Specifically, for a text mode wrapper, you'd do something like:I believe this will close  twice when  is closed, but luckily, double-close is harmless here (the second  does nothing, realizing it's already closed).
SolutionYou can use . Here is an example using two python modules:caller.pybackwards.pyExplanation is using a "Pseudo-TTY device" to talk to . We are providing input with  and capturing input with  (and the  attribute).
It looks like you need to create separate handles for reading and for writing: to open read/write just requires a seek method. I couldn't figure out how to timeout reading, so it's nice to add an opener (see the docstring for ) that opens the reader in non-blocking mode. I set up a simple echo service on a named pipe called :


Answer URL
https://docs.python.org/3/library/io.html#io.BufferedRWPair
