Natural Text
How do I register class methods with a decorator and use inheritance at the same time.  I've found a lot of semi-helpful posts/tutorials online, however, I haven't been able to find exactly what I'm looking for. In the process, I think I've confused myself (class decorators vs metaclasses).  Here's the expected operation of what I am hoping to build. (FYI using Python 3.6)EDIT:Here is what I have actually tried (originally omitted to try and keep the post size down)In this attempt, I tried to use a class decorator.  I was hoping to use the  function as a decorator for the class methods to add a attribute to the method.  My understanding is that everything in Python is an object (even functions) so adding an arbitrary attribute should be do-able.  My thought was to then use the class decorator () to add a  attribute of the class that would then contain a list of method names that were "tagged". This obviously does not work as I intended. The added attribute to class methods is not "seen" by the class decorator.  In this attempt I tried to use a MetaClass.  Similar to the last approach, the idea was to add an attribute to the class method and then use that as a key for building the list of "tagged" methods.  This didn't work either as I ran into what I think is the same fundamental issue as before where the attribute added to the function is not maintained. To start with, I was trying to shy away from this method because it required a global variable ().  I'm hoping to find a cleaner solution. I dislike both the metaclass and class decorator approaches (provided that they even work) because they require some operator by the child class (either the decorator or explicitly adding the metaclass value).  I would ideally like to have a clean and simple solution wherein the child object does not need to have any special configuration outside of inheriting the parent class. 
As I mentioned in the comments, you are basically on the right track. You have a decorator  that marks your attributes for addition to the list. Either a metaclass or a class decorator is a perfectly valid tool to compile the list and add it to your class as an attribute.There are two main problems with your implementation.You seem to have a misunderstanding of how function decorators work (which is strange given that you seem to understand class decorators perfectly, but totally understandable because I too have read the same misleading tutorials). As with class decorators, function decorators can return anything at all, not necessarily the nested function that is so often given in examples. For example,  returns a data descriptor that is not even callable!Remember that the result of the decorator replaces whatever the input was. So in your current implementation, you start with some function that returns a property value. You then replace it with a function of no arguments that sets an attribute on the original function object. But the original function object is basically discarded and can't be called. That makes no sense. What you probably want is a function that sets an attribute on the original function and just returns that original function, so it does not get replaced:You can't decorate a property in the way you are thinking. The  decorator does not return a function. It returns an immutable object, and you can not set an attribute on it (except changing the docstring as of Py3.6). The reason that your code did not fail with an  is that your  decorator does not do what you think it does.A possible solution for this to apply  before applying  (given the version of  shown above). Now, instead of checking if each "method" is , you have to also check if the "method" is really a property object, and check if it's  attribute is . Alternatively, you can check if the input to  is a , and tag the  attribute instead of the property itself. This will make your decorators order-independent again.Fixing these two problems will give you the tagged items in each child class. It will not, however, give you the complete list including the parent classes. Luckily, the parents of your class object are fully known for both a class decorator and a metaclass, so you can create a complete list based on simple inheritance.Before showing code, I also want to mention something about metaclasses vs. decorators for your code. Functionally, there will not be much difference between the two in the sense that they both look up attributes with  set and fill in a list on the class. There is going to be a usage difference though. You will only have to set the metaclass once for the parent to get the same behavior for all the children because the type of the parent is generally the type of the subclass (you do not need to have  in all your child classes). A decorator would have to be applied to every child individually. I can see pros and cons for both approaches, so I will show both.Using Class DecoratorsResults inThere is a slight conceptual disconnect here, because the decorator needs to be applied to every child to gather the data, but only the parent needs to have a  property for it to work on all children.Using a MetaclassResults in:Another thing to keep in mind is that in the metaclass option, you have the MRO option available up front. You can therefore construct a complete list of tags right there and then. I do not like redundant information because it usually ends up being a maintenance burden. A better alternative would be to define the property in the metaclass, and assign it to each child you create as a bonus.UpdateIn fact, my last suggestion makes the metaclass option objectively better because it allows you to circumvent explicitly using MRO, instead delegating the resolution to , as you should:Now none of the classes need to explicitly define a  property at all.
The main issue with your two attempted implementations is that your  decorator isn't working the way you intend. For a simple decorator that doesn't need to be passed any arguments (like ) and returns the original function, you don't need a nested function at all:You still have a problem though, since not all objects allow you to set arbitrary attributes on them. Functions do, but instances of  do not.One way to work around that for that would be to change the order of the decorators on your property methods, so that  gets applied first (on the function, where it will work), and the  decorator applies afterwards. Then you'd just need to check each  in the class to see if it's  is tagged later on.Now to address the question of how best to gather up the list of tagged methods. Either of the approaches you tried can be made to work with just a little tweaking (such as looking inside of  instances to see the tag on the getter). But another option would be to make the  method in the  class do all the work. This might be slow the first time you checked for tags, but you could cache the result for later calls:If you want to go with metaclasses, you don't need to worry about every class needing the  declaration. Metaclasses are inherited, you only need to explicitly declare the metaclass in . All classes that inherit from  will use it's metaclass too. The only downside to this is that they can't declare some other metaclass of their own, as you'll get a metaclass conflict (though you might be able to work around it by making the other metaclass inherit from  or even creating a new metaclass that inherits from both  and the other desired metaclass).


Answer URL
https://docs.python.org/3/library/functions.html#property
