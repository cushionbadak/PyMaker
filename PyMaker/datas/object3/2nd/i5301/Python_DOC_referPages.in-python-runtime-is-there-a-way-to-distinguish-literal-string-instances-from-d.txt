Natural Text
In Python runtime, is there a way to distinguish literal string instances from dynamically created ones?For example, I want to be able to tell the difference between these two values:An example use case for this check is to protect a -like function from any attacks, like exposing value of local variables.If it's not possible, is there any good reason for it?And a side note...PEP 498 -- Literal String Interpolation introduces f-strings, which are string literals which may split into literals and expressions at tokenization time.F-strings work fairly similar to , but has the enforcement of the input being a literal string, at the cost of syntax update for the language.If this kind of check has been available on runtime, f-strings could have been implemented as a function.Update 1As noted by @kevin in his answer, CPython has optimizations that allows it to reuse existing instances when there's no need to create new ones. In my first example,  is skipped with just linking to existing  instance.But that's not a language requirement, and in fact doesn't always happen. Any string formatting other than some obvious ones would result in creation of a new instance.In the following example, you can see that although the strings are equal by value, they are not the same object. Using  would give us the same instance, though.As documented in , "Normally, the names used in Python programs are automatically interned, and the dictionaries used to hold module, class or instance attributes have interned keys." In other words, normally, runtime string instances are not interned.
No, you can't do that.  Or at least, you can't do it at runtime.  If you're willing to accept the limitations of compile-time analysis, you can parse and examine Python code with , but that is probably a far more involved tool than what you are looking for, and certainly will not allow you to "implement f-strings as a function."For the specific case of your example, the Python language specification permits  and  to both point to the same object (and they definitely will if you pass both of them through the  function and compare the results).  Since a conforming Python implementation could alias them, there is no reliable way to tell them apart.  In fact, when I tried it in CPython 3.6.1, they were aliased:Output:Notice that it didn't even waste time computing .  It got constant-folded into the literal value , which was then deduplicated with the other  which the function was already using for .(A more aggressive optimizer could have then propagated those constants and converted  into , but CPython does not do that (yet?), probably because it is rare to use  for immuntable values like strings.  Most of the other operations which could plausibly benefit from constant propagation are subject to various kinds of monkey patching, which prevents this optimization in the vast majority of real-world use cases.  As such, I presume that it is not worth implementing.)If it's not possible, is there any good reason for it?Because Python, like most imperative languages, uses eager evaluation, which throws this information away immediately.  With a lazy-evaluated language, this question would at least be reasonable to ask, but I don't believe most of them preserve this information either.  The question of whether a string is literal or non-literal simply isn't considered a part of the string's value, in most programming languages that deal with strings.


Answer URL
https://docs.python.org/3/library/sys.html#sys.intern
https://docs.python.org/3/library/sys.html#sys.intern
https://docs.python.org/3/library/ast.html
https://docs.python.org/3/library/sys.html#sys.intern
