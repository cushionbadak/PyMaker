Natural Text
Surprisingly, there's no explicit documentation for . Weak references are explained here.  is also shortly mentioned in the documentation of . But I could not find anything about  itself.What exactly is ?- Is it just a member acting as a flag: If present, the object may be weakly-referenced?- Or is it a function/variable that can be overridden/assigned to get a desired behavior? How?
 is just an opaque object that references all the weak references to the current object. In actual fact it's an instance of  (or sometimes ) which is both a weak reference to the object and part of a doubly linked list to all weak references for that object. It's just an implementation detail that allows the garbage collector to inform weak references that its referent has been collected, and to not allow access to its underlying pointer anymore. The weak reference can't rely on checking the reference count of the object it refers to. This is because that memory may have been reclaimed and is now being used by another object. Best case scenario the VM will crash, worst case the weak reference will allow access to an object it wasn't originally referring to. This is why the garbage collector must inform the weak reference its referent is no longer valid.See weakrefobject.h for the structure and C-API for this object. And the implementation detail is here
[Edit 1: Explain the linked list nature and when weakrefs are re-used]Interestingly enough, the official documentation is somewhat non-enlightening on this topic:Without a  variable for each instance, classes defining  do not support weak references to its instances. If weak reference support is needed, then add  to the sequence of strings in the  declaration.The  object documentation on the topic does not seem to help things along too much:When a type’s  declaration contains a slot named , that slot becomes the weak reference list head for instances of the type, and the slot’s offset is stored in the type’s .Weak references form a linked list. The head of that list (the first weak reference to an object) is available via . Weakrefs are re-used whenever possible, so the list (not a Python list!) typically is either empty or contains a single element.Example:When you first use , you create a new weak reference chain for the target object. The head of this chain is the new weakref and gets stored in the target object's :As we can see,  is re-used. We can force python to create a new weakref, by e.g. adding a callback parameter:Now , and  is the second reference in the chain. The reference chain is not directly accessible from Python code. We see only the head element of the chain (), but not how the chain continues ( -> ).So  is the head of the internal linked list of all the weak references to the object. I cannot find any piece of official documentation where this role of  is concisely explained, so one should probably not rely on this behavior, as it is an implementation detail.
The  variable is an attribute which makes the object to support the weak references and preserving the weak references to object.The python documentation has explained it as following:when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else.Therefore, the duty of weak references is supplying the conditions for an object in order to be able to be garbage collected regardless of its type and the scope.And about the , we can first look into the documentation, which explains it very well:By default, instances of classes have a dictionary for attribute storage. This wastes space for objects having very few instance variables. The space consumption can become acute when creating large numbers of instances.The default can be overridden by defining  in a class definition. The  declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because  is not created for each instance.Now, since by using  you will control the demanded storage for your attribute, it actually prevents the automatic creation of  and  for each instance. Which the  is the necessary variable of each object in order to be able to deal with weak references.Also, in addition to all these the documentation for  class says:This class variable can be assigned a string, iterable, or sequence of strings with variable names used by instances.  reserves space for the declared variables and prevents the automatic creation of  and  for each instance.So, In a nutshell, we can conclude that  are for managing the storage allocation manually and since  is the license of accepting the weak references for objects which is related to storage (because of the ability of being garbage collected), therefore  will control the  as well as controlling the  attribute.Also documentation has shown you the way of making an object to support the weak references along side of using :Without a  variable for each instance, classes defining  do not support weak references to its instances. If weak reference support is needed, then add  to the sequence of strings in the  declaration.Here is an example in python 3.X:But in python 2.7 there, although the documentation is like the aforementioned docs, creating a weak reference from instances that doesn't provide the  variable in their  names doesn't raise a :


Answer URL
https://docs.python.org/3/reference/datamodel.html#slots
https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_weaklistoffset
