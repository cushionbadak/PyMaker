Natural Text
I have a class, shown below, that inherits from When I  (or ) an instance of this class, as shown below,I get the following outputSo clearly some  object is passed as the first argument when doing a  (or ). I know that the  function works by passing arguments to the constructor of the object in question such that an identical object will be created...so why is it passing these  objects?This behaviour seems to occur only when inheriting from immutable objects, since when I tested this when inheriting from a  object, the  function did not pass a  object.(Note that the class I defined above is a very (very!) simplified case of a real class I am using, that also inherits from )Thanks in advanceNOTEI am using Python 3.5.1
The reason this happens is because internally  and  make use of  to facilitate object state serialisation. From the docs:This module does not copy types like module, method, stack trace, stack frame, file, socket, window, array, or any similar types. It does “copy” functions and classes (shallow and deeply), by returning the original object unchanged; this is compatible with the way these are treated by the pickle module. ...In fact, the  module uses the registered  functions from the  module.Why does  need to ? Because:A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.To do that, though,  needs to be able to understand the object hierarchy. Pickling is designed to solve that problem by mapping a hierarchy to a standard serialised format. This also is where the byte objects come from. “Pickling” is the process whereby a Python object hierarchy is converted into a byte stream, and “unpickling” is the inverse operation, whereby a byte stream (from a binary file or bytes-like object) is converted back into an object hierarchy.It would appear that, for whatever reason (maybe  implements  in a special way?), the unpickling isn't reproducing the integer argument passed to . Why? I have no earthly idea. Poke around a little bit and see what you can dig up. The SolutionThe docs also make it pretty clear what to do if  or  are misbehaving for you - define your own copy implementation!In order for a class to define its own copy implementation, it can define special methods  and . The former is called to implement the shallow copy operation; no additional arguments are passed. The latter is called to implement the deep copy operation; it is passed one argument, the memo dictionary. If the  implementation needs to make a deep copy of a component, it should call the  function with the component as first argument and the memo dictionary as second argument.


Answer URL
https://docs.python.org/3/library/copy.html
