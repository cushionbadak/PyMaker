Natural Text
I have a program where I am currently using a concurrent.futures.ThreadPoolExecutor to run multiple tasks concurrently. These tasks are typically I/O bound, involving access to local databases and remote REST APIs. However, these tasks could themselves be split into subtasks, which would also benefit from concurrency. What I am hoping is that it is safe to use a concurrent.futures.ThreadPoolExecutor within the tasks. I have coded up a toy example, which seems to work:Although this toy example seems to work, I'd like some confidence that this is intentional. I would hope it is, because otherwise it would not be safe to use the executor to execute arbitrary code, in case it also used concurrent.futures to exploit concurrency.
There is absolutely no issue with spawning threads from other threads. Your case is no different.Sooner or later though, the overhead of spawning threads will be quite high, and spawning more threads will actually cause your software to slow down.I highly suggest using a library like asyncio which beautifully handles tasks asynchronously. It does so by using one thread with non-blocking io. The results will probably be even faster than with normal threads, as the overhead is much less significant. If you do not wish to use asyncio, why not create another pool executor inside main, and pass it on to the  function? This way, instead of 25 (5x5) threads, you will have a maximum of 10 (2x5) which is much more reasonable?You cannot pass the same  executor which calls  to  as it might cause a deadlock (by each  waiting for another  to finish before they can schedule ).


Answer URL
https://docs.python.org/3/library/asyncio.html
