Natural Text
EDIT: This question is about why the behavior is what it is, not how to get around it, which is what the alleged duplicate is about.I've used the following notation to create lists of a certain size in different cases. For example:This appears to work as expected and is shorter than:I then tried to create an list of lists using the same approach:Fair enough. It seems to work as expected.However, while going through the debugger, I noticed that all the sub-list buckets had the same value, even though I had added only a single item. For example:I was not expecting all top-level array elements to be references to a single sub-list; I expected 5 independent sub-lists.For that, I had to write code like so:I'm clearly missing something, probably a historical fact or simply a different way in which the consistency here is viewed.Can someone explain why two different code snippets that one would reasonably expect to be equivalent to each other actually end up implicitly producing different and non-obvious (IMO) results, especially given Python's zen of always being explicit and obvious?Please note that I'm already aware of this question, which is different to what I'm asking.I'm simply looking for a detailed explanation/justification. If there're historical, technical, and/or theoretical reasons for this behavior, then please be sure to include a reference or two.
When you do the following:You are first creating a list, then using the  operator with an  . This takes whatever objects are in your list, and creates n- many repetitions of it. But since in Python, explicit is better than implicit, you don't implicitly make a copy of those objects. Indeed, this is consistent with the semantics of Python. Try to name a single case where Python implicitly makes a copy.Furthermore, it is consistent with the addition on the list:And the output:Now, as noted in the comments, coming from C++ it makes sense that the above would be surprising, but if one is used to Python, the above is what one would expect.On the other hand:Is a list comprehension. It is equivalent to:Here, clearly, every time you are in the loop you create a new list. That is how literal syntax works.As an aside, I almost never use the  operator on lists, except for one particular idiom I am fond of:
For cpython, the relevant part of the source code is in the function  in listobject.c. An enlightening snippet is repeated below, with my added comments:Since a  is mainly a  containing a list of pointers to the list elements, it is simple to assign these points as elements to the new . On the contrary, imagine the code if the object located at each pointer needed to be copied. It would be more complex and there would be a noticable performance hit. However, I'm not going to speculate in regards to the motivation of this design decision.


Answer URL
https://docs.python.org/3/library/copy.html
