Natural Text
I am curious how often a file would actually be loaded into memory when its needed from a module.  Here is the scenario:lookup.pymain.pySo my question is how many times is mapping_dict from lookup.py loaded?  Once upon the initial import?  Every time map_file is called? Every time any function in lookup.py is called (map_file and other_function in this case).Some combination of the above? 
I'm not sure if the other answers are terribly clear about this, so let me post something else that may (or may not) help. Here is what effectively happens, under normal circumstances, when you import a module:Python looks in  (which is basically a ) for an entry with the name of the module being imported. If it finds something, it takes that object, creates a variable corresponding to the module's name, and assigns the object to the variable.If it doesn't find an object in , it creates an object to represent that module and puts it in  under the appropriate name. Then it looks up the file that contains the module's source code, runs that file as a Python script (ish), and then scoops up all the variable definitions that exist afterward and assigns them as attributes of the new module object.Note that this means the code in the file only gets executed once, when the module is first imported.Let's see how this works in practice, in your example. Python is happily running the code in  and it encounters"OK (says Python), let's go to  and see if anything is stored under the name . [...checking...] No, there is nothing stored under that name. Time to find  (using )."Python creates a new, empty module object and puts it in  under the name . Then it opens the file  and starts running code from it.Python now looks in  under the name . It will go through this whole procedure recursively, but I'll skip going into details and just jump ahead to where we have a fully loaded module object in  under the key . Then Python assigns that object to the name  in the current scope (effectively, it does ).Python now loads the JSON file. I'm skipping over most of the details, but it involves accessing the  variable in the current scope (which, remember, refers to a module object) and taking the  attribute of that object, and then calling it. The thing that comes out of that call gets put into another variable in the current scope, .Python now sees  and temporarily stops executing; instead, it reads a block of code, compiles it into bytecode, and sticks that bytecode into a function object. That function object gets assigned to the variable  in the current scope. Then, back to executing.Again, Python stops executing and reads a block of code, compiles it into bytecode, and sticks that bytecode into a function object which gets assigned to the variable .Now we are at the end of the file . We have four variables in the current scope: , , , and . Python assigns these four variables as attributes of the module object. Remember, the module object is stored in  under the key , so now  is an object with the four attributes , , , and .Time to go back to , where we are still finishing up the  statement. The last thing this statement does is to assign the value of  to a variable in the current scope called . (Effectively, .) Again, that object has four attributes, as previously described.Moving on toOn each iteration through that loop, Python accesses the  variable, which refers to a module object, then accesses the  attribute of that object, which is a function object that basically just contains a bunch of bytecode. Python then calls the function object, which actually executes the bytecode - and remember, this is the code that was inside the  definition, which was not executed at the time the  module was loaded. Only now does it get executed.All that code does is access  and return it.  is simply a variable that refers to an existing object; presumably a . So accessing  simply checks in the  to see if it has an entry with key corresponding to the value of , and if so, returns it. Accessing this entry doesn't open any files or do anything complicated. In particular, it does not run , because that bit of code is not part of the function. That bit of code was run long ago, when  was imported, and was not saved for running again, so it will not run again under normal circumstances.
Each module is loaded only once. The import statement first checks if the module exists in , if it is, it just performs a dictionary lookup. If the item is not found, it loads the module. You can force module re-importation using  (Python-2 only) or by deleting the entry in  (this is a bit of a hack).Please note that reloading a given module will not reload any of the libraries it imports (Python2-only below, in Python3, you can use importlib.reload):
As answered in the comments, but I'll expand a bit on it to really show why.The question is, how many times do we load the JSON file (line 3 from )When  is imported, assuming there is no  guard around it,  (an object) is set to the contents of the json file. As well, the functions defined are each set assigned to a function object. You can test this by typing the function name without the parentheses at the end. You should see a memory pointer corresponding to the objectFrom there on, unless lookup.py is re-imported, mapping_dict is never reassigned or updated. Referencing the functions references the objects they were assigned to.


Answer URL
https://docs.python.org/3/library/importlib.html
