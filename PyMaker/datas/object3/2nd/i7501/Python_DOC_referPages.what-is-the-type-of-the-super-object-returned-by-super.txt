Natural Text
From here:Return a proxy object that delegates method calls to a parent or sibling class of . This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by  except that the  itself is skipped.If the second argument is omitted, the super object returned is  unbound. If the second argument is an object,  must be  true. If the second argument is a type,  must be  true (this is useful for classmethods).If I am correct, a type is a class, and a class is a type. A classis an object, so a type is also an object.  Why does the quotedistinguish the two cases when the second argument being an object when it is a type?When the second argument is a type, why is required to be true?What is the type of the super object    returned by  in each of the three cases respectively? Or how do you determine the type of the super object returned by ?When the second argument is an object, because "The search order is same as that used by  except that the  itself is skipped", I guessed that the type of the superobject returned by  function should be a subclass of any ancestry class of the first argument , but I found that it is actually not by testing with . So did I misunderstand something?
You seem to be confusing the word  with the  built-in. Here they simply references the first argument passed into .What the documentation tells you is that if you pass in two arguments, then the second argument either has to be an instance of the first argument, or it has to be a subclass. In other words, either  or  must be true. There is no other meaning here.Just like  or  or any of the other built-in types, the type of the object returned by calling  is that type. There are no separate types returned for different arguments. See the C source code defining the object.The  object implements a  hook that implements specific attribute behaviour. The documentation tells you that the rules for attribute lookups are the same as for  (but with the documented MRO skip), but that does not mean that  returns an ancestor class.What actually happens is that  takes the MRO of the second argument (either  or , depending on wether  or  was true), find the first argument in that sequence and start testing for attributes after that. Because the MRO is scanned for the (type of) the second argument first, it does have to be findable, which is why the constraints are what they are. In Pure Python, this is what  does (simplified to focus on just the two argument behaviour):
just for the point 3 about the type super in the 3 cases (2 first are similar):


Answer URL
https://docs.python.org/3/library/functions.html#type
