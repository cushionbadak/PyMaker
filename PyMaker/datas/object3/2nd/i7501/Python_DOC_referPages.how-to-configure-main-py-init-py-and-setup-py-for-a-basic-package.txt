Natural Text
Background:I have a directory structure like so: I want to be able to run the code in a lot of different ways.  and then  and then  which should do the thing in  which should also do the thing in  but this time, we assume you've downloaded source rather than . Now I've gotten the first two to work, but with a messy setup: setup.py: __init__.py:__main__.py:What would make more sense to me would be in both cases to writebut that gives me import errors. Question:Is the way I have it really the only way? And most importantly, how do I support the third use case? Right now,  throwsNotes:I have read https://chriswarrick.com/blog/2014/09/15/python-apps-the-right-way-entry_points-and-scripts/http://setuptools.readthedocs.io/en/latest/setuptools.htmlThe many questions here that look like this one but don't answer my question above.
You have almost everything you need (even a bit more)! I'd go with the following setup:code.py:__init__.py:Doing a relative import here because  will be used when importing the whole package. Note that we explicitly mark the import as relative by using the -syntax because this is required for Python 3 (and in Python 2 if you did ).__main__.py:This is the package's main script and so we use an absolute  statement. By doing so we assume that the package has been installed (or at least has been put on the path); and that is the way packages should be dealt with! You might think that this conflicts with your third use case but actually there is no reason not to  when dealing with a package. And it really isn't a big deal (especially when using a )!If your concern is to tinker with the source files and readily observe the changes by running the  file then you can simply install the package using the  ("editable") switch:  (assuming you are in directory ). With your current directory structure, however, this won't work because the  switch will place an  to the directory containing the  file; this directory does not contain a package named  but  instead (I have a question about that).Instead, if you follow the convention to name the root directory of a package's source after the package itself (that is  for your example) then installing with  is not a problem: Python does find the required package  in the corresponding directory:This also lets you omit the extra definition of  in .A note about : For the three use cases which you've specified there is no need to define an entry point. That is you can skip the line . By shipping a  module  will readily execute the code in this module. You can also add an extra if-clause:The entry point on the other hand lets you directly execute the code in  from the CLI; that is running  will execute the corresponding code.RecapThe bottom line is that I'd always use  when dealing with packages. And why not, especially if you've already created a  file? If changes to the package are to be applied "in real-time" then you can install with the  switch (this might require a renaming of the  folder, see above). So your third use case would read as "Download the source and  (within a virtualenv); then you can run ".EditRun  without If you don't want to install the package via pip but still be able to run the  script, I'd still go with the above setup. Then we need to make sure that the  statement(s) are still succeeding and this can be achieved by extending the import path (note that the this requires the  directory to be renamed to the package's name!).Modify For Linux bash you can set the Pythonpath as follows:Or if you're in the same directory as :Of course there are different ways for different operating systems.Extend the path in You (or rather your colleague) could add the following lines to the top of the script (before the  statements):Extend the path in You can place a module named  in the  directory of your Python installation which contains the following lines:Create a separate, top-level  scriptSo you'd have the following layout:where  containsNow  is treated as a part of the  package and the relative import will work.Instead of running  you would run  now.
 fails because there is no Python package installed on your system named . There is a Python module on your system named , but in your import statement you don't specify the package that your  module can be found in.The purpose of the  file that you have in  tells Python that the  directory should be treated a Python package, with its contents as the modules within the package. Since  is located in  along with your  file, your  module is located in your  package.Now that you know which package your  module can be found in, you can import stuff from it with:Also, as a side note: The  does its job just by being present in your  directory, so it doesn't even need to contain any code. For that reason it's generally a good idea to leave the  file blank.
I often use this setup because it works better with It's probably not (yet) the detailed answer you're expecting but I think it's worth trying for the three use cases.


Answer URL
https://docs.python.org/3/library/site.html
