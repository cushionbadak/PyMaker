Natural Text
This question already has an answer here:What is __init__.py for?                    10 answers                Given that I have the following directory structure with  being the current working directoryWhen I run  I getIf I , the above command works.Am I doing something wrong or do I  misunderstand the point of ?  I thought it was to stop modules existing where they shouldn't, e.g. a directory named , but if you replace  with  in my example, I'm seemingly forced to create the module that should never be used, just so I can reference a file deeper in the hierarchy.UpdateI'm working with a build system that's generating the 's for me and is enforcing the directory structure and while I could mess with the hierarchy, I'd prefer to just add the  myself. To change the question slightly, why do I need a python package at every level instead of just at the top? Is it just a rule that you can only import modules from the python path or from a chain of packages off of the python path?
Yes, this file is required if you want directory to be treated as module.The  files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case,  can just be an empty file, but it can also execute initialization code for the package or set the  variable, described later.https://docs.python.org/3/tutorial/modules.html#packagesI try to create non-empty . You have great possibility to document module, to get rid of the nested imports for users/developers by providing the most useful objects(classes/functions) at the first level... ...actually to be as simple in use as possible in contrast to - let's say - the java importsEdit after question updateThe default importers/finders (examine the ) are:BuiltinImporter - searches for/loads built-in modulesFrozenImporter - searches for/loads frozen modules (e.g. *.pyc)PathFinder - the one you are interested in, allow to search for/load modules based on file systemThe third is the  thing (actually FrozenImporter as well). The searches for module in paths from  (and in  defined in packages). The module could be either standalone python file (if it is in the root of searched path) or directory with .Referring to your example:If you create  in ,  will be available (as you said).If you add  to  or pass it through ,  will be available (note without parent module foo).If you write your own finder (and Loader) you can load for example any file you want despite where it is. That gives you great power. For example take a look on , exposes code based on SO's search results.


Answer URL
https://docs.python.org/3/tutorial/modules.html#packages
https://docs.python.org/3/library/importlib.html#importlib.machinery.BuiltinImporter
https://docs.python.org/3/library/importlib.html#importlib.machinery.FrozenImporter
https://docs.python.org/3/library/importlib.html#importlib.machinery.PathFinder
https://docs.python.org/3/library/importlib.html#importlib.abc.MetaPathFinder
