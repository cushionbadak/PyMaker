Natural Text
I'm working on a class representing on object with numerous associated data. I'm storing these data in a dictionary class attribute called metadata. A representation could be:The calculating of the values is in some cases very slow, so what I want to do is, using "getter" functions, first try and get the value from the metadata  dict. Only on a KeyError (i.e. when the getter tries to get a value for a key which doesn't exist yet) should the value be calculated (and added to the dictionary for fast access next time the getter is called).I began with a simple:As there are many getters in the class, I started thought that these first 3 lines of code could be handled by a decorator. However I'm having problems making this work. The problem is that I need to pass the metadata dictionary from the class instance to the decorator. I've found several tutorials and posts like this one which show that it is possible to send a parameter to an enclosing function but the difficulty I'm having is sending a class instantiation attribute metadata to it (if I send a string value it works).Some example code from my attempt is here:The errors I'm getting are generally self not defined but I've tried various combinations of parameter placement, decorator placement etc. without success.So my questions are:How can I make this work?Are decorators a suitable way to achieve what I'm trying to do?
Yes, a decorator is a good use case for this. Django for example has something similar already included with it, it's called .Basically all it does is that when the property is accessed first time it will store the data in instance's dict() by the same name as the function. When we fetch the same property later on it simple fetches the value from the instance dictionary.A  is a non-data descriptor. Hence once the key is set in instance's dictionary, the access to property would always get the value from there.In your case:Use the  argument to convert an existing method to cached property.Demo:Based on the example above we can see that we can use  as long as we know the internal data hasn't been updated yet, hence saving processing time. But it doesn't make  redundant, as it can get the correct total based on the data.Another example could be that our public facing client was using something(say ) as method so far but we realised that it would be more appropriate to use it as a property(just ), in that case it makes sense to keep the method intact but mark it as deprecated and start suggesting the users to use the new property from now on.
Another way to go about this is to use class "properties" like so:Now you can access this as though it were a class attribute:


Answer URL
https://docs.python.org/3/howto/descriptor.html#descriptor-protocol
