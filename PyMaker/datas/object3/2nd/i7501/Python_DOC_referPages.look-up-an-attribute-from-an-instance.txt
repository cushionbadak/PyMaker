Natural Text
From Python in a NutshellGetting an attribute from an instanceWhen you use the syntax    to refer to an attribute of  instance    of class   , the lookup proceeds in three steps:When    is found in    (or in one of  ’s ancestor classes) as the name of an overriding descriptor    (i.e.,     supplies methods   and   )• The value of    is the result of  Otherwise, when    is a key in  •   fetches and returns the value at  Otherwise,    delegates the lookup to  ’s class (according to the same two-step lookup used for  , as just  detailed)• When a descriptor    is found, the overall result of the  attribute lookup is, again,  • When  a  nondescriptor  value     is  found,  the  overall   result  of  the  attribute lookup is just  When these lookup steps do not find an attribute, Python raises an   exception. However, for lookups of   , when    defines or inherits the special  method   , Python calls    rather than raising  the exception. It’s then up to    to either return a suitable value or raise  the appropriate exception, normally   .Are step 1 and the first part of step 3 the same? If yes, why does the same step appear twice?Do they both happen "when  is found in  (or in one of ’s ancestor classes) as the name of an overriding descriptor  "?At every request to access attribute , Python calls  , which must get and return the attribute  value or else raise . The normal semantics of  attribute access (using , , ’s class  attributes, ) are all due to .  When class  overrides , it must implement all of  the attribute access semantics it wants to offer. Most often, the most  convenient way to implement attribute access semantics is by  delegating (e.g., calling  as part  of the operation of your override of ).
Are step 1 and the first part of step 3 the same? If yes, why the same step appear twice?Step 1 requires both  and  (although actually, either  or  along with  would trigger it). Step 3 happens unconditionally if the attribute isn't found through steps 1 or 2.Do they both happen "when  name is found in  C (or in one of  C’s ancestor classes) as the name of an overriding descriptor  v"?No. An "overriding descriptor" triggers step 1; another kind of descriptor or a non-descriptor will only be considered in step 3. (The official Python docs don't use the term "overriding descriptor"; they refer to a descriptor with  or  as a "data descriptor", and if a data descriptor has , the  will take priority over an object found in an instance dict.)


Answer URL
https://docs.python.org/3/reference/datamodel.html#invoking-descriptors
