Natural Text
Quick question to mainly satisfy my curiosity on the topic. I am writing some large python programs with an SQlite database backend and will be dealing with a large number of records in the future, so I need to optimize as much as I can. For a few functions, I am searching through keys in a dictionary. I have been using the "in" keyword for prototyping and was planning on going back and optimizing those searches later as I know the "in" keyword is generally O(n) (as this just translates to python iterating over an entire list and comparing each element). But, as a python dict is basically just a hash map, is the python interpreter smart enough to interpret:to:It is basically the same operation but the top would be O(n) and the bottom would be O(1).  It's easy for me to use the bottom version in my code, but then I was just curious and thought I would ask. 
First,  is guaranteed to give you the same value as  for any dict .And the  operation on a , or the  object you get back from calling  on it (in 3.x), is not O(N), it's O(1).There's no real "optimization" going on; it's just that using the hash is the obvious way to implement  on a hash table, just as it's the obvious way to implement .You may ask where this is guaranteed.Well, it's not. Mapping Types defines  as, basically, a hash table implementation of . There's nothing stopping someone from creating a hash table implementation of a Mapping, but still providing O(N) searches. But it would be extra work to make such a bad implementation, so why would they?If you really need to prove it to yourself, you can test every implementation you care about (with a profiler, or by using some type with a custom  and  that logs calls, or…), or read the source.In 2.x, you do not want to call , because that generates a  of the keys, instead of a . You could use , but that may generate an iterator or something else that's not O(1). So, just use the dict itself as a sequence.Even in 3.x, you don't want to call , because there's no need to. Iterating a , checking its , and in general treating it like a sequence is always equivalent to doing the same thing to its keys, so why bother? (And of course building the trivial , and accessing through it, are going to add a few nanoseconds to your running time and a few keystrokes to your program.)(It's not quite clear that using sequence operations is equivalent for / and  in 2.x. Other than performance issues, they are equivalent in every CPython, Jython, IronPython, and PyPy implementation, but it doesn't seem to be stated anywhere the way it is in 3.x. And it doesn't matter; just use .)While we're at it, note that this:… is not going to work. If the  is not in the , this will raise , not return .Also, you should never check  with  or ; always use .You can do this with a —or, more simply, do . But again, there's no reason to do so. Also, that won't handle cases where  is a perfectly valid item. If that's the case, you need to do something like .So, the right thing to write is:More generally, this is not true:I know the "in" keyword is generally O(n) (as this just translates to python iterating over an entire list and comparing each elementThe  operator, like most other operators, is just a call to a  method (or the equivalent for a C/Java/.NET/RPython builtin).  implements it by iterating the list and comparing each element;  implements it by hashing the value and looking up the hash;  implements it by walking a B+Tree; etc. So, it could be O(n), O(1), O(log n), or something completely different.
In Python 2  creates the whole list of keys first that's why it is an  operation, while  is an  operation. will raise  if key is not found in the dict, so it is not equivalent to the first code.Python 2 results:In Python 3  returns a view object which is quite faster than Python 2's  but still slower simple normal :Python 3 results:Use just:
The proper way to do this would bethe in operator is O(1) for dictionaries and sets in python.
The in operator for dict has average case time-complexity of O(1). For detailed information about time complexity of other dict() methods, visit this link.


Answer URL
