Natural Text
For example:Python documentation says that  is implemented calling  and seeing whether it raises an exception or not. However, that leads to a great overhead, since the value obtained is discarded and an exception may be raised.The question is if calling  means the same thing, is it faster, safe, or may it fail in a particular occasion?
It is not quite the same thing.  is a diagnostic tool that omits attributes that  and  would find. From the  documentation:The default  mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information:If the object is a module object, the list contains the names of the module’s attributes.If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases.Otherwise, the list contains the object’s attributes’ names, the names of its class’s attributes, and recursively of the attributes of its class’s base classes.andNote: Because  is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting  set of names more than it tries to supply a rigorously or consistently  defined set of names, and its detailed behavior may change across  releases. For example,  attributes are not in the result  list when the argument is a class.Emphasis mine.This means that  will find metaclass supplied attributes, but  would not, and what is found can differ accross Python releases as the definition for the function is to provide debugging convenience, not completeness.Demo of the specific metaclass scenario, where  finds the metaclass-defined attribute:Last but not least:If the object has a method named , this method will be called and must return the list of attributes.This means that  and  can vary even more widely in what attributes are 'found' if a  method has been implemented.Just stick with . It is faster, for one, because testing for an attribute is cheap as that's just a membership test against one or more dictionaries. Enumerating all dictionary keys and merging them across instance, class and base classes on the other hand has a far higher CPU cost.
the hasattr is more than 100 times faster :) 
 does not call , or anything like that,  It depends on the class to "describe" itself: You should only use  when looking for documentation.  
hasattr() is basicallywhile "attribute in dir(s)" is more like:Hence, hasattr is expected to be a bit faster.Anyways, if I be allowed to go a bit off-track then I would suggest this.If you want to do something like:then its advisable to do it like this:Why?To avoid the overhead of an extra try-except block/ for loop.In python, it's Easier to Ask Forgiveness than Permission.


Answer URL
