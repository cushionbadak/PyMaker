Natural Text
What explains the difference in behavior of boolean and bitwise operations on lists vs numpy.arrays? I'm getting confused about the appropriate use of the '' vs '' in python, illustrated in the following simple examples. This answer, and this answer both helped me understand that 'and' is a boolean operation but '&' is a bitwise operation. I was reading some information to better understand the concept of bitwise operations, but I am struggling to use that information to make sense of  my above 4 examples. Note, in my particular situation, my desired output is a newlist where:Example 4, above, led me to my desired output, so that is fine. But I am left feeling confused about when/how/why I should use 'and' vs '&'. Why do lists and numpy arrays behave differently with these operators? Can anyone help me understand the difference between boolean and bitwise operations to explain why they handle lists and numpy.arrays differently? I just want to make sure I continue to use these operations correctly going forward. Thanks a lot for the help!EDITS1) Thanks @delnan for pointing out that in my original examples I had am ambiguity that was masking my deeper confusion. I have updated my examples to clarify my question. 
 tests whether both expressions are logically  while  (when used with / values) tests if both are .In Python, empty built-in objects are typically treated as logically  while non-empty built-ins are logically . This facilitates the common use case where you want to do something if a list is empty and something else if the list is not. Note that this means that the list [False] is logically :So in Example 1, the first list is non-empty and therefore logically , so the truth value of the  is the same as that of the second list. (In our case, the second list is non-empty and therefore logically , but identifying that would require an unnecessary step of calculation.)For example 2, lists cannot meaningfully be combined in a bitwise fashion because they can contain arbitrary unlike elements. Things that can be combined bitwise include: Trues and Falses, integers.NumPy objects, by contrast, support vectorized calculations. That is, they let you perform the same operations on multiple pieces of data.Example 3 fails because NumPy arrays (of length > 1) have no truth value as this prevents vector-based logic confusion.Example 4 is simply a vectorized bit  operation.Bottom LineIf you are not dealing with arrays and are not performing math manipulations of integers, you probably want .If you have vectors of truth values that you wish to combine, use  with .
The short-circuiting boolean operators (, ) can't be overriden because there is no satisfying way to do this without introducing new language features or sacrificing short circuiting. As you may or may not know, they evaluate the first operand for its truth value, and depending on that value, either evaluate and return the second argument, or don't evaluate the second argument and return the first:Note that the (result of evaluating the) actual operand is returned, not truth value thereof.The only way to customize their behavior is to override  (renamed to  in Python 3), so you can affect which operand gets returned, but not return something different. Lists (and other collections) are defined to be "truthy" when they contain anything at all, and "falsey" when they are empty.NumPy arrays reject that notion: For the use cases they aim at, two different notions of truth are common: (1) Whether any element is true, and (2) whether all elements are true. Since these two are completely (and silently) incompatible, and neither is clearly more correct or more common, NumPy refuses to guess and requires you to explicitly use  or . and  (and , by the way) can be fully overriden, as they don't short circuit. They can return anything at all when overriden, and NumPy makes good use of that to do element-wise operations, as they do with practically any other scalar operation. Lists, on the other hand, don't broadcast operations across their elements. Just as  doesn't mean anything and  means something completely different, there is no  operator for lists.
About First a very important point, from which everything will follow (I hope).In ordinary Python,  is not special in any way (except having cute syntax for constructing, which is mostly a historical accident). Once a list  is made, it is for all intents and purposes just an ordinary Python object, like a number , set , or a function .(Yes, it supports changing its elements, and it supports iteration, and many other things, but that's just what a type is: it supports some operations, while not supporting some others. int supports raising to a power, but that doesn't make it very special - it's just what an int is. lambda supports calling, but that doesn't make it very special - that's what lambda is for, after all:).About  is not an operator (you can call it "operator", but you can call "for" an operator too:). Operators in Python are (implemented through) methods called on objects of some type, usually written as part of that type. There is no way for a method to hold an evaluation of some of its operands, but  can (and must) do that.The consequence of that is that  cannot be overloaded, just like  cannot be overloaded. It is completely general, and communicates through a specified protocol. What you can do is customize your part of the protocol, but that doesn't mean you can alter the behavior of  completely. The protocol is:Imagine Python interpreting "a and b" (this doesn't happen literally this way, but it helps understanding). When it comes to "and", it looks at the object it has just evaluated (a), and asks it: are you true? (NOT: are you ?) If you are an author of a's class, you can customize this answer. If  answers "no",  (skips b completely, it is not evaluated at all, and) says:  is my result (NOT: False is my result).If  doesn't answer,  asks it: what is your length? (Again, you can customize this as an author of 's class). If  answers 0,  does the same as above - considers it false (NOT False), skips b, and gives  as result.If  answers something other than 0 to the second question ("what is your length"), or it doesn't answer at all, or it answers "yes" to the first one ("are you true"),  evaluates b, and says:  is my result. Note that it does NOT ask  any questions.The other way to say all of this is that  is almost the same as , except a is evaluated only once.Now sit for a few minutes with a pen and paper, and convince yourself that when {a,b} is a subset of {True,False}, it works exactly as you would expect of Boolean operators. But I hope I have convinced you it is much more general, and as you'll see, much more useful this way.Putting those two togetherNow I hope you understand your example 1.  doesn't care if mylist1 is a number, list, lambda or an object of a class Argmhbl. It just cares about mylist1's answer to the questions of the protocol. And of course, mylist1 answers 5 to the question about length, so  and returns mylist2. And that's it. It has nothing to do with elements of mylist1 and mylist2 - they don't enter the picture anywhere.Second example:  on On the other hand,  is an operator like any other, like  for example. It can be defined for a type by defining a special method on that class.  defines it as bitwise "and", and bool defines it as logical "and", but that's just one option: for example, sets and some other objects like dict keys views define it as a set intersection.  just doesn't define it, probably because Guido didn't think of any obvious way of defining it.numpyOn the other leg:-D, numpy arrays are special, or at least they are trying to be. Of course, numpy.array is just a class, it cannot override  in any way, so it does the next best thing: when asked "are you true", numpy.array raises a ValueError, effectively saying "please rephrase the question, my view of truth doesn't fit into your model". (Note that the ValueError message doesn't speak about  - because numpy.array doesn't know who is asking it the question; it just speaks about truth.)For , it's completely different story. numpy.array can define it as it wishes, and it defines  consistently with other operators: pointwise. So you finally get what you want.HTH,
Example 1:This is how the and operator works. x and y  => if x is false, then x, else ySo in other words, since  is not , the result of the expression is . (Only empty lists evaluate to .)Example 2:The  operator is for a bitwise and, as you mention. Bitwise operations only work on numbers. The result of a & b is a number composed of 1s in bits that are 1 in both a and b. For example: It's easier to see what's happening using a binary literal (same numbers as above): Bitwise operations are similar in concept to boolean (truth) operations, but they work only on bits. So, given a couple statements about my carMy car is redMy car has wheelsThe logical "and" of these two statements is: (is my car red?) and (does car have wheels?) => logical true of false valueBoth of which are true, for my car at least. So the value of the statement as a whole is logically true. The bitwise "and" of these two statements is a little more nebulous:(the numeric value of the statement 'my car is red') & (the numeric value of the statement 'my car has wheels') => numberIf python knows how to convert the statements to numeric values, then it will do so and compute the bitwise-and of the two values. This may lead you to believe that  is interchangeable with , but as with the above example they are different things. Also, for the objects that can't be converted, you'll just get a . Example 3 and 4:Numpy implements arithmetic operations for arrays: Arithmetic and comparison operations on ndarrays are defined as element-wise operations, and generally yield ndarray objects as results.But does not implement logical operations for arrays, because you can't overload logical operators in python. That's why example three doesn't work, but example four does. So to answer your  vs  question: Use . The bitwise operations are used for examining the structure of a number (which bits are set, which bits aren't set). This kind of information is mostly used in low-level operating system interfaces (unix permission bits, for example). Most python programs won't need to know that. The logical operations (, , ), however, are used all the time. 
In Python an expression of  returns , given that  or any of  or  evaluate to False, e.g.:Bitwise operator is simply not defined for lists. But it is defined for integers - operating over the binary representation of the numbers. Consider 16 (01000) and 31 (11111):NumPy is not a psychic, it does not know, whether you mean thate.g.  should be equal to  in a logical expression. In this it overrides a standard Python behaviour, which is: "Any empty collection with  is ".Probably an expected behaviour of NumPy's arrays's & operator. 
For the first example and base on the django's docIt will always return the second list, indeed a non empty list is see as a True value for Python thus python return the 'last' True value so the second list
Operations with a Python list operate on the list.  will check if  is empty, and return  if it is, and  if it isn't.  will append  to , so you get a new list with  elements. Operators that only make sense when applied element-wise, such as , raise a , as element-wise operations aren't supported without looping through the elements.Numpy arrays support element-wise operations.  will calculate the bitwise or for each corresponding element in  and .  will calculate the sum for each corresponding element in  and . This does not work for  and . is essentially a short-hand for the following code:For this you need a good definition of . For global operations like used on Python lists, the definition is that  if  is not empty, and  if it is empty. For numpy's element-wise operations, there is some disambiguity whether to check if any element evaluates to , or all elements evaluate to . Because both are arguably correct, numpy doesn't guess and raises a  when  is (indirectly) called on an array. 


Answer URL
