Natural Text
I want to get all logging output with mock. I searched, butonly found ways to mock explicitly logging.info or logging.warn.I need all output, whatever logging level was set. In our libraries we use this:
stdlibSince Python 3.4 the batteries'  has . When used without  and  arguments, it catches all logging (suppresses existing handlers). You can later access recorded entries from the context manager's  attribute. Text output strings are stored in  list.TornadoFor Python 2 I usually take Tornado's . It's self-contained and works for normal Python code. It's actually more elegant solution then stdlib's, because instead of several class,  is just a normal  (a class, source). But it lacks a couple of features, including access to recorded entries, so usually I also extend it a bit, like:Then you can have something like:However, note that for the filter approach current logging level is important (can be overridden with  argument), and also you need a filter per logger of interest. You can follow the approach and make something that fits your case better.UpdateAlternatively there's unittest2 backport for Python 2 which has .
If you are writing your tests using , take a look at a neat fixture named  that will capture log records for you. It captures all the emitted log records which you can then access via  list. Each element is an instance of , so you can easily access any of the s attributes. Example:InstallThe fixture was first introduced in a  plugin named  which is now abandoned. Luckily, it got a decent fork named , which has been merged into  recently. So, if you use a recent version of , you are already good to go; for older versions of , install  from PyPI.DocsAt the moment,  doesn't provide any docs for the  fixture (or at least I couldn't find any), so you can refer to 's documentation.Plain If  is not an option, I wouldn't patch  at all - you can simply add a custom handler instead that will record all the incoming logs. A small example:You can then extend the custom handler and implement any logic you need, like collecting the records in a  that maps log levels to lists of records, or add a  implementation, so you can start and stop capturing records inside the test:
I found this solution:
The module testfixtures has a class to handle this:Source: http://testfixtures.readthedocs.io/en/latest/logging.html


Answer URL
https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertLogs
https://docs.python.org/3/library/logging.html#logging.Filter
https://docs.python.org/3/library/logging.html#logrecord-attributes
