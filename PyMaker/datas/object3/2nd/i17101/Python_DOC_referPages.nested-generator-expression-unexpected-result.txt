Natural Text
This question already has an answer here:Accessing class variables from a list comprehension in the class definition                    5 answers                Why is one class variable not defined in list comprehension but another is?                    1 answer                Here's the test code:Under the assumption that the generator expression on line 3 () forms an iterator I would expect the final result to reflect the final assigned values for  and . OTOH, if that generator expression were to be evaluated at line 3, producing the result tuple, then I'd expect the first definitions of  and  to be used.What I see is a MIX; i.e., the result is !?Can anyone explain this behavior?
A generator expression creates a function of sorts; one with just one argument, the outermost iterable.Here that's , and that is bound as an argument to the generator expression when the generator expression is created.All other names are either locals (such as  and ), globals, or closures.  is looked up as a global, so it is looked up each time you advance the generator.As a result,  is bound to the generator on line 3,  is looked up when you iterated over the generator expression on the last line.You can see this when compiling the generator to bytecode and inspecting that bytecode:The  bytecode turned the generator expression code object into a function, and it is called immediately, passing in  as the argument. The  name is not referenced at all here.This is documented in the original generators PEP:Only the outermost for-expression is evaluated immediately, the other  expressions are deferred until the generator is run:is equivalent to:and in the generator expressions reference:Variables used in the generator expression are evaluated lazily when the  method is called for generator object (in the same fashion as normal generators). However, the leftmost  clause is immediately evaluated, so that an error produced by it can be seen before any other possible error in the code that handles the generator expression. Subsequent  clauses cannot be evaluated immediately since they may depend on the previous for loop. For example: .The PEP has an excellent section motivating why names (other than the outermost iterable) are bound late, see Early Binding vs. Late Binding.


Answer URL
