Natural Text
I am trying to run shell commands from Python on the CGI script below. Can someone explain to me why  is  when I execute the script on the shell, while  is  when I run it from a web browser? Thanks in advance. Also, if I try subprocesses like  (e.g. ), the exit status will be zero when run in the terminal but there will be a  when done in the browser. I'm really puzzled... 
As @abarnert mentioned in a comment, using  is generally to be avoided unless you don't have any choice (e.g. you absolutely require the system shell's expansion functionality). As this section of the subprocess documentation explains, use of the shell introduces various serious security issues where any of the command (including arguments) is obtained from an external source (e.g. a form submission). In addition to these issues, you're also trusting that the shell is correctly configured on the host system, which is not always a safe assumption for special users such as those used for web services. In addition to the security holes, it's also wasteful to fork an extra shell process just to execute a command which can be executed directly. Also, you're probably hurting your portability by relying on a system shell, since different platforms will apply different expansions and rules to the command string.When using  it's best to pass commands as a list of arguments rather than a single string, and this becomes particularly important when using . It may not be required on all platforms, but it certainly is on Linux and hence keeps your code more portable. In additional, splitting the arguments yourself avoids possible mishaps forgetting to escape or quote arguments to the shell.Also, @abarbert has correctly explained that you won't necessarily have the  correctly set up in a CGI environment so it's best practice to reference everything via absolute path names. Again, this is generally good practice for portability to different platforms and environments (though of course hard-coding the path to a binary already gets in the way of portability, but at least you can minimise the issue - who knows when you or someone else will need to port this code).Taking this into account, your  and  examples would look like this:It's also somewhat confused by the fact that many shells treat  as a builtin, which overrides the actual  command - referencing it by absolute path (i.e. ) forces it to use the actual command rather than the builtin.When running as a CGI script the internal server error typically means you've had an uncaught Python exception. If you look in the log files for your webserver (assuming you have access to them) then you should find the full text of the exception, but this does vary from server to server. When running without , I suspect you're getting an  exception when it fails to find the executable to run. When you run with the shell, you won't get an exception - you'll just get output on standard error with the shell's error message. Again, this should be duplicated in the logs. If you do get an exception, I suspect it's due to the user you're running as not having a valid login shell specified - some configurations run scripts as a user with something like  as their login shell to avoid the account being abused. I'd expect a return code of  rather than  if this were the case.In short, see what information has gone to your webserver's error logs and best practice is to avoid  and make sure you specify all commands as lists of arguments rather than whitespace-delimited strings. If you can get some more information from the logs and post it here, we can update our answers to provide more specific help.Finally, if at all possible I would avoid any code which uses  in a webserver, and this includes . Sometimes there's no way to avoid it, but certainly for simple things like  you can use Python functions instead (). You're probably fine while you're running as a standard CGI script, but if you ever plan to port your code to a more efficient hosting environment (e.g. mod-wsgi, fastcgi) then you have to be quite careful spawning external processes because of the duplication of file descriptors and other resources which occurs. I'm not saying it can't be done safely, but it's a potential source of confusing bugs in the future so I really would avoid it if you possibly can. This is all not to mention the relative inefficiency of spawning an external process to handle a web request, which may matter if you plan your code to scale.


Answer URL
