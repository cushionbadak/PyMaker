Natural Text
I have a table (curves.csv) organized like this (not organized would be a better description)I would like to convert this table toI currently have this:I just feel like I am getting further form the answer, not closer!Any pointers would be,as always, much appreciated
How about something like this, using the  module:which gives us a dictionary looking likeand an output file like
The best way to approach a problem like this, I find, is to separate the breaking down of the old format, and the building up of the new. Instead, break down the old format into a sane data structure that makes it easy to play with the data in Python, then build the new format using that nice, malleable structure.Wherever we are working with comma separated values, we can simplify it all by using the  module, which is in the standard library, and greatly simplifies this kind of job.This solution also makes pretty heavy use of the list comprehension (and it's various cousins), so if you are not familiar with them, I recommend reading up a little (linked previously is my short video explaining them).We begin by opening the file using the  statement (a best practice that ensures the file is closed), then we skip the line of headers, and parse the data. To do this, we take each line in the data, then group the line into chunks of length 3 (using the  function, which is an  recipie). This gives us our column, row and value, which we then use as the key and value of a dictionary.This gives us a dictionary of . That's a good format to work from, so now we construct the file back up into the wanted format.First we need to know what rows and columns we need, we do this by taking only the rows from the parsed data, and making a set (as sets can't contain duplicates), and finally sorting them back into a list so we have the right order.We then open our output file, and write the columns to it (remembering to add a  for the row headers column), and then write out our data. For each row, we write the row number, then get the value for each column from our parsed data, using  so we get  if there isn't a value. This gives the output that was wanted.As a note: it appears you are using Python 2.x in the question, my answer was written in 3.x. The only difference should be that  is  in 3.x.
Just to show (a bit late) that it can also be done in R:If you don't like to use a third party package, then you can do it all with base:
Without using the  module:
R solution with -ing the concatenation function, c.


Answer URL
