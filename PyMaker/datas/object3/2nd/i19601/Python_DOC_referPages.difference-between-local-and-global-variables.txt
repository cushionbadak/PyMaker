Natural Text
Possible Duplicate:Python passing list as argument I looked for many topics about that, but I can't understand what happen really.I have this code:and the result is:I can't understand how the  was modified and  not. However before test the code, I thought that  and  would stay unmodified because they are global variables.
When you do  you are calling a method that actually changes the list named by the variable . All the other commands setting the values of  and  are actually just creating new names for new variables.This version doesn’t change anything:While this one does:However there is a tricky matter with  which is not exactly the same as . The Python Language Reference  section on Augmented assignment statements explains the difference: An augmented assignment expression like x += 1 can be rewritten as x = x + 1 to achieve a similar, but not exactly equal effect. In the augmented version, x is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead.”
Lists are passed by reference in Python.  is modified because you directly call : is not modified because you did not modify the list. You used the addition operator, , which does not modify . Instead, it creates a new list and returns the result.If you Google the term "pass by reference" you should be able to find some good explanatory examples in Python.
There are two different things happening in your function:To expand on the comments I added inline:inside , the variable  is whatever you passed in (so it is ). It isn't a copy, a new list with the same contents - it refers to the same actual objectwhen you assign  you do two things:create a new list with the value set  to point to this new list, instead of whatever you passed inIf we re-name the variable it becomes explicit, and works exactly the same:Alternatively, if you want to modify the original  in place (ie, to actually modify ), you would doNote the last line still means  will be a different list object to , but it will have the same values. If you just , the  will be identical with , so they'll be two names for the same list object.If you want to prevent this behaviour, you can call  like this:now, inside , it will be working on its own copies of the arguments, and can't affect the original  and .
When you assigned a new value to the name  with the  statement, it no longer refers to . Most of your other statements change the value of the objects to which they already refer.


Answer URL
