Natural Text
I'm writing a Python script for a FOSS language learning initiative. Let's say I have an XML file (or to keep it simple, a Python list) with a list of words in a particular language (in my case, the words are in Tamil, which uses a Brahmi-based Indic script). I need to draw out the subset of those words that can be spelled using just those letters. An English example: A Tamil example: The order that the words are returned in, or the order that the letters are entered in should not make a difference.  Although I understand the difference between unicode codepoints and graphemes, I'm not sure how they're handled in regular expressions. In this case, I would want to match only those words that are made up of the specific graphemes in the input list, and nothing else (i.e. the markings that follow a letter should only follow that letter, but the graphemes themselves can occur in any order).
To support characters that can span several Unicode codepoints:It assumes that the same character can be used zero or more times in a word.If you want only words that contain exactly given characters:Note: there is no  in the output in this case because  doesn't use all given characters.What does it mean to normalize? And could you please explain the syntax of the re.match() regex?Without normalization  and  do not match. The characters are from the  docs.
EDIT: Okay, don't use any of the answers from here.  I wrote them all while thinking Python regular expressions didn't have a word boundary marker, and I tried to work around this lack.  Then @Mark Tolonen added a comment that Python has  as a word boundary marker!  So I posted another answer, short and simple, using .  I'll leave this here in case anyone is interested in seeing solutions that work around the lack of , but I don't really expect anyone to be.It is easy to make a regular expression that matches only a string of a specific set of characters.  What you need to use is a "character class" with just the characters you want to match.I'll do this example in English.  This is a character class that will match a single character from the set .  Order of the characters doesn't matter.  Putting a  on the end makes it match one or more characters from the set.  But this is not enough by itself; if you had the word "coach" this would match and return "coac".Sadly, there isn't a regular expression feature for "word boundary". [EDIT: This turns out not to be correct, as I said in the first paragraph.]  We need to make one of our own.  There are two possible word beginnings: the start of a line, or whitespace separating our word from the previous word.  Similarly, there are two possible word endings: end of a line, or whitespace separating our word from the next word.Since we will be matching some extra stuff we don't want, we can put parentheses around the part of the pattern we do want.To match two alternatives, we can make a group in parentheses and separate the alternatives with a vertical bar.  Python regular expressions have a special notation to make a group whose contents we don't want to keep: So, here is the pattern to match the beginning of a word.  Start of line or white space:  Here is the pattern for end of word.  White space or end of line:  `(?:\s|$)Putting it all together, here is our final pattern:You can build this dynamically.  You don't need to hard-code the whole thing.Now, this doesn't in any way check for valid words.  If you have the following text:The pattern I showed you will match on  and , and those are not really words.  They are strings made only of letters from  though.So just do the same thing with Unicode strings.  (If you are using Python 3.x then all strings are Unicode strings, so there you go.)  Put the Tamil characters in the character class and you are good to go.This has a confusing problem:  doesn't return all possible matches.EDIT: Okay, I figured out what was confusing me.What we want is for our pattern to work with  so you can collect all the words.  But  only finds non-overlapping patterns.  In my example,  only returned  and not  as I expected... but this is because my pattern was matching the white space after .  The match group didn't collect the white space, but it was matched all the same, and since  wants no overlap between matches, the white space was "used up" and didn't work for .The solution is to use a feature of Python regular expressions that I have never used before: special syntax that says "must not be preceded by" or "must not be followed by".  The sequence  matches any non-whitespace so we could use that.  But punctuation is non-whitespace, and I think we do want punctuation to delimit a word.  There is also special syntax for "must be preceded by" or "must be followed by".  So here is, I think, the best we can do:Build a string that means "match when the character class string is at start of line and followed by whitespace, or when character class string is preceded by whitespace and followed by whitespace, or when character class string is preceded by whitespace and followed by end of line, or when character class string is preceded by start of line and followed by end of line".Here is that pattern using :I'm very sorry but I really do think this is the best we can do and still work with !It's actually less confusing in Python code though:So, the crazy thing is that when we have alternative patterns that could match,  seems to return an empty string for the alternatives that didn't match.  So we just need to filter out the length-zero strings from our results:I guess it might be less confusing to just build four different patterns, run  on each, and join the results together.EDIT: Okay, here is the code for building four patterns and trying each.  I think this is an improvement.EDIT: Okay, here is a very different approach.  I like this one best.First, we will match all words in the text.  A word is defined as one or more characters that are not punctuation and are not white space.Then, we use a filter to remove words from the above; we keep only words that are made only of the characters we want.EDIT: Now I don't like any of the above solutions; please see the other answer, the one using , for the best solution in Python.
It is easy to make a regular expression that matches only a string of a specific set of characters. What you need to use is a "character class" with just the characters you want to match.I'll do this example in English. This is a character class that will match a single character from the set . Order of the characters doesn't matter. Putting a + on the end makes it match one or more characters from the set. But this is not enough by itself; if you had the word  this would match and return .\b`.)So, just build up a pattern like the above, only using the desired character set at runtime, and there you go.  You can use this pattern with  or .
I would not use regular expressions to solve this problem. I would rather use collections.Counter like so:This solution should also work for other languages.  finds the intersection between the two counters, or the min(c[x], f[x]). If this intersection is equivalent to your word, then you want to return the word as a match.


Answer URL
