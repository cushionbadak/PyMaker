Natural Text
I'm currently writing an application which allows the user to extend it via a 'plugin' type architecture.  They can write additional python classes based on a BaseClass object I provide, and these are loaded against various application signals.  The exact number and names of the classes loaded as plugins is unknown before the application is started, but are only loaded once at startup.During my research into the best way to tackle this I've come up with two common solutions.Option 1 - Roll your own using imp, pkgutil, etc.See for instance, this answer or this one.Option 2 - Use a plugin manager libraryRandomly picking a couplestraight.pluginyapsythis approachMy question is - on the proviso that the application must be restarted in order to load new plugins - is there any benefit of the above methods over something inspired from this SO answer and this one such as:Are there any disadvantages to this approach compared to the ones above? (other than all the plugins must be in the same file) Thanks!EDITComments request further information... the only additional thing I can think to add is that the plugins use the blinker library to provide signals that they subscribe to.  Each plugin may subscribe to different signals of different types and hence must have its own specific "register" method.  
The metaclass approach is useful for this issue in Python < 3.6 (see @quasoft's answer for Python 3.6+).  It is very simple and acts automatically on any imported module.  In addition, complex logic can be applied to plugin registration with very little effort.  It requires:The metaclass approach works like the following:1) A custom  metaclass is defined which maintains a list of all plugins2) A  class is defined which sets  as its metaclass3) When an object deriving from  - for instance  is imported, it triggers the  method on the metaclass.  This registers the plugin and performs any application specific logic and event subscription.Alternatively if you put the  logic in  it is called whenver a new instance of a  derived class is created.Then a base plugin class which looks like:Finally, an actual plugin class would look like the following:Plugins can be accessed from any python module that has imported :See the full working example
Since Python 3.6 a new class method  is added, that is called on a base class, whenever a new subclass is created.This method can further simplify the solution offered by will-hart above, by removing the metaclass.The  method was introduced with PEP 487: Simpler customization of class creation. The PEP comes with a minimal example for a plugin architecture:It is now possible to customize subclass creation without using a  metaclass. The new  classmethod will be called on  the base class whenever a new subclass is created:The PEP example above stores references to the classes in the  field.If you want to store instances of the plugin classes, you can use a structure like this:which outputs:
The approach from will-hart was the most useful one to me! For i needed more control I wrapped the Plugin Base class in a function like:and then:This allows to add additional baseclasses or switching to another metaclass.


Answer URL
https://docs.python.org/3/whatsnew/3.6.html
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__
