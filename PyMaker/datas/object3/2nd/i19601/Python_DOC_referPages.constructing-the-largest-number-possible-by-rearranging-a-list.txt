Natural Text
Say I have an array of positive whole integers; I'd like to manipulate the order so that the concatenation of the resultant array is the largest number possible. For example  results in ;  results in . I'm not sure of an answer.

Intuitively, we can see that a reverse sort of single digit numbers would lead to the higest number:so reverse sorting should work. The problem arises when there are multi-digit snippets in the input. Here, intuition again lets us order  before  and  before , but why does that work? Again, if they had been the same length, it would have been clear how to sort them:The trick then, is to 'extend' shorter numbers so they can be compared with the longer ones and can be sorted automatically, lexicographically. All you need to do, really, is to repeat the snippet to beyond the maximum length:comparing  and : compare  and  instead and thus  comes first.comparing  and : compare  and  instead and thus  comes first.comparing  and : compare  and  instead and thus  comes first.comparing  and : compare  and  instead and thus  comes first.This works because python only needs to compare the two snippets until they differ somewhere; and it's (repeating) matching prefixes that we need to skip when comparing two snippets to determine which order they need to be in to form a largest number.You only need to repeat a snippet until it is longer than the longest snippet * 2 in the input to guarantee that you can find the first non-matching digit when comparing two snippets. You can do this with a  argument to , but you need to determine the maximum length of the snippets first. Using that length, you can 'pad' all snippets in the sort key until they are longer than that maximum length:where  pads the snippet with itself to be more than  in length.This gives:Note that this solution is a) 3 lines short and b) works on Python 3 as well without having to resort to  and c) does not bruteforce the solution (which is what the  option does).
Hint one: you concatenate strings, not integers. Hint two: .
You can use itertools.permutations as hinted and use the key argument of the max function (which tells which function to apply to each element in order to decide the maximum) after you concat them with the join function.It's easier to work with strings to begin with.
I don't like the brute force approach to this. It requires a massive amount of computation for large sets.You can write your own comparison function for the sorted builtin method, which will return a sorting parameter for any pair, based on any logic you put in the function.Sample code:
Well, there's always the brute force approach...Or this, an adaptation of @Zah's answer that receives a list of integers and returns an integer, as specified in the question:
You can do this with some clever sorting.If two strings are the same length, choose the larger of the two to come first. Easy.If they're not the same length, figure out what would be the result if the best possible combination were appended to the shorter one. Since everything that follows the shorter one must be equal to or less than it, you can determine this by appending the short one to itself until it's the same size as the longer one. Once they're the same length you do a direct comparison as before.If the second comparison is equal, you've proven that the shorter string can't possibly be better than the longer one. Depending on what it's paired with it could still come out worse, so the longer one should come first.This should be much more efficient than running through all the permutations.



Answer URL
