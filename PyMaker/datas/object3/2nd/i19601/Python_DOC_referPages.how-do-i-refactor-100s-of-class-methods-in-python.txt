Natural Text
I am working on some legacy code (created by someone in love with spaghetti code) that has over 150 getters and over 150 setters. The getters look like this:I would love to take the contents of each of these Getters and put them into a decorator /closure or some other method to make this code easier to maintain. The Setters are all one liners, so they're not as important. But they are basically all the same too. Any ideas to make this less painful?NOTE: I still need the original Getter names as they are used in other programs as this nasty script is used in lots of other legacy code.
Now, you can do this:Then:Clearly, there's also a lot of repetitive and unnecessary stuff in the original function. (And it would be much better to use PEP8-style names for your properties.) But obviously it's much easier to refactor first, then improve, than the other way around. (In other words, start here, but don't stop here.)From the comments:How does the method maker get the "self" reference?The method maker doesn't actually get the  reference. There is no  reference to get at the time the method maker is being called. But there also is no  reference to get for a normal method at the time the class is being defined. In either case, you're just defining a function that takes  as its first parameter, and it somehow magically gets the appropriate  when you call it.To really understand how this actually works, you need to know about descriptors. See Implementing Descriptors and Invoking Descriptors (or the 3.3 version), read it over a few times, look at how the  decorator is implemented, play around in the interactive interpreter, give up, go to sleep, and try again tomorrow, and it should all click. But it's easier if you learn the magic version first, so let's do that, using a simpler example:An unbound method is just a thing with an  holding its class, an  holding a normal function, and an  holding . And when you do  in the class definition, or  after the fact, you don't actually end up with  itself as the value of  or , but with an unbound method wrapped around , its  pointing at .When you take an instance of a class, all of its unbound methods become bound methods. If you look at the bound methods' attributes, they're the same as the unbound methods, except that  is  instead of . And when you call , that's how it worksâ€”Python sees that  is a bound method, so, in effect, it calls . And that's how  gets its self parameter.(This all becomes simpler in Python 3, because there's no such thing as unbound methods anymore, but I assume you care more about Python 2 given that you're dealing with a huge mess of legacy code.)
You don't necessarily need to create getter/setter methods at class-creation time. You can also create callables as-needed:Although this approach is easy to understand and doesn't use any metaprogramming voodoo, it's slow and defeats introspection.You can speed this up by "reifying" methods as you call them, i.e., attaching an  to the class as attributes on instances of the class are accessed.If you then run the following code:You will get the following result:Notice that getattr is only called the first time any instance accesses a special property. After that a bound method is returned from the  we dynamically created and attached to the instance's class. After the first access of an attribute, the classes and instances will be nearly indistinguishable from a method we created the "normal" way and will have exactly the same runtime speed.
You could try something like this:Because you can't overshoot the end of a string when slicing, the length test is no longer necessary.
If there are literally hunderds of getters that share the same code; you could use metaclass to automate the getters creations:OutputThe output shows that the length limiting feature works.See also:Can anyone help condense this Python code?What is a metaclass in Python?


Answer URL
