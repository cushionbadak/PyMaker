Natural Text
I know that python has a concept of small integers which are numbers from  to , and if two variables assign to same numbers between this range, they both will use the same underlying object.From Python documentation,/* Small integers are preallocated in this array so that they    can  be shared.    The integers that are preallocated are those in the  range    -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).  */Also explained here,The current implementation keeps an array of integer objects for all  integers between -5 and 256, when you create an int in that range you  actually just get back a reference to the existing object. So it  should be possible to change the value of 1. I suspect the behaviour  of Python in this case is undefined. :-)Example,gives the same id,Which makes sense and also explained on this answer, "is" operator behaves unexpectedly with integersIf two numbers are less than , they should also have different IDs as follows,gives,this makes sense so far,But any number greater than  should have different ,This should return different IDs,But it doesn'tEven when I am using very large integer, the IDs are same,gives me,Can someone tell me why number greater than 256 have same IDs even though in the Python code the range is  to  (not inclusive)EDIT:I have tried using PyCharm with both Python 2.7 and 3.6. Also tried on PythonTutor.com
On mint Python 3.6.3 (2 as well) I cannot reproduce. My guess is  or pythontutor are wrapping the run in something before interpreting - since those are not open code we cannot see the internals so I cannot verify. The reason I think this is true, is while (everything below is mint Python 3):You can have this:so wrapping the two integers in something the interpreter can compile allows for these extra optimizations - like using the same constant for both definitions. Note this is limited as well:I would not have code that depends on this on any way - the guarantee is only on -5 to 256.


Answer URL
https://docs.python.org/3/c-api/long.html
