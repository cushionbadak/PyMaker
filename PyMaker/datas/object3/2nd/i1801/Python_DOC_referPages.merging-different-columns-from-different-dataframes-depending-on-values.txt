Natural Text
How to perform a (||) (|) join with pandas?How do I add NaNs for missing rows after merge?How do I get rid of NaNs after merging?Can I merge on the index?How do I merge multiple DataFrames?   ? ? ? ? Who? What? Why?!... and more. I've seen these recurring questions asking about various facets of the pandas merge functionality. Most of the information regarding merge and its various use cases today is fragmented across dozens of badly worded, unsearchable posts. The aim here is to collate some of the more important points for posterity.This QnA is meant to be the next instalment in a series of helpful user-guides on common pandas idioms (see this post on pivoting, and this post on concatenation, which I will be touching on, later). Please note that this post is not meant to be a replacement for the documentation, so please read that as well! Some of the examples are taken from there. 
This post aims to give readers a primer on SQL-flavoured merging with pandas, how to use it, and when not to use it.In particular, here's what this post will go through:The basics - types of joins (LEFT, RIGHT, OUTER, INNER)merging with different column namesavoiding duplicate merge key column in output   Merging with index under different conditions effectively using your named indexmerge key as the index of one and column of anotherMultiway merges on columns and indexes (unique and non-unique)Notable alternatives to  and What this post will not go through:Performance-related discussions and timings (for now). Mostly notable mentions of better alternatives, wherever appropriate.Handling suffixes, removing extra columns, renaming outputs, and other specific use cases. There are other (read: better) posts that deal with that, so figure it out!Note  Most examples default to INNER JOIN operations while demonstrating various features, unless otherwise specified. Furthermore, all the DataFrames here can be copied and replicated so  you can play with them. Also, see this  post  on how to read DataFrames from your clipboard.Lastly, all visual representation of JOIN operations are borrowed with  thanks from the article  https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins.Enough Talk, just show me how to use !Setup For the sake of simplicity, the key column has the same name (for now).An INNER JOIN is represented by                                              Note here refers to the keys from the join column in the  DataFrame,   refers to keys from the join column in the  DataFrame, and the intersection  represents keys common to both  and .  The shaded region represents the keys that are present in the JOIN result. This convention will be followed throughout. Keep in mind that Venn diagrams are not a 100% accurate representation of JOIN operations, so take them with a pinch of salt. To perform an INNER JOIN, call  specifying the left DataFrame, the right DataFrame, and the join key. This returns only rows from  and  which share a common key (in this example, "B" and "D). In more recent versions of pandas (v0.21 or so),  is now a first order function, so you can call . A LEFT OUTER JOIN, or LEFT JOIN  is represented by                                              This can be performed by specifying . Carefully note the placement of NaNs here. If you specify , then only keys from  are used, and missing data from  is replaced by NaN.And similarly, for a RIGHT OUTER JOIN, or RIGHT JOIN which is...                                             ...specify :Here, keys from  are used, and missing data from  is replaced by NaN.Finally, for the FULL OUTER JOIN, given by                                             specify .This uses the keys from both frames, and NaNs are inserted for missing rows in both.  The documentation summarises these various merges nicely:Other JOINs - LEFT-Excluding, RIGHT-Excluding, and FULL-Excluding/ANTI JOINsIf you need LEFT-Excluding JOINs and RIGHT-Excluding JOINs in two steps.For LEFT-Excluding JOIN, represented as                                             Start by performing a LEFT OUTER JOIN and then filtering (excluding!) rows coming from  only,Where,And similarly, for a RIGHT-Excluding JOIN,                                              Lastly, if you are required to do a merge that only retains keys from the left or right, but not both (IOW, performing an ANTI-JOIN),                                              You can do this in similar fashion—Different names for key columnsIf the key columns are named differently—for example,  has , and  has  instead of —then you will have to specify  and  as arguments instead of :Avoiding duplicate key column in outputWhen merging on  from  and  from , if you only want either of the  or  (but not both) in the output, you can start by setting the index as a preliminary step.Contrast this with the output of the command just before (thst is, the output of ), you'll notice  is missing. You can figure out what column to keep based on which frame's index is set as the key. This may matter when, say, performing some OUTER JOIN operation. Merging only a single column from one of the For example, considerIf you are required to merge only "new_val" (without any of the other columns), you can usually just subset columns before merging:If you're doing a LEFT OUTER JOIN, a more performant solution would involve :As mentioned, this is similar to, but faster thanMerging on multiple columnsTo join on more than one column, specify a list for  (or  and , as appropriate).Or, in the event the names are different,Other useful  operations and functionsMerging a DataFrame with Series on index: See this answer.Besides ,  and  are also used in certain cases to update one DataFrame with another. is a useful function for ordered JOINs. (read: merge_asOf) is useful for approximate joins.This section only covers the very basics, and is designed to only whet your appetite. For more examples and cases, see the documentation on , , and  as well as the links to the function specs.Index-based *-JOIN (+ index-column s)SetupTypically, a merge on index would look like this:Support for index namesIf your index is named, then v0.23 users can also specify the level name to  (or  and  as necessary).Merging on index of one, column(s) of anotherIt is possible (and quite simple) to use the index of one, and the column of another, to perform a merge. For example,Or vice versa ( and ). In this special case, the index for  is named, so you can also use the index name with , like this:Besides these, there is another succinct option. You can use  which defaults to joins on the index.  does a LEFT OUTER JOIN by default, so  is necessary here.Note that I needed to specify the  and  arguments since  would otherwise error out:Since the column names are the same. This would not be a problem if they were differently named.Lastly, as an alternative for index-based joins, you can use :Omit  if you need a FULL OUTER JOIN (the default):For more information, see this canonical post on  by @piRSquared.Generalizing: ing multiple DataFramesSetupOftentimes, the situation arises when multiple DataFrames are to be merged together. Naively, this can be done by chaining  calls:However, this quickly gets out of hand for many DataFrames. Furthermore, it may be necessary to generalise for an unknown number of DataFrames. To do this, one often used simple trick is with , and you can use it to achieve a INNER JOIN like so:Note that every column besides the "key" column should be differently named for this to work out-of-box. Otherwise, you may need to use a .For a FULL OUTER JOIN, you can curry  using :As you may have noticed, this is quite powerful—you can also use it to control column names during merge. Simply add more keyword arguments as needed:The alternative: If your column values are unique, then it makes sense to use , this is faster than a two-at-a-time multi-way merge. Multiway merge on unique indexesIf you are merging multiple DataFrames on unique indexes, you should once again prefer  for better performance.As always, omit  for a FULL OUTER JOIN.Multiway merge on indexes with duplicates is fast, but has its shortcomings. It cannot handle duplicates.In this situation,  is the best option, since it can handle non-unique indexes ( calls  under the hood).


Answer URL
https://docs.python.org/3/library/functools.html#functools.reduce
https://docs.python.org/3/library/functools.html#functools.partial
