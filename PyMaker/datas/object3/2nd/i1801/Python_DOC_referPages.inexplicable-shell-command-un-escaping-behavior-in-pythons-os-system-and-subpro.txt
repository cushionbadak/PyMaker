Natural Text
I am perplexed by Python's un-escaping of backslashes in commands passed to  on Ubuntu 18.04 (things work fine on CentOS). Consider this program:When I run it on Ubuntu 18.04, I get this:Note that it outputs one backslash where it should output two, and outputs two backslashes where it should output three or four!However, on my CentOS 7 box things work as expected. On both machines the shell is . Here is the strace output of the python2.7 invocation of the script, just in case: https://gist.githubusercontent.com/mbautin/a97cfb6f880860f5fe6ce1474b248cfd/rawI guess the safest behavior for calling shell commands from Python is to write them to a temporary script file!
While I can agree that the behavior is strange, it is not inexplicable. There is a reason for the behavior, which has nothing to do with Python or . Exactly the same behavior is seen in a C program, using the  call to the OS (Linux) as with your Python program.The reason has to do with your shell, though, but not exactly with . The reason is rather that when calling  or the  family (including  ) with . The documentation states that "On POSIX with shell=True, the shell defaults to /bin/sh." Thus, the shell that invokes your  command is not  even if that is your default shell and the shell from which you are running your script/starting Python.Instead, your command is executed by  of your system. For a long time, this just pointed to  (running in POSIX compliant mode) in almost all Linux versions, however, lately this has changed in some distributions, among them Ubuntu (but not CentOS apparently, since you do not see the same behavior there), which now have  point at  instead:Thus, your script is in fact executed by  instead of . And "for efficiency" (see  at the prompt)  has chosen to internally implement  instead of using  (used by ). Unfortunately, the   is not as potent as  and has a different interpretation of string inputs, namely   does it's escaping of a number of backslash commands, which in effect means it "swallows"one extra backslash for you.It is possible to make  behave in the same way by specifying the  option (see ) but unfortunately, it is not possible to have the  builtin  to not escape backslashes.Now, this is the reason for what you see. A good way to avoid the problem is to not rely on the system shell invocation. If it is a single command, such as  it is best to not invoke a shell at all, removing the  flag. Or, if you need some shell specific functionality, control the invocation of the shell yourself. And, a third way, in this particular case, is to explicitly point to  while executing, as that ensures that the "standard"  is used:Note that when used without  the command should be a  and not a string. This can be shlex.split() as shown.Of these approaches, the first one (direct  invocation) is preferred, due to security concerns, if there is any chance of some parameters coming from untrusted sources. In that case, however,  should also not be used, as it opens up the same security vulnerabilities.


Answer URL
https://docs.python.org/3/library/shlex.html
https://docs.python.org/3/library/subprocess.html#security-considerations
