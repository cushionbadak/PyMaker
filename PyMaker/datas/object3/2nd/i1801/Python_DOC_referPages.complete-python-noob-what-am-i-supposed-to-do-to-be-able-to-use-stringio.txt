Natural Text
I am using Python 3.2.1 and I can't import the  module. I use  and it works, but I can't use it with 's  like this:I get the following error:and when I write  it says
when i write import StringIO it says there is no such module.From Whatâ€™s New In Python 3.0:The  and  modules are gone. Instead, import the   module and use  or  for text and data  respectively..A possibly useful method of fixing some Python 2 code to also work in Python 3 (caveat emptor):Note: This example may be tangential to the main issue of the question and is included only as something to consider when generically addressing the missing  module.  For a more direct solution the the message , see this answer.
In my case I have used:
On Python 3  expects a bytes stream. Use the following:
Thank you OP for your question, and Roman for your answer. I had to search a bit to find this; I hope the following helps others.Python 2.7See: https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.htmlPython 3.5:Aside:dtype="|Sx", where x = any of { 1, 2, 3, ...}:dtypes. Difference between S1 and S2 in Python"The |S1 and |S2 strings are data type descriptors; the first means the array holds strings of length 1, the second of length 2. ..."
You can use the StringIO from the six module:
In order to make examples from herework with Python 3.5.2, you can rewrite as follows :The reason for the change may be that the content of a file is in data (bytes) which do not make text until being decoded somehow.  may be a better name than .
Roman Shapovalov's code should work in Python 3.x as well as Python 2.6/2.7. Here it is again with the complete example:Output:Explanation for Python 3.x: takes a byte stream (a file-like object interpreted as bytes instead of Unicode). takes a byte string and returns a byte stream. , on the other hand, would take a Unicode string and and return a Unicode stream. gets assigned a string literal, which in Python 3.x is a Unicode string. takes the Unicode string  and makes a byte string out of it, thus giving  a valid argument.The only difference for Python 2.6/2.7 is that  is a byte string (assuming  is not used), and then  takes the byte string  and still makes the same byte string out of it. So the result is the same.Since this is one of SO's most popular questions regarding , here's some more explanation on the import statements and different Python versions.Here are the classes which take a string and return a stream: (Python 2.6, 2.7, and 3.x) - Takes a byte string. Returns a byte stream. (Python 2.6, 2.7, and 3.x) - Takes a Unicode string. Returns a Unicode stream. (Python 2.x) - Takes a byte string or Unicode string. If byte string, returns a byte stream. If Unicode string, returns a Unicode stream. (Python 2.x) - Faster version of , but can't take Unicode strings which contain non-ASCII characters.Note that  is imported as , then used as . Either that, or you do  and then use . The module name and class name just happen to be the same. It's similar to  that way.What to use, depending on your supported Python versions:If you only support Python 3.x: Just use  or  depending on what kind of data you're working with.If you support both Python 2.6/2.7 and 3.x, or are trying to transition your code from 2.6/2.7 to 3.x: The easiest option is still to use  or . Although  is flexible and thus seems preferred for 2.6/2.7, that flexibility could mask bugs that will manifest in 3.x. For example, I had some code which used  or  depending on Python version, but I was actually passing a byte string, so when I got around to testing it in Python 3.x it failed and had to be fixed.Another advantage of using  is the support for universal newlines. If you pass the keyword argument  into , it will be able to split lines on any of , , or . I found that  would trip up on  in particular.Note that if you import  or  from , you get  in Python 2.x and the appropriate class from  in Python 3.x. If you agree with my previous paragraphs' assessment, this is actually one case where you should avoid  and just import from  instead.If you support Python 2.5 or lower and 3.x: You'll need  for 2.5 or lower, so you might as well use . But realize that it's generally very difficult to support both 2.5 and 3.x, so you should consider bumping your lowest supported version to 2.6 if at all possible.
try thisfrom StringIO import StringIOx="1 3\n 4.5 8"  numpy.genfromtxt(StringIO(x))


Answer URL
https://docs.python.org/3/library/io.html#binary-i-o
https://docs.python.org/3/library/io.html#text-i-o
