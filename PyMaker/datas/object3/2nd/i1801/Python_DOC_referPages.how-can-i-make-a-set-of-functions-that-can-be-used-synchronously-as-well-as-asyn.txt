Natural Text
Imagine I have a set of functions like this:I want these to be usable synchronously:as well as asynchronously, for example like this:The problem is, of course, that  somehow has to propagate the "context" it's running in (synchronously vs. asynchronously) to .I want to avoid writing an asynchronous variant of each of my functions because that would result in a lot of duplicate code:Is there any way to do this without having to implement an asynchronous copy of all my functions?
Here's my "not-an-answer-answer," which I know that Stack Overflow loves...Is there any way to do this without having to implement an asynchronous copy of all my functions?I don't think that there is.  Making a "blanket translator" to convert functions to native coroutines seems next-to-impossible.   That's because making a synchronous function asynchronous is about more than throwing an  keyword in front of it and a couple of  statements within it.  Keep in mind that anything that you  must be awaitable.Your  illustrates that point.  Synchronous functions will make blocking calls, such as ; asynchronous (native coroutines) will await non-blocking coroutines.  Making this function asynchronous, as you point out, requires not just using , but awaiting .  Now let's say instead of , you're calling a more complex, blocking function.  You build some sort of fancy decorator that slaps a function attribute called , which is a callable, onto the decorated function.  But how does that decorator know how to "translate" the blocking calls within  into their coroutine equivalents, if those are even defined?  I can't think of any magic that would be smart enough to convert all of the calls in a synchronous function to their able counterparts.In your comments, you mention that this is for HTTP requests.  For a real-world example the differences in call signatures and APIs between the  and  packages.  In ,  is an instance method; in ,  is a property.  How could you build something smart enough to know differences such as that?I don't mean to be discouraging--but I think that using threading would be more realistic.
So I found a way to achieve this, but since this is literally the first time I've done anything with  I can't guarantee that this doesn't have any bugs or that it's not a terrible idea.The concept is actually pretty simple: Define your functions like normal asynchronous functions using  and  where necessary, and then add a wrapper around them that automatically awaits the function if no event loop is running. Proof of concept:However, this approach does have its limitations. If you have a synchronous function calling a hybrid function, calling the synchronous function from an asynchronous function will change its behavior:Take care to account for this!


Answer URL
https://docs.python.org/3/glossary.html#term-awaitable
https://docs.python.org/3/library/asyncio-task.html#generator-based-coroutines
https://docs.python.org/3/library/select.html
