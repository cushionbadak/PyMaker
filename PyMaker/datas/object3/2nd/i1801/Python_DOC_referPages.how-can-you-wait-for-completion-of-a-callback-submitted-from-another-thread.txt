Natural Text
I have two Python threads that share some state,  and . At one point,  submits a callback to be run by  on its loop with something like:After this I want to continue doing something else, but I want to make sure that  has been run by  before doing so. Is there any way (besides standard threading synchronization primitives) to make  wait for the completion of the callback? I know  returns a  object that can cancel the task, but I am not sure whether this can be used for waiting (I still don't know much about ).In this case, this callback calls  and cancels the remaining tasks, and after that, in , after  there is a . So for this use case in particular a thread-safe mechanism that allows me to know from  when the loop has been effectively closed would also work for me - again, not involving a mutex/condition variable/etc.I know that  is not meant to be thread-safe, with very few exceptions, but I wanted to know if a convenient way to achieve this is provided.Here is a very small snippet of what I mean in case it helps.I have tried this variation with  but it does not work, instead thread  hangs forever. Not sure if I am doing something wrong or it is because I am stopping the loop.
Callbacks are set and (mostly) forget. They are not intended to be used for something you need to get a result back from. This is why the handle produced only lets you cancel a callback (this callback is no longer needed), nothing more.If you need to wait for a result from an asyncio-managed coroutine in another thread, use a coroutine and schedule it as a task with ; this gives you a  instance, which you can then wait for to be done.However, stopping the loop with  does require the loop to handle one more round of callbacks than it'll actually be able to run; the  returned by  would otherwise not be notified of the state change of the task it scheduled. You can remedy this by running  through  in thread B before closing the loop:This is, of course, slightly hacky and depends on the internals of callback management and cross-threading task scheduling to not change. As the default  implementation stands, running a single noop task is plenty for several rounds of callbacks creating more callbacks being handled, but alternative loop implementations may handle this differently.So for shutting down the loop, you may be better off using thread-based coordination:
Is there any way (besides standard threading synchronization primitives) to make A wait for the completion of the callback?Normally you'd use , as Martijn initially suggested. But your use of  makes the callback somewhat specific. Given that, you are probably best off using the standard thread synchronization primitives, which are in this case very straightforward and can be completely decoupled from the callback implementation and the rest of your code. For example:Instead of using , use . The threading synchronization is there, but completely hidden inside .


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
https://docs.python.org/3/library/asyncio-task.html#asyncio.run_coroutine_threadsafe
https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future
