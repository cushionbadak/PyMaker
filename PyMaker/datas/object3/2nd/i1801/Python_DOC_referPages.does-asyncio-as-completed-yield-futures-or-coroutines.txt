Natural Text
From the  docs:Run awaitable objects in the aws set concurrently. Return an iterator  of Future objects. Each Future object returned represents the earliest  result from the set of the remaining awaitables.I would assume each of these  objects has the methods described in : , , and .  But it appears that the yielded elements are just coroutines, not  objects.  What am I missing?This seems to defeat the description of .  How is the coroutine "completed" if I need to  it?Ultimately, the reason I care about this is because I'd like to let exceptions bubble up as they do in .  Consider adding on one bogus URL that will raise when  is called:What I would like to be able to do is something like this (using the methods of a Future object, but these aren't Future objects at all, which is the problem):
What I would like to be able to do is something like this [...]Perhaps not as convenient, but you should be able to extract the exception with code like this:This [yielding coroutines rather than futures] seems to defeat the description of . How is the coroutine "completed" if I need to await it?It's not. When  was first implemented, asynchronous iterators didn't exist. Without asynchronous iteration there was no way to return the futures as they complete, so  sort of faked it by yielding (immediately) dummy awaitables which one has to await to get the actual result.Even if  yielded actual futures, it wouldn't help with your use case because those futures wouldn't complete without someone awaiting them. To provide the expected semantics of  yielding completed futures,  needs to implement asynchronous iteration, whose equivalent of  can await.The surprising behavior of  has been brought up before, and I have already filed an issue to fix it by providing async iteration. Once it is implemented, your original code will work with just the  changed to .


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed
https://docs.python.org/3/library/asyncio-future.html#asyncio.Future
