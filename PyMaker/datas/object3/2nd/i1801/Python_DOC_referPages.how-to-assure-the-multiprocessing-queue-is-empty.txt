Natural Text
The code below first starts multiple processes. Then it runs a  loop checking the  objects. Lastly, it iterates the processes to check if any alive. After all the processes are completed it  the  loop.Unfortunately, it happens while the  object is not empty. Breaking the loop without getting a data stored in  could be an easy to oversee data loss. How to modify the code logic so it assures the  object is empty before breaking the loop?
synchronization issue, again. when you check a queue find it is empty, there is no guarantee that no new item would come in the future.you could put a sentinel to the queue when a subprocess finishes its job, to notify there will be no more items in the queue. parent process could drain the queue until got the sentinel. this is also the method used by . you could use  as sentinel here:
A working solution is posted below. Instead of running the procs with the  this approach uses  method that starts the processes without blocking.  object is then used to store data which is accessible by  function running by the MainProcess.



Answer URL
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.pool
https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor
https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.cancel_join_thread
