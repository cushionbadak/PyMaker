Natural Text
If I am going to implement a safe resource wrapper in Python, do I need to implement the Dispose Pattern like C#?Here is a demo implementation of what I mean: is a resource wrapper object managed by Python GC, and  is a handle to an external resource that is not managed by Python GC.I want to ensure both managed and unmanaged resource gets freed if user manual closes the wrapper, and, they also gets freed if the wrapper object gets GCed.
No, in Python you should use Context Managers:Note 1: There's this comment in  method:This means  is called by GC,  might be  already GCed, but we donâ€™t knowfor sure, so we do nothing and rely on  GC to free .I'm not sure what you mean by that, but as long as you hold reference to an object (and as long as it isn't a weak reference) it won't be GC'ed.Note 2: What happens if an object that is a context manager is used without  block? Then resource will be released when object is garbage collected - but I wouldn't worry about that. Using context managers is common idiom in python (see any example with ing file). If that's crucial for your application, you can acquire resources in , that way won't be acquired unless in  block.Note 3, about cyclic references: If you have two objects that hold reference to each other, you've formed cyclic reference, so that two object won't be freed by "regular" reference-counting GC. Instead, they are to be collected by generational GC, unless thay happen to have  method.  inhibits GC from collecting objects. See :A list of objects which the collector found to be unreachable but  could not be freed (uncollectable objects). By default, this list  contains only objects with . [1] Objects that have   methods and are part of a reference cycle cause the entire reference cycle to be uncollectable, including objects not necessarily  in the cycle but reachable only from it.Python 3.4 introduced PEP-442, which introduces safe object finalization. Either way, you won't have invalid references. If you have attribute () it will be valid.Takeaway: don't use .


Answer URL
https://docs.python.org/3/library/weakref.html
