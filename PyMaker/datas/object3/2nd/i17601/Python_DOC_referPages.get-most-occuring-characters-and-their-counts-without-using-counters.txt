Natural Text
For example, if I give a string  and , it should return . I have tried it in this way:But for  it was returning the output , in which the count is wrong.
As you want to do this without using , let’s go through your code for a bit first:Apart from the very non-descriptive names (which you should avoid), you can essentially compact that to  to get a list of all characters in the word without duplicates. As  is a string, calling  on it will automatically iterate the string character by character.Next, in your  function you check  although you are explicitely interating over the . So whatever  will be, it will always be in . So you can leave that check out. And then, when you actually increase the count, you increment it by the occurences of —which are all characters in the original word—inside of the passed . As you use the function as a sortkey for the list of (unique) characters of the word, you will essentially count the occurences of every character of the word in the single-character string which represents the current unique character. So with both  and  being a single character, you actually increment the  by one, if —albeit in a very weird way. And next—still within the loop over the original characters—you append that count to  and return the count.So what happened so far? You looked at the very first character of  and checked if  equals the character. If that’s the case, you increment  from  to , otherwise you leave it at . And then you just keep that  and return from the function. As such, you never actually look at the other characters of the word, which explains why your count is always 1 or 2.If you kept the loop running, and only returned (and appended the count) afterwards then it works correctly (i.e. remove two indentation levels from those two lines). However, as you start with , you’re always one too many, so you should start at 0.Moving on, you now sort both  and  so by the same values so they line up. By construction of the lists, this luckily works, but it still is somewhat weird. You then zip the sorted lists up and reverse the order. And then you do something which I don’t really understand: You take the list which is already reverse-sorted by the character count, and sort it reversed by the negative count. Reverse-sorting the negative count is essentially normal-sorting by the positive count; so you sort it ascending. This will give you the inverse result of what you want, and isn’t actually necessary either, as the list is already sorted after being zipped.Anyway, there is quite a lot to improve with your code. First of all, even if you are not using a counter, you should still use a dictionary to store the counts. I assume that you may not use a  either, so we’ll just build the functionality on our own. Instead of creating a list of all the characters in the word and then counting how often that character occurs in the word, we will just loop once through the word and keep note of every character we see:This is already all we need to do to actually count the characters. For that example word, we would now get this as our dictionary: .So now, we just need to find the  biggest elements from there. Your  idea was actually quite good for this; so let’s create a list of tuples from the dict which we can then sort:And now we already have our final list ready, which we then can get the first  elements from to get our result, .In total, this is what our function looks like:Used like this, and compared to :


Answer URL
