Natural Text
The file structure looks like this:How can I make them into groups like this?The total files could be tens of thousands, I want the speed . There are not only jpg and tif files, could be other formats.
Use  to walk the tree. Since that doesn't give you the file sizes, you will need to call  on each one.Next, apparently you want to group by extension first, then by base filename (where two filenames go together if the only difference between them is that some numerical part is off by 1), but sort the groups by filename. Generally, the easiest way to group things is to sort them, then group by adjacency via the  function, and you can always sort them back afterward.I'm not sure what your actual grouping key is supposed to be, because I can't think of anything sensible that would separate 2004 from 0001-2000, but not separate it from 2501. Likewise, I'm not sure what the rule is that would give you 2004-2845 despite the gaps. So I'll leave those parts to you.So:In some cases, there is no obvious grouping key function, but there is an obvious way to tell whether two adjacent values count as being part of the same group. If so, write that as an old-style  function, like this:Then you can use the same  function described in the Sorting HOWTO:However you do this, it will probably turn out that the slowest part by far is calling  on every file. And that's a shame, because  may already have that stat information, but it never gives it to you.To optimize this, you can go directly to native APIs that give you the information as efficiently as possible. Most modern *nix platforms (including OS X and non-ancient linux) have , which is like a souped-up  implemented in C, which can optionally stat all the files for you. Older *nixes should at least have  or . Windows has , which is more like a souped-up —it gives you all kinds of info on each file, including sizes, very fast, but it doesn't recurse into subdirectories, so you have to do that manually.If your comparison is supposed to make  and  the same, but not  and  or  and , obviously we need to break each name down into pieces. And the middle one needs to be converted to a number, so that  and 0010` will be adjacent (because they obviously aren't as strings). I think what you want is this:*So, for example,  will break down into , , and . Play with this function and make sure it's doing what you actually want.Next, how do we use this for a comparison function? Well, it's almost a normal lexicographical comparison, except that in the middle bit, if the left one is one less than the right it counts as equal. So:(We don't actually need the full -1/0/1 return from an old-style  function, just nonzero/0/nonzero… but it's just as easy, and probably more readable, to do it.)Again, call  on various pairs of filenames to make sure they're doing what you want.And you will probably want some error handling in here. As it standard,  fails to match because you gave it, say, , you'll get an . But you should be able to figure that out.One last thing: I can't remember if  checks each new value against the last value in the group, or the first. If it's the latter, this  won't work. You could try to write a stateful comparator instead, but there's a much easier solution:  gives you the equivalent Python source code, and it's not that complicated, so you can just copy it and paste it into your code and change it to remember the most recent value in the group.Finally, if this whole deal with iterators and groupby and so forth all sounds like Greek to you, don't try to just bang on the code until it works. Generator Tricks for System Programmers will teach you Greek, and all kinds of problems like this one will be easier for you for the rest of your life. (Well, until you're forced to write in another language that doesn't have generators…)* I'm pretty sure you don't need , because Python 2.7 and 3.x will not interpret  as octal… but since I have to look it up to be sure, making it explicit seems like a good idea for readability.
The majority of the work is getting your file sizes into a human readable format. See if this works out for youNote that this treats 1KB = 1000B and not 1KB = 1024BSo depending on the system you're on, you might want to consider changing that.
@abarnert: The following code it derived from your blog: Grouping into runs of adjacent values(links: http://stupidpythonideas.blogspot.com/2014/01/grouping-into-runs-of-adjacent-values.html)I try python2.6.6 in Win7 and python2.6.6 in CentOS 6.5, the problem is same. Because there is no itertools.cmp_to_key() in this python 2.6, I revized your code a little bit, hopefully, the problem does not come from my revise.


Answer URL
