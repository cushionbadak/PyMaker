Natural Text
This question already has an answer here:What do (lambda) function closures capture?                    6 answers                Local variables in nested functions                    3 answers                I am trying to dynamically create some methods to a class but when I create an object of this class and access the properties, I always get the last value.UPDATEI was able to make it work using a function to create the method:
This has nothing to do with using . It's explained in the official FAQ as Why do lambdas defined in a loop with different values all return the same result?.When you do this:… each  is a closure over the  variable.* This means that, when you call that , it will return the current value of  within its defining scope, not the value of  at the time at which the closure was constructed. At the end of the loop, 's value is , so that's what all of your properties return.You can get around this by (among other solutions**) using the "default value hack":Now, each property has a parameter named , whose default value is the value of  at function definition time. When called (without supplying a  argument), the body ends up with a local variable  with that value, instead of a closure variable  referring to the non-local scope.* Actually, it's not technically a closure, because the defining scope is global. But it acts the same as if it were done inside another scope.** There's also the JavaScript idiom of creating a new scope to define the function within, , or , or creating a callable object instead of a function, or… But, despite having the word "hack" in the name, the "default value hack" is a well-known Python idiom, enshrined in the docs and used within the stdlib, and it's usually the best answer, unless you have some other reason for another scope or a  or a custom callable.


Answer URL
