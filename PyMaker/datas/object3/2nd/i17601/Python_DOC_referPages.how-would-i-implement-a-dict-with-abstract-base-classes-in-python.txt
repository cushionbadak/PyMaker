Natural Text
This question already has an answer here:How to “perfectly” override a dict?                    5 answers                I attempted to implement a mapping in Python by using the abstract base class, MutableMapping, but I got an error on instantiation. How would I go about making a working version of this dictionary that would emulate the builtin  class, in as many ways as possible, to be clear, with Abstract Base Classes?A good answer will demonstrate how to make this work, specifically without subclassing  (a concept that I am quite familiar with).
How would I implement a dict with Abstract Base Classes?A good answer will demonstrate how to make this work, specifically  without subclassing dict.Here's the error message: It turns out that one must implement them to use the Abstract Base Class (ABC), .ImplementationSo I implement a mapping that works like a dict in most respects that uses the object's attribute reference dict for the mapping. (Delegation is not the same as inheritance, so we'll just delegate to the instance , we could use any other ad-hoc mapping, but you don't seem to care about that part of the implementation. It makes sense to do it this way in Python 2, because MutableMapping doesn't have  in Python 2, so you're creating a  either way. In Python 3, you could avoid dicts altogether by setting .)DemonstrationAnd to demonstrate the usage:And for ensuring the dict API, lesson learned is that you can always check for :And while a dict is always going to be an instance of a MutableMapping due to registration on collections import, the reverse is not always true:After performing this exercise, it is clear to me that using Abstract Base Classes provides only the guarantee of a standard API for users of the class. In this case, users assuming a MutableMapping object will be guaranteed the standard API for Python.Caveats:The  class constructor method is not implemented.One could mask the builtin dict methods like  or It's fairly simple to unmask again:But I wouldn't use this code in production.Demonstration without a dict, Python 3:
At the LeastYou need to implement in your subclass, all the abstract methods that you inherit from MutableMappingMoreoverYou need to provide a data structure to store your mapping (hash, AVL, Red Black), and a way to construct your Dictionary
The best way to demonstrate this without actually using a  anywhere is probably to implement something dead simple, very different from , and not completely useless. Like a fixed-sized mapping of fixed-size  to same-fixed-size . (You might use this for, e.g., a routing table—it'll be much more compact than a  mapping unpacked keys to unpacked values, although obviously at the cost of speed and flexibility.)A hash table is just an array of  tuples. Since the whole point of this is packing data in, we cram those into a , meaning we can just use a big  for storage. To mark a slot empty, we set its hash value to —which means we need to "escape" any real  by turning it into a , which is stupid, but simpler to code. We'll also use the dumbest possible  algorithm for simplicity.As the error message says, you need to provide implementations for the abstract methods , , , , and . However, a better place to look is the docs, which will tell you that if you implement those five methods (plus any other methods required by the base classes, but as you can see from the table there are none), you'll get all the other methods for free. You may not get the most efficient possible implementations of all of them, but we'll come back to that.First, let's deal with . Normally people expect this to be O(1), which means we need to keep track of it independently, updating it as needed. So:Now,  just probes until it finds the desired key or reaches the end:And  does the same thing, except it empties out the slot if found, and updates . is a bit trickier—if found, we have to replace the value in the slot; if not, we have to fill an empty slot. And here we have to deal with the fact that the hash table may be full. And of course we have to take care of :And that leaves . Just as with a , we don't have any particular order, so we can just iterate the hash table slots and yield all the non-empty ones:While we're at it, we might as well write a . Note that we can use the fact that we get  for free:However, note that the default  just creates an , and if you track that through the source, you'll see that it iterates  and looks up each value. You can obviously do better if the performance matters:And likewise for , and possibly other methods.
The whole idea of an abstract base class is that it has some members, (pure virtual members in C++ terms), that your code has to supply - in C++ these are the Pure Virtual members and other Virtual members you may override.Python differs from C++ in that all members of all classes are Virtual and may be overridden, (and you can add members to all classes and instances) but Abstract Base classes have some required missing classes these are the equivent to the C++ pure virtual.Having got that out of the way you just need to supply the missing members to be able to create an instance of your derived class.  For an example of the sort of thing you are trying to do see the accepted answer here but rather than use a dict within the class you will have to provide the methods that it provides yourself.
With  as base class you should create this methods yourself in your class: .To create custom dict class you can derive it from dict:


Answer URL
