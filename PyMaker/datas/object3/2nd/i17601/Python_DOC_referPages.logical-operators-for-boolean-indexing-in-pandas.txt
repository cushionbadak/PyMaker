Natural Text
I'm working with boolean index in Pandas.The question is why the statement:works fine whereasexists with error?Example:
When you sayYou are implicitly asking Python to convert  and  to boolean values. NumPy arrays (of length greater than 1) and Pandas objects such as Series do not have a boolean value -- in other words, they raise when used as a boolean value. That's because its unclear when it should be True or False. Some users might assume they are True if they have non-zero length, like a Python list. Others might desire for it to be True only if all its elements are True. Others might want it to be True if any of its elements are True. Because there are so many conflicting expectations, the designers of NumPy and Pandas refuse to guess, and instead raise a ValueError.Instead, you must be explicit, by calling the ,  or  method to indicate which behavior you desire.In this case, however, it looks like you do not want boolean evaluation, you want element-wise logical-and. That is what the  binary operator performs:returns a boolean array. By the way, as alexpmil notes, the parentheses are mandatory since  has a higher operator precedence than .Without the parentheses,  would be evaluated as  which would in turn be equivalent to the chained comparison . That is an expression of the form .The use of  with two Series would again trigger the same  as above. That's why the parentheses are mandatory.
TLDR; Logical Operators in Pandas are ,  and , and  parentheses  is important!Python's ,  and  logical operators are designed to work with scalars. So Pandas had to do one better and override the bitwise operators to achieve vectorized (element-wise) version of this functionality. So the following in python ( and  are expressions which evaluate to a boolean result)... ...will translate to...for pandas.If in the process of performing logical operation you get a , then you need to use parentheses for grouping:For example,And so on.Boolean Indexing: A common operation is to compute boolean masks through logical conditions to filter the data. Pandas provides three operators:  for logical AND,  for logical OR, and  for logical NOT. Consider the following setup:Logical ANDFor  above, say you'd like to return all rows where A < 5 and B > 5. This is done by computing masks for each condition separately, and ANDing them. Overloaded Bitwise  OperatorBefore continuing, please take note of this particular excerpt of the docs, which stateAnother common operation is the use of boolean vectors to filter the  data. The operators are:  for ,  for , and  for . These  must be grouped by using parentheses, since by default Python will  evaluate an expression such as  as , while the desired evaluation order is .So, with this in mind, element wise logical AND can be implemented with the bitwise operator : And the subsequent filtering step is simply,The parentheses are used to override the default precedence order of bitwise operators, which have higher precedence over the conditional operators  and . See the section of Operator Precedence in the python docs. If you do not use parentheses, the expression is evaluated incorrectly. For example, if you accidentally attempt something such as It is parsed as Which becomes, Which becomes (see the python docs on chained operator comparison),Which becomes, Which throwsSo, don't make that mistake!1Avoiding Parentheses GroupingThe fix is actually quite simple. Most operators have a corresponding bound method for DataFrames. If the individual masks are built up using functions instead of conditional operators, you will no longer need to group by parens to specify evaluation order:See the section on Flexible Comparisons.. To summarise, we haveAnother option for avoiding parentheses is to use  (or ):I have extensively documented  and  in Dynamic Expression Evaluation in pandas using pd.eval().Allows you to perform this operation in a functional manner. Internally calls  which corresponds to the bitwise operator.You won't usually need this, but it is useful to know.Generalizing:  (and )Another alternative is using  , which also does not need parentheses grouping: is a ufunc (Universal Functions), and most ufuncs have a  method. This means it is easier to generalise with  if you have multiple masks to AND. For example, to AND masks  and  and  with , you would have to do However, an easier option is This is powerful, because it lets you build on top of this with more complex logic (for example, dynamically generating masks in a list comprehension and adding all of them):1 - I know I'm harping on this point, but please bear with me. This is a very, very common beginner's mistake, and must be explained very thoroughly. Logical ORFor the  above, say you'd like to return all rows where A == 3 or B == 7.Overloaded Bitwise  If you haven't yet, please also read the section on Logical AND above, all caveats apply here.Alternatively, this operation can be specified with Calls  under the hood.For two conditions, use :For multiple masks, use :Logical NOTGiven a mask, such as If you need to invert every boolean value (so that the end result is ), then you can use any of the methods below.Bitwise  Again, expressions need to be parenthesised.This internally calls But don't use it directly.Internally calls  on the Series.This is the numpy variant.Note,  can be substituted for ,  with , and  with .
Logical operators for boolean indexing in PandasIt's important to realize that you cannot use any of the Python logical operators (,  or ) on  or s (similarly you cannot use them on s with more than one element). The reason why you cannot use those is because they implicitly call  on their operands which throws an Exception because these data structures decided that the boolean of an array is ambiguous:I did cover this more extensively  in my answer to the "Truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()" Q+A.NumPys logical functionsHowever NumPy provides element-wise operating equivalents to these operators as functions that can be used on , , , or any other (conforming)  subclass: has  has  has  which has no Python equivalent but is a logical "exclusive or" operation So, essentially, one should use (assuming  and  are pandas DataFrames):Bitwise functions and bitwise operators for booleansHowever in case you have boolean NumPy array, pandas Series, or pandas DataFrames you could also use the element-wise bitwise functions (for booleans they are - or at least should be - indistinguishable from the logical functions):bitwise and:  or the  operatorbitwise or:  or the  operatorbitwise not:  (or the alias ) or the  operatorbitwise xor:  or the  operatorTypically the operators are used. However when combined with comparison operators one has to remember to wrap the comparison in parenthesis because the bitwise operators have a higher precedence than the comparison operators:This may be irritating because the Python logical operators have a lower precendence than the comparison operators so you normally write  (where  and  are for example simple integers) and don't need the parenthesis.Differences between logical and bitwise operations (on non-booleans)It is really important to stress that bit and logical operations are only equivalent for boolean NumPy arrays (and boolean Series & DataFrames). If these don't contain booleans then the operations will give different results. I'll include examples using NumPy arrays but the results will be similar for the pandas data structures:And since NumPy (and similarly pandas) does different things for boolean (Boolean or “mask” index arrays) and integer (Index arrays) indices the results of indexing will be also be different:Summary tableWhere the logical operator does not work for NumPy arrays, pandas Series, and pandas DataFrames. The others work on these data structures (and plain Python objects) and work element-wise.However be careful with the bitwise invert on plain Python s because the bool will be interpreted as integers in this context (for example  returns  and  returns ).


Answer URL
https://docs.python.org/3/reference/expressions.html#operator-precedence
https://docs.python.org/3/reference/expressions.html#operator-precedence
https://docs.python.org/3/reference/expressions.html#comparisons
https://docs.python.org/3/library/operator.html#operator.and_
https://docs.python.org/3/library/operator.html#operator.or_
