Natural Text
I am making a program the downloads a large file, and I have added in a feature with which the program determines what percentage has been downloaded and informs the user each time another 10% was downloaded and at what time (ie, ) When I was testing the program on smaller files, however, I noticed it was far less accurate. Here is a sample program I made:This downloads Fport, a tool I was going to download anyway. Anyway, I got this output:Which I thought was exactly what I wanted. I was about to put it in when I noticed a little error. 8192 doesn't go into 57843. Not 8 times. I plugged it into a calculator and discovered that, in fact, it goes in approximately 7 times. Which is a rather large difference, considering. This disconnect affects bigger files less, but it is still there. Is this some kind of metadata or header? If so, it's rather large, isn't it? Is there a way I can account for it (ie, is it always about 16000 bytes)?
So, if you look at the  (CPython around 2.7) code it becomes clear why this is the case:In the last line, the reporthook is told that  was read, not , which would probably be more accurate. I'm not sure why this is the case, i.e. if there's a good reason or if it's a minor bug in the library. You could ask on the Python mailers and/or file a bug of course.Note: I think it's fairly common to read data in fixed-sized blocks, see for example . There, the return value may not be the same as the number of bytes requested to be read if an EOF (end of file) was encountered, which is similar in the Python  API.
The documentation explains that  is called once per "chunk", with a chunk number and total size. will not try to make chunk sizes exactly equal; it will try to make chunk sizes a nice power of 2 like 8192, because that's generally fastest and simplest.So, what you want to do is use the actual bytes for calculating percentage, not the chunk numbers.The  interface doesn't give you an easy way to get the actual bytes. Counting blocks only works if you assume every  (but the last) actually returns n bytes, which isn't guaranteed.  only works (on most platforms) if you assume  uses unbuffered files or flushes before every call, which again isn't guaranteed.This is one of the many reasons not to use the "legacy interface".The high-level interface (just calling  and using the  as a file object) may look like it's providing less information than , but if you read  Restrictions, it makes it pretty clear that this is an illusion. So, you could just use , in which case you're just copying from one file object to another instead of using a limited callback interface, so you can use any file-object-copying functions you like, or write your own:If you really want something that hooks into the lower-level guts of , then  is not that something; it just fakes it. You'll have to create your own opener subclass and the whole mess that goes with it.If you want an interface that's almost as simple as  but provides as much functionality as a custom opener… well,  doesn't have that, which is why third-party modules like  exist.
's high-level interface really isn't suitable for what you're trying to do. You can use the lower-level interfaces… but really, this is one of those things that the third-party library  makes an order of magnitude simpler. (You don't have to use —the various  wrappers, for example, also make it easier than . But  is the most -like and the simplest of the third-party alternatives.) can work like  and pull everything down automatically, but by just adding  you can take control of pulling the data. There are a few different interfaces to it (decoded Unicode lines, bytes lines, raw data off the socket, etc.), but  is probably the one you want—it gives you chunks of content on demand, buffering appropriately, transparently mapping chunked transfer mode to flat transfers, dealing with 100 continue, … basically everything HTTP can throw at you. So:Adding progress still needs to be done manually. But since you're pulling chunks rather than having them saved to a file behind your back, you know exactly how many bytes you've seen. And, as long as the server has supplied a  header (which some servers won't do in some cases, but there's nothing you can do about that except deal with it), it's easy:


Answer URL
