Natural Text
I got fed up last night and started porting PyVISA to Python 3 (progress here: https://github.com/thevorpalblade/pyvisa).I've gotten it to the point where everything works, as long as I pass device addresses (well, any string really) as an ASCII string rather than the default unicode string (For example, HP = vida.instrument(b"GPIB::16") works, whereasHP = vida.instrument("GPIB::16") does not, raising a ValueError.Ideally, the end user should not have to care about string encoding.Any suggestions as to how I should approach this? Something in the ctypes type definitions perhaps?As it stands, the relevant ctypes type definition is:
, like most things in Python 3, intentionally doesn't automatically convert between unicode and bytes. That's because in most use cases, that would just be asking for the same kind of mojibake or  disasters that people switched to Python 3 to avoid.However, when you know you're only dealing with pure ASCII, that's another story. You have to be explicit—but you can factor out that explicitness into a wrapper.As explained in Specifying the required argument types (function prototypes), in addition to a standard  type, you can pass any class that has a  classmethod—which normally returns an instance of some type (usually the same type) with an  attribute, but can also just return a native -type value instead.This may not be the exact rule you want—for example, it'll fail on  (just as  will) even though that could be converted quietly to … but then you wouldn't want to implicitly convert an  to . Anything, whatever rule you decide on should be easy to code.Here's an example (on OS X; you'll obviously have to change how  is loaded for linux, Windows, etc., but you presumably know how to do that):Obviously you can catch the exception and raise a different one if those aren't clear enough for your use case.You can similarly write a , or an  class factory, or whatever else you need for some particular library and stick it in the  the same way.If you also want to auto-decode return types, see Return types and .One last thing: When you're sure the data are supposed to be UTF-8, but you want to deal with the case where they aren't in the same way Python 2.x would (by preserving them as-is), you can even do that in 3.x. Use the aforementioned  as your argtype, and a decoder errcheck, and use . See here for a complete example.


Answer URL
