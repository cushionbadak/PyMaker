Natural Text
PrefaceI have a test where I'm working with nested iterables (by nested iterable I mean iterable with only iterables as elements). As a test cascade considerE.g.  may be simple identity functionand contract is simply checks that flattened iterables have same elementsBut if some of  elements is an iterator, it may be exhausted since  is making shallow copies, not deep ones, i.e. for given  and  next statementleads to predictableProblemHow to deep copy an arbitrary nested iterable?NoteI'm aware of  function, but it won't work for file objects.
Naive solutionStraightforward algorithm would be Perform elementwise copying of original nested iterable.Make  copies of elementwise copy.Obtain coordinates related to each independent copy.which may be implemented likePros:quite easy to read & explain.Cons:if we wanted to extend our approach for iterables with greater nesting level (like iterable of nested iterables and so on) this approach doesn't look helpful.We can do better.Improved solutionIf we look at  function documentation, it contains Python recipe, which with help of  decorator can be rewritten likePros:handles nesting on deeper levels or even mixed elements like both iterables and non-iterables on the same level,may be extended for user-defined structures (e.g. for making independent deep copies of them).Cons:less readable (but as we know "practicality beats purity"),provides some overhead related to dispatching (but it's ok since it is based on dictionary lookup which has  complexity).TestPreparationLet's define our nested iterable as followsSince iterators creation says nothing about underlying copies performance, let's define function for iterators exhausting (described here)TimeUsing  packageI have on my laptop with Windows 10 x64 in Python 3.5.4MemoryUsing  packagefor "naive" approach andfor "improved" one.Note: I've made different runs of script because making them at once won't be representative since second statement will reuse previously created under-the-hood  objects.ConclusionAs we can see both functions have similar performance, but the last one supports deeper levels of nesting and looks pretty extensible.AdvertisementI've added "improved" solution to  package from  version which can be used likeIt is property-based tested using  framework, so we may be sure that it works as expected.
Addressing your question: How to deep copy a nested iterable?You can use  from the standard library:Update@Azat Ibrakov said: you are working with sequences, try to deepcopy a file object for example (hint: it will fail)No, deepcopy on a file object, won't fail, you can deep copy a file object, demonstration:Prints:The problem is in the concept.According to Python Iterator protocol, the items contained by some container are obtained executing the  function see the docs here.You won't have all items of an object that implements the iterator protocol (as file objects) until you traverse the whole iterator (execute  until StopIteration exception is raised).That's because there is no way you can tell for sure the result of executing the  ( for Python 2.x) method of an iteratorSee the following example:Again you could:A file object is an especial case here, there are file handlers involved, before, you see you can deepcopy a file object, but it will have  state.Alternative.You could call  on your iterables, that will automatically evaluate iterables an then you will be able to test again THE ITERABLE'S CONTENT. Returning to files:So, resumingYou can deepcopy nested iterables but, you can't evaluate iterables while they are being copied, it just has no sense (remember ). If you need to test on the iterables CONTENT you need to evaluate them.


Answer URL
https://docs.python.org/3/library/copy.html#copy.deepcopy
https://docs.python.org/3/library/itertools.html#itertools.tee
https://docs.python.org/3/library/functools.html#functools.singledispatch
