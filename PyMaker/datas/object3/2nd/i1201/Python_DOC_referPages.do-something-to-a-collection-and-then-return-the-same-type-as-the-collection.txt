Natural Text
I want to apply a function  to a collection  but keep its type. If I use , I get a 'map object':If I know that  is something like a  or  I can force it to have the same type:However, that quickly breaks down for  (which I am currently in a habbit of using) -- because to my knowledge  needs to be constructed with unpack syntax or by calling its  function. Also,  is const, so I cannot iterate over all entries and just change them.Further problems arise from use of a .Is there a generic way to express such an  function that works for everything that is iterable?
Looks like a perfect task for  decorator:after that  function can be simply used likeI'm not aware of what is desired behavior for  objects though, but the greatness of this approach that it is easy to extend.
I have a hunch you're coming from Haskell -- is that right? (I'm guessing because you use  and  as variable names.) The answer to your question in Haskell would be "yes, it's called , but it only works with types that have a defined Functor instance." Python, on the other hand, has no general concept of "Functor." So strictly speaking, the answer is no. To get something like this, you'd have to fall back on other abstractions that Python does provide. ABCs to the rescueOne pretty general approach would be to use abstract base classes. These provide a structured way to specify and check for particular interfaces. A Pythonic version of the Functor typeclass would be an abstract base class that defines a special  method, allowing individual classes to specify how they are to be mapped. But no such thing exists. (I think it would be a really cool addition to Python though!)Now, you can define your own abstract base classes, so you could create a Functor ABC that expects a  interface, but you'd still have to write all your own functorized subclasses of , , and so on, so that's not really ideal.A better approach would be to use the existing interfaces to cobble together a generic definition of mapping that seems reasonable. You'd have to think pretty carefully about what aspects of the existing interfaces you'd need to combine. Just checking to see whether a type defines  isn't enough, because as you've already seen, a definition of iteration for a type doesn't necessarily translate into a definition of construction. For example, iterating over a dictionary only gives you the keys, but to map a dictionary in this precise way would require iteration over items.Concrete examplesHere's an abstract base method that includes special cases for  and three abstract base classes -- , , and . It will behave as expected for any type that defines any of the above interfaces in the expected way. It then falls back to the generic behavior for iterables. In the latter case, the output won't have the same type as the input, but at least it will work. I've defined this as an ABC because that way you can create new classes that inherit from it. But you can also just call it on an existing instance of any class and it will behave as expected. You could also just use the  method above as a stand-alone function.The cool thing about defining an ABC is that you can use it as a "mix-in." Here's a  derived from a  namedtuple:You could also modify this approach slightly in light of Azat Ibrakov's answer, using the  decorator. (It was new to me -- he should get all credit for this part of the answer, but I thought I'd write it up for the sake of completeness.)This would look something like the below. Notice that we still have to special-case s because they break the tuple constructor interface. That hadn't bothered me before, but now it feels like a really annoying design flaw. Also, I set things up so that the final  function uses the expected argument order. (I wanted to use  instead of  because "Mappable" is a more Pythonic name than "Functor" IMO. But  is already a built-in library! Darn.)A few tests:A final note on breaking interfacesNeither of these approaches can guarantee that this will work for all things recognized as s, and so on, because the ABC mechanism doesn't check function signatures. This is a problem not only for constructors, but also for all other methods. And it's unavoidable without type annotations. In practice, however, it probably doesn't matter much. If you find yourself using a tool that breaks interface conventions in weird ways, consider using a different tool. (I'd actually say that goes for s too, as much as I like them!) This is the "consenting adults" philosophy behind many Python design decisions, and it has worked pretty well for the last couple of decades.


Answer URL
https://docs.python.org/3/library/functools.html#functools.singledispatch
https://docs.python.org/3/library/collections.abc.html#module-collections.abc
