Natural Text
I come across this code from one of my friends. It is a test for overiding comparison methods in Python. When i ran the code i got this: TrueTrueTrueand this: "TypeError: '<' not supported between instances of 'A' and 'B'"If that is the case, why the same error did not happen with "a1 == b1"? 
You don't need to implement  on  if comparison doesn't make sense for  normally;  can do all the heavy lifting for comparisons between  and , but you need to implement the reflected comparison operators for this to work.The problem here is that  doesn't implement , so Python will execute  by using the reflected operator from , making the line test . But you didn't implement  in , so there is no way to reflect the operation.The simplest fix (recommended in general if you implement any of the comparison operations) is to use  to expand the single implemented operator to the whole rich comparison suite:That's it; your code will just work, as that decoration will ensure  is defined in terms of /, so the attempt to flip the comparison will succeed.You could equivalently define each of the operations one by one, e.g.:but that's tedious and error-prone; use .The  test worked just fine because equality is reflexive, so the same overload works in either direction when the other operand doesn't implement it; Python tries  and finds it doesn't work, so it tries , since  is logically equivalent to . It's only rich comparisons where the reflected operation uses a different method.
You need to define  in class  too:And, of course, the same will remain true for the rest of operators. The reason of why that happens is because in  the method called is  and in  the method called is . The former method is defined but not the latter.Btw, you were calling 's contructor in 's constructor. I assume that you want a  to be also an , so  inherits from . Thats the reason why my code says .
So I changed you code to add  statements to the  method, like so:and the results were this:So even though you only wrote a  method for the  class, it was used when comparing in the reversed order, . This (I believe) is a feature of the Python language that assumes equality operators are reflexive, i.e.  and  should have the same result.However, this property does not apply to the  operator in this case, because  is different from .


Answer URL
https://docs.python.org/3/library/functools.html#functools.total_ordering
