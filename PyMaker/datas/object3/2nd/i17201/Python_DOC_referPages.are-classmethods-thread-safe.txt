Natural Text
I am working on a class which operates in a multithreaded environment, and looks something like this (with excess noise removed):My concern is that two threads might call  or  at the same time, or that a subclass might try to do something stupid with  in one of these functions.  I could use  instead of , but calling  would become a lot more complicated, especially if a subclass reimplements one of these but not the other.  So my question is this:  Is the above class thread-safe, or is there a potential problem with using classmethods like that?
Whether a method is thread safe or not depends on what the method does.Working with local variables only is thread safe. But when you change the same non local variable from different threads, it becomes unsafe. seems to modify only the given object, which is independent from any other object in the list, so it should be thread safe.If the same object is in the list several times, you may have to think about making the object thread safe. That can be done by using  in every method which modifies the object.Anyway, what you are doing here is using processes instead of threads. In this case the objects are pickled and send through a pipe to the other process, where they are modified and send back. In contrast to threads processes do not share memory. So I donâ€™t think using a lock in the class-method would have an effect.http://docs.python.org/3/library/threading.html?highlight=threading#module-threading
There's no difference between classmethods and regular functions (and instance methods) in this regard.  Neither is automagically thread-safe.If one or more classmethods/methods/functions can manipulate data structures simultaneously from different threads, you'd need to add synchronization protection, typically using s.
Both other answers are technically correct in that the safety of  depends on what happens inside the function. But the more precise answer is that the call itself is safe. In other words if and are a pure functions, then your code is safe. Any unsafe-ness would be due to them not being pure functions (e.g. relying on or affecting a shared variable during execution)As shx2 mentioned, classmethods are only "in" a class visually, for grouping. They have no inherent attachment to any instance of the class. Therefore this code is roughly equivalent in functioning:A further note on concurrency given the other answers: is easy to understand, but should be your last resort. In naive implementations it is often slower than completely linear processing. Your code will usually be faster if you can use things like , , or  to transfer information instead. is the new hotness in python3. It's a bit more difficult to get right but is generally the fastest method. If you want a great walkthrough modern concurrency techniques in python check out core developer Raymond Hettinger's Keynote on Concurrency. The whole thing is great, but the downside of is highlighted starting at t=57:59.


Answer URL
