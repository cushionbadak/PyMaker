Natural Text
I want to get the only Non-None element from this list:I've triedBut the result isDeleting only the None that are not inside of any list. Is there any way to clean the whole list? so the output is
I'll break this down for you, first starting with generators. The  keyword is sister to , but with much different functionality. Both are used to bring values out of a function into its calling scope, but  allows you to jump back into the function afterwards! As an example, below is a generator that accepts a list full of numbers and produces the square for each number in the list.Generators are one-time use, however. As you can see, after I reached the end of the generator, it threw an exception . If I built it again and ran through it with a loop, then tried to run through it AGAIN...It doesn't do anything the second time. The generator is exhausted. That's the downside -- the upside is that it's generally much faster and more memory-efficient to use generators instead of lists. also allows you to use another keyword: . That's what I did there in case of a nested list ( just means that the element has an attribute , which means it can be iterated upon using something like a  loop). You give  another generator, and it yields each element from THAT generator in turn. For example:Here's what it does in turn:So basically the code above says (in pseudocode):When you call it, it builds a generator that can be iterated upon. To make it into a formal list, you'll have to do , but in most cases you don't need that.Is that any clearer?
Another slightly more modular approach:A generic  function is something you should keep in your toolbox, since (so far) it's not something you can find in the standard library, and it comes up occasionally.
Just for fun, how about:This will return a  with only the  element present. It will generalize to return a  with any non- element.In Python 3.x I think you swap  for  and it works the same. is designed to flatten a  of s for iteration.  can work directly on the  returned.  gets rid of elements that match the predicate specified by the  function. Note that if you have strings in ,  will essentially break the strings up into individual elements. If that is a problem for you, see this other SO post.Another implementation which avoids the problem of non-iterables at the base level:I'm told this may not work in Python 3 because of how  is implemented there. Anyway I'm only posting these ideas so that you are aware of functionality already available in the Python standard library under . Have fun learning Python!


Answer URL
