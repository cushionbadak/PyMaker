Natural Text
My Python script is crashing. To debug it, I ran it in interactive mode At this point, I would like to inspect the variable . I triedAlas  is not in scope (though  is). That's frustrating. How can I inspect the variable? Is there a more useful version of  that keeps what's in scope at the crash (rather than the top level)?Code used for  above. Needless to say, this is a simplification. 
To drop to a debugger only if there is an exception you could define a custom excepthook:Running the script drops you into pdb and in the frame which raised the exception:If defining the excepthook seems like too much code, you could tuck it away in autility module, such as utils_debug.py:and then you would only need to addto your .Or, if you are using IPython, you could use the %pdb magic function (which drops you into  when there is an exception). It is unclear why inspecting   at the pdb prompt is giving you a NameError. (A runnable example would be very useful.) You might try using  (backtrace) to inspect the frame stack. If  is defined in a different frame than the one  is currently in, you might be able use  (up) to go up to the frame where  is defined.
According to the Python docs https://docs.python.org/3.4/library/pdb.html can also be invoked as a script to debug other scripts. For example: . When invoked as a script, pdb will automatically enter post-mortem debugging if the program being debugged exits abnormally. This isn't entirely accurate. It actually enters debugging at the first line. However if you type  it will then continue to the crashAt this point you can type  to inspect the variable.Wahey!
A simple alternative is to use cgitb module.Now the traceback itself prints the value of the message.
You can use some of the Python debuggers as mentioned at the other answer or give a try to my diagnostics library that stores more detailed traceback for you as HTML file :) Just create directory named  next to the  file and enable exception hook by lines below:
I usually use the code module for this type of thing.  Catch the exception as early as you can and dump everything into an interactive console right there.This will start a python REPL inside the exception handler, the raised exception will be in local_vars['e'], and you'll have access to the scope where the try block was called.  If the exception is being raised inside some other library, you can modify the other library's code with this exception handler, use the PYTHONPATH environment variable to point python at the modified version of the library, and leave the original in place.
I highly recommend both ipython and ipdb for these sorts of situations.From within the ipython shell, you typeWhen the unhandled exception returns you to the ipython shell, you typeThis will put you in ipdb, at the exact line of code that throws the unhandled exception. You can then inspect the variables simply by evaluating them, just as you would in a normal python shell.My answer is similar to Colonel Panic's answer that was already accepted. The main advantage here is ipython and ipdb. I prefer these tools for a variety of reasons, the most prominent is that they enable tab completion of variable names. Once you become used to tab completion, it's hard to live without it, because it allows you to work so much faster.
use , pdb for debugging each line this will give you break after each line and you can track your code when main() will be call this function will start working and you can track message , you can debug it your terminal will look like it


Answer URL
https://docs.python.org/3/library/cgitb.html
