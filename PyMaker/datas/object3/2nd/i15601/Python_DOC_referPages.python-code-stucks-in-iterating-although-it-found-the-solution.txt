Natural Text
I'm trying to write a python code to find the prime factors of any given number  My problem is that this code works fine with small numbers however with big numbers i have to interrupt the executionfor example:  the prime factors of this big number were found in less than a second, so my question is how to tweak this code to stop unnecessary iterations after finding the factors with the use of the for not the while loop
You can speed things up by dividing  by the obtained value in each iteration step. This way you decrease the number you are iterating. I would implement something like this (not yet sure if this is optimal and results in the lowest number of operations):Note, if using the improvement of looping until the root of the number we omit the case that the number itself is a prime number. However, if the function does not result any prime factors it is save to assume that the input is a prime number itself. The  statements stop the main loop (and the function) after the recursive call. So each call of the function only results in one value and a call for the function on the result of the division of the number by its found prime.If you make a set with all the prime numbers and check if the value is in this set you will win some time, instead of looping over all values.Compared to the non-recursive solution by jonrsharpe this one is almost four times as fast:The implementation is limited by the overflow limit of , which results in an overflow for the input value . More details on the maximum size for  can be found in this question:  Python: Range() maximum size; dynamic or static?A possible issue with this solution could be that the maximum recursion depth is achieved. For more details on that visit this question: Maximum recursion depth
You could try adding prime factors to a list as you find them, and see if they multiply to make the number you are trying to factorize, but I think that might add more time than it would save.As suggested in the comments, you could also stop at the square root of the number - using .In terms of generally speeding it up you could also try creating a set of primes, and adding to it when you find them in the 5th line. Example:
One further point - use xrange() rather than range(), so you do not internally create the list of all numbers to iterate: (if you are using Python 2 !)What is the difference between range and xrange functions in Python 2.X?
just iterate square root of value, this is how you can iterate through less nombers anduse  to skip repeated iteration usinf 
Here's how I would do it:By factoring out the checks for  you can almost halve the search space, and using the fact that all prime factors must be below the square root of a number you cut it down even further. This takes about a quarter of a second for :Another option would be to use a prime sieve to generate all primes below , then filter out those that are also factors of  (effectively the reverse operation).


Answer URL
https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops
