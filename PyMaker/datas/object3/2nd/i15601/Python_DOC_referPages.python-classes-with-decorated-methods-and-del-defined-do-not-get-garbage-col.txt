Natural Text
I'm running into a problem with Python3.2. If a class decorates a function from the parent class and also has a destructor then instances of that class are never garbage collected.Here's some sample code that illustrates the problem:If you are so inclined, you could also monkey-patch in a decorator at run-time and see the same thing:In each case, there is uncollected garbage, presumably because there is a bound reference to  in the decorated method.Upgrading to Python3.4 isn't really an option for me at this point, so I'm looking for a way to let objects like these get garbage collected.
It is not the decorator that causes this problem. It is the fact that you store a method on the instance they are bound to. The decorator is only the means here, not the actual cause.Methods hold a reference to the instance in , and you then created a circular reference by storing the method in a closure with the decorator object, back onto . Don't do that. Python 3.3 and before won't garbage collect circular references with objects with  methods.Unwrap the method and store the original function: will no longer be bound however, methods are only bound if looked up on the class, not the instance.Or actually apply the decorator at the class level:If neither is an option, use a weak reference to track the instance, rather than reference the method, then rebind as needed:


Answer URL
https://docs.python.org/3/library/weakref.html#weakref.ref
