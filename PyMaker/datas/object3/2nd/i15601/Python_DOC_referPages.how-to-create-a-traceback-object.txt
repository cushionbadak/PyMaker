Natural Text
I want to create a traceback like the one returned by sys.exc_info()[2].  I don't want a list of lines, I want an actual traceback object:How can I do this?  My goal is to have it include the current stack minus one frame, so it looks the the caller is the most recent call.
There's no documented way to create traceback objects.None of the functions in the  module create them. You can of course access the type as , but if you call its constructor you just get a .The reason for this is that tracebacks contain references to internals that you can't actually access or generate from within Python.However, you can access stack frames, and everything else you'd need to simulate a traceback is trivial. You can even write a class that has , , , and  attributes (using the info you can get from  and one of the  functions), which will look exactly like a traceback to any pure-Python code.So there's a good chance that whatever you really want to do is doable, even though what you're asking for is not.
If you really need to fool another library—especially one written in C and using the non-public API—there are two potential ways to get a real traceback object. I haven't gotten either one to work reliably. Also, both are CPython-specific, require not just using the C API layer but using undocumented types and functions that could change at any moment, and offer the potential for new and exciting opportunities to segfault your interpreter. But if you want to try, they may be useful for a start.The  type is not part of the public API. But (except for being defined in the Python directory instead of the Object directory) it's built as a C API type, just not documented. So, if you look at  and  for your Python version, you'll see that… well, there's no , but there is a  that constructs a new traceback and swaps it into the current exception info. I'm not sure it's valid to call this unless there's a current exception, and if there is a current exception you might be screwing it up by mutating it like this, but with a bit of trial&crash or reading the code, hopefully you can get this to work:As a fun alternative, we can try to mutate a traceback object on the fly. To get a traceback object, just raise and catch an exception:The only problem is that it's pointing at your stack frame, not your caller's, right? If tracebacks were mutable, you could fix that easily:And there's no methods for setting these things, either. Notice that it doesn't have a , and its  works by building a  on the fly, so obviously the only way we're getting at this stuff is through the underlying struct. Which you should really build with , but as a quick hack:Now, for a normal 64-bit build of CPython,  /  are the normal object header, and after that come the traceback-specific fields, so  is the , and  and  are the  and , respectively. So:But the next part is a bit harder, because  isn't actually a , it's just a raw , so off you go to , where you see that it really is a  so you can just use the same trick again. Just remember to  the frame's next frame and  the frame itself after doing reassigning  to point at , or as soon as you try to print the traceback you'll segfault and lose all the work you'd done writing this up. :)
Since Python 3.7 you can create traceback objects dynamically from Python.To create traceback identical to one created by raise:use this:Relevant documentation is here:https://docs.python.org/3/library/types.html#types.TracebackTypehttps://docs.python.org/3/reference/datamodel.html#traceback-objectshttps://docs.python.org/3/library/sys.html#sys._getframe
As others have pointed out, it's not possible to create traceback objects. However, you can write your own class that has the same properties:You can still pass instances of this class to some Python functions. Most notably, , which produces the same output as Python's standard excepthook.If you (like me) encountered this problem because you are working on a PyQt-based GUI app, you may also be interested in a more comprehensive solution laid out in this blog post.
"In order to better support dynamic creation of stack traces, types.TracebackType can now be instantiated from Python code, and the tb_next attribute on tracebacks is now writable."There is an explanation(in python 3.7) for the same in here(python 3.7) https://docs.python.org/3/library/types.html#types.TracebackType


Answer URL
https://docs.python.org/3/library/traceback.html
https://docs.python.org/3/library/types.html#types.TracebackType
https://docs.python.org/3/library/traceback.html#traceback.extract_stack
https://docs.python.org/3/library/inspect.html#the-interpreter-stack
https://docs.python.org/3/library/types.html#types.TracebackType
https://docs.python.org/3/reference/datamodel.html#traceback-objects
https://docs.python.org/3/library/sys.html#sys._getframe
https://docs.python.org/3/library/traceback.html#traceback.print_exception
https://docs.python.org/3/library/types.html#types.TracebackType
