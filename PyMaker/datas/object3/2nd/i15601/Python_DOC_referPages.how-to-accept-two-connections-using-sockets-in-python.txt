Natural Text
I am working on a chat program. But right now it can only except one client. How would I make it to where it can accept two clients? I am still a bit of a noob when it comes to sockets so can you explain very thoroughly?Server Code:I have tried changing the s.listen(1) to s.listen(2). But that did not seem to allow a second person to connect. Can someone explain why?
One call to  accepts one connection. To accept two connections, call  twice.
If you want two connections in sequence, but never more than one at a time, you just need a loop around the  and everything that follows it. Then it'll accept one connection, handle it until the socket closes and your  executes, then handle the second connection, and so on.In this case, the  backlog—the 2 in your —means it'll queue up no more than 2 waiting connections while you're processing the first one; anyone after that will get rejected.If you want two simultaneous connections, you have to do one of two things:Multithreading, with a thread for each connection. (Multiprocessing, and magic green-threading a la , are basically the same idea.)Multiplexing, with a reactor or proactor handling non-blocking or asynchronous I/O for all of the connections instead of just directly calling a socket with a single connection. (There are many variations on this idea, from coroutine schedulers like  to simple loops around .)In this case, the  backlog is really only important if your program is too slow to keep up with connections as they come in. When that happens, it's usually better to refuse new connections than to accept them and slow things down even further, so keeping a small backlog is a good idea.But since your connection handler blocks on  after each socket messages, this is going to be a weird design, to say the least. (Not the blocking part—you can fix that by assigning a thread,  entry, coroutine, etc. to stdin. But what actually happens with the input. You've got 8 connections, and only 1 input. Which connection gets the result when the user types something?)Here's a simple threaded server:However, for a realistic server that you want to be able to shut down in some way, you're going to want to provide some way to shut down the connection threads. Also, for servers that interact between clients (like sending one user's chat messages to all of the other users), you need some way to pass messages between the threads, or to share information between them. Often you end up needing two threads per connection—one to block on , and another one to block on a queue and call  with other users' messages.For a multiplexing server, the different approaches look very different, but there are good examples for all of them. See ,  for their examples, Socket Programming HOWTO for the  examples, and Google for examples for third-party libraries like Twisted, gevent, etc.As a side note, you seem to be expecting that  is guaranteed to send an entire message in one go, and that the other side's  will receive that entire message and nothing else. TCP guarantees no such thing. See Sockets are byte streams, not message streams for more details.Also, in , what is the  for? In Python 2.x,  is already a , so this just wastefully makes an extra copy for no good reason. In Python 3.x,  is a , so this converts that into its string representation, like  instead of , which is almost certainly not what you want.


Answer URL
https://docs.python.org/3/library/asyncio.html
https://docs.python.org/3/library/selectors.html
https://docs.python.org/3/howto/sockets.html
