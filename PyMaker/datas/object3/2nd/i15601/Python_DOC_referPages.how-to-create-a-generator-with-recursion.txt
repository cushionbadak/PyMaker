Natural Text
Algorithm from Hacker's Delight 2nd EditionPorted to pythonA simple Hilbert curve class.So what I want is something that gives a (x,y) every time next() is called. I tried doing this myself but can't get it to work so any help would be appreciated. Would I have to rewrite this to work with a generator? Source
I think at least part of what you're trying to do is to turn  into a generator function, which yields the  pairs after each call to ? If so, that's pretty easy.The hard part is those recursive calls. But that's not really hard at all. That's exactly what  is for:* Take some iterator (like a recursive call to a generator function) and yield each of its values.**Then there's the easy part, the non-recursive yielding of the  pairs after each call to . You can do that with an explicit  after each call. Or you can change  to add a , so you can just . But you can also change  to an iterator that only iterates one value, and then you can  it as well. (There's no real advantage to that here, but I think it's worth showing so you can think through how it works—especially since you asked "can I iterate from here?" in .)But now you've got that  that just calls  and does nothing with the result. That's not very useful. Maybe you're trying to turn the  class itself into an iterator class?In that case, the easiest thing to do is store the generator iterator and delegate to it:However, at this point, I'm not sure why you need this to be a class at all. The  and  aren't really part of the object's state, they're part of the generator state, which Python would take care of magically if you just used local variables in  (and normal parameter-and-return passing in ). And the only other state is , which is only necessary because you're writing a class instead of a function.* Actually, it turns out to be good for a lot more than that, as Greg Ewing describes amazingly well; we wouldn't have  without it. But the original reason for adding it to the language was as "Syntax for Delegating to a Subgenerator".** Note that this only works if you have —meaning Python 3.3 or later. If you're still using Python 2.x, and  isn't enough to get you to upgrade, you can simulate some uses of it—including this one—by changing every  into . It won't be as readable, and it will be significantly slower, but it will work.


Answer URL
https://docs.python.org/3/library/asyncio.html
