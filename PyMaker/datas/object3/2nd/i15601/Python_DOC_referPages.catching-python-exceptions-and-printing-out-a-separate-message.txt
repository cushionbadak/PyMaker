Natural Text
I'm currently trying to write code to catch exceptions, and depending upon which exception is thrown, a different module will be imported than when no exception was thrown. The first exception,  that is caught, catches the exception thrown when python  module cannot be found during the execution of  (inside , there is an  statement). The second exception, , is caught when the  python library is found (likewsie during the execution of the  statement inside the ), but the  C library is not installed into the OS. We hope that these two  statements are sufficient to catch all possible exceptions that can be thrown when a user attempts to run this module on a machine that just does not have the python  library, the  C library, or does not have Sun Grid Engine installed. without any of these proceeds, the module proceeds to then  and so the code can then execute on the user's machine locally. Right now the code works as expected in the sense that it goes to import local when it finds exceptions with sge, but we are still looking to improve the exception handling here to make it more robust.In my opinion I think having the actual Exception message that was thrown be printed to stdout is good as it will allow the user to know why he was unable to import sge_execution_engine especially if he was not expecting it to fail being imported. However, instead of using  to actually have the actual exception message be printed on screen, I realized that perhaps a better way would be to use the  format and then print out  and also call some of the attributes associated with the Exception that is thrown and assigned to . I saw this being done in the Python tutorial on exceptions where there was this chunk of code:It seems like the  chunk is handling the exception message in a fine-grained way by specifically calling on the  and  attributes of the  object. However, when I look at the  documentation , I do not see these specific attributes being listed out as part of the documentation for the exception. In fact, this is also the case for all the other exceptions under the Python documentation, so it seems there is no way we can figure out what attributes will be associated with a particular exception. If we don't know anything about this, then how will we be able to figure out what attributes to call on the  object when we use the  syntax to handle our exceptions?I would appreciate anyone's suggestion on this, and even if your answer is not directly answering my question, but if you have another entirely different suggestion on how I could better handle my exception here, please don't hesitate to make a post!Thank you very much!
Using a bare  is rarely a good idea, but this is one of those rare times -- primarily because you have a backup that you want to use if, for any reason, you cannot import the system :Notice you now only need one  clause.The better way to handle getting that information to the user is probably to go ahead and print it out, and then also use the logging module to make a permanent record:and then in your  clause add:and your message, along with the actual exception, will be saved in a log file.
First you're right that it's better to catch the exception into a variable than to ignore it and then pull it back out with . There are a few good reasons to use  (low-level code, code that has to work with both pre-2.6 and 3.x, etc.), but in general, when you get can do it your way, you should.And this works even for your last bare except. In 2.7, a plain  means the same thing as , so you can write , and then use the  value.Also note that if you want to do exactly the same thing for multiple exception types, you can write .As for "making it more robust", that's not an absolute thing. For example, if there's some unexpected exception that's neither a  nor an , do you want to log it and try the fallback code, or quite and dump the traceback? If it's, e.g., a  caused by someone checking in a bad edit to your program, you may not want to treat that like a runtime error… or maybe you do; that really depends on your development practices and target userbase.Meanwhile:It seems like the  chunk is handling the exception message in a fine-grained way by specifically calling on the  and  attributes of the  object. However, when I look at the  documentation, I do not see these specific attributes being listed out as part of the documentation for the exception.You need to look up the hierarchy. Notice that  is a subclass of , which does document the  and  attributes. (What these attributes actually mean is only documneted for  and its subclasses, but the fact that they exist is documented.)If you think this is all a bit of a mess… well, it is. It's all cleaned up in Python 3.x, where  and  are merged into , which clearly documents its attributes, and where you usually don't have to switch on  in the first place because common  values generate a specific subclass like , and so on. But as long as you're using 2.7, you don't get the benefits of the last 6 years of improvements to the language.For example, looking at the hierarchy or  (from lowest to highest in the hierarchy), I can't find any attributes about it.If you  a , you'll see that it only has two attributes (besides the usual special stuff like  and ):  and . isn't documented because it was deprecated in 2.5, and only exists in 2.7 to allow some pre-2.5 code to keep running.* But  is documented; you just need to go up one level further, to :The tuple of arguments given to the exception constructor. Some built-in exceptions (like ) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.So, the reason you can't find the other attributes in  is that there are no other attributes to find. And the same goes for those other classes. The handful of types that have special attributes (, , maybe a few module-specific types elsewhere in the stdlib) document them explicitly.**If we are using the  syntax, is doing a  sufficient to get the exception printed out without calling its attributesIt's sufficient to get some useful form of the exception printed. Again, from the  docs:If  or  is called on an instance of this class, the representation of the argument(s) to the instance are returned or the empty string when there were no arguments.In some cases, that's not what you want. In particular, notice that it doesn't include the type of the exception. You can get that with , which gives you something that looks like a constructor call (e.g., ).If you want the same output you get in a traceback, you have to put the  and the  or  together yourself—e.g., .If you want to get the actual information out of the exception, like that base  or that string —well, you can't,*** because that information has already been thrown away. You'll have to write your own code to keep track of it, like:* It's as if  were defined to do .** I believe in 2.5 there were a few exception types that had undocumented attributes as an implementation detail of CPython, but by 2.7 they're all either gone or documented.*** Well, you could parse the exception string, but needless to say, that's an implementation detail, not something guaranteed to be stable and portable. It could be different in Jython, or on a Spanish-language system, or it may not quote strings the way you expect, etc.


Answer URL
https://docs.python.org/3/library/logging.html
