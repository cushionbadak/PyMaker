Natural Text
Guido van Rossum, in his speech in 2014 on Tulip/Asyncio shows the slide:Tasks vs coroutinesCompare:res = yield from  some_coroutine(...)res = yield from Task(some_coroutine(...))Task can make progress without waiting for itAs log as you wait for something else    i.e. yield from And I'm completely missing the point.From my point of view both constructs are identical: In case of bare coroutine - It gets scheduled, so the task is created anyways, because scheduler operates with Tasks, then coroutine caller coroutine is suspended until callee is done and then becomes free to continue execution.  In case of  - All the same - new task is schduled and caller coroutine waits for its completion.What is the difference in the way that code executed in both cases and what impact it has that developer should consider in practice?p.s.Links to authoritative sources (GvR, PEPs, docs, core devs notes) will be very appreciated.
For the calling side co-routine  feels like a function call (i.e. it will again gain control when coroutine() finishes). on the other hand feels more like creating a new thread.  returns almost instantly and very likely the caller gains control back before the  finishes.The difference between  and  is obvious, right?
The point of using  is for cases where you don't want to explicitly wait for , but you want  to be executed in the background while you wait for other tasks. That is what Guido's slide means by [A]  can make progress without waiting for it...as long as you wait  for something elseConsider this example:Output:As you can see,  was never actually executed, because we didn't explicitly call  on it.Now, if we use  to wrap a  instance around , the result is different:Output:So, there's really no practical reason for using , since it's slower than  without any benefit; it introduces the overhead of adding  to the internal  scheduler, but that's not needed, since using  guarantees that  is going to execute, anyway. If you just want to call a coroutine and wait for it to finish, just  the coroutine directly.Side note:I'm using * instead of  directly because the docs recommend it:Donâ€™t directly create  instances: use the  function or  the  method.* Note that as of Python 3.4.4,  is deprecated in favor of .
As described in PEP 380, the accepted PEP document that introduced yield from, the expression  comes from the idea of the following loop:With this, things become very clear: if  is , then the coroutine is executed. On the other hand, if  is ,  is executed instead.  is not executed, only the newly created generator is passed as the first argument to .Conclusion: => coroutine continues execution and returns the next value => a new task is created, which stores a non-executed  generator object.


Answer URL
https://docs.python.org/3/library/asyncio-task.html#task
https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
