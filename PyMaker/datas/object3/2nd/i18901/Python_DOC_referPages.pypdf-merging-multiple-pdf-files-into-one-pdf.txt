Natural Text
If I have 1000+ pdf files need to be merged into one pdf,Execute the above code，when ,An error message：I think this is a bug, If not, What should I do？
I recently came across this exact same problem, so I dug into PyPDF2 to see what's going on, and how to resolve it.Note: I am assuming that  is a well-formed file path string.  Assume the same for all of my codeThe Short AnswerUse the  class instead of the  class.  I've tried to provide the following to as closely resemble your content as I could:The Long AnswerThe way you're using  and  is keeping each file open, and eventually causing Python to generate IOError 24.  To be more specific, when you add a page to the , you are adding references to the page in the open  (hence the noted IO Error if you close the file).  Python detects the file to still be referenced and doesn't do any garbage collection / automatic file closing despite re-using the file handle.  They remain open until  no longer needs access to them, which is at  in your code.To solve this, create copies in memory of the content, and allow the file to be closed.  I noticed in my adventures through the PyPDF2 code that the  class already has this functionality, so instead of re-inventing the wheel, I opted to use it instead.  I learned, though, that my initial look at  wasn't close enough, and that it only created copies in certain conditions.My initial attempts looked like the following, and were resulting in the same IO Problems:Looking at the PyPDF2 source code, we see that  requires  to be passed, and then uses the  function, passing in it's last page as the new files position.  does the following with  (before opening it with :We can see that the  option does accept a string, and when doing so, assumes it's a file path and creates a file object at that location.  The end result is the exact same thing we're trying to avoid.  A  object holding open a file until the file is eventually written!However, if we either make a file object of the file path string or a (see Edit 2) object of the path string before it gets passed into , it will automatically create a copy for us as a  object, allowing Python to close the file.I would recommend the simpler , as others have reported that a  object may stay open in memory, even after calling .Hope this helped!EDIT: I assumed you were using , not .  If you aren't, I highly recommend switching, as PyPDF is no longer maintained with the author giving his official blessings to Phaseit in developing PyPDF2.  If for some reason you cannot swap to PyPDF2 (licensing, system restrictions, etc.) than  won't be available to you.  In that situation you can re-use the code from PyPDF2's  function (provided above) to create a copy of the file as a  object, and use that in your code in place of the file object. EDIT 2: Previous recommendation of using  changed based on comments (Thanks @Agostino).
The pdfrw package reads each file all in one go, so will not suffer from the problem of too many open files.  Here is an example concatenation script.The relevant part -- assumes  is a list of input filenames, and  is an output file name:Disclaimer:  I am the primary pdfrw author.
The problem is that you are only allowed to have a certain number of files open at any given time. There are ways to change this (http://docs.python.org/3/library/resource.html#resource.getrlimit), but I don't think you need this.What you could try is closing the files in the for loop:
It maybe just what it says, you are opening to many files.You may explicitly use  in the loop, or use the  statement. So that each opened file is properly closed. 


Answer URL
