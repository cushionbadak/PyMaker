Natural Text
In Python 3.3.1, this works:This also works:But this doesn't work:The documentation for the  keyword states (emphasis added):The nonlocal statement causes the listed identifiers to refer to  previously bound variables in the nearest enclosing scope. In the third example, the "nearest enclosing scope" just happens to be the global scope. So why doesn't it work?PLEASE READ THIS BITI do notice that the documentation goes on to state (emphasis added):The [] statement allows encapsulated code to  rebind variables outside of the local scope besides the global  (module) scope.but, strictly speaking, this doesn't mean that what I'm doing in the third example shouldn't work.
The search order for names is LEGB, i.e Local, Enclosing, Global, Builtin.  So the global scope is not an enclosing scope.EDITFrom the docs:   The nonlocal statement causes the listed identifiers to refer to  previously bound variables in the nearest enclosing scope. This is  important because the default behavior for binding is to search the  local namespace first. The statement allows encapsulated code to  rebind variables outside of the local scope besides the global  (module) scope.
The answer is that the global scope does not enclose anything - it is global to everything. Use the  keyword in such a case.
why is a module's scope considered global and not an enclosing one? It's still not global to other modules (well, unless you do ), is it?If you put some name into 's namespace; it is visible in any module that uses  i.e., it is global for the whole Python process.In general, your application should use as few mutable globals as possible. See Why globals are bad?:Non-localityNo Access Control or Constraint Checking Implicit couplingConcurrency issuesNamespace pollutionTesting and Confinement Therefore It would be bad if  allowed to create globals by accident. If you want to modify a global variable; you could use  keyword directly. is the most destructive: may affect all uses of the module anywhere in the program is less destructive: limited by the outer() function scope (the binding is checked at compile time)no declaration (local variable) is the least destructive option: limited by inner() function scopeYou can read about history and motivation behind  in PEP: 3104Access to Names in Outer Scopes.
It depends upon the Boundary cases: nonlocals come with some senstivity areas which we need to be aware of. First, unlike the global statement, nonlocal names really must have previous been assigned in an enclosing def's scope when a nonlocal is evaluated or else you'll get an error-you cannot create them dynamically by assigning them anew in the enclosing scope. In fact, they are checked at function definition time before either or nested function is calledSecond, nonlocal restricts the scope lookup to just enclosing defs; nonlocals are not looked up in the enclosing module's global scope or the built-in scope outside all def's, even if they are already there:for example:-These restrictions make sense once you realize that python would not otherwise generally know enclosing scope to create a brand-new name in. In the prior listing, should spam be assigned in tester, or the module outside? Because this is ambiguous, Python must resolve nonlocals at function creation time, not function call time.


Answer URL
