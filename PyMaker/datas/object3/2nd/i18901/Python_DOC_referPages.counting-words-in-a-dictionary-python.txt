Natural Text
I have this code, which I want to open a specified file, and then every time there is a while loop it will count it, finally outputting the total number of while loops in a specific file. I decided to convert the input file to a dictionary, and then create a for loop that every time the word while followed by a space was seen it would add a +1 count to WHILE_ before finally printing WHILE_ at the end.However this did not seem to work, and I am at a loss as to why. Any help fixing this would be much appreciated.This is the code I have at the moment:This is the input file I was working from:The output should be 2, but my code at the moment prints 0
This is an incredibly bizarre design. You're calling  to get a list of strings, then calling  on that list, which will join the whole thing up into one big string with the quoted  of each line joined by commas and surrounded by square brackets, then splitting the result on spaces. I have no idea why you'd ever do such a thing.Your bizarre variable names, extra useless lines of code like , etc. only serve to obfuscate things further.But I can explain why it doesn't work. Try printing out  after you do all that silliness, and you'll see that the only keys that include  are  and . Since neither of these match any of the patterns you're looking for, your count ends up as 0.It's also worth noting that you only add 1 to  even if there are multiple instances of the pattern, so your whole dict of counts is useless.This will be a lot easier if you don't obfuscate your strings, try to recover them, and then try to match the incorrectly-recovered versions. Just do it directly.While I'm at it, I'm also going to fix some other problems so that your code is readable, and simpler, and doesn't leak files, and so on. Here's a complete implementation of the logic you were trying to hack up by hand:When you run this on your sample input, you correctly get . And extending it to handle  and  is trivial and obvious.However, note that there's a serious problem in your logic: Anything that looks like a keyword but is in the middle of a comment or string will still get picked up. Without writing some kind of code to strip out comments and strings, there's no way around that. Which means you're going to overcount  and  by 1. The obvious way of stripping— and similarly for quotes—won't work. First, it's perfectly valid to have a string before an  keyword, as in . Second, you can't handle multiline strings this way.These problems, and others like them, are why you almost certainly want a real parser. If you're just trying to parse Python code, the  module in the standard library is the obvious way to do this. If you want to be write quick&dirty parsers for a variety of different languages, try , which is very nice, and comes with some great examples.Here's a simple example:Or, more flexibly:


Answer URL
