Natural Text
I have a  module, that is used in at least two other modules ( and ).  It has these globals:It has two functions:And: I call  from , which initializes the file and console loggers. I then call  from all over the place, so multiple threads are accessing  and .  Do I need any further protection for my log file? The documentation states that thread locks are handled by the handler.
The good news is that you don't need to do anything extra for thread safety, and you either need nothing extra or something almost trivial for clean shutdown. I'll get to the details later.The bad news is that your code has a serious problem even before you get to that point:  and  are the same object. From the documentation for :Return a logger with the specified name or, if no name is specified, return a logger which is the root logger of the hierarchy.So, you're getting the root logger and storing it as , and then you're getting the root logger and storing it as . So, in , you initialize , then re-initialize the same object under a different name with different values.You can add multiple handlers to the same logger—and, since the only initialization you actually do for each is , your code will sort of work as intended, but only by accident. And only sort of. You will get two copies of each message in both logs if you pass , and you will get copies in the console even if you pass .There's actually no reason for global variables at all; the whole point of  is that you can call it every time you need it and get the global root logger, so you don't need to store it anywhere.A more minor problem is that you're not escaping the text you insert into HTML. At some point you're going to try to log the string  and end up in trouble.Less seriously, a sequence of  tags that isn't inside a  inside an  is not a valid HTML document. But plenty of viewers will take care of that automatically, or you can post-process your logs trivially before displaying them. But if you really want this to be correct, you need to subclass  and have your  add a header if given an empty file and remove a footer if present, then have your  add a footer.Getting back to your actual question:You do not need any additional locking. If a handler correctly implements , , and  (and it's called on a platform with threads), the logging machinery will automatically make sure to acquire the lock when needed to make sure each message is logged atomically.As far as I know, the documentation doesn't directly say that  and  implement these methods, it does strongly imply it (the text you mentioned in the question says "The logging module is intended to be thread-safe without any special work needing to be done by its clients", etc.). And you can look at the source for your implementation (e.g., CPython 3.3) and see that they both inherit correctly-implemented methods from .Likewise, if a handler correctly implements  and , the logging machinery will make sure it's finalized correctly during normal shutdown.Here, the documentation does explain what , , and . They're mostly what you'd expect, except that  is a no-op, meaning it's possible that final log messages to the console may get lost. From the docs:Note that the  method is inherited from  and so does no output, so an explicit  call may be needed at times.If this matters to you, and you want to fix it, you need to do something like this:And then use  instead of . has no such problem.The normal way to send logs to two places is to just use the root logger with two handlers, each with their own formatter.Also, even if you do want two loggers, you don't need the separate  and  maps; calling  is exactly the same thing as calling . You'll still need some way to map your custom level names , etc. to the standard names , etc., but you can just do one lookup, instead of doing it once per logger (plus, if your names are just the standard names with different cast, you can cheat).This is all described pretty well in the `Multiple handlers and formatters section, and the rest of the logging cookbook.The only problem with the standard way of doing this is that you can't easily turn off console logging on a message-by-message basis. That's because it's not a normal thing to do. Usually, you just log by levels, and set the log level higher on the file log. But, if you want more control, you can use filters. For example, give your  a filter that accepts everything, and your  a filter that requires something starting with , then use the filter . That reduces  to almost a one-liner.You still need the extra two lines to remove newlines—but you can even do that in the filter, or via an adapter, if you want. (Again, see the cookbook.) And then  really is a one-liner.
Python logging is thread safe:Is Python's logging module thread safe?http://docs.python.org/2/library/logging.html#thread-safetySo you have no problem in the Python (library) code.The routine that you call from multiple threads () does not write to any shared state.  So you have no problem in your code.So you are OK.


Answer URL
