Natural Text
I have a header file like:I can wrap it in SWIG using std_vector.i and pyabc.i but that is quite inefficient (there's a jump between C++ and Python code for every access) and given that these are literally just a bunch of bytes I ought to be able to wrap them with Python's  interface.How can I expose my  as a Python ?
Exposing it as a  requires creating a  first. In Python 3.3+ there is a convenient helper function,  that does a lot of the work for us. In earlier versions though we'll need to take a few extra steps, so our basic out typemap looks like:Here we're basically allocating some memory for the . This just contains the details of the buffer internally for Python. The memory we allocate will be owned by the  object once it's created. Unfortunately since it's going to be released with a call to  we need to allocate it with , even though it's C++ code.Besides the  and an optional   takes a  (the buffer itself), the size of the buffer, a boolean indicating if it's writeable and a flag. In this case our flag simply indicates that we have provided C-style contiguous memory for the buffer.For deciding if it is readonly or not we used SWIG's built in  variable and a helper (which could be a C++11 type trait if we wanted).To complete our SWIG interface we need to provide that helper and include the header file, so the whole thing becomes:We can then test it with:Which worked as expected, tested using Python 2.7.Compared to just wrapping it using std_vector.i this approach does have some drawbacks. The biggest being that we can't resize the vector, or convert it back to a vector later trivially. We could work around that, at least partially by creating a SWIG proxy for the vector like normal and using the second parameter of  to store it internally. (This would also be needed if we had to manage the ownership of the vector for instance).


Answer URL
