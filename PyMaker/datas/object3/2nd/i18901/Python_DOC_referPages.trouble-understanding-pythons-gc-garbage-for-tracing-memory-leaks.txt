Natural Text
One of my python applications appears to leak memory, judging from steadily increasing memory usage. My hypothesis is a cyclic reference somewhere, despite best efforts to avoid this. To isolate the problem I am looking into ways to manually check for unreachable items, a tool aimed purely at debugging.The gc module seems capable of the necessary tracking, and I attempted the following code that aims to compile a list of unreacheable items that were formed since the last call. The first call merely sets a base checkpoint and will not identify unreachable items.Here, _deep_purge_list aims to break cycles and remove objects manually. The following implementation handles some common cases but is not near water tight. My first question relates to this, see down.Based on very limited testing the setup appears to function properly. The following cyclic reference correctly reports once:However with the following something odd happens:Repeated invocations keep returning that last result. The problem does not occur when unreachable is called for the first time after the import. However, at this point I have no reason to believe that this problem is numpy specific; my guess is it exposes a flaw in my approach.My questions:Is there a better way to remove items in gc.garbage? Ideally, isthere a way to have gc remove them, like it would (should?) have donewithout DEBUG_SAVEALL?Can anybody explain the problem with the numpy import, and/orsuggest ways to fix it?Afterthought:It appears that the code below performs close to intended:However, for debugging I prefer rich string representations over type/id as provided by gc. Moreover I would like to understand the flaw in my former approach, and learn something about the gc module.Appreciating your help,GertjanUpdate 06/05:I ran into a situation where the first implementation did not report any unreachable items, unless locals() was called just prior to it (discarding the return value). Not understanding how this could possibly affect gc's object tracking this leaves me even more confused. I am not sure how easy it will be to construct a small example that demonstrates this issue, but if demand calls for it I can give it a shot.
The last time I had such a need I ended up using the  module to good effect.  It gives much more accurate information than you can easily get from the  module directly.  Unfortunately I don't have any code at hand illustrating its usage. The one place where it falls down is in memory allocated by any C code libraries called.  For instance if a project uses PIL it is very easy to leak memory due to not releasing python objects properly that are backed by C data.  It is C backed module dependent how to properly close out such objects.


Answer URL
https://docs.python.org/3/library/gc.html
