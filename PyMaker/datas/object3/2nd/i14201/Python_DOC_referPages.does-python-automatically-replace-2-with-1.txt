Natural Text
I saw suggestions (see e.g. Is multiplication and division using shift operators in C actually faster?) that you should not manually replace multiplication with the shift operator, because the compiler has to do it automatically and shift operators decrease readability. I have written a simple test to check this:I used equivalent operations ( is equivalent to  and  to ) and here is the result:What is wrong? Is my testing method wrong? Is the time measurement wrong? Or does Python not perform such optimizations (and, if yes, should I be afraid of that)? I used cPython 3.4.2 x64 on Win 8.1 x64.
This optimization doesn't occur at bytecode level:The dis module allows you to show you what happens "inside" Python when your code is executed or, more precisely, what exactly is executed. The output shows that the  operator is mapped to  and the  operator is mapped to . These two bytecode operations are implemented in C.
Using  (to look at the bytecode equivalent of functions) and  (more robust timing than trying to do it manually using ) can give you a better idea of what's going on internally. Test script:And outputs (CPython v2.7.6 on Windows 7):Clearly Python is not replacing the multiplication/division operations with the equivalent bit shifts (e.g.  is not replaced by ), although it looks like such an optimisation could give performance improvements. As to why the bit shift is faster, see e.g. Speeds of << >> multiplication and division on Programmers.
Only in very limited circumstances could CPython implement these optimisations. The reason being that CPython is a ducked-typed language. Given the code fragment , this can mean very different things dependent on the value of . If  is an integer than it does indeed have the same meaning as . However, if  is a float or a string or a list or any other class that implements  in its own unique way then it most certainly doesn't have the same meaning as . For example, . So unless the value of  is known at compile time then this optimisation cannot be made. If the value of  is known beforehand then the entire operation can be optimised away eg.You can see that the compiler has performed the operation itself and just returns the constant value .


Answer URL
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/timeit.html
https://docs.python.org/3/library/dis.html
https://docs.python.org/3/library/timeit.html
