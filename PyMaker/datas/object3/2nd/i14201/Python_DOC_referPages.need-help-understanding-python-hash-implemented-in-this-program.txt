Natural Text
Can anyone explain me what the hash function mentioned in the above snippet, it works fine but i donot understand ("salt" + str(ni) + str(x) + "salt). 
it works fine but i donot understand ("salt" + str(ni) + str(x) + "salt).This part is trivial.First, the  functions takes any object and converts it to its string representation. For example,  is going to be a number  or , which  will convert to the string  or .Next, we're just concatenating four strings together:  gives you .I'm guessing that you're really asking is why you would do this.When you're writing a hash function for some combination of values in terms of a simpler hash function, you want to be careful to make sure you include some kind of "salting", so your special combination of values doesn't accidentally hash to the same thing as a simple combination of the same values.For an even simpler example, consider this class:But this means that . Usually, you don't want that; a Point isn't the same thing as a tuple, it's a type with its own (very thin, but not nonexistent) semantics. So, you stick some extra value, called a "salt", into the hash. For example:And now, .Notice that this is distinct from, but not unrelated to, other important reasons for salting hashes (e.g., in cryptographic hashes, you can negotiate some shared random nonce to use as a salt, to make sure that nobody can reproduce the same hash results unless they have the negotiated salt, and you can use key exchange protocols to make sure they don't have it).However, it's worth mentioning that this is a very silly hash function.First, it's simpler, more robust, and more efficient to hash a tuple of values than to has a concatenated string. Most likely this code was written for some other language that didn't have a generic  function, only a  function.Second, the only reason you'd want to both prepend and append a salt, instead of just one or the other, is if you didn't trust the  function you're relying on to treat the parts of its values uniformly. And really, if you can't trust that, putting the salt on both ends doesn't help that much—and may actually hurt. (For example, if your  undervalues everything after the first few characters, then prepending the salt does nicely avoid collision with unsalted values while appending it wouldn't—but it also means you're pushing 4 more actual characters out of the over-valued parts of the input, so your salted hashes are going to be even more badly distributed than normal hashes. If you really can't trust a hash function, you can't build a more complex hash function on top of it; you have to build your own.
The part you highlightIs a function factory. Instead of  returning a value, it returns a function whose, erm, function depends on the value you pass it. Imagine something like:You could use this greeting to create other functions, for example:Then use each of THOSE functions, which all expect one argument (the name of the person to say hello to)In this case, it's using a function factory to build a couple different hashing functions, then returning the list. This is identical to:


Answer URL
https://docs.python.org/3/library/functions.html#func-str
