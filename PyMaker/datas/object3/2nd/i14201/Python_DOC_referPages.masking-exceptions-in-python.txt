Natural Text
It is typical to use the  statement to open a file so that the file handle cannot be leaked:But what if the exception occurs somewhere within the  call?  The  function is very likely not an atomic instruction in the Python interpreter, so it's entirely possible that an asynchronous exception such as  would be thrown* at some moment before the  call has finished, but after the system call has already completed.The conventional way of handle this (in, for example, POSIX signals) to use the masking mechanism: while masked, the delivery of exceptions is suspended until they are later unmasked.  This allows operations such as  to be implemented in an atomic way.  Does such a primitive exist in Python?[*] One might say it's doesn't matter for  since the program is about to die anyway, but that is not true of all programs.  It's conceivable that a program might choose to catch  on the top level and continue execution, in which case the leaked file handle can add up over time.
I do not think its possible to mask  , you can mask  but not  . In your case  is the exception that is raised when the  is raised (which is the Ctrl + C) .It is not possible to mask  because well it does not make sense, right? Let's say you are doing open('file','r') , but  does not exist, this causes the  function to throw  Exception, we should not be able to  these kinds of exceptions. It does not make sense to mask it, because open would never be able to complete in the above case.exceptions â€“ anomalous or exceptional conditions requiring special processingFor  exception , its different because like I said, its actually a  that causes the  exception to be raised.You can only  signals in Unix starting from Python 3.3 using the function  [Reference]For that you will have to move the the  to a different block so that we can so something like  the signal, run the context expression to get the context manager and then  the signal , a sample code would look like (please note I have not personally tested this code) -
Some clarification: it seems that asynchronous exceptions are not commonly used in Python.  The standard library only documents  AFAIK.  Other libraries can implement their own via signal handlers, but I don't think (or hope?) this is a common practice, as asynchronous exceptions are notoriously tricky to work with.Here is a naive solution that won't work:The exception-handling part is still vulnerable to exceptions: a  could occur a second time after the exception is caught but before  is complete.There is also a "gap" between the end of the  statement and the beginning of the  statement where it is vulnerable to exceptions.I don't think there's anyway to make it work this way.Thinking from a different perspective, it seems that the only way in which asynchronous exceptions can arise is from signals.  If this is true, one could mask them as @AnandSKumar suggested.  However, masking is not portable as it requires pthreads.Nonetheless, we can fake masking with a little trickery:This will work if SIGINT is the only source that we care about.  Unfortunately it breaks down for multiple signals, not just because we don't know which ones are being handled, but also because we can't swap out multiple signals atomically!


Answer URL
https://docs.python.org/3/library/signal.html#signal.pthread_sigmask
