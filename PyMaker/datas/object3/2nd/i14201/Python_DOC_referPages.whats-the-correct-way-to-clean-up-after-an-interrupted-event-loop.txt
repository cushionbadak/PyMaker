Natural Text
I have an event loop that runs some co-routines as part of a command line tool. The user may interrupt the tool with the usual Ctrl + C, at which point I want to clean up properly after the interrupted event loop.Here's what I tried.Running this and hitting Ctrl + C yields:Clearly, I didn't clean up correctly. I thought perhaps calling  on the tasks would be the way to do it.What's the correct way to clean up after an interrupted event loop?
When you CTRL+C, the event loop gets stopped, so your calls to  don't actually take effect. For the tasks to be cancelled, you need to start the loop back up again.Here's how you can handle it:Once we catch , we  call  and then start the  up again.  will actually exit as soon as  gets cancelled (note that cancelling the  returned by  also cancels all the  inside of it), because the interrupted  call added a  to  that stops the loop. So, when we cancel , that callback fires, and the loop stops. At that point we call , just to avoid getting a warning about not fetching the exception from the .
Updated for Python 3.6+: Add call to  to avoid memory leaks by asynchronous generators that weren't fully used. Additionally  is now used rather then  to ensure that the final  call does not interfere with possible other uses of the loop.The following solution, inspired by some of the other answers, should work in almost all cases and does not depend on you manually keeping track of tasks that need to be cleaned up on Ctrl+C:The above code will obtain all currently tasks from the event loop using  and place them in a single combined future using . All tasks in that future (which are all currently running tasks) are then canceled using the future's  method. The  then ensures that all the received  exceptions are stored instead of causing the future to become errored.The above code will also override the default exception handler to prevent the generated  exceptions from being logged.
Unless you are on Windows, set up event-loop based signal handlers for SIGINT (and also SIGTERM so you can run it as a service). In these handlers, you may either exit the event loop immediately, or initiate some kind of cleanup sequence and exit later.Example in official Python documentation: https://docs.python.org/3.4/library/asyncio-eventloop.html#set-signal-handlers-for-sigint-and-sigterm


Answer URL
https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel
