Natural Text
I've achived these two things.Find all possible sublists of a list in given range .  Then, Possible sublists of the list  in the given range  is : And, minimum of the resultant product after multipying all the elements of the sublists: So, the resultant list after multiplying all the elements in the above sublists will becomeNow, the minimum of the above list, which is  i.e My Code: My Question:This code is taking more time to get executed for the Larger Lists and Larger Ranges !  Is there any possible "Pythonic" way of reducing the time complexity of the above code ?  Thanks in advance !EDIT : Got it. But, If there is more than one such possible sublist with the same minimum product, I need the longest sub list range  If there are still more than one sublists with the same "longest sub range", I need to print the sub-interval which has the lowest start index.Consider this list  if . There is a tie.  with two possibilities  .  Both sub list range = 0  In this case i need to  =   Tried using dictionaries, It works for some inputs but not for all ! How to do this 'efficiently' ? Thank you !
First, given the list and the index range, we can get the sublist For positive integers  and ,  is no less than  or . So you don't need to do multiplying, it's not possible that multiplying of two or more elements has a smaller result. The minimum of this list is the minimum of all the  multiplying results.So the result is:
For generating the sublists, it is as simple as two nested  loops in a list comprehension:example:For finding the minimum product:(you import  from , or define it as )
The accepted answer is correct for all positive ints as you cannot multiply the smallest element by any number and get a smaller result. It might make more sense if you were getting  all the slices greater than length 1.If you were going to calculate it then you could use  to get each slice and get the min using a generator expression:If for i = 0 and j = 4 you considered  a legitimate slice then you would need to use itertools.combinations.
#EDIT: Quick Solution:Since all the numbers are positive integers, and you want to find the minimum product of all possible sublists of  listslice, it will also contain sublists of length 1. The minimum products of all such sublists will be lowest number among the  slice.Another Solution:The below method will be useful when you need to find the maximum product of sublists or you need all the possible combinations of  list slice.We'll use itertools.combinations to solve this. We can do this in 3 steps.Step1: Get the slice of the list This will give us the slice to work on.Step-2 Generate all possible combinations: iterools.combinations returns r length subsequences of elements from  the input iterableSo, we will use this to generate subsequences of length 1 to length equal to length of . We will get a list of tuples with each element being a subsequence.    Step-3 : Find min product of all possible combinationsAfter getting the subsequences, we apply list comprehension along with  to get the list of products for all the subsequences in  list. Then we apply  function to get the minimum product out of the  which will give us our answer.
Take a look a https://docs.python.org/3/library/itertools.html#itertools.combinationsCall it passing the sublist, in a loop, with the other parameter varying from 1 to the length of the sublist.It will definitely take "more time to get executed for the Larger Lists and Larger Ranges", i think that's inevitable. But might be much faster than your approach. Measure and see.



Answer URL
https://docs.python.org/3/library/itertools.html#itertools.combinations
https://docs.python.org/3/library/itertools.html#itertools.combinations
