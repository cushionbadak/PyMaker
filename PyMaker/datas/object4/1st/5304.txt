link:
library/ssl.html#manual-settings

docs:

Manual settings¶

Verifying certificates¶
When calling the SSLContext constructor directly,
CERT_NONE is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you’re talking to.
Therefore, when in client mode, it is highly recommended to use
CERT_REQUIRED.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
SSLSocket.getpeercert(), matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the match_hostname() function can be used.  This common
check is automatically performed when SSLContext.check_hostname is
enabled.

Changed in version 3.7: Hostname matchings is now performed by OpenSSL. Python no longer uses
match_hostname().

In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you’ll also have
to specify CERT_REQUIRED and similarly check the client certificate.


Protocol versions¶
SSL versions 2 and 3 are considered insecure and are therefore dangerous to
use.  If you want maximum compatibility between clients and servers, it is
recommended to use PROTOCOL_TLS_CLIENT or
PROTOCOL_TLS_SERVER as the protocol version. SSLv2 and SSLv3 are
disabled by default.
>>> client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
>>> client_context.options |= ssl.OP_NO_TLSv1
>>> client_context.options |= ssl.OP_NO_TLSv1_1


The SSL context created above will only allow TLSv1.2 and later (if
supported by your system) connections to a server. PROTOCOL_TLS_CLIENT
implies certificate validation and hostname checks by default. You have to
load certificates into the context.


Cipher selection¶
If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
SSLContext.set_ciphers() method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL’s documentation
about the cipher list format.
If you want to check which ciphers are enabled by a given cipher list, use
SSLContext.get_ciphers() or the openssl ciphers command on your
system.

