link:
library/asyncio-protocol.html#write-only-transports

docs:

Write-only Transports¶


WriteTransport.abort()¶
Close the transport immediately, without waiting for pending operations
to complete.  Buffered data will be lost.  No more data will be received.
The protocol’s protocol.connection_lost() method will eventually be
called with None as its argument.



WriteTransport.can_write_eof()¶
Return True if the transport supports
write_eof(), False if not.



WriteTransport.get_write_buffer_size()¶
Return the current size of the output buffer used by the transport.



WriteTransport.get_write_buffer_limits()¶
Get the high and low watermarks for write flow control. Return a
tuple (low, high) where low and high are positive number of
bytes.
Use set_write_buffer_limits() to set the limits.

New in version 3.4.2.




WriteTransport.set_write_buffer_limits(high=None, low=None)¶
Set the high and low watermarks for write flow control.
These two values (measured in number of
bytes) control when the protocol’s
protocol.pause_writing()
and protocol.resume_writing()
methods are called. If specified, the low watermark must be less
than or equal to the high watermark.  Neither high nor low
can be negative.
pause_writing() is called when the buffer size
becomes greater than or equal to the high value. If writing has
been paused, resume_writing() is called when
the buffer size becomes less than or equal to the low value.
The defaults are implementation-specific.  If only the
high watermark is given, the low watermark defaults to an
implementation-specific value less than or equal to the
high watermark.  Setting high to zero forces low to zero as
well, and causes pause_writing() to be called
whenever the buffer becomes non-empty.  Setting low to zero causes
resume_writing() to be called only once the
buffer is empty. Use of zero for either limit is generally
sub-optimal as it reduces opportunities for doing I/O and
computation concurrently.
Use get_write_buffer_limits()
to get the limits.



WriteTransport.write(data)¶
Write some data bytes to the transport.
This method does not block; it buffers the data and arranges for it
to be sent out asynchronously.



WriteTransport.writelines(list_of_data)¶
Write a list (or any iterable) of data bytes to the transport.
This is functionally equivalent to calling write() on each
element yielded by the iterable, but may be implemented more
efficiently.



WriteTransport.write_eof()¶
Close the write end of the transport after flushing all buffered data.
Data may still be received.
This method can raise NotImplementedError if the transport
(e.g. SSL) doesn’t support half-closed connections.

