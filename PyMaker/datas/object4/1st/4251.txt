link:
library/multiprocessing.html#multiprocessing.Process

docs:


class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)¶
Process objects represent activity that is run in a separate process. The
Process class has equivalents of all the methods of
threading.Thread.
The constructor should always be called with keyword arguments. group
should always be None; it exists solely for compatibility with
threading.Thread.  target is the callable object to be invoked by
the run() method.  It defaults to None, meaning nothing is
called. name is the process name (see name for more details).
args is the argument tuple for the target invocation.  kwargs is a
dictionary of keyword arguments for the target invocation.  If provided,
the keyword-only daemon argument sets the process daemon flag
to True or False.  If None (the default), this flag will be
inherited from the creating process.
By default, no arguments are passed to target.
If a subclass overrides the constructor, it must make sure it invokes the
base class constructor (Process.__init__()) before doing anything else
to the process.

Changed in version 3.3: Added the daemon argument.



run()¶
Method representing the process’s activity.
You may override this method in a subclass.  The standard run()
method invokes the callable object passed to the object’s constructor as
the target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.



start()¶
Start the process’s activity.
This must be called at most once per process object.  It arranges for the
object’s run() method to be invoked in a separate process.



join([timeout])¶
If the optional argument timeout is None (the default), the method
blocks until the process whose join() method is called terminates.
If timeout is a positive number, it blocks at most timeout seconds.
Note that the method returns None if its process terminates or if the
method times out.  Check the process’s exitcode to determine if
it terminated.
A process can be joined many times.
A process cannot join itself because this would cause a deadlock.  It is
an error to attempt to join a process before it has been started.



name¶
The process’s name.  The name is a string used for identification purposes
only.  It has no semantics.  Multiple processes may be given the same
name.
The initial name is set by the constructor.  If no explicit name is
provided to the constructor, a name of the form
‘Process-N1:N2:…:Nk’ is constructed, where
each Nk is the N-th child of its parent.



is_alive()¶
Return whether the process is alive.
Roughly, a process object is alive from the moment the start()
method returns until the child process terminates.



daemon¶
The process’s daemon flag, a Boolean value.  This must be set before
start() is called.
The initial value is inherited from the creating process.
When a process exits, it attempts to terminate all of its daemonic child
processes.
Note that a daemonic process is not allowed to create child processes.
Otherwise a daemonic process would leave its children orphaned if it gets
terminated when its parent process exits. Additionally, these are not
Unix daemons or services, they are normal processes that will be
terminated (and not joined) if non-daemonic processes have exited.

In addition to the  threading.Thread API, Process objects
also support the following attributes and methods:


pid¶
Return the process ID.  Before the process is spawned, this will be
None.



exitcode¶
The child’s exit code.  This will be None if the process has not yet
terminated.  A negative value -N indicates that the child was terminated
by signal N.



authkey¶
The process’s authentication key (a byte string).
When multiprocessing is initialized the main process is assigned a
random string using os.urandom().
When a Process object is created, it will inherit the
authentication key of its parent process, although this may be changed by
setting authkey to another byte string.
See Authentication keys.



sentinel¶
A numeric handle of a system object which will become “ready” when
the process ends.
You can use this value if you want to wait on several events at
once using multiprocessing.connection.wait().  Otherwise
calling join() is simpler.
On Windows, this is an OS handle usable with the WaitForSingleObject
and WaitForMultipleObjects family of API calls.  On Unix, this is
a file descriptor usable with primitives from the select module.

New in version 3.3.




terminate()¶
Terminate the process.  On Unix this is done using the SIGTERM signal;
on Windows TerminateProcess() is used.  Note that exit handlers and
finally clauses, etc., will not be executed.
Note that descendant processes of the process will not be terminated –
they will simply become orphaned.

Warning
If this method is used when the associated process is using a pipe or
queue then the pipe or queue is liable to become corrupted and may
become unusable by other process.  Similarly, if the process has
acquired a lock or semaphore etc. then terminating it is liable to
cause other processes to deadlock.




kill()¶
Same as terminate() but using the SIGKILL signal on Unix.

New in version 3.7.




close()¶
Close the Process object, releasing all resources associated
with it.  ValueError is raised if the underlying process
is still running.  Once close() returns successfully, most
other methods and attributes of the Process object will
raise ValueError.

New in version 3.7.


Note that the start(), join(), is_alive(),
terminate() and exitcode methods should only be called by
the process that created the process object.
Example usage of some of the methods of Process:
>>> import multiprocessing, time, signal
>>> p = multiprocessing.Process(target=time.sleep, args=(1000,))
>>> print(p, p.is_alive())
<Process(Process-1, initial)> False
>>> p.start()
>>> print(p, p.is_alive())
<Process(Process-1, started)> True
>>> p.terminate()
>>> time.sleep(0.1)
>>> print(p, p.is_alive())
<Process(Process-1, stopped[SIGTERM])> False
>>> p.exitcode == -signal.SIGTERM
True


