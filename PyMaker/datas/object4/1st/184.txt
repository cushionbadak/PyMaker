link:
reference/import.html#the-module-cache

docs:

5.3.1. The module cache¶
The first place checked during import search is sys.modules.  This
mapping serves as a cache of all modules that have been previously imported,
including the intermediate paths.  So if foo.bar.baz was previously
imported, sys.modules will contain entries for foo, foo.bar,
and foo.bar.baz.  Each key will have as its value the corresponding module
object.
During import, the module name is looked up in sys.modules and if
present, the associated value is the module satisfying the import, and the
process completes.  However, if the value is None, then a
ModuleNotFoundError is raised.  If the module name is missing, Python will
continue searching for the module.
sys.modules is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it),
but it will invalidate the cache entry for the named module, causing
Python to search anew for the named module upon its next
import. The key can also be assigned to None, forcing the next import
of the module to result in a ModuleNotFoundError.
Beware though, as if you keep a reference to the module object,
invalidate its cache entry in sys.modules, and then re-import the
named module, the two module objects will not be the same. By contrast,
importlib.reload() will reuse the same module object, and simply
reinitialise the module contents by rerunning the module’s code.
