link:
library/imp.html#imp.reload

docs:

<dt id="imp.reload">
<code class="descclassname">imp.</code><code class="descname">reload</code><span class="sig-paren">(</span><em>module</em><span class="sig-paren">)</span><a class="headerlink" href="#imp.reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Reload a previously imported <em>module</em>.  The argument must be a module object, so
it must have been successfully imported before.  This is useful if you have
edited the module source file using an external editor and want to try out the
new version without leaving the Python interpreter.  The return value is the
module object (the same as the <em>module</em> argument).</p>
<p>When <code class="docutils literal notranslate"><span class="pre">reload(module)</span></code> is executed:</p>
<ul class="simple">
<li>Python modules’ code is recompiled and the module-level code reexecuted,
defining a new set of objects which are bound to names in the module’s
dictionary.  The <code class="docutils literal notranslate"><span class="pre">init</span></code> function of extension modules is not called a second
time.</li>
<li>As with all other objects in Python the old objects are only reclaimed after
their reference counts drop to zero.</li>
<li>The names in the module namespace are updated to point to any new or changed
objects.</li>
<li>Other references to the old objects (such as names external to the module) are
not rebound to refer to the new objects and must be updated in each namespace
where they occur if that is desired.</li>
</ul>
<p>There are a number of other caveats:</p>
<p>When a module is reloaded, its dictionary (containing the module’s global
variables) is retained.  Redefinitions of names will override the old
definitions, so this is generally not a problem.  If the new version of a module
does not define a name that was defined by the old version, the old definition
remains.  This feature can be used to the module’s advantage if it maintains a
global table or cache of objects — with a <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> statement it can test
for the table’s presence and skip its initialization if desired:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p>It is legal though generally not very useful to reload built-in or dynamically
loaded modules, except for <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where the top-level script is run."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> and <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>.
In many cases, however, extension modules are not designed to be initialized
more than once, and may fail in arbitrary ways when reloaded.</p>
<p>If a module imports objects from another module using <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> …
<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> …, calling <a class="reference internal" href="#imp.reload" title="imp.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> for the other module does not
redefine the objects imported from it — one way around this is to re-execute
the <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code> statement, another is to use <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> and qualified
names (<em>module</em>.*name*) instead.</p>
<p>If a module instantiates instances of a class, reloading the module that defines
the class does not affect the method definitions of the instances — they
continue to use the old class definition.  The same is true for derived classes.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>Relies on both <code class="docutils literal notranslate"><span class="pre">__name__</span></code> and <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> being defined on the module
being reloaded instead of just <code class="docutils literal notranslate"><span class="pre">__name__</span></code>.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 3.4: </span>Use <a class="reference internal" href="importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> instead.</p>
</div>
</dd>