link:
library/email.policy.html#email.policy.Policy

docs:

<dt id="email.policy.Policy">
<em class="property">class </em><code class="descclassname">email.policy.</code><code class="descname">Policy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> for all policy classes.  It provides
default implementations for a couple of trivial methods, as well as the
implementation of the immutability property, the <a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code></a> method, and
the constructor semantics.</p>
<p>The constructor of a policy class can be passed various keyword arguments.
The arguments that may be specified are any non-method properties on this
class, plus any additional non-method properties on the concrete class.  A
value specified in the constructor will override the default value for the
corresponding attribute.</p>
<p>This class defines the following properties, and thus values for the
following may be passed in the constructor of any policy class:</p>
<dl class="attribute">
<dt id="email.policy.Policy.max_line_length">
<code class="descname">max_line_length</code><a class="headerlink" href="#email.policy.Policy.max_line_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum length of any line in the serialized output, not counting the
end of line character(s).  Default is 78, per <span class="target" id="index-0"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.  A value of
<code class="docutils literal notranslate"><span class="pre">0</span></code> or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> indicates that no line wrapping should be
done at all.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.Policy.linesep">
<code class="descname">linesep</code><a class="headerlink" href="#email.policy.Policy.linesep" title="Permalink to this definition">¶</a></dt>
<dd><p>The string to be used to terminate lines in serialized output.  The
default is <code class="docutils literal notranslate"><span class="pre">\n</span></code> because that’s the internal end-of-line discipline used
by Python, though <code class="docutils literal notranslate"><span class="pre">\r\n</span></code> is required by the RFCs.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.Policy.cte_type">
<code class="descname">cte_type</code><a class="headerlink" href="#email.policy.Policy.cte_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the type of Content Transfer Encodings that may be or are
required to be used.  The possible values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%"/>
<col width="89%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">7bit</span></code></td>
<td>all data must be “7 bit clean” (ASCII-only).  This means that
where necessary data will be encoded using either
quoted-printable or base64 encoding.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">8bit</span></code></td>
<td>data is not constrained to be 7 bit clean.  Data in headers is
still required to be ASCII-only and so will be encoded (see
<a class="reference internal" href="#email.policy.Policy.fold_binary" title="email.policy.Policy.fold_binary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold_binary()</span></code></a> and <a class="reference internal" href="#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code class="xref py py-attr docutils literal notranslate"><span class="pre">utf8</span></code></a> below for
exceptions), but body parts may use the <code class="docutils literal notranslate"><span class="pre">8bit</span></code> CTE.</td>
</tr>
</tbody>
</table>
<p>A <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> value of <code class="docutils literal notranslate"><span class="pre">8bit</span></code> only works with <code class="docutils literal notranslate"><span class="pre">BytesGenerator</span></code>, not
<code class="docutils literal notranslate"><span class="pre">Generator</span></code>, because strings cannot contain binary data.  If a
<code class="docutils literal notranslate"><span class="pre">Generator</span></code> is operating under a policy that specifies
<code class="docutils literal notranslate"><span class="pre">cte_type=8bit</span></code>, it will act as if <code class="docutils literal notranslate"><span class="pre">cte_type</span></code> is <code class="docutils literal notranslate"><span class="pre">7bit</span></code>.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.Policy.raise_on_defect">
<code class="descname">raise_on_defect</code><a class="headerlink" href="#email.policy.Policy.raise_on_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, any defects encountered will be raised as errors.  If
<a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> (the default), defects will be passed to the
<a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a> method.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.Policy.mangle_from_">
<code class="descname">mangle_from_</code><a class="headerlink" href="#email.policy.Policy.mangle_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, lines starting with <em>“From “</em> in the body are
escaped by putting a <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> in front of them. This parameter is used when
the message is being serialized by a generator.
Default: <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.5: </span>The <em>mangle_from_</em> parameter.</p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.Policy.message_factory">
<code class="descname">message_factory</code><a class="headerlink" href="#email.policy.Policy.message_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A factory function for constructing a new empty message object.  Used
by the parser when building messages.  Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>, in
which case <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> is used.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.6.</span></p>
</div>
</dd></dl>
<p>The following <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> method is intended to be called by code using
the email library to create policy instances with custom settings:</p>
<dl class="method">
<dt id="email.policy.Policy.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> instance whose attributes have the same
values as the current instance, except where those attributes are
given new values by the keyword arguments.</p>
</dd></dl>
<p>The remaining <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> methods are called by the email package code,
and are not intended to be called by an application using the email package.
A custom policy must implement all of these methods.</p>
<dl class="method">
<dt id="email.policy.Policy.handle_defect">
<code class="descname">handle_defect</code><span class="sig-paren">(</span><em>obj</em>, <em>defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.handle_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a <em>defect</em> found on <em>obj</em>.  When the email package calls this
method, <em>defect</em> will always be a subclass of
<code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>.</p>
<p>The default implementation checks the <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raise_on_defect</span></code></a> flag.  If
it is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <em>defect</em> is raised as an exception.  If it is <code class="docutils literal notranslate"><span class="pre">False</span></code>
(the default), <em>obj</em> and <em>defect</em> are passed to <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_defect()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.register_defect">
<code class="descname">register_defect</code><span class="sig-paren">(</span><em>obj</em>, <em>defect</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.register_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <em>defect</em> on <em>obj</em>.  In the email package, <em>defect</em> will always
be a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Defect</span></code>.</p>
<p>The default implementation calls the <code class="docutils literal notranslate"><span class="pre">append</span></code> method of the <code class="docutils literal notranslate"><span class="pre">defects</span></code>
attribute of <em>obj</em>.  When the email package calls <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><code class="xref py py-attr docutils literal notranslate"><span class="pre">handle_defect</span></code></a>,
<em>obj</em> will normally have a <code class="docutils literal notranslate"><span class="pre">defects</span></code> attribute that has an <code class="docutils literal notranslate"><span class="pre">append</span></code>
method.  Custom object types used with the email package (for example,
custom <code class="docutils literal notranslate"><span class="pre">Message</span></code> objects) should also provide such an attribute,
otherwise defects in parsed messages will raise unexpected errors.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.header_max_count">
<code class="descname">header_max_count</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_max_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum allowed number of headers named <em>name</em>.</p>
<p>Called when a header is added to an <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>
or <a class="reference internal" href="email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> object.  If the returned value is not
<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>, and there are already a number of headers with the
name <em>name</em> greater than or equal to the value returned, a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised.</p>
<p>Because the default behavior of <code class="docutils literal notranslate"><span class="pre">Message.__setitem__</span></code> is to append the
value to the list of headers, it is easy to create duplicate headers
without realizing it.  This method allows certain headers to be limited
in the number of instances of that header that may be added to a
<code class="docutils literal notranslate"><span class="pre">Message</span></code> programmatically.  (The limit is not observed by the parser,
which will faithfully produce as many headers as exist in the message
being parsed.)</p>
<p>The default implementation returns <code class="docutils literal notranslate"><span class="pre">None</span></code> for all header names.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.header_source_parse">
<code class="descname">header_source_parse</code><span class="sig-paren">(</span><em>sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_source_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with a list of strings, each string
ending with the line separation characters found in the source being
parsed.  The first line includes the field header name and separator.
All whitespace in the source is preserved.  The method should return the
<code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> tuple that is to be stored in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> to
represent the parsed header.</p>
<p>If an implementation wishes to retain compatibility with the existing
email package policies, <em>name</em> should be the case preserved name (all
characters up to the ‘<code class="docutils literal notranslate"><span class="pre">:</span></code>’ separator), while <em>value</em> should be the
unfolded value (all line separator characters removed, but whitespace
kept intact), stripped of leading whitespace.</p>
<p><em>sourcelines</em> may contain surrogateescaped binary data.</p>
<p>There is no default implementation</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.header_store_parse">
<code class="descname">header_store_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_store_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the name and value provided by
the application program when the application program is modifying a
<code class="docutils literal notranslate"><span class="pre">Message</span></code> programmatically (as opposed to a <code class="docutils literal notranslate"><span class="pre">Message</span></code> created by a
parser).  The method should return the <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">value)</span></code> tuple that is to
be stored in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> to represent the header.</p>
<p>If an implementation wishes to retain compatibility with the existing
email package policies, the <em>name</em> and <em>value</em> should be strings or
string subclasses that do not change the content of the passed in
arguments.</p>
<p>There is no default implementation</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.header_fetch_parse">
<code class="descname">header_fetch_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.header_fetch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the <em>name</em> and <em>value</em> currently
stored in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> when that header is requested by the
application program, and whatever the method returns is what is passed
back to the application as the value of the header being retrieved.
Note that there may be more than one header with the same name stored in
the <code class="docutils literal notranslate"><span class="pre">Message</span></code>; the method is passed the specific name and value of the
header destined to be returned to the application.</p>
<p><em>value</em> may contain surrogateescaped binary data.  There should be no
surrogateescaped binary data in the value returned by the method.</p>
<p>There is no default implementation</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the <em>name</em> and <em>value</em> currently
stored in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> for a given header.  The method should return a
string that represents that header “folded” correctly (according to the
policy settings) by composing the <em>name</em> with the <em>value</em> and inserting
<a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><code class="xref py py-attr docutils literal notranslate"><span class="pre">linesep</span></code></a> characters at the appropriate places.  See <span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
for a discussion of the rules for folding email headers.</p>
<p><em>value</em> may contain surrogateescaped binary data.  There should be no
surrogateescaped binary data in the string returned by the method.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.Policy.fold_binary">
<code class="descname">fold_binary</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.Policy.fold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a>, except that the returned value should be a
bytes object rather than a string.</p>
<p><em>value</em> may contain surrogateescaped binary data.  These could be
converted back into binary data in the returned bytes object.</p>
</dd></dl>
</dd>