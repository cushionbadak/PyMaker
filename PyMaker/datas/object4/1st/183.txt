link:
reference/import.html#searching

docs:

5.3. Searching¶
To begin the search, Python needs the fully qualified
name of the module (or package, but for the purposes of this discussion, the
difference is immaterial) being imported.  This name may come from various
arguments to the import statement, or from the parameters to the
importlib.import_module() or __import__() functions.
This name will be used in various phases of the import search, and it may be
the dotted path to a submodule, e.g. foo.bar.baz.  In this case, Python
first tries to import foo, then foo.bar, and finally foo.bar.baz.
If any of the intermediate imports fail, a ModuleNotFoundError is raised.

5.3.1. The module cache¶
The first place checked during import search is sys.modules.  This
mapping serves as a cache of all modules that have been previously imported,
including the intermediate paths.  So if foo.bar.baz was previously
imported, sys.modules will contain entries for foo, foo.bar,
and foo.bar.baz.  Each key will have as its value the corresponding module
object.
During import, the module name is looked up in sys.modules and if
present, the associated value is the module satisfying the import, and the
process completes.  However, if the value is None, then a
ModuleNotFoundError is raised.  If the module name is missing, Python will
continue searching for the module.
sys.modules is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it),
but it will invalidate the cache entry for the named module, causing
Python to search anew for the named module upon its next
import. The key can also be assigned to None, forcing the next import
of the module to result in a ModuleNotFoundError.
Beware though, as if you keep a reference to the module object,
invalidate its cache entry in sys.modules, and then re-import the
named module, the two module objects will not be the same. By contrast,
importlib.reload() will reuse the same module object, and simply
reinitialise the module contents by rerunning the module’s code.


5.3.2. Finders and loaders¶
If the named module is not found in sys.modules, then Python’s import
protocol is invoked to find and load the module.  This protocol consists of
two conceptual objects, finders and loaders.
A finder’s job is to determine whether it can find the named module using
whatever strategy it knows about. Objects that implement both of these
interfaces are referred to as importers - they return
themselves when they find that they can load the requested module.
Python includes a number of default finders and importers.  The first one
knows how to locate built-in modules, and the second knows how to locate
frozen modules.  A third default finder searches an import path
for modules.  The import path is a list of locations that may
name file system paths or zip files.  It can also be extended to search
for any locatable resource, such as those identified by URLs.
The import machinery is extensible, so new finders can be added to extend the
range and scope of module searching.
Finders do not actually load modules.  If they can find the named module, they
return a module spec, an encapsulation of the module’s import-related
information, which the import machinery then uses when loading the module.
The following sections describe the protocol for finders and loaders in more
detail, including how you can create and register new ones to extend the
import machinery.

Changed in version 3.4: In previous versions of Python, finders returned loaders
directly, whereas now they return module specs which contain loaders.
Loaders are still used during import but have fewer responsibilities.



5.3.3. Import hooks¶
The import machinery is designed to be extensible; the primary mechanism for
this are the import hooks.  There are two types of import hooks: meta
hooks and import path hooks.
Meta hooks are called at the start of import processing, before any other
import processing has occurred, other than sys.modules cache look up.
This allows meta hooks to override sys.path processing, frozen
modules, or even built-in modules.  Meta hooks are registered by adding new
finder objects to sys.meta_path, as described below.
Import path hooks are called as part of sys.path (or
package.__path__) processing, at the point where their associated path
item is encountered.  Import path hooks are registered by adding new callables
to sys.path_hooks as described below.


5.3.4. The meta path¶
When the named module is not found in sys.modules, Python next
searches sys.meta_path, which contains a list of meta path finder
objects.  These finders are queried in order to see if they know how to handle
the named module.  Meta path finders must implement a method called
find_spec() which takes three arguments:
a name, an import path, and (optionally) a target module.  The meta path
finder can use any strategy it wants to determine whether it can handle
the named module or not.
If the meta path finder knows how to handle the named module, it returns a
spec object.  If it cannot handle the named module, it returns None.  If
sys.meta_path processing reaches the end of its list without returning
a spec, then a ModuleNotFoundError is raised.  Any other exceptions
raised are simply propagated up, aborting the import process.
The find_spec() method of meta path
finders is called with two or three arguments.  The first is the fully
qualified name of the module being imported, for example foo.bar.baz.
The second argument is the path entries to use for the module search.  For
top-level modules, the second argument is None, but for submodules or
subpackages, the second argument is the value of the parent package’s
__path__ attribute. If the appropriate __path__ attribute cannot
be accessed, a ModuleNotFoundError is raised.  The third argument
is an existing module object that will be the target of loading later.
The import system passes in a target module only during reload.
The meta path may be traversed multiple times for a single import request.
For example, assuming none of the modules involved has already been cached,
importing foo.bar.baz will first perform a top level import, calling
mpf.find_spec("foo", None, None) on each meta path finder (mpf). After
foo has been imported, foo.bar will be imported by traversing the
meta path a second time, calling
mpf.find_spec("foo.bar", foo.__path__, None). Once foo.bar has been
imported, the final traversal will call
mpf.find_spec("foo.bar.baz", foo.bar.__path__, None).
Some meta path finders only support top level imports. These importers will
always return None when anything other than None is passed as the
second argument.
Python’s default sys.meta_path has three meta path finders, one that
knows how to import built-in modules, one that knows how to import frozen
modules, and one that knows how to import modules from an import path
(i.e. the path based finder).

Changed in version 3.4: The find_spec() method of meta path
finders replaced find_module(), which
is now deprecated.  While it will continue to work without change, the
import machinery will try it only if the finder does not implement
find_spec().


