link:
library/csv.html#module-contents

docs:

Module Contents¶
The csv module defines the following functions:


csv.reader(csvfile, dialect='excel', **fmtparams)¶
Return a reader object which will iterate over lines in the given csvfile.
csvfile can be any object which supports the iterator protocol and returns a
string each time its __next__() method is called — file objects and list objects are both suitable.   If csvfile is a file object,
it should be opened with newline=''. [1]  An optional
dialect parameter can be given which is used to define a set of parameters
specific to a particular CSV dialect.  It may be an instance of a subclass of
the Dialect class or one of the strings returned by the
list_dialects() function.  The other optional fmtparams keyword arguments
can be given to override individual formatting parameters in the current
dialect.  For full details about the dialect and formatting parameters, see
section Dialects and Formatting Parameters.
Each row read from the csv file is returned as a list of strings.  No
automatic data type conversion is performed unless the QUOTE_NONNUMERIC format
option is specified (in which case unquoted fields are transformed into floats).
A short usage example:
>>> import csv
>>> with open('eggs.csv', newline='') as csvfile:
...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
...     for row in spamreader:
...         print(', '.join(row))
Spam, Spam, Spam, Spam, Spam, Baked Beans
Spam, Lovely Spam, Wonderful Spam





csv.writer(csvfile, dialect='excel', **fmtparams)¶
Return a writer object responsible for converting the user’s data into delimited
strings on the given file-like object.  csvfile can be any object with a
write() method.  If csvfile is a file object, it should be opened with
newline='' [1].  An optional dialect
parameter can be given which is used to define a set of parameters specific to a
particular CSV dialect.  It may be an instance of a subclass of the
Dialect class or one of the strings returned by the
list_dialects() function.  The other optional fmtparams keyword arguments
can be given to override individual formatting parameters in the current
dialect.  For full details about the dialect and formatting parameters, see
section Dialects and Formatting Parameters. To make it
as easy as possible to interface with modules which implement the DB API, the
value None is written as the empty string.  While this isn’t a
reversible transformation, it makes it easier to dump SQL NULL data values to
CSV files without preprocessing the data returned from a cursor.fetch* call.
All other non-string data are stringified with str() before being written.
A short usage example:
import csv
with open('eggs.csv', 'w', newline='') as csvfile:
    spamwriter = csv.writer(csvfile, delimiter=' ',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
    spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
    spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])





csv.register_dialect(name[, dialect[, **fmtparams]])¶
Associate dialect with name.  name must be a string. The
dialect can be specified either by passing a sub-class of Dialect, or
by fmtparams keyword arguments, or both, with keyword arguments overriding
parameters of the dialect. For full details about the dialect and formatting
parameters, see section Dialects and Formatting Parameters.



csv.unregister_dialect(name)¶
Delete the dialect associated with name from the dialect registry.  An
Error is raised if name is not a registered dialect name.



csv.get_dialect(name)¶
Return the dialect associated with name.  An Error is raised if
name is not a registered dialect name.  This function returns an immutable
Dialect.



csv.list_dialects()¶
Return the names of all registered dialects.



csv.field_size_limit([new_limit])¶
Returns the current maximum field size allowed by the parser. If new_limit is
given, this becomes the new limit.

The csv module defines the following classes:


class csv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)¶
Create an object that operates like a regular reader but maps the
information in each row to an OrderedDict
whose keys are given by the optional fieldnames parameter.
The fieldnames parameter is a sequence.  If fieldnames is
omitted, the values in the first row of file f will be used as the
fieldnames.  Regardless of how the fieldnames are determined, the ordered
dictionary preserves their original ordering.
If a row has more fields than fieldnames, the remaining data is put in a
list and stored with the fieldname specified by restkey (which defaults
to None).  If a non-blank row has fewer fields than fieldnames, the
missing values are filled-in with None.
All other optional or keyword arguments are passed to the underlying
reader instance.

Changed in version 3.6: Returned rows are now of type OrderedDict.

A short usage example:
>>> import csv
>>> with open('names.csv', newline='') as csvfile:
...     reader = csv.DictReader(csvfile)
...     for row in reader:
...         print(row['first_name'], row['last_name'])
...
Eric Idle
John Cleese

>>> print(row)
OrderedDict([('first_name', 'John'), ('last_name', 'Cleese')])





class csv.DictWriter(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)¶
Create an object which operates like a regular writer but maps dictionaries
onto output rows.  The fieldnames parameter is a sequence of keys that identify the order in which values in the
dictionary passed to the writerow() method are written to file
f.  The optional restval parameter specifies the value to be
written if the dictionary is missing a key in fieldnames.  If the
dictionary passed to the writerow() method contains a key not found in
fieldnames, the optional extrasaction parameter indicates what action to
take.
If it is set to 'raise', the default value, a ValueError
is raised.
If it is set to 'ignore', extra values in the dictionary are ignored.
Any other optional or keyword arguments are passed to the underlying
writer instance.
Note that unlike the DictReader class, the fieldnames parameter
of the DictWriter class is not optional.
A short usage example:
import csv

with open('names.csv', 'w', newline='') as csvfile:
    fieldnames = ['first_name', 'last_name']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

    writer.writeheader()
    writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
    writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
    writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})





class csv.Dialect¶
The Dialect class is a container class relied on primarily for its
attributes, which are used to define the parameters for a specific
reader or writer instance.



class csv.excel¶
The excel class defines the usual properties of an Excel-generated CSV
file.  It is registered with the dialect name 'excel'.



class csv.excel_tab¶
The excel_tab class defines the usual properties of an Excel-generated
TAB-delimited file.  It is registered with the dialect name 'excel-tab'.



class csv.unix_dialect¶
The unix_dialect class defines the usual properties of a CSV file
generated on UNIX systems, i.e. using '\n' as line terminator and quoting
all fields.  It is registered with the dialect name 'unix'.

New in version 3.2.




class csv.Sniffer¶
The Sniffer class is used to deduce the format of a CSV file.
The Sniffer class provides two methods:


sniff(sample, delimiters=None)¶
Analyze the given sample and return a Dialect subclass
reflecting the parameters found.  If the optional delimiters parameter
is given, it is interpreted as a string containing possible valid
delimiter characters.



has_header(sample)¶
Analyze the sample text (presumed to be in CSV format) and return
True if the first row appears to be a series of column headers.


An example for Sniffer use:
with open('example.csv', newline='') as csvfile:
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    reader = csv.reader(csvfile, dialect)
    # ... process CSV file contents here ...


The csv module defines the following constants:


csv.QUOTE_ALL¶
Instructs writer objects to quote all fields.



csv.QUOTE_MINIMAL¶
Instructs writer objects to only quote those fields which contain
special characters such as delimiter, quotechar or any of the characters in
lineterminator.



csv.QUOTE_NONNUMERIC¶
Instructs writer objects to quote all non-numeric fields.
Instructs the reader to convert all non-quoted fields to type float.



csv.QUOTE_NONE¶
Instructs writer objects to never quote fields.  When the current
delimiter occurs in output data it is preceded by the current escapechar
character.  If escapechar is not set, the writer will raise Error if
any characters that require escaping are encountered.
Instructs reader to perform no special processing of quote characters.

The csv module defines the following exception:


exception csv.Error¶
Raised by any of the functions when an error is detected.

