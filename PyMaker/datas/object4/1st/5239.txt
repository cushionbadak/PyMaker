link:
library/ssl.html#ssl.SSLSocket.verify_client_post_handshake

docs:

<dt id="ssl.SSLSocket.verify_client_post_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">verify_client_post_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.verify_client_post_handshake" title="Permalink to this definition">¶</a></dt>
<dd><p>Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA
can only be initiated for a TLS 1.3 connection from a server-side socket,
after the initial TLS handshake and with PHA enabled on both sides, see
<a class="reference internal" href="#ssl.SSLContext.post_handshake_auth" title="ssl.SSLContext.post_handshake_auth"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SSLContext.post_handshake_auth</span></code></a>.</p>
<p>The method does not perform a cert exchange immediately. The server-side
sends a CertificateRequest during the next write event and expects the
client to respond with a certificate on the next read event.</p>
<p>If any precondition isn’t met (e.g. not TLS 1.3, PHA not enabled), an
<a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> is raised.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the method raises <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.7.1.</span></p>
</div>
</dd>