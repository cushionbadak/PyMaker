link:
library/doctest.html#doctest.IGNORE_EXCEPTION_DETAIL

docs:


doctest.IGNORE_EXCEPTION_DETAIL¶
When specified, an example that expects an exception passes if an exception of
the expected type is raised, even if the exception detail does not match.  For
example, an example expecting ValueError: 42 will pass if the actual
exception raised is ValueError: 3*14, but will fail, e.g., if
TypeError is raised.
It will also ignore the module name used in Python 3 doctest reports. Hence
both of these variations will work with the flag specified, regardless of
whether the test is run under Python 2.7 or Python 3.2 (or later versions):
>>> raise CustomError('message')
Traceback (most recent call last):
CustomError: message

>>> raise CustomError('message')
Traceback (most recent call last):
my_module.CustomError: message


Note that ELLIPSIS can also be used to ignore the
details of the exception message, but such a test may still fail based
on whether or not the module details are printed as part of the
exception name. Using IGNORE_EXCEPTION_DETAIL and the details
from Python 2.3 is also the only clear way to write a doctest that doesn’t
care about the exception detail yet continues to pass under Python 2.3 or
earlier (those releases do not support doctest directives and ignore them as irrelevant comments). For example:
>>> (1, 2)[3] = 'moo'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object doesn't support item assignment


passes under Python 2.3 and later Python versions with the flag specified,
even though the detail
changed in Python 2.4 to say “does not” instead of “doesn’t”.

Changed in version 3.2: IGNORE_EXCEPTION_DETAIL now also ignores any information relating
to the module containing the exception under test.

