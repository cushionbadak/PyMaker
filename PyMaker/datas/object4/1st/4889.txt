link:
library/asyncio-protocol.html#asyncio.BaseTransport.get_extra_info

docs:

<dt id="asyncio.BaseTransport.get_extra_info">
<code class="descclassname">BaseTransport.</code><code class="descname">get_extra_info</code><span class="sig-paren">(</span><em>name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.BaseTransport.get_extra_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the transport or underlying resources
it uses.</p>
<p><em>name</em> is a string representing the piece of transport-specific
information to get.</p>
<p><em>default</em> is the value to return if the information is not
available, or if the transport does not support querying it
with the given third-party event loop implementation or on the
current platform.</p>
<p>For example, the following code attempts to get the underlying
socket object of the transport:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">'socket'</span><span class="p">)</span>
<span class="k">if</span> <span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">getsockopt</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
</pre></div>
</div>
<p>Categories of information that can be queried on some transports:</p>
<ul class="simple">
<li>socket:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'peername'</span></code>: the remote address to which the socket is
connected, result of <a class="reference internal" href="socket.html#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getpeername()</span></code></a>
(<code class="docutils literal notranslate"><span class="pre">None</span></code> on error)</li>
<li><code class="docutils literal notranslate"><span class="pre">'socket'</span></code>: <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> instance</li>
<li><code class="docutils literal notranslate"><span class="pre">'sockname'</span></code>: the socket’s own address,
result of <a class="reference internal" href="socket.html#socket.socket.getsockname" title="socket.socket.getsockname"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockname()</span></code></a></li>
</ul>
</li>
<li>SSL socket:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'compression'</span></code>: the compression algorithm being used as a
string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the connection isn’t compressed; result
of <a class="reference internal" href="ssl.html#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.compression()</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">'cipher'</span></code>: a three-value tuple containing the name of the
cipher being used, the version of the SSL protocol that defines
its use, and the number of secret bits being used; result of
<a class="reference internal" href="ssl.html#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.cipher()</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">'peercert'</span></code>: peer certificate; result of
<a class="reference internal" href="ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.getpeercert()</span></code></a></li>
<li><code class="docutils literal notranslate"><span class="pre">'sslcontext'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> instance</li>
<li><code class="docutils literal notranslate"><span class="pre">'ssl_object'</span></code>: <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> or
<a class="reference internal" href="ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> instance</li>
</ul>
</li>
<li>pipe:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'pipe'</span></code>: pipe object</li>
</ul>
</li>
<li>subprocess:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'subprocess'</span></code>: <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> instance</li>
</ul>
</li>
</ul>
</dd>