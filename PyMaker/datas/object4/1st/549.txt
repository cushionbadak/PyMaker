link:
library/stdtypes.html#memoryview

docs:

<dt id="memoryview">
<em class="property">class </em><code class="descname">memoryview</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> that references <em>obj</em>.  <em>obj</em> must support the
buffer protocol.  Built-in objects that support the buffer protocol include
<a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> has the notion of an <em>element</em>, which is the
atomic memory unit handled by the originating object <em>obj</em>.  For many
simple types such as <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, an element
is a single byte, but other types such as <a class="reference internal" href="array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a> may have
bigger elements.</p>
<p><code class="docutils literal notranslate"><span class="pre">len(view)</span></code> is equal to the length of <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-class docutils literal notranslate"><span class="pre">tolist</span></code></a>.
If <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">0</span></code>, the length is 1. If <code class="docutils literal notranslate"><span class="pre">view.ndim</span> <span class="pre">=</span> <span class="pre">1</span></code>, the length
is equal to the number of elements in the view. For higher dimensions,
the length is equal to the length of the nested list representation of
the view. The <a class="reference internal" href="#memoryview.itemsize" title="memoryview.itemsize"><code class="xref py py-class docutils literal notranslate"><span class="pre">itemsize</span></code></a> attribute will give you the
number of bytes in a single element.</p>
<p>A <a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> supports slicing and indexing to expose its data.
One-dimensional slicing will result in a subview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">103</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">&lt;memory at 0x7f3ddc9f4350&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="go">b'bce'</span>
</pre></div>
</div>
<p>If <a class="reference internal" href="#memoryview.format" title="memoryview.format"><code class="xref py py-class docutils literal notranslate"><span class="pre">format</span></code></a> is one of the native format specifiers
from the <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module, indexing with an integer or a tuple of
integers is also supported and returns a single <em>element</em> with
the correct type.  One-dimensional memoryviews can be indexed
with an integer or a one-integer tuple.  Multi-dimensional memoryviews
can be indexed with tuples of exactly <em>ndim</em> integers where <em>ndim</em> is
the number of dimensions.  Zero-dimensional memoryviews can be indexed
with the empty tuple.</p>
<p>Here is an example with a non-byte format:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">11111111</span><span class="p">,</span> <span class="mi">22222222</span><span class="p">,</span> <span class="o">-</span><span class="mi">33333333</span><span class="p">,</span> <span class="mi">44444444</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-11111111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">44444444</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[-11111111, -33333333]</span>
</pre></div>
</div>
<p>If the underlying object is writable, the memoryview supports
one-dimensional slice assignment. Resizing is not allowed:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="o">.</span><span class="n">readonly</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="sa">b</span><span class="s1">'z'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'zbcefg')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'123'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'z123fg')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'spam'</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview assignment: lvalue and rvalue have different structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'spam'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">bytearray(b'z1spam')</span>
</pre></div>
</div>
<p>One-dimensional memoryviews of hashable (read-only) types with formats
‘B’, ‘b’ or ‘c’ are also hashable. The hash is defined as
<code class="docutils literal notranslate"><span class="pre">hash(m)</span> <span class="pre">==</span> <span class="pre">hash(m.tobytes())</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abcefg'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">'ce'</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abcefg'</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>One-dimensional memoryviews can now be sliced.
One-dimensional memoryviews with formats ‘B’, ‘b’ or ‘c’ are now hashable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.4: </span>memoryview is now registered automatically with
<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.5: </span>memoryviews can now be indexed with tuple of integers.</p>
</div>
<p><a class="reference internal" href="#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> has several methods:</p>
<dl class="method">
<dt id="memoryview.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>exporter</em><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>A memoryview and a <span class="target" id="index-48"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> exporter are equal if their shapes are
equivalent and if all corresponding values are equal when the operands’
respective format codes are interpreted using <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> syntax.</p>
<p>For the subset of <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> format strings currently supported by
<a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">w</span></code> are equal if <code class="docutils literal notranslate"><span class="pre">v.tolist()</span> <span class="pre">==</span> <span class="pre">w.tolist()</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'I'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">==</span> <span class="n">y</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If either format string is not supported by the <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module,
then the objects will always compare as unequal (even if the format
strings and buffer contents are identical):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ctypes</span> <span class="k">import</span> <span class="n">BigEndianStructure</span><span class="p">,</span> <span class="n">c_long</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">BEPoint</span><span class="p">(</span><span class="n">BigEndianStructure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"x"</span><span class="p">,</span> <span class="n">c_long</span><span class="p">),</span> <span class="p">(</span><span class="s2">"y"</span><span class="p">,</span> <span class="n">c_long</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">BEPoint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">point</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that, as with floating point numbers, <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">is</span> <span class="pre">w</span></code> does <em>not</em> imply
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">w</span></code> for memoryview objects.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>Previous versions compared the raw memory disregarding the item format
and the logical array structure.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="memoryview.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tobytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data in the buffer as a bytestring.  This is equivalent to
calling the <a class="reference internal" href="#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> constructor on the memoryview.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">"abc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">b'abc'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">b'abc'</span>
</pre></div>
</div>
<p>For non-contiguous arrays the result is equal to the flattened list
representation with all elements converted to bytes. <a class="reference internal" href="#memoryview.tobytes" title="memoryview.tobytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tobytes()</span></code></a>
supports all format strings, including those that are not in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module syntax.</p>
</dd></dl>
<dl class="method">
<dt id="memoryview.hex">
<code class="descname">hex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string object containing two hexadecimal digits for each
byte in the buffer.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s2">"abc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">'616263'</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.5.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="memoryview.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data in the buffer as a list of elements.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abc'</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.1, 2.2, 3.3]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span><a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a> now supports all single character native formats in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module syntax as well as multi-dimensional
representations.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="memoryview.release">
<code class="descname">release</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the underlying buffer exposed by the memoryview object.  Many
objects take special actions when a view is held on them (for example,
a <a class="reference internal" href="#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> would temporarily forbid resizing); therefore,
calling release() is handy to remove these restrictions (and free any
dangling resources) as soon as possible.</p>
<p>After this method has been called, any further operation on the view
raises a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></a> (except <a class="reference internal" href="#memoryview.release" title="memoryview.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> itself which can
be called multiple times):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<p>The context management protocol can be used for a similar effect,
using the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="sa">b</span><span class="s1">'abc'</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">97</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">operation forbidden on released memoryview object</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="memoryview.cast">
<code class="descname">cast</code><span class="sig-paren">(</span><em>format</em><span class="optional">[</span>, <em>shape</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#memoryview.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast a memoryview to a new format or shape. <em>shape</em> defaults to
<code class="docutils literal notranslate"><span class="pre">[byte_length//new_itemsize]</span></code>, which means that the result view
will be one-dimensional. The return value is a new memoryview, but
the buffer itself is not copied. Supported casts are 1D -&gt; C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>
and C-contiguous -&gt; 1D.</p>
<p>The destination format is restricted to a single element native format in
<a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> syntax. One of the formats must be a byte format
(‘B’, ‘b’ or ‘c’). The byte length of the result must be the same
as the original length.</p>
<p>Cast 1D/long to 1D/unsigned bytes:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">format</span>
<span class="go">'l'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'B'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">'B'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">24</span>
</pre></div>
</div>
<p>Cast 1D/unsigned bytes to 1D/char:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">'zyz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'a'</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">"&lt;stdin&gt;"</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">memoryview: invalid value for format "B"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'a'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b'ayz')</span>
</pre></div>
</div>
<p>Cast 1D/bytes to 3D/ints to 1D/signed char:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"i"</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'i'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">format</span>
<span class="go">'i'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">format</span>
<span class="go">'b'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
</pre></div>
</div>
<p>Cast 1D/unsigned char to 2D/unsigned long:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"L"</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'L'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">48</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0, 1, 2], [3, 4, 5]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.5: </span>The source format is no longer restricted when casting to a byte view.</p>
</div>
</dd></dl>
<p>There are also several readonly attributes available:</p>
<dl class="attribute">
<dt id="memoryview.obj">
<code class="descname">obj</code><a class="headerlink" href="#memoryview.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying object of the memoryview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">'xyz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#memoryview.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nbytes</span> <span class="pre">==</span> <span class="pre">product(shape)</span> <span class="pre">*</span> <span class="pre">itemsize</span> <span class="pre">==</span> <span class="pre">len(m.tobytes())</span></code>. This is
the amount of space in bytes that the array would use in a contiguous
representation. It is not necessarily equal to <code class="docutils literal notranslate"><span class="pre">len(m)</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'i'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">m</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Multi-dimensional arrays:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buf</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"d"</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">'d'</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">96</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.readonly">
<code class="descname">readonly</code><a class="headerlink" href="#memoryview.readonly" title="Permalink to this definition">¶</a></dt>
<dd><p>A bool indicating whether the memory is read only.</p>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.format">
<code class="descname">format</code><a class="headerlink" href="#memoryview.format" title="Permalink to this definition">¶</a></dt>
<dd><p>A string containing the format (in <a class="reference internal" href="struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> module style) for each
element in the view. A memoryview can be created from exporters with
arbitrary format strings, but some methods (e.g. <a class="reference internal" href="#memoryview.tolist" title="memoryview.tolist"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code></a>) are
restricted to native single element formats.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>format <code class="docutils literal notranslate"><span class="pre">'B'</span></code> is now handled according to the struct module syntax.
This means that <code class="docutils literal notranslate"><span class="pre">memoryview(b'abc')[0]</span> <span class="pre">==</span> <span class="pre">b'abc'[0]</span> <span class="pre">==</span> <span class="pre">97</span></code>.</p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#memoryview.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size in bytes of each element of the memoryview:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">struct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">'H'</span><span class="p">,</span> <span class="p">[</span><span class="mi">32000</span><span class="p">,</span> <span class="mi">32001</span><span class="p">,</span> <span class="mi">32002</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">32000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">'H'</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#memoryview.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer indicating how many dimensions of a multi-dimensional array the
memory represents.</p>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.shape">
<code class="descname">shape</code><a class="headerlink" href="#memoryview.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a> giving the shape of the
memory as an N-dimensional array.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>An empty tuple instead of <code class="docutils literal notranslate"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.strides">
<code class="descname">strides</code><a class="headerlink" href="#memoryview.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of integers the length of <a class="reference internal" href="#memoryview.ndim" title="memoryview.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a> giving the size in bytes to
access each element for each dimension of the array.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>An empty tuple instead of <code class="docutils literal notranslate"><span class="pre">None</span></code> when ndim = 0.</p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.suboffsets">
<code class="descname">suboffsets</code><a class="headerlink" href="#memoryview.suboffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Used internally for PIL-style arrays. The value is informational only.</p>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.c_contiguous">
<code class="descname">c_contiguous</code><a class="headerlink" href="#memoryview.c_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>A bool indicating whether the memory is C-<a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.f_contiguous">
<code class="descname">f_contiguous</code><a class="headerlink" href="#memoryview.f_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>A bool indicating whether the memory is Fortran <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
<dl class="attribute">
<dt id="memoryview.contiguous">
<code class="descname">contiguous</code><a class="headerlink" href="#memoryview.contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>A bool indicating whether the memory is <a class="reference internal" href="../glossary.html#term-contiguous"><span class="xref std std-term">contiguous</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
</dd>