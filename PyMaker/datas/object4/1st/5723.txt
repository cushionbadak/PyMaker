link:
library/email.mime.html#email.mime.audio.MIMEAudio

docs:

<dt id="email.mime.audio.MIMEAudio">
<em class="property">class </em><code class="descclassname">email.mime.audio.</code><code class="descname">MIMEAudio</code><span class="sig-paren">(</span><em>_audiodata</em>, <em>_subtype=None</em>, <em>_encoder=email.encoders.encode_base64</em>, <em>*</em>, <em>policy=compat32</em>, <em>**_params</em><span class="sig-paren">)</span><a class="headerlink" href="#email.mime.audio.MIMEAudio" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime.audio</span></code></p>
<p>A subclass of <a class="reference internal" href="#email.mime.nonmultipart.MIMENonMultipart" title="email.mime.nonmultipart.MIMENonMultipart"><code class="xref py py-class docutils literal notranslate"><span class="pre">MIMENonMultipart</span></code></a>, the
<a class="reference internal" href="#email.mime.audio.MIMEAudio" title="email.mime.audio.MIMEAudio"><code class="xref py py-class docutils literal notranslate"><span class="pre">MIMEAudio</span></code></a> class is used to create MIME message objects of major type
<em class="mimetype">audio</em>. <em>_audiodata</em> is a string containing the raw audio data.  If
this data can be decoded by the standard Python module <a class="reference internal" href="sndhdr.html#module-sndhdr" title="sndhdr: Determine type of a sound file."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sndhdr</span></code></a>, then the
subtype will be automatically included in the <em class="mailheader">Content-Type</em> header.
Otherwise you can explicitly specify the audio subtype via the <em>_subtype</em>
argument.  If the minor type could not be guessed and <em>_subtype</em> was not given,
then <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
<p>Optional <em>_encoder</em> is a callable (i.e. function) which will perform the actual
encoding of the audio data for transport.  This callable takes one argument,
which is the <a class="reference internal" href="#email.mime.audio.MIMEAudio" title="email.mime.audio.MIMEAudio"><code class="xref py py-class docutils literal notranslate"><span class="pre">MIMEAudio</span></code></a> instance. It should use
<a class="reference internal" href="email.compat32-message.html#email.message.Message.get_payload" title="email.message.Message.get_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code></a> and
<a class="reference internal" href="email.compat32-message.html#email.message.Message.set_payload" title="email.message.Message.set_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_payload()</span></code></a> to change the payload to encoded
form.  It should also add
any <em class="mailheader">Content-Transfer-Encoding</em> or other headers to the message
object as necessary.  The default encoding is base64.  See the
<a class="reference internal" href="email.encoders.html#module-email.encoders" title="email.encoders: Encoders for email message payloads."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.encoders</span></code></a> module for a list of the built-in encoders.</p>
<p>Optional <em>policy</em> argument defaults to <a class="reference internal" href="email.policy.html#email.policy.Compat32" title="email.policy.Compat32"><code class="xref py py-class docutils literal notranslate"><span class="pre">compat32</span></code></a>.</p>
<p><em>_params</em> are passed straight through to the base class constructor.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.6: </span>Added <em>policy</em> keyword-only parameter.</p>
</div>
</dd>