link:
library/hashlib.html#hash-algorithms

docs:

Hash algorithms¶
There is one constructor method named for each type of hash.  All return
a hash object with the same simple interface. For example: use sha256() to
create a SHA-256 hash object. You can now feed this object with bytes-like
objects (normally bytes) using the update() method.
At any point you can ask it for the digest of the
concatenation of the data fed to it so far using the digest() or
hexdigest() methods.

Note
For better multithreading performance, the Python GIL is released for
data larger than 2047 bytes at object creation or on update.


Note
Feeding string objects into update() is not supported, as hashes work
on bytes, not on characters.

Constructors for hash algorithms that are always present in this module are
sha1(), sha224(), sha256(), sha384(),
sha512(), blake2b(), and blake2s().
md5() is normally available as well, though it
may be missing if you are using a rare “FIPS compliant” build of Python.
Additional algorithms may also be available depending upon the OpenSSL
library that Python uses on your platform. On most platforms the
sha3_224(), sha3_256(), sha3_384(), sha3_512(),
shake_128(), shake_256() are also available.

New in version 3.6: SHA3 (Keccak) and SHAKE constructors sha3_224(), sha3_256(),
sha3_384(), sha3_512(), shake_128(), shake_256().


New in version 3.6: blake2b() and blake2s() were added.

For example, to obtain the digest of the byte string b'Nobody inspects the
spammish repetition':
>>> import hashlib
>>> m = hashlib.sha256()
>>> m.update(b"Nobody inspects")
>>> m.update(b" the spammish repetition")
>>> m.digest()
b'\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06'
>>> m.digest_size
32
>>> m.block_size
64


More condensed:
>>> hashlib.sha224(b"Nobody inspects the spammish repetition").hexdigest()
'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'




hashlib.new(name[, data])¶
Is a generic constructor that takes the string name of the desired
algorithm as its first parameter.  It also exists to allow access to the
above listed hashes as well as any other algorithms that your OpenSSL
library may offer.  The named constructors are much faster than new()
and should be preferred.

Using new() with an algorithm provided by OpenSSL:
>>> h = hashlib.new('ripemd160')
>>> h.update(b"Nobody inspects the spammish repetition")
>>> h.hexdigest()
'cc4a5ce1b3df48aec5d22d1f16b894a0b894eccc'


Hashlib provides the following constant attributes:


hashlib.algorithms_guaranteed¶
A set containing the names of the hash algorithms guaranteed to be supported
by this module on all platforms.  Note that ‘md5’ is in this list despite
some upstream vendors offering an odd “FIPS compliant” Python build that
excludes it.

New in version 3.2.




hashlib.algorithms_available¶
A set containing the names of the hash algorithms that are available in the
running Python interpreter.  These names will be recognized when passed to
new().  algorithms_guaranteed will always be a subset.  The
same algorithm may appear multiple times in this set under different names
(thanks to OpenSSL).

New in version 3.2.


The following values are provided as constant attributes of the hash objects
returned by the constructors:


hash.digest_size¶
The size of the resulting hash in bytes.



hash.block_size¶
The internal block size of the hash algorithm in bytes.

A hash object has the following attributes:


hash.name¶
The canonical name of this hash, always lowercase and always suitable as a
parameter to new() to create another hash of this type.

Changed in version 3.4: The name attribute has been present in CPython since its inception, but
until Python 3.4 was not formally specified, so may not exist on some
platforms.


A hash object has the following methods:


hash.update(data)¶
Update the hash object with the bytes-like object.
Repeated calls are equivalent to a single call with the
concatenation of all the arguments: m.update(a); m.update(b) is
equivalent to m.update(a+b).

Changed in version 3.1: The Python GIL is released to allow other threads to run while hash
updates on data larger than 2047 bytes is taking place when using hash
algorithms supplied by OpenSSL.




hash.digest()¶
Return the digest of the data passed to the update() method so far.
This is a bytes object of size digest_size which may contain bytes in
the whole range from 0 to 255.



hash.hexdigest()¶
Like digest() except the digest is returned as a string object of
double length, containing only hexadecimal digits.  This may be used to
exchange the value safely in email or other non-binary environments.



hash.copy()¶
Return a copy (“clone”) of the hash object.  This can be used to efficiently
compute the digests of data sharing a common initial substring.

