link:
library/subprocess.html#older-high-level-api

docs:

Older high-level API¶
Prior to Python 3.5, these three functions comprised the high level API to
subprocess. You can now use run() in many cases, but lots of existing code
calls these functions.


subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None)¶
Run the command described by args.  Wait for command to complete, then
return the returncode attribute.
Code needing to capture stdout or stderr should use run() instead:

run(…).returncode
To suppress stdout or stderr, supply a value of DEVNULL.
The arguments shown above are merely some common ones.
The full function signature is the
same as that of the Popen constructor - this function passes all
supplied arguments other than timeout directly through to that interface.

Note
Do not use stdout=PIPE or stderr=PIPE with this
function.  The child process will block if it generates enough
output to a pipe to fill up the OS pipe buffer as the pipes are
not being read from.


Changed in version 3.3: timeout was added.




subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None)¶
Run command with arguments.  Wait for command to complete. If the return
code was zero then return, otherwise raise CalledProcessError. The
CalledProcessError object will have the return code in the
returncode attribute.
Code needing to capture stdout or stderr should use run() instead:

run(…, check=True)
To suppress stdout or stderr, supply a value of DEVNULL.
The arguments shown above are merely some common ones.
The full function signature is the
same as that of the Popen constructor - this function passes all
supplied arguments other than timeout directly through to that interface.

Note
Do not use stdout=PIPE or stderr=PIPE with this
function.  The child process will block if it generates enough
output to a pipe to fill up the OS pipe buffer as the pipes are
not being read from.


Changed in version 3.3: timeout was added.




subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, cwd=None, encoding=None, errors=None, universal_newlines=None, timeout=None, text=None)¶
Run command with arguments and return its output.
If the return code was non-zero it raises a CalledProcessError. The
CalledProcessError object will have the return code in the
returncode attribute and any output in the
output attribute.
This is equivalent to:
run(..., check=True, stdout=PIPE).stdout


The arguments shown above are merely some common ones.
The full function signature is largely the same as that of run() -
most arguments are passed directly through to that interface.
However, explicitly passing input=None to inherit the parent’s
standard input file handle is not supported.
By default, this function will return the data as encoded bytes. The actual
encoding of the output data may depend on the command being invoked, so the
decoding to text will often need to be handled at the application level.
This behaviour may be overridden by setting text, encoding, errors,
or universal_newlines to True as described in
Frequently Used Arguments and run().
To also capture standard error in the result, use
stderr=subprocess.STDOUT:
>>> subprocess.check_output(
...     "ls non_existent_file; exit 0",
...     stderr=subprocess.STDOUT,
...     shell=True)
'ls: non_existent_file: No such file or directory\n'



New in version 3.1.


Changed in version 3.3: timeout was added.


Changed in version 3.4: Support for the input keyword argument was added.


Changed in version 3.6: encoding and errors were added.  See run() for details.


New in version 3.7: text was added as a more readable alias for universal_newlines.


