link:
library/multiprocessing.html#miscellaneous

docs:

Miscellaneous¶


multiprocessing.active_children()¶
Return list of all live children of the current process.
Calling this has the side effect of “joining” any processes which have
already finished.



multiprocessing.cpu_count()¶
Return the number of CPUs in the system.
This number is not equivalent to the number of CPUs the current process can
use.  The number of usable CPUs can be obtained with
len(os.sched_getaffinity(0))
May raise NotImplementedError.

See also
os.cpu_count()




multiprocessing.current_process()¶
Return the Process object corresponding to the current process.
An analogue of threading.current_thread().



multiprocessing.freeze_support()¶
Add support for when a program which uses multiprocessing has been
frozen to produce a Windows executable.  (Has been tested with py2exe,
PyInstaller and cx_Freeze.)
One needs to call this function straight after the if __name__ ==
'__main__' line of the main module.  For example:
from multiprocessing import Process, freeze_support

def f():
    print('hello world!')

if __name__ == '__main__':
    freeze_support()
    Process(target=f).start()


If the freeze_support() line is omitted then trying to run the frozen
executable will raise RuntimeError.
Calling freeze_support() has no effect when invoked on any operating
system other than Windows.  In addition, if the module is being run
normally by the Python interpreter on Windows (the program has not been
frozen), then freeze_support() has no effect.



multiprocessing.get_all_start_methods()¶
Returns a list of the supported start methods, the first of which
is the default.  The possible start methods are 'fork',
'spawn' and 'forkserver'.  On Windows only 'spawn' is
available.  On Unix 'fork' and 'spawn' are always
supported, with 'fork' being the default.

New in version 3.4.




multiprocessing.get_context(method=None)¶
Return a context object which has the same attributes as the
multiprocessing module.
If method is None then the default context is returned.
Otherwise method should be 'fork', 'spawn',
'forkserver'.  ValueError is raised if the specified
start method is not available.

New in version 3.4.




multiprocessing.get_start_method(allow_none=False)¶
Return the name of start method used for starting processes.
If the start method has not been fixed and allow_none is false,
then the start method is fixed to the default and the name is
returned.  If the start method has not been fixed and allow_none
is true then None is returned.
The return value can be 'fork', 'spawn', 'forkserver'
or None.  'fork' is the default on Unix, while 'spawn' is
the default on Windows.

New in version 3.4.




multiprocessing.set_executable()¶
Sets the path of the Python interpreter to use when starting a child process.
(By default sys.executable is used).  Embedders will probably need to
do some thing like
set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))


before they can create child processes.

Changed in version 3.4: Now supported on Unix when the 'spawn' start method is used.




multiprocessing.set_start_method(method)¶
Set the method which should be used to start child processes.
method can be 'fork', 'spawn' or 'forkserver'.
Note that this should be called at most once, and it should be
protected inside the if __name__ == '__main__' clause of the
main module.

New in version 3.4.



Note
multiprocessing contains no analogues of
threading.active_count(), threading.enumerate(),
threading.settrace(), threading.setprofile(),
threading.Timer, or threading.local.

