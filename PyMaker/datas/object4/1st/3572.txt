link:
library/logging.config.html#dictionary-schema-details

docs:

Dictionary Schema Details¶
The dictionary passed to dictConfig() must contain the following
keys:

version - to be set to an integer value representing the schema
version.  The only valid value at present is 1, but having this key
allows the schema to evolve while still preserving backwards
compatibility.

All other keys are optional, but if present they will be interpreted
as described below.  In all cases below where a ‘configuring dict’ is
mentioned, it will be checked for the special '()' key to see if a
custom instantiation is required.  If so, the mechanism described in
User-defined objects below is used to create an instance;
otherwise, the context is used to determine what to instantiate.

formatters - the corresponding value will be a dict in which each
key is a formatter id and each value is a dict describing how to
configure the corresponding Formatter instance.
The configuring dict is searched for keys format and datefmt
(with defaults of None) and these are used to construct a
Formatter instance.

filters - the corresponding value will be a dict in which each key
is a filter id and each value is a dict describing how to configure
the corresponding Filter instance.
The configuring dict is searched for the key name (defaulting to the
empty string) and this is used to construct a logging.Filter
instance.

handlers - the corresponding value will be a dict in which each
key is a handler id and each value is a dict describing how to
configure the corresponding Handler instance.
The configuring dict is searched for the following keys:

class (mandatory).  This is the fully qualified name of the
handler class.
level (optional).  The level of the handler.
formatter (optional).  The id of the formatter for this
handler.
filters (optional).  A list of ids of the filters for this
handler.

All other keys are passed through as keyword arguments to the
handler’s constructor.  For example, given the snippet:
handlers:
  console:
    class : logging.StreamHandler
    formatter: brief
    level   : INFO
    filters: [allow_foo]
    stream  : ext://sys.stdout
  file:
    class : logging.handlers.RotatingFileHandler
    formatter: precise
    filename: logconfig.log
    maxBytes: 1024
    backupCount: 3


the handler with id console is instantiated as a
logging.StreamHandler, using sys.stdout as the underlying
stream.  The handler with id file is instantiated as a
logging.handlers.RotatingFileHandler with the keyword arguments
filename='logconfig.log', maxBytes=1024, backupCount=3.

loggers - the corresponding value will be a dict in which each key
is a logger name and each value is a dict describing how to
configure the corresponding Logger instance.
The configuring dict is searched for the following keys:

level (optional).  The level of the logger.
propagate (optional).  The propagation setting of the logger.
filters (optional).  A list of ids of the filters for this
logger.
handlers (optional).  A list of ids of the handlers for this
logger.

The specified loggers will be configured according to the level,
propagation, filters and handlers specified.

root - this will be the configuration for the root logger.
Processing of the configuration will be as for any logger, except
that the propagate setting will not be applicable.

incremental - whether the configuration is to be interpreted as
incremental to the existing configuration.  This value defaults to
False, which means that the specified configuration replaces the
existing configuration with the same semantics as used by the
existing fileConfig() API.
If the specified value is True, the configuration is processed
as described in the section on Incremental Configuration.

disable_existing_loggers - whether any existing non-root loggers are
to be disabled. This setting mirrors the parameter of the same name in
fileConfig(). If absent, this parameter defaults to True.
This value is ignored if incremental is True.


