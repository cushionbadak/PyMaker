link:
library/test.html#module-test

docs:

test — Regression tests package for Python¶

Note
The test package is meant for internal use by Python only. It is
documented for the benefit of the core developers of Python. Any use of
this package outside of Python’s standard library is discouraged as code
mentioned here can change or be removed without notice between releases of
Python.


The test package contains all regression tests for Python as well as the
modules test.support and test.regrtest.
test.support is used to enhance your tests while
test.regrtest drives the testing suite.
Each module in the test package whose name starts with test_ is a
testing suite for a specific module or feature. All new tests should be written
using the unittest or doctest module.  Some older tests are
written using a “traditional” testing style that compares output printed to
sys.stdout; this style of test is considered deprecated.

See also

Module unittest
Writing PyUnit regression tests.
Module doctest
Tests embedded in documentation strings.



Writing Unit Tests for the test package¶
It is preferred that tests that use the unittest module follow a few
guidelines. One is to name the test module by starting it with test_ and end
it with the name of the module being tested. The test methods in the test module
should start with test_ and end with a description of what the method is
testing. This is needed so that the methods are recognized by the test driver as
test methods. Also, no documentation string for the method should be included. A
comment (such as # Tests function returns only True or False) should be used
to provide documentation for test methods. This is done because documentation
strings get printed out if they exist and thus what test is being run is not
stated.
A basic boilerplate is often used:
import unittest
from test import support

class MyTestCase1(unittest.TestCase):

    # Only use setUp() and tearDown() if necessary

    def setUp(self):
        ... code to execute in preparation for tests ...

    def tearDown(self):
        ... code to execute to clean up after tests ...

    def test_feature_one(self):
        # Test feature one.
        ... testing code ...

    def test_feature_two(self):
        # Test feature two.
        ... testing code ...

    ... more test methods ...

class MyTestCase2(unittest.TestCase):
    ... same structure as MyTestCase1 ...

... more test classes ...

if __name__ == '__main__':
    unittest.main()


This code pattern allows the testing suite to be run by test.regrtest,
on its own as a script that supports the unittest CLI, or via the
python -m unittest CLI.
The goal for regression testing is to try to break code. This leads to a few
guidelines to be followed:

The testing suite should exercise all classes, functions, and constants. This
includes not just the external API that is to be presented to the outside
world but also “private” code.

Whitebox testing (examining the code being tested when the tests are being
written) is preferred. Blackbox testing (testing only the published user
interface) is not complete enough to make sure all boundary and edge cases
are tested.

Make sure all possible values are tested including invalid ones. This makes
sure that not only all valid values are acceptable but also that improper
values are handled correctly.

Exhaust as many code paths as possible. Test where branching occurs and thus
tailor input to make sure as many different paths through the code are taken.

Add an explicit test for any bugs discovered for the tested code. This will
make sure that the error does not crop up again if the code is changed in the
future.

Make sure to clean up after your tests (such as close and remove all temporary
files).

If a test is dependent on a specific condition of the operating system then
verify the condition already exists before attempting the test.

Import as few modules as possible and do it as soon as possible. This
minimizes external dependencies of tests and also minimizes possible anomalous
behavior from side-effects of importing a module.

Try to maximize code reuse. On occasion, tests will vary by something as small
as what type of input is used. Minimize code duplication by subclassing a
basic test class with a class that specifies the input:
class TestFuncAcceptsSequencesMixin:

    func = mySuperWhammyFunction

    def test_func(self):
        self.func(self.arg)

class AcceptLists(TestFuncAcceptsSequencesMixin, unittest.TestCase):
    arg = [1, 2, 3]

class AcceptStrings(TestFuncAcceptsSequencesMixin, unittest.TestCase):
    arg = 'abc'

class AcceptTuples(TestFuncAcceptsSequencesMixin, unittest.TestCase):
    arg = (1, 2, 3)


When using this pattern, remember that all classes that inherit from
unittest.TestCase are run as tests.  The Mixin class in the example above
does not have any data and so can’t be run by itself, thus it does not
inherit from unittest.TestCase.



See also

Test Driven Development
A book by Kent Beck on writing tests before code.




Running tests using the command-line interface¶
The test package can be run as a script to drive Python’s regression
test suite, thanks to the -m option: python -m test. Under
the hood, it uses test.regrtest; the call python -m
test.regrtest used in previous Python versions still works.  Running the
script by itself automatically starts running all regression tests in the
test package. It does this by finding all modules in the package whose
name starts with test_, importing them, and executing the function
test_main() if present or loading the tests via
unittest.TestLoader.loadTestsFromModule if test_main does not exist.  The
names of tests to execute may also be passed to the script. Specifying a single
regression test (python -m test test_spam) will minimize output and
only print whether the test passed or failed.
Running test directly allows what resources are available for
tests to use to be set. You do this by using the -u command-line
option. Specifying all as the value for the -u option enables all
possible resources: python -m test -uall.
If all but one resource is desired (a more common case), a
comma-separated list of resources that are not desired may be listed after
all. The command python -m test -uall,-audio,-largefile
will run test with all resources except the audio and
largefile resources. For a list of all resources and more command-line
options, run python -m test -h.
Some other ways to execute the regression tests depend on what platform the
tests are being executed on. On Unix, you can run make test at the
top-level directory where Python was built. On Windows,
executing rt.bat from your PCbuild directory will run all
regression tests.

