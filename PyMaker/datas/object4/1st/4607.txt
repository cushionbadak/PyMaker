link:
library/asyncio-task.html#awaitables

docs:

Awaitables¶
We say that an object is an awaitable object if it can be used
in an await expression.  Many asyncio APIs are designed to
accept awaitables.
There are three main types of awaitable objects:
coroutines, Tasks, and Futures.
Coroutines
Python coroutines are awaitables and therefore can be awaited from
other coroutines:
import asyncio

async def nested():
    return 42

async def main():
    # Nothing happens if we just call "nested()".
    # A coroutine object is created but not awaited,
    # so it *won't run at all*.
    nested()

    # Let's do it differently now and await it:
    print(await nested())  # will print "42".

asyncio.run(main())



Important
In this documentation the term “coroutine” can be used for
two closely related concepts:

a coroutine function: an async def function;
a coroutine object: an object returned by calling a
coroutine function.


asyncio also supports legacy generator-based coroutines.
Tasks
Tasks are used to schedule coroutines concurrently.
When a coroutine is wrapped into a Task with functions like
asyncio.create_task() the coroutine is automatically
scheduled to run soon:
import asyncio

async def nested():
    return 42

async def main():
    # Schedule nested() to run soon concurrently
    # with "main()".
    task = asyncio.create_task(nested())

    # "task" can now be used to cancel "nested()", or
    # can simply be awaited to wait until it is complete:
    await task

asyncio.run(main())


Futures
A Future is a special low-level awaitable object that
represents an eventual result of an asynchronous operation.
When a Future object is awaited it means that the coroutine will
wait until the Future is resolved in some other place.
Future objects in asyncio are needed to allow callback-based code
to be used with async/await.
Normally there is no need to create Future objects at the
application level code.
Future objects, sometimes exposed by libraries and some asyncio
APIs, can be awaited:
async def main():
    await function_that_returns_a_future_object()

    # this is also valid:
    await asyncio.gather(
        function_that_returns_a_future_object(),
        some_python_coroutine()
    )


A good example of a low-level function that returns a Future object
is loop.run_in_executor().
