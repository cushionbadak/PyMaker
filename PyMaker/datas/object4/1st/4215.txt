link:
library/threading.html#semaphore-objects

docs:

Semaphore Objects¶
This is one of the oldest synchronization primitives in the history of computer
science, invented by the early Dutch computer scientist Edsger W. Dijkstra (he
used the names P() and V() instead of acquire() and
release()).
A semaphore manages an internal counter which is decremented by each
acquire() call and incremented by each release()
call.  The counter can never go below zero; when acquire()
finds that it is zero, it blocks, waiting until some other thread calls
release().
Semaphores also support the context management protocol.


class threading.Semaphore(value=1)¶
This class implements semaphore objects.  A semaphore manages an atomic
counter representing the number of release() calls minus the number of
acquire() calls, plus an initial value.  The acquire() method
blocks if necessary until it can return without making the counter negative.
If not given, value defaults to 1.
The optional argument gives the initial value for the internal counter; it
defaults to 1. If the value given is less than 0, ValueError is
raised.

Changed in version 3.3: changed from a factory function to a class.



acquire(blocking=True, timeout=None)¶
Acquire a semaphore.
When invoked without arguments:

If the internal counter is larger than zero on entry, decrement it by
one and return true immediately.
If the internal counter is zero on entry, block until awoken by a call to
release().  Once awoken (and the counter is greater
than 0), decrement the counter by 1 and return true.  Exactly one
thread will be awoken by each call to release().  The
order in which threads are awoken should not be relied on.

When invoked with blocking set to false, do not block.  If a call
without an argument would block, return false immediately; otherwise, do
the same thing as when called without arguments, and return true.
When invoked with a timeout other than None, it will block for at
most timeout seconds.  If acquire does not complete successfully in
that interval, return false.  Return true otherwise.

Changed in version 3.2: The timeout parameter is new.




release()¶
Release a semaphore, incrementing the internal counter by one.  When it
was zero on entry and another thread is waiting for it to become larger
than zero again, wake up that thread.




class threading.BoundedSemaphore(value=1)¶
Class implementing bounded semaphore objects.  A bounded semaphore checks to
make sure its current value doesn’t exceed its initial value.  If it does,
ValueError is raised. In most situations semaphores are used to guard
resources with limited capacity.  If the semaphore is released too many times
it’s a sign of a bug.  If not given, value defaults to 1.

Changed in version 3.3: changed from a factory function to a class.



Semaphore Example¶
Semaphores are often used to guard resources with limited capacity, for example,
a database server.  In any situation where the size of the resource is fixed,
you should use a bounded semaphore.  Before spawning any worker threads, your
main thread would initialize the semaphore:
maxconnections = 5
# ...
pool_sema = BoundedSemaphore(value=maxconnections)


Once spawned, worker threads call the semaphore’s acquire and release methods
when they need to connect to the server:
with pool_sema:
    conn = connectdb()
    try:
        # ... use connection ...
    finally:
        conn.close()


The use of a bounded semaphore reduces the chance that a programming error which
causes the semaphore to be released more than it’s acquired will go undetected.

