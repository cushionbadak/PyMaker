link:
library/socket.html#socket-objects

docs:

Socket Objects¶
Socket objects have the following methods.  Except for
makefile(), these correspond to Unix system calls applicable
to sockets.

Changed in version 3.2: Support for the context manager protocol was added.  Exiting the
context manager is equivalent to calling close().



socket.accept()¶
Accept a connection. The socket must be bound to an address and listening for
connections. The return value is a pair (conn, address) where conn is a
new socket object usable to send and receive data on the connection, and
address is the address bound to the socket on the other end of the connection.
The newly created socket is non-inheritable.

Changed in version 3.4: The socket is now non-inheritable.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.bind(address)¶
Bind the socket to address.  The socket must not already be bound. (The format
of address depends on the address family — see above.)



socket.close()¶
Mark the socket closed.  The underlying system resource (e.g. a file
descriptor) is also closed when all file objects from makefile()
are closed.  Once that happens, all future operations on the socket
object will fail. The remote end will receive no more data (after
queued data is flushed).
Sockets are automatically closed when they are garbage-collected, but
it is recommended to close() them explicitly, or to use a
with statement around them.

Changed in version 3.6: OSError is now raised if an error occurs when the underlying
close() call is made.


Note
close() releases the resource associated with a connection but
does not necessarily close the connection immediately.  If you want
to close the connection in a timely fashion, call shutdown()
before close().




socket.connect(address)¶
Connect to a remote socket at address. (The format of address depends on the
address family — see above.)
If the connection is interrupted by a signal, the method waits until the
connection completes, or raise a socket.timeout on timeout, if the
signal handler doesn’t raise an exception and the socket is blocking or has
a timeout. For non-blocking sockets, the method raises an
InterruptedError exception if the connection is interrupted by a
signal (or the exception raised by the signal handler).

Changed in version 3.5: The method now waits until the connection completes instead of raising an
InterruptedError exception if the connection is interrupted by a
signal, the signal handler doesn’t raise an exception and the socket is
blocking or has a timeout (see the PEP 475 for the rationale).




socket.connect_ex(address)¶
Like connect(address), but return an error indicator instead of raising an
exception for errors returned by the C-level connect() call (other
problems, such as “host not found,” can still raise exceptions).  The error
indicator is 0 if the operation succeeded, otherwise the value of the
errno variable.  This is useful to support, for example, asynchronous
connects.



socket.detach()¶
Put the socket object into closed state without actually closing the
underlying file descriptor.  The file descriptor is returned, and can
be reused for other purposes.

New in version 3.2.




socket.dup()¶
Duplicate the socket.
The newly created socket is non-inheritable.

Changed in version 3.4: The socket is now non-inheritable.




socket.fileno()¶
Return the socket’s file descriptor (a small integer), or -1 on failure. This
is useful with select.select().
Under Windows the small integer returned by this method cannot be used where a
file descriptor can be used (such as os.fdopen()).  Unix does not have
this limitation.



socket.get_inheritable()¶
Get the inheritable flag of the socket’s file
descriptor or socket’s handle: True if the socket can be inherited in
child processes, False if it cannot.

New in version 3.4.




socket.getpeername()¶
Return the remote address to which the socket is connected.  This is useful to
find out the port number of a remote IPv4/v6 socket, for instance. (The format
of the address returned depends on the address family — see above.)  On some
systems this function is not supported.



socket.getsockname()¶
Return the socket’s own address.  This is useful to find out the port number of
an IPv4/v6 socket, for instance. (The format of the address returned depends on
the address family — see above.)



socket.getsockopt(level, optname[, buflen])¶
Return the value of the given socket option (see the Unix man page
getsockopt(2)).  The needed symbolic constants (SO_* etc.)
are defined in this module.  If buflen is absent, an integer option is assumed
and its integer value is returned by the function.  If buflen is present, it
specifies the maximum length of the buffer used to receive the option in, and
this buffer is returned as a bytes object.  It is up to the caller to decode the
contents of the buffer (see the optional built-in module struct for a way
to decode C structures encoded as byte strings).



socket.getblocking()¶
Return True if socket is in blocking mode, False if in
non-blocking.
This is equivalent to checking socket.gettimeout() == 0.

New in version 3.7.




socket.gettimeout()¶
Return the timeout in seconds (float) associated with socket operations,
or None if no timeout is set.  This reflects the last call to
setblocking() or settimeout().



socket.ioctl(control, option)¶




Platform:Windows



The ioctl() method is a limited interface to the WSAIoctl system
interface.  Please refer to the Win32 documentation for more
information.
On other platforms, the generic fcntl.fcntl() and fcntl.ioctl()
functions may be used; they accept a socket object as their first argument.
Currently only the following control codes are supported:
SIO_RCVALL, SIO_KEEPALIVE_VALS, and SIO_LOOPBACK_FAST_PATH.

Changed in version 3.6: SIO_LOOPBACK_FAST_PATH was added.




socket.listen([backlog])¶
Enable a server to accept connections.  If backlog is specified, it must
be at least 0 (if it is lower, it is set to 0); it specifies the number of
unaccepted connections that the system will allow before refusing new
connections. If not specified, a default reasonable value is chosen.

Changed in version 3.5: The backlog parameter is now optional.




socket.makefile(mode='r', buffering=None, *, encoding=None, errors=None, newline=None)¶
Return a file object associated with the socket.  The exact returned
type depends on the arguments given to makefile().  These arguments are
interpreted the same way as by the built-in open() function, except
the only supported mode values are 'r' (default), 'w' and 'b'.
The socket must be in blocking mode; it can have a timeout, but the file
object’s internal buffer may end up in an inconsistent state if a timeout
occurs.
Closing the file object returned by makefile() won’t close the
original socket unless all other file objects have been closed and
socket.close() has been called on the socket object.

Note
On Windows, the file-like object created by makefile() cannot be
used where a file object with a file descriptor is expected, such as the
stream arguments of subprocess.Popen().




socket.recv(bufsize[, flags])¶
Receive data from the socket.  The return value is a bytes object representing the
data received.  The maximum amount of data to be received at once is specified
by bufsize.  See the Unix manual page recv(2) for the meaning of
the optional argument flags; it defaults to zero.

Note
For best match with hardware and network realities, the value of  bufsize
should be a relatively small power of 2, for example, 4096.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.recvfrom(bufsize[, flags])¶
Receive data from the socket.  The return value is a pair (bytes, address)
where bytes is a bytes object representing the data received and address is the
address of the socket sending the data.  See the Unix manual page
recv(2) for the meaning of the optional argument flags; it defaults
to zero. (The format of address depends on the address family — see above.)

Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).


Changed in version 3.7: For multicast IPv6 address, first item of address does not contain
%scope part anymore. In order to get full IPv6 address use
getnameinfo().




socket.recvmsg(bufsize[, ancbufsize[, flags]])¶
Receive normal data (up to bufsize bytes) and ancillary data from
the socket.  The ancbufsize argument sets the size in bytes of
the internal buffer used to receive the ancillary data; it defaults
to 0, meaning that no ancillary data will be received.  Appropriate
buffer sizes for ancillary data can be calculated using
CMSG_SPACE() or CMSG_LEN(), and items which do not fit
into the buffer might be truncated or discarded.  The flags
argument defaults to 0 and has the same meaning as for
recv().
The return value is a 4-tuple: (data, ancdata, msg_flags,
address).  The data item is a bytes object holding the
non-ancillary data received.  The ancdata item is a list of zero
or more tuples (cmsg_level, cmsg_type, cmsg_data) representing
the ancillary data (control messages) received: cmsg_level and
cmsg_type are integers specifying the protocol level and
protocol-specific type respectively, and cmsg_data is a
bytes object holding the associated data.  The msg_flags
item is the bitwise OR of various flags indicating conditions on
the received message; see your system documentation for details.
If the receiving socket is unconnected, address is the address of
the sending socket, if available; otherwise, its value is
unspecified.
On some systems, sendmsg() and recvmsg() can be used to
pass file descriptors between processes over an AF_UNIX
socket.  When this facility is used (it is often restricted to
SOCK_STREAM sockets), recvmsg() will return, in its
ancillary data, items of the form (socket.SOL_SOCKET,
socket.SCM_RIGHTS, fds), where fds is a bytes object
representing the new file descriptors as a binary array of the
native C int type.  If recvmsg() raises an
exception after the system call returns, it will first attempt to
close any file descriptors received via this mechanism.
Some systems do not indicate the truncated length of ancillary data
items which have been only partially received.  If an item appears
to extend beyond the end of the buffer, recvmsg() will issue
a RuntimeWarning, and will return the part of it which is
inside the buffer provided it has not been truncated before the
start of its associated data.
On systems which support the SCM_RIGHTS mechanism, the
following function will receive up to maxfds file descriptors,
returning the message data and a list containing the descriptors
(while ignoring unexpected conditions such as unrelated control
messages being received).  See also sendmsg().
import socket, array

def recv_fds(sock, msglen, maxfds):
    fds = array.array("i")   # Array of ints
    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))
    for cmsg_level, cmsg_type, cmsg_data in ancdata:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS):
            # Append data, ignoring any truncated integers at the end.
            fds.fromstring(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
    return msg, list(fds)


Availability: most Unix platforms, possibly others.

New in version 3.3.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.recvmsg_into(buffers[, ancbufsize[, flags]])¶
Receive normal data and ancillary data from the socket, behaving as
recvmsg() would, but scatter the non-ancillary data into a
series of buffers instead of returning a new bytes object.  The
buffers argument must be an iterable of objects that export
writable buffers (e.g. bytearray objects); these will be
filled with successive chunks of the non-ancillary data until it
has all been written or there are no more buffers.  The operating
system may set a limit (sysconf() value SC_IOV_MAX)
on the number of buffers that can be used.  The ancbufsize and
flags arguments have the same meaning as for recvmsg().
The return value is a 4-tuple: (nbytes, ancdata, msg_flags,
address), where nbytes is the total number of bytes of
non-ancillary data written into the buffers, and ancdata,
msg_flags and address are the same as for recvmsg().
Example:
>>> import socket
>>> s1, s2 = socket.socketpair()
>>> b1 = bytearray(b'----')
>>> b2 = bytearray(b'0123456789')
>>> b3 = bytearray(b'--------------')
>>> s1.send(b'Mary had a little lamb')
22
>>> s2.recvmsg_into([b1, memoryview(b2)[2:9], b3])
(22, [], 0, None)
>>> [b1, b2, b3]
[bytearray(b'Mary'), bytearray(b'01 had a 9'), bytearray(b'little lamb---')]


Availability: most Unix platforms, possibly others.

New in version 3.3.




socket.recvfrom_into(buffer[, nbytes[, flags]])¶
Receive data from the socket, writing it into buffer instead of creating a
new bytestring.  The return value is a pair (nbytes, address) where nbytes is
the number of bytes received and address is the address of the socket sending
the data.  See the Unix manual page recv(2) for the meaning of the
optional argument flags; it defaults to zero.  (The format of address
depends on the address family — see above.)



socket.recv_into(buffer[, nbytes[, flags]])¶
Receive up to nbytes bytes from the socket, storing the data into a buffer
rather than creating a new bytestring.  If nbytes is not specified (or 0),
receive up to the size available in the given buffer.  Returns the number of
bytes received.  See the Unix manual page recv(2) for the meaning
of the optional argument flags; it defaults to zero.



socket.send(bytes[, flags])¶
Send data to the socket.  The socket must be connected to a remote socket.  The
optional flags argument has the same meaning as for recv() above.
Returns the number of bytes sent. Applications are responsible for checking that
all data has been sent; if only some of the data was transmitted, the
application needs to attempt delivery of the remaining data. For further
information on this topic, consult the Socket Programming HOWTO.

Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.sendall(bytes[, flags])¶
Send data to the socket.  The socket must be connected to a remote socket.  The
optional flags argument has the same meaning as for recv() above.
Unlike send(), this method continues to send data from bytes until
either all data has been sent or an error occurs.  None is returned on
success.  On error, an exception is raised, and there is no way to determine how
much data, if any, was successfully sent.

Changed in version 3.5: The socket timeout is no more reset each time data is sent successfully.
The socket timeout is now the maximum total duration to send all data.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.sendto(bytes, address)¶

socket.sendto(bytes, flags, address)
Send data to the socket.  The socket should not be connected to a remote socket,
since the destination socket is specified by address.  The optional flags
argument has the same meaning as for recv() above.  Return the number of
bytes sent. (The format of address depends on the address family — see
above.)

Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.sendmsg(buffers[, ancdata[, flags[, address]]])¶
Send normal and ancillary data to the socket, gathering the
non-ancillary data from a series of buffers and concatenating it
into a single message.  The buffers argument specifies the
non-ancillary data as an iterable of
bytes-like objects
(e.g. bytes objects); the operating system may set a limit
(sysconf() value SC_IOV_MAX) on the number of buffers
that can be used.  The ancdata argument specifies the ancillary
data (control messages) as an iterable of zero or more tuples
(cmsg_level, cmsg_type, cmsg_data), where cmsg_level and
cmsg_type are integers specifying the protocol level and
protocol-specific type respectively, and cmsg_data is a
bytes-like object holding the associated data.  Note that
some systems (in particular, systems without CMSG_SPACE())
might support sending only one control message per call.  The
flags argument defaults to 0 and has the same meaning as for
send().  If address is supplied and not None, it sets a
destination address for the message.  The return value is the
number of bytes of non-ancillary data sent.
The following function sends the list of file descriptors fds
over an AF_UNIX socket, on systems which support the
SCM_RIGHTS mechanism.  See also recvmsg().
import socket, array

def send_fds(sock, msg, fds):
    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array("i", fds))])


Availability: most Unix platforms, possibly others.

New in version 3.3.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).




socket.sendmsg_afalg([msg, ]*, op[, iv[, assoclen[, flags]]])¶
Specialized version of sendmsg() for AF_ALG socket.
Set mode, IV, AEAD associated data length and flags for AF_ALG socket.
Availability: Linux >= 2.6.38.

New in version 3.6.




socket.sendfile(file, offset=0, count=None)¶
Send a file until EOF is reached by using high-performance
os.sendfile and return the total number of bytes which were sent.
file must be a regular file object opened in binary mode. If
os.sendfile is not available (e.g. Windows) or file is not a
regular file send() will be used instead. offset tells from where to
start reading the file. If specified, count is the total number of bytes
to transmit as opposed to sending the file until EOF is reached. File
position is updated on return or also in case of error in which case
file.tell() can be used to figure out the number of
bytes which were sent. The socket must be of SOCK_STREAM type.
Non-blocking sockets are not supported.

New in version 3.5.




socket.set_inheritable(inheritable)¶
Set the inheritable flag of the socket’s file
descriptor or socket’s handle.

New in version 3.4.




socket.setblocking(flag)¶
Set blocking or non-blocking mode of the socket: if flag is false, the
socket is set to non-blocking, else to blocking mode.
This method is a shorthand for certain settimeout() calls:

sock.setblocking(True) is equivalent to sock.settimeout(None)
sock.setblocking(False) is equivalent to sock.settimeout(0.0)


Changed in version 3.7: The method no longer applies SOCK_NONBLOCK flag on
socket.type.




socket.settimeout(value)¶
Set a timeout on blocking socket operations.  The value argument can be a
nonnegative floating point number expressing seconds, or None.
If a non-zero value is given, subsequent socket operations will raise a
timeout exception if the timeout period value has elapsed before
the operation has completed.  If zero is given, the socket is put in
non-blocking mode. If None is given, the socket is put in blocking mode.
For further information, please consult the notes on socket timeouts.

Changed in version 3.7: The method no longer toggles SOCK_NONBLOCK flag on
socket.type.




socket.setsockopt(level, optname, value: int)¶



socket.setsockopt(level, optname, value: buffer)



socket.setsockopt(level, optname, None, optlen: int)
Set the value of the given socket option (see the Unix manual page
setsockopt(2)).  The needed symbolic constants are defined in the
socket module (SO_* etc.).  The value can be an integer,
None or a bytes-like object representing a buffer. In the later
case it is up to the caller to ensure that the bytestring contains the
proper bits (see the optional built-in module struct for a way to
encode C structures as bytestrings). When value is set to None,
optlen argument is required. It’s equivalent to call setsockopt C
function with optval=NULL and optlen=optlen.

Changed in version 3.5: Writable bytes-like object is now accepted.


Changed in version 3.6: setsockopt(level, optname, None, optlen: int) form added.




socket.shutdown(how)¶
Shut down one or both halves of the connection.  If how is SHUT_RD,
further receives are disallowed.  If how is SHUT_WR, further sends
are disallowed.  If how is SHUT_RDWR, further sends and receives are
disallowed.



socket.share(process_id)¶
Duplicate a socket and prepare it for sharing with a target process.  The
target process must be provided with process_id.  The resulting bytes object
can then be passed to the target process using some form of interprocess
communication and the socket can be recreated there using fromshare().
Once this method has been called, it is safe to close the socket since
the operating system has already duplicated it for the target process.
Availability: Windows.

New in version 3.3.


Note that there are no methods read() or write(); use
recv() and send() without flags argument instead.
Socket objects also have these (read-only) attributes that correspond to the
values given to the socket constructor.


socket.family¶
The socket family.



socket.type¶
The socket type.



socket.proto¶
The socket protocol.

