link:
library/argparse.html#other-utilities

docs:

Other utilities¶

Sub-commands¶


ArgumentParser.add_subparsers([title][, description][, prog][, parser_class][, action][, option_string][, dest][, required][, help][, metavar])¶
Many programs split up their functionality into a number of sub-commands,
for example, the svn program can invoke sub-commands like svn
checkout, svn update, and svn commit.  Splitting up functionality
this way can be a particularly good idea when a program performs several
different functions which require different kinds of command-line arguments.
ArgumentParser supports the creation of such sub-commands with the
add_subparsers() method.  The add_subparsers() method is normally
called with no arguments and returns a special action object.  This object
has a single method, add_parser(), which takes a
command name and any ArgumentParser constructor arguments, and
returns an ArgumentParser object that can be modified as usual.
Description of parameters:

title - title for the sub-parser group in help output; by default
“subcommands” if description is provided, otherwise uses title for
positional arguments
description - description for the sub-parser group in help output, by
default None
prog - usage information that will be displayed with sub-command help,
by default the name of the program and any positional arguments before the
subparser argument
parser_class - class which will be used to create sub-parser instances, by
default the class of the current parser (e.g. ArgumentParser)
action - the basic type of action to be taken when this argument is
encountered at the command line
dest - name of the attribute under which sub-command name will be
stored; by default None and no value is stored
required - Whether or not a subcommand must be provided, by default
False.
help - help for sub-parser group in help output, by default None
metavar - string presenting available sub-commands in help; by default it
is None and presents sub-commands in form {cmd1, cmd2, ..}

Some example usage:
>>> # create the top-level parser
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo', action='store_true', help='foo help')
>>> subparsers = parser.add_subparsers(help='sub-command help')
>>>
>>> # create the parser for the "a" command
>>> parser_a = subparsers.add_parser('a', help='a help')
>>> parser_a.add_argument('bar', type=int, help='bar help')
>>>
>>> # create the parser for the "b" command
>>> parser_b = subparsers.add_parser('b', help='b help')
>>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')
>>>
>>> # parse some argument lists
>>> parser.parse_args(['a', '12'])
Namespace(bar=12, foo=False)
>>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])
Namespace(baz='Z', foo=True)


Note that the object returned by parse_args() will only contain
attributes for the main parser and the subparser that was selected by the
command line (and not any other subparsers).  So in the example above, when
the a command is specified, only the foo and bar attributes are
present, and when the b command is specified, only the foo and
baz attributes are present.
Similarly, when a help message is requested from a subparser, only the help
for that particular parser will be printed.  The help message will not
include parent parser or sibling parser messages.  (A help message for each
subparser command, however, can be given by supplying the help= argument
to add_parser() as above.)
>>> parser.parse_args(['--help'])
usage: PROG [-h] [--foo] {a,b} ...

positional arguments:
  {a,b}   sub-command help
    a     a help
    b     b help

optional arguments:
  -h, --help  show this help message and exit
  --foo   foo help

>>> parser.parse_args(['a', '--help'])
usage: PROG a [-h] bar

positional arguments:
  bar     bar help

optional arguments:
  -h, --help  show this help message and exit

>>> parser.parse_args(['b', '--help'])
usage: PROG b [-h] [--baz {X,Y,Z}]

optional arguments:
  -h, --help     show this help message and exit
  --baz {X,Y,Z}  baz help


The add_subparsers() method also supports title and description
keyword arguments.  When either is present, the subparser’s commands will
appear in their own group in the help output.  For example:
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers(title='subcommands',
...                                    description='valid subcommands',
...                                    help='additional help')
>>> subparsers.add_parser('foo')
>>> subparsers.add_parser('bar')
>>> parser.parse_args(['-h'])
usage:  [-h] {foo,bar} ...

optional arguments:
  -h, --help  show this help message and exit

subcommands:
  valid subcommands

  {foo,bar}   additional help


Furthermore, add_parser supports an additional aliases argument,
which allows multiple strings to refer to the same subparser. This example,
like svn, aliases co as a shorthand for checkout:
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers()
>>> checkout = subparsers.add_parser('checkout', aliases=['co'])
>>> checkout.add_argument('foo')
>>> parser.parse_args(['co', 'bar'])
Namespace(foo='bar')


One particularly effective way of handling sub-commands is to combine the use
of the add_subparsers() method with calls to set_defaults() so
that each subparser knows which Python function it should execute.  For
example:
>>> # sub-command functions
>>> def foo(args):
...     print(args.x * args.y)
...
>>> def bar(args):
...     print('((%s))' % args.z)
...
>>> # create the top-level parser
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers()
>>>
>>> # create the parser for the "foo" command
>>> parser_foo = subparsers.add_parser('foo')
>>> parser_foo.add_argument('-x', type=int, default=1)
>>> parser_foo.add_argument('y', type=float)
>>> parser_foo.set_defaults(func=foo)
>>>
>>> # create the parser for the "bar" command
>>> parser_bar = subparsers.add_parser('bar')
>>> parser_bar.add_argument('z')
>>> parser_bar.set_defaults(func=bar)
>>>
>>> # parse the args and call whatever function was selected
>>> args = parser.parse_args('foo 1 -x 2'.split())
>>> args.func(args)
2.0
>>>
>>> # parse the args and call whatever function was selected
>>> args = parser.parse_args('bar XYZYX'.split())
>>> args.func(args)
((XYZYX))


This way, you can let parse_args() do the job of calling the
appropriate function after argument parsing is complete.  Associating
functions with actions like this is typically the easiest way to handle the
different actions for each of your subparsers.  However, if it is necessary
to check the name of the subparser that was invoked, the dest keyword
argument to the add_subparsers() call will work:
>>> parser = argparse.ArgumentParser()
>>> subparsers = parser.add_subparsers(dest='subparser_name')
>>> subparser1 = subparsers.add_parser('1')
>>> subparser1.add_argument('-x')
>>> subparser2 = subparsers.add_parser('2')
>>> subparser2.add_argument('y')
>>> parser.parse_args(['2', 'frobble'])
Namespace(subparser_name='2', y='frobble')





FileType objects¶


class argparse.FileType(mode='r', bufsize=-1, encoding=None, errors=None)¶
The FileType factory creates objects that can be passed to the type
argument of ArgumentParser.add_argument().  Arguments that have
FileType objects as their type will open command-line arguments as
files with the requested modes, buffer sizes, encodings and error handling
(see the open() function for more details):
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))
>>> parser.add_argument('out', type=argparse.FileType('w', encoding='UTF-8'))
>>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])
Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)


FileType objects understand the pseudo-argument '-' and automatically
convert this into sys.stdin for readable FileType objects and
sys.stdout for writable FileType objects:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('infile', type=argparse.FileType('r'))
>>> parser.parse_args(['-'])
Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)



New in version 3.4: The encodings and errors keyword arguments.




Argument groups¶


ArgumentParser.add_argument_group(title=None, description=None)¶
By default, ArgumentParser groups command-line arguments into
“positional arguments” and “optional arguments” when displaying help
messages. When there is a better conceptual grouping of arguments than this
default one, appropriate groups can be created using the
add_argument_group() method:
>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group = parser.add_argument_group('group')
>>> group.add_argument('--foo', help='foo help')
>>> group.add_argument('bar', help='bar help')
>>> parser.print_help()
usage: PROG [--foo FOO] bar

group:
  bar    bar help
  --foo FOO  foo help


The add_argument_group() method returns an argument group object which
has an add_argument() method just like a regular
ArgumentParser.  When an argument is added to the group, the parser
treats it just like a normal argument, but displays the argument in a
separate group for help messages.  The add_argument_group() method
accepts title and description arguments which can be used to
customize this display:
>>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
>>> group1 = parser.add_argument_group('group1', 'group1 description')
>>> group1.add_argument('foo', help='foo help')
>>> group2 = parser.add_argument_group('group2', 'group2 description')
>>> group2.add_argument('--bar', help='bar help')
>>> parser.print_help()
usage: PROG [--bar BAR] foo

group1:
  group1 description

  foo    foo help

group2:
  group2 description

  --bar BAR  bar help


Note that any arguments not in your user-defined groups will end up back
in the usual “positional arguments” and “optional arguments” sections.



Mutual exclusion¶


ArgumentParser.add_mutually_exclusive_group(required=False)¶
Create a mutually exclusive group. argparse will make sure that only
one of the arguments in the mutually exclusive group was present on the
command line:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> group = parser.add_mutually_exclusive_group()
>>> group.add_argument('--foo', action='store_true')
>>> group.add_argument('--bar', action='store_false')
>>> parser.parse_args(['--foo'])
Namespace(bar=True, foo=True)
>>> parser.parse_args(['--bar'])
Namespace(bar=False, foo=False)
>>> parser.parse_args(['--foo', '--bar'])
usage: PROG [-h] [--foo | --bar]
PROG: error: argument --bar: not allowed with argument --foo


The add_mutually_exclusive_group() method also accepts a required
argument, to indicate that at least one of the mutually exclusive arguments
is required:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> group = parser.add_mutually_exclusive_group(required=True)
>>> group.add_argument('--foo', action='store_true')
>>> group.add_argument('--bar', action='store_false')
>>> parser.parse_args([])
usage: PROG [-h] (--foo | --bar)
PROG: error: one of the arguments --foo --bar is required


Note that currently mutually exclusive argument groups do not support the
title and description arguments of
add_argument_group().



Parser defaults¶


ArgumentParser.set_defaults(**kwargs)¶
Most of the time, the attributes of the object returned by parse_args()
will be fully determined by inspecting the command-line arguments and the argument
actions.  set_defaults() allows some additional
attributes that are determined without any inspection of the command line to
be added:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', type=int)
>>> parser.set_defaults(bar=42, baz='badger')
>>> parser.parse_args(['736'])
Namespace(bar=42, baz='badger', foo=736)


Note that parser-level defaults always override argument-level defaults:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default='bar')
>>> parser.set_defaults(foo='spam')
>>> parser.parse_args([])
Namespace(foo='spam')


Parser-level defaults can be particularly useful when working with multiple
parsers.  See the add_subparsers() method for an
example of this type.



ArgumentParser.get_default(dest)¶
Get the default value for a namespace attribute, as set by either
add_argument() or by
set_defaults():
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default='badger')
>>> parser.get_default('foo')
'badger'





Printing help¶
In most typical applications, parse_args() will take
care of formatting and printing any usage or error messages.  However, several
formatting methods are available:


ArgumentParser.print_usage(file=None)¶
Print a brief description of how the ArgumentParser should be
invoked on the command line.  If file is None, sys.stdout is
assumed.



ArgumentParser.print_help(file=None)¶
Print a help message, including the program usage and information about the
arguments registered with the ArgumentParser.  If file is
None, sys.stdout is assumed.

There are also variants of these methods that simply return a string instead of
printing it:


ArgumentParser.format_usage()¶
Return a string containing a brief description of how the
ArgumentParser should be invoked on the command line.



ArgumentParser.format_help()¶
Return a string containing a help message, including the program usage and
information about the arguments registered with the ArgumentParser.



Partial parsing¶


ArgumentParser.parse_known_args(args=None, namespace=None)¶

Sometimes a script may only parse a few of the command-line arguments, passing
the remaining arguments on to another script or program. In these cases, the
parse_known_args() method can be useful.  It works much like
parse_args() except that it does not produce an error when
extra arguments are present.  Instead, it returns a two item tuple containing
the populated namespace and the list of remaining argument strings.
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_true')
>>> parser.add_argument('bar')
>>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
(Namespace(bar='BAR', foo=True), ['--badger', 'spam'])



Warning
Prefix matching rules apply to
parse_known_args(). The parser may consume an option even if it’s just
a prefix of one of its known options, instead of leaving it in the remaining
arguments list.



Customizing file parsing¶


ArgumentParser.convert_arg_line_to_args(arg_line)¶
Arguments that are read from a file (see the fromfile_prefix_chars
keyword argument to the ArgumentParser constructor) are read one
argument per line. convert_arg_line_to_args() can be overridden for
fancier reading.
This method takes a single argument arg_line which is a string read from
the argument file.  It returns a list of arguments parsed from this string.
The method is called once per line read from the argument file, in order.
A useful override of this method is one that treats each space-separated word
as an argument.  The following example demonstrates how to do this:
class MyArgumentParser(argparse.ArgumentParser):
    def convert_arg_line_to_args(self, arg_line):
        return arg_line.split()





Exiting methods¶


ArgumentParser.exit(status=0, message=None)¶
This method terminates the program, exiting with the specified status
and, if given, it prints a message before that.



ArgumentParser.error(message)¶
This method prints a usage message including the message to the
standard error and terminates the program with a status code of 2.



Intermixed parsing¶


ArgumentParser.parse_intermixed_args(args=None, namespace=None)¶



ArgumentParser.parse_known_intermixed_args(args=None, namespace=None)¶

A number of Unix commands allow the user to intermix optional arguments with
positional arguments.  The parse_intermixed_args()
and parse_known_intermixed_args() methods
support this parsing style.
These parsers do not support all the argparse features, and will raise
exceptions if unsupported features are used.  In particular, subparsers,
argparse.REMAINDER, and mutually exclusive groups that include both
optionals and positionals are not supported.
The following example shows the difference between
parse_known_args() and
parse_intermixed_args(): the former returns ['2',
'3'] as unparsed arguments, while the latter collects all the positionals
into rest.
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.add_argument('cmd')
>>> parser.add_argument('rest', nargs='*', type=int)
>>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())
(Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])
>>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())
Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])


parse_known_intermixed_args() returns a two item tuple
containing the populated namespace and the list of remaining argument strings.
parse_intermixed_args() raises an error if there are any
remaining unparsed argument strings.

New in version 3.7.


