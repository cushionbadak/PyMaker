link:
library/tkinter.html#handy-reference

docs:

Handy Reference¶

Setting Options¶
Options control things like the color and border width of a widget. Options can
be set in three ways:

At object creation time, using keyword arguments
fred = Button(self, fg="red", bg="blue")



After object creation, treating the option name like a dictionary index
fred["fg"] = "red"
fred["bg"] = "blue"



Use the config() method to update multiple attrs subsequent to object creation
fred.config(fg="red", bg="blue")




For a complete explanation of a given option and its behavior, see the Tk man
pages for the widget in question.
Note that the man pages list “STANDARD OPTIONS” and “WIDGET SPECIFIC OPTIONS”
for each widget.  The former is a list of options that are common to many
widgets, the latter are the options that are idiosyncratic to that particular
widget.  The Standard Options are documented on the options(3) man
page.
No distinction between standard and widget-specific options is made in this
document.  Some options don’t apply to some kinds of widgets. Whether a given
widget responds to a particular option depends on the class of the widget;
buttons have a command option, labels do not.
The options supported by a given widget are listed in that widget’s man page, or
can be queried at runtime by calling the config() method without
arguments, or by calling the keys() method on that widget.  The return
value of these calls is a dictionary whose key is the name of the option as a
string (for example, 'relief') and whose values are 5-tuples.
Some options, like bg are synonyms for common options with long names
(bg is shorthand for “background”). Passing the config() method the name
of a shorthand option will return a 2-tuple, not 5-tuple. The 2-tuple passed
back will contain the name of the synonym and the “real” option (such as
('bg', 'background')).







Index
Meaning
Example



0
option name
'relief'

1
option name for database lookup
'relief'

2
option class for database
lookup
'Relief'

3
default value
'raised'

4
current value
'groove'



Example:
>>> print(fred.config())
{'relief': ('relief', 'relief', 'Relief', 'raised', 'groove')}


Of course, the dictionary printed will include all the options available and
their values.  This is meant only as an example.


The Packer¶
The packer is one of Tk’s geometry-management mechanisms.    Geometry managers
are used to specify the relative positioning of the positioning of widgets
within their container - their mutual master.  In contrast to the more
cumbersome placer (which is used less commonly, and we do not cover here), the
packer takes qualitative relationship specification - above, to the left of,
filling, etc - and works everything out to determine the exact placement
coordinates for you.
The size of any master widget is determined by the size of the “slave widgets”
inside.  The packer is used to control where slave widgets appear inside the
master into which they are packed.  You can pack widgets into frames, and frames
into other frames, in order to achieve the kind of layout you desire.
Additionally, the arrangement is dynamically adjusted to accommodate incremental
changes to the configuration, once it is packed.
Note that widgets do not appear until they have had their geometry specified
with a geometry manager.  It’s a common early mistake to leave out the geometry
specification, and then be surprised when the widget is created but nothing
appears.  A widget will appear only after it has had, for example, the packer’s
pack() method applied to it.
The pack() method can be called with keyword-option/value pairs that control
where the widget is to appear within its container, and how it is to behave when
the main application window is resized.  Here are some examples:
fred.pack()                     # defaults to side = "top"
fred.pack(side="left")
fred.pack(expand=1)




Packer Options¶
For more extensive information on the packer and the options that it can take,
see the man pages and page 183 of John Ousterhout’s book.

anchor
Anchor type.  Denotes where the packer is to place each slave in its parcel.
expand
Boolean, 0 or 1.
fill
Legal values: 'x', 'y', 'both', 'none'.
ipadx and ipady
A distance - designating internal padding on each side of the slave widget.
padx and pady
A distance - designating external padding on each side of the slave widget.
side
Legal values are: 'left', 'right', 'top', 'bottom'.



Coupling Widget Variables¶
The current-value setting of some widgets (like text entry widgets) can be
connected directly to application variables by using special options.  These
options are variable, textvariable, onvalue, offvalue, and
value.  This connection works both ways: if the variable changes for any
reason, the widget it’s connected to will be updated to reflect the new value.
Unfortunately, in the current implementation of tkinter it is not
possible to hand over an arbitrary Python variable to a widget through a
variable or textvariable option.  The only kinds of variables for which
this works are variables that are subclassed from a class called Variable,
defined in tkinter.
There are many useful subclasses of Variable already defined:
StringVar, IntVar, DoubleVar, and
BooleanVar.  To read the current value of such a variable, call the
get() method on it, and to change its value you call the set()
method.  If you follow this protocol, the widget will always track the value of
the variable, with no further intervention on your part.
For example:
class App(Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.pack()

        self.entrythingy = Entry()
        self.entrythingy.pack()

        # here is the application variable
        self.contents = StringVar()
        # set it to some value
        self.contents.set("this is a variable")
        # tell the entry widget to watch this variable
        self.entrythingy["textvariable"] = self.contents

        # and here we get a callback when the user hits return.
        # we will have the program print out the value of the
        # application variable when the user hits return
        self.entrythingy.bind('<Key-Return>',
                              self.print_contents)

    def print_contents(self, event):
        print("hi. contents of entry is now ---->",
              self.contents.get())




The Window Manager¶
In Tk, there is a utility command, wm, for interacting with the window
manager.  Options to the wm command allow you to control things like titles,
placement, icon bitmaps, and the like.  In tkinter, these commands have
been implemented as methods on the Wm class.  Toplevel widgets are
subclassed from the Wm class, and so can call the Wm methods
directly.
To get at the toplevel window that contains a given widget, you can often just
refer to the widget’s master.  Of course if the widget has been packed inside of
a frame, the master won’t represent a toplevel window.  To get at the toplevel
window that contains an arbitrary widget, you can call the _root() method.
This method begins with an underscore to denote the fact that this function is
part of the implementation, and not an interface to Tk functionality.
Here are some examples of typical usage:
import tkinter as tk

class App(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.pack()

# create the application
myapp = App()

#
# here are method calls to the window manager class
#
myapp.master.title("My Do-Nothing Application")
myapp.master.maxsize(1000, 400)

# start the program
myapp.mainloop()




Tk Option Data Types¶

anchor
Legal values are points of the compass: "n", "ne", "e", "se",
"s", "sw", "w", "nw", and also "center".
bitmap
There are eight built-in, named bitmaps: 'error', 'gray25',
'gray50', 'hourglass', 'info', 'questhead', 'question',
'warning'.  To specify an X bitmap filename, give the full path to the file,
preceded with an @, as in "@/usr/contrib/bitmap/gumby.bit".
boolean
You can pass integers 0 or 1 or the strings "yes" or "no".
callback
This is any Python function that takes no arguments.  For example:
def print_it():
    print("hi there")
fred["command"] = print_it



color
Colors can be given as the names of X colors in the rgb.txt file, or as strings
representing RGB values in 4 bit: "#RGB", 8 bit: "#RRGGBB", 12 bit”
"#RRRGGGBBB", or 16 bit "#RRRRGGGGBBBB" ranges, where R,G,B here
represent any legal hex digit.  See page 160 of Ousterhout’s book for details.
cursor
The standard X cursor names from cursorfont.h can be used, without the
XC_ prefix.  For example to get a hand cursor (XC_hand2), use the
string "hand2".  You can also specify a bitmap and mask file of your own.
See page 179 of Ousterhout’s book.
distance
Screen distances can be specified in either pixels or absolute distances.
Pixels are given as numbers and absolute distances as strings, with the trailing
character denoting units: c for centimetres, i for inches, m for
millimetres, p for printer’s points.  For example, 3.5 inches is expressed
as "3.5i".
font
Tk uses a list font name format, such as {courier 10 bold}. Font sizes with
positive numbers are measured in points; sizes with negative numbers are
measured in pixels.
geometry
This is a string of the form widthxheight, where width and height are
measured in pixels for most widgets (in characters for widgets displaying text).
For example: fred["geometry"] = "200x100".
justify
Legal values are the strings: "left", "center", "right", and
"fill".
region
This is a string with four space-delimited elements, each of which is a legal
distance (see above).  For example: "2 3 4 5" and "3i 2i 4.5i 2i" and
"3c 2c 4c 10.43c"  are all legal regions.
relief
Determines what the border style of a widget will be.  Legal values are:
"raised", "sunken", "flat", "groove", and "ridge".
scrollcommand
This is almost always the set() method of some scrollbar widget, but can
be any widget method that takes a single argument.
wrap:
Must be one of: "none", "char", or "word".



Bindings and Events¶
The bind method from the widget command allows you to watch for certain events
and to have a callback function trigger when that event type occurs.  The form
of the bind method is:
def bind(self, sequence, func, add=''):


where:

sequence
is a string that denotes the target kind of event.  (See the bind man page and
page 201 of John Ousterhout’s book for details).
func
is a Python function, taking one argument, to be invoked when the event occurs.
An Event instance will be passed as the argument. (Functions deployed this way
are commonly known as callbacks.)
add
is optional, either '' or '+'.  Passing an empty string denotes that
this binding is to replace any other bindings that this event is associated
with.  Passing a '+' means that this function is to be added to the list
of functions bound to this event type.

For example:
def turn_red(self, event):
    event.widget["activeforeground"] = "red"

self.button.bind("<Enter>", self.turn_red)


Notice how the widget field of the event is being accessed in the
turn_red() callback.  This field contains the widget that caught the X
event.  The following table lists the other event fields you can access, and how
they are denoted in Tk, which can be useful when referring to the Tk man pages.








Tk
Tkinter Event Field
Tk
Tkinter Event Field



%f
focus
%A
char

%h
height
%E
send_event

%k
keycode
%K
keysym

%s
state
%N
keysym_num

%t
time
%T
type

%w
width
%W
widget

%x
x
%X
x_root

%y
y
%Y
y_root





The index Parameter¶
A number of widgets require “index” parameters to be passed.  These are used to
point at a specific place in a Text widget, or to particular characters in an
Entry widget, or to particular menu items in a Menu widget.

Entry widget indexes (index, view index, etc.)
Entry widgets have options that refer to character positions in the text being
displayed.  You can use these tkinter functions to access these special
points in text widgets:
Text widget indexes
The index notation for Text widgets is very rich and is best described in the Tk
man pages.
Menu indexes (menu.invoke(), menu.entryconfig(), etc.)
Some options and methods for menus manipulate specific menu entries. Anytime a
menu index is needed for an option or a parameter, you may pass in:

an integer which refers to the numeric position of the entry in the widget,
counted from the top, starting with 0;
the string "active", which refers to the menu position that is currently
under the cursor;
the string "last" which refers to the last menu item;
An integer preceded by @, as in @6, where the integer is interpreted
as a y pixel coordinate in the menu’s coordinate system;
the string "none", which indicates no menu entry at all, most often used
with menu.activate() to deactivate all entries, and finally,
a text string that is pattern matched against the label of the menu entry, as
scanned from the top of the menu to the bottom.  Note that this index type is
considered after all the others, which means that matches for menu items
labelled last, active, or none may be interpreted as the above
literals, instead.





Images¶
Images of different formats can be created through the corresponding subclass
of tkinter.Image:

BitmapImage for images in XBM format.
PhotoImage for images in PGM, PPM, GIF and PNG formats. The latter
is supported starting with Tk 8.6.

Either type of image is created through either the file or the data
option (other options are available as well).
The image object can then be used wherever an image option is supported by
some widget (e.g. labels, buttons, menus). In these cases, Tk will not keep a
reference to the image. When the last Python reference to the image object is
deleted, the image data is deleted as well, and Tk will display an empty box
wherever the image was used.

See also
The Pillow package adds support for
formats such as BMP, JPEG, TIFF, and WebP, among others.


