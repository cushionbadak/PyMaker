link:
reference/datamodel.html#coroutine-objects

docs:

3.4.2. Coroutine Objects¶
Coroutine objects are awaitable objects.
A coroutine’s execution can be controlled by calling __await__() and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises StopIteration, and the exception’s
value attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled StopIteration exceptions.
Coroutines also have the methods listed below, which are analogous to
those of generators (see Generator-iterator methods).  However, unlike
generators, coroutines do not directly support iteration.

Changed in version 3.5.2: It is a RuntimeError to await on a coroutine more than once.



coroutine.send(value)¶
Starts or resumes execution of the coroutine.  If value is None,
this is equivalent to advancing the iterator returned by
__await__().  If value is not None, this method delegates
to the send() method of the iterator that caused
the coroutine to suspend.  The result (return value,
StopIteration, or other exception) is the same as when
iterating over the __await__() return value, described above.



coroutine.throw(type[, value[, traceback]])¶
Raises the specified exception in the coroutine.  This method delegates
to the throw() method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, StopIteration, or other exception) is the same as
when iterating over the __await__() return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.



coroutine.close()¶
Causes the coroutine to clean itself up and exit.  If the coroutine
is suspended, this method first delegates to the close()
method of the iterator that caused the coroutine to suspend, if it
has such a method.  Then it raises GeneratorExit at the
suspension point, causing the coroutine to immediately clean itself up.
Finally, the coroutine is marked as having finished executing, even if
it was never started.
Coroutine objects are automatically closed using the above process when
they are about to be destroyed.

