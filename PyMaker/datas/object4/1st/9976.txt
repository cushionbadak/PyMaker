link:
library/compileall.html#command-line-use

docs:

Command-line use¶
This module can work as a script (using python -m compileall) to
compile Python sources.


directory ...¶

file ...¶
Positional arguments are files to compile or directories that contain
source files, traversed recursively.  If no argument is given, behave as if
the command line was -l <directories from sys.path>.



-l¶
Do not recurse into subdirectories, only compile source code files directly
contained in the named or implied directories.



-f¶
Force rebuild even if timestamps are up-to-date.



-q¶
Do not print the list of files compiled. If passed once, error messages will
still be printed. If passed twice (-qq), all output is suppressed.



-d destdir¶
Directory prepended to the path to each file being compiled.  This will
appear in compilation time tracebacks, and is also compiled in to the
byte-code file, where it will be used in tracebacks and other messages in
cases where the source file does not exist at the time the byte-code file is
executed.



-x regex¶
regex is used to search the full path to each file considered for
compilation, and if the regex produces a match, the file is skipped.



-i list¶
Read the file list and add each line that it contains to the list of
files and directories to compile.  If list is -, read lines from
stdin.



-b¶
Write the byte-code files to their legacy locations and names, which may
overwrite byte-code files created by another version of Python.  The default
is to write files to their PEP 3147 locations and names, which allows
byte-code files from multiple versions of Python to coexist.



-r¶
Control the maximum recursion level for subdirectories.
If this is given, then -l option will not be taken into account.
python -m compileall <directory> -r 0 is equivalent to
python -m compileall <directory> -l.



-j N¶
Use N workers to compile the files within the given directory.
If 0 is used, then the result of os.cpu_count()
will be used.



--invalidation-mode [timestamp|checked-hash|unchecked-hash]¶
Control how the generated byte-code files are invalidated at runtime.
The timestamp value, means that .pyc files with the source timestamp
and size embedded will be generated. The checked-hash and
unchecked-hash values cause hash-based pycs to be generated. Hash-based
pycs embed a hash of the source file contents rather than a timestamp. See
Cached bytecode invalidation for more information on how Python validates
bytecode cache files at runtime.
The default is timestamp if the SOURCE_DATE_EPOCH environment
variable is not set, and checked-hash if the SOURCE_DATE_EPOCH
environment variable is set.


Changed in version 3.2: Added the -i, -b and -h options.


Changed in version 3.5: Added the  -j, -r, and -qq options.  -q option
was changed to a multilevel value.  -b will always produce a
byte-code file ending in .pyc, never .pyo.


Changed in version 3.7: Added the --invalidation-mode option.

There is no command-line option to control the optimization level used by the
compile() function, because the Python interpreter itself already
provides the option: python -O -m compileall.
