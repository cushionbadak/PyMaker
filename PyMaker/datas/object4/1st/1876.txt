link:
library/itertools.html#itertools.permutations

docs:


itertools.permutations(iterable, r=None)Â¶
Return successive r length permutations of elements in the iterable.
If r is not specified or is None, then r defaults to the length
of the iterable and all possible full-length permutations
are generated.
Permutations are emitted in lexicographic sort order.  So, if the
input iterable is sorted, the permutation tuples will be produced
in sorted order.
Elements are treated as unique based on their position, not on their
value.  So if the input elements are unique, there will be no repeat
values in each permutation.
Roughly equivalent to:
def permutations(iterable, r=None):
    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --> 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r > n:
        return
    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return


The code for permutations() can be also expressed as a subsequence of
product(), filtered to exclude entries with repeated elements (those
from the same position in the input pool):
def permutations(iterable, r=None):
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    for indices in product(range(n), repeat=r):
        if len(set(indices)) == r:
            yield tuple(pool[i] for i in indices)


The number of items returned is n! / (n-r)! when 0 <= r <= n
or zero when r > n.
