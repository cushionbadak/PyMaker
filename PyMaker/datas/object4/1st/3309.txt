link:
library/io.html#io.BufferedIOBase.write

docs:

<dt id="io.BufferedIOBase.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#io.BufferedIOBase.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>, <em>b</em>, and return the number
of bytes written (always equal to the length of <em>b</em> in bytes, since if
the write fails an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> will be raised).  Depending on the
actual implementation, these bytes may be readily written to the
underlying stream, or held in a buffer for performance and latency
reasons.</p>
<p>When in non-blocking mode, a <a class="reference internal" href="exceptions.html#BlockingIOError" title="BlockingIOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> is raised if the
data needed to be written to the raw stream but it couldn’t accept
all the data without blocking.</p>
<p>The caller may release or mutate <em>b</em> after this method returns,
so the implementation should only access <em>b</em> during the method call.</p>
</dd>