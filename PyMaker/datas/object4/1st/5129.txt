link:
library/ssl.html#functions-constants-and-exceptions

docs:

Functions, Constants, and Exceptions¶

Socket creation¶
Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() of an SSLContext instance to wrap
sockets as SSLSocket objects. The helper functions
create_default_context() returns a new context with secure default
settings. The old wrap_socket() function is deprecated since it is
both inefficient and has no support for server name indication (SNI) and
hostname matching.
Client socket example with default context and IPv4/IPv6 dual stack:
import socket
import ssl

hostname = 'www.python.org'
context = ssl.create_default_context()

with socket.create_connection((hostname, 443)) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print(ssock.version())


Client socket example with custom context and IPv4:
hostname = 'www.python.org'
# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations('path/to/cabundle.pem')

with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print(ssock.version())


Server socket example listening on localhost IPv4:
context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')

with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
    sock.bind(('127.0.0.1', 8443))
    sock.listen(5)
    with context.wrap_socket(sock, server_side=True) as ssock:
        conn, addr = ssock.accept()
        ...




Context creation¶
A convenience function helps create SSLContext objects for common
purposes.


ssl.create_default_context(purpose=Purpose.SERVER_AUTH, cafile=None, capath=None, cadata=None)¶
Return a new SSLContext object with default settings for
the given purpose.  The settings are chosen by the ssl module,
and usually represent a higher security level than when calling the
SSLContext constructor directly.
cafile, capath, cadata represent optional CA certificates to
trust for certificate verification, as in
SSLContext.load_verify_locations().  If all three are
None, this function can choose to trust the system’s default
CA certificates instead.
The settings are: PROTOCOL_TLS, OP_NO_SSLv2, and
OP_NO_SSLv3 with high encryption cipher suites without RC4 and
without unauthenticated cipher suites. Passing SERVER_AUTH
as purpose sets verify_mode to CERT_REQUIRED
and either loads CA certificates (when at least one of cafile, capath or
cadata is given) or uses SSLContext.load_default_certs() to load
default CA certificates.

Note
The protocol, options, cipher and other settings may change to more
restrictive values anytime without prior deprecation.  The values
represent a fair balance between compatibility and security.
If your application needs specific settings, you should create a
SSLContext and apply the settings yourself.


Note
If you find that when certain older clients or servers attempt to connect
with a SSLContext created by this function that they get an error
stating “Protocol or cipher suite mismatch”, it may be that they only
support SSL3.0 which this function excludes using the
OP_NO_SSLv3. SSL3.0 is widely considered to be completely broken. If you still wish to continue to
use this function but still allow SSL 3.0 connections you can re-enable
them using:
ctx = ssl.create_default_context(Purpose.CLIENT_AUTH)
ctx.options &= ~ssl.OP_NO_SSLv3




New in version 3.4.


Changed in version 3.4.4: RC4 was dropped from the default cipher string.


Changed in version 3.6: ChaCha20/Poly1305 was added to the default cipher string.
3DES was dropped from the default cipher string.




Exceptions¶


exception ssl.SSLError¶
Raised to signal an error from the underlying SSL implementation
(currently provided by the OpenSSL library).  This signifies some
problem in the higher-level encryption and authentication layer that’s
superimposed on the underlying network connection.  This error
is a subtype of OSError.  The error code and message of
SSLError instances are provided by the OpenSSL library.

Changed in version 3.3: SSLError used to be a subtype of socket.error.



library¶
A string mnemonic designating the OpenSSL submodule in which the error
occurred, such as SSL, PEM or X509.  The range of possible
values depends on the OpenSSL version.

New in version 3.3.




reason¶
A string mnemonic designating the reason this error occurred, for
example CERTIFICATE_VERIFY_FAILED.  The range of possible
values depends on the OpenSSL version.

New in version 3.3.





exception ssl.SSLZeroReturnError¶
A subclass of SSLError raised when trying to read or write and
the SSL connection has been closed cleanly.  Note that this doesn’t
mean that the underlying transport (read TCP) has been closed.

New in version 3.3.




exception ssl.SSLWantReadError¶
A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs
to be received on the underlying TCP transport before the request can be
fulfilled.

New in version 3.3.




exception ssl.SSLWantWriteError¶
A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs
to be sent on the underlying TCP transport before the request can be
fulfilled.

New in version 3.3.




exception ssl.SSLSyscallError¶
A subclass of SSLError raised when a system error was encountered
while trying to fulfill an operation on a SSL socket.  Unfortunately,
there is no easy way to inspect the original errno number.

New in version 3.3.




exception ssl.SSLEOFError¶
A subclass of SSLError raised when the SSL connection has been
terminated abruptly.  Generally, you shouldn’t try to reuse the underlying
transport when this error is encountered.

New in version 3.3.




exception ssl.SSLCertVerificationError¶
A subclass of SSLError raised when certificate validation has
failed.

New in version 3.7.



verify_code¶
A numeric error number that denotes the verification error.



verify_message¶
A human readable string of the verification error.




exception ssl.CertificateError¶
An alias for SSLCertVerificationError.

Changed in version 3.7: The exception is now an alias for SSLCertVerificationError.




Random generation¶


ssl.RAND_bytes(num)¶
Return num cryptographically strong pseudo-random bytes. Raises an
SSLError if the PRNG has not been seeded with enough data or if the
operation is not supported by the current RAND method. RAND_status()
can be used to check the status of the PRNG and RAND_add() can be used
to seed the PRNG.
For almost all applications os.urandom() is preferable.
Read the Wikipedia article, Cryptographically secure pseudorandom number
generator (CSPRNG),
to get the requirements of a cryptographically generator.

New in version 3.3.




ssl.RAND_pseudo_bytes(num)¶
Return (bytes, is_cryptographic): bytes are num pseudo-random bytes,
is_cryptographic is True if the bytes generated are cryptographically
strong. Raises an SSLError if the operation is not supported by the
current RAND method.
Generated pseudo-random byte sequences will be unique if they are of
sufficient length, but are not necessarily unpredictable. They can be used
for non-cryptographic purposes and for certain purposes in cryptographic
protocols, but usually not for key generation etc.
For almost all applications os.urandom() is preferable.

New in version 3.3.


Deprecated since version 3.6: OpenSSL has deprecated ssl.RAND_pseudo_bytes(), use
ssl.RAND_bytes() instead.




ssl.RAND_status()¶
Return True if the SSL pseudo-random number generator has been seeded
with ‘enough’ randomness, and False otherwise.  You can use
ssl.RAND_egd() and ssl.RAND_add() to increase the randomness of
the pseudo-random number generator.



ssl.RAND_egd(path)¶
If you are running an entropy-gathering daemon (EGD) somewhere, and path
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.
See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources
of entropy-gathering daemons.
Availability: not available with LibreSSL and OpenSSL > 1.1.0.



ssl.RAND_add(bytes, entropy)¶
Mix the given bytes into the SSL pseudo-random number generator.  The
parameter entropy (a float) is a lower bound on the entropy contained in
string (so you can always use 0.0).  See RFC 1750 for more
information on sources of entropy.

Changed in version 3.5: Writable bytes-like object is now accepted.




Certificate handling¶


ssl.match_hostname(cert, hostname)¶
Verify that cert (in decoded format as returned by
SSLSocket.getpeercert()) matches the given hostname.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in RFC 2818, RFC 5280 and RFC 6125.  In addition to HTTPS, this
function should be suitable for checking the identity of servers in
various SSL-based protocols such as FTPS, IMAPS, POPS and others.
CertificateError is raised on failure. On success, the function
returns nothing:
>>> cert = {'subject': ((('commonName', 'example.com'),),)}
>>> ssl.match_hostname(cert, "example.com")
>>> ssl.match_hostname(cert, "example.org")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/py3k/Lib/ssl.py", line 130, in match_hostname
ssl.CertificateError: hostname 'example.org' doesn't match 'example.com'



New in version 3.2.


Changed in version 3.3.3: The function now follows RFC 6125, section 6.4.3 and does neither
match multiple wildcards (e.g. *.*.com or *a*.example.org) nor
a wildcard inside an internationalized domain names (IDN) fragment.
IDN A-labels such as www*.xn--pthon-kva.org are still supported,
but x*.python.org no longer matches xn--tda.python.org.


Changed in version 3.5: Matching of IP addresses, when present in the subjectAltName field
of the certificate, is now supported.


Changed in version 3.7: The function is no longer used to TLS connections. Hostname matching
is now performed by OpenSSL.
Allow wildcard when it is the leftmost and the only character
in that segment. Partial wildcards like www*.example.com are no
longer supported.


Deprecated since version 3.7.




ssl.cert_time_to_seconds(cert_time)¶
Return the time in seconds since the Epoch, given the cert_time
string representing the “notBefore” or “notAfter” date from a
certificate in "%b %d %H:%M:%S %Y %Z" strptime format (C
locale).
Here’s an example:
>>> import ssl
>>> timestamp = ssl.cert_time_to_seconds("Jan  5 09:34:43 2018 GMT")
>>> timestamp  
1515144883
>>> from datetime import datetime
>>> print(datetime.utcfromtimestamp(timestamp))  
2018-01-05 09:34:43


“notBefore” or “notAfter” dates must use GMT (RFC 5280).

Changed in version 3.5: Interpret the input time as a time in UTC as specified by ‘GMT’
timezone in the input string. Local timezone was used
previously. Return an integer (no fractions of a second in the
input format)




ssl.get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None)¶
Given the address addr of an SSL-protected server, as a (hostname,
port-number) pair, fetches the server’s certificate, and returns it as a
PEM-encoded string.  If ssl_version is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If ca_certs is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in
SSLContext.wrap_socket().  The call will attempt to validate the
server certificate against that set of root certificates, and will fail
if the validation attempt fails.

Changed in version 3.3: This function is now IPv6-compatible.


Changed in version 3.5: The default ssl_version is changed from PROTOCOL_SSLv3 to
PROTOCOL_TLS for maximum compatibility with modern servers.




ssl.DER_cert_to_PEM_cert(DER_cert_bytes)¶
Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.



ssl.PEM_cert_to_DER_cert(PEM_cert_string)¶
Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.



ssl.get_default_verify_paths()¶
Returns a named tuple with paths to OpenSSL’s default cafile and capath.
The paths are the same as used by
SSLContext.set_default_verify_paths(). The return value is a
named tuple DefaultVerifyPaths:

cafile - resolved path to cafile or None if the file doesn’t exist,
capath - resolved path to capath or None if the directory doesn’t exist,
openssl_cafile_env - OpenSSL’s environment key that points to a cafile,
openssl_cafile - hard coded path to a cafile,
openssl_capath_env - OpenSSL’s environment key that points to a capath,
openssl_capath - hard coded path to a capath directory

Availability: LibreSSL ignores the environment vars
openssl_cafile_env and openssl_capath_env.

New in version 3.4.




ssl.enum_certificates(store_name)¶
Retrieve certificates from Windows’ system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data. Trust specifies the purpose of the certificate as a set
of OIDS or exactly True if the certificate is trustworthy for all
purposes.
Example:
>>> ssl.enum_certificates("CA")
[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),
 (b'data...', 'x509_asn', True)]


Availability: Windows.

New in version 3.4.




ssl.enum_crls(store_name)¶
Retrieve CRLs from Windows’ system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data.
Availability: Windows.

New in version 3.4.




ssl.wrap_socket(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=CERT_NONE, ssl_version=PROTOCOL_TLS, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)¶
Takes an instance sock of socket.socket, and returns an instance
of ssl.SSLSocket, a subtype of socket.socket, which wraps
the underlying socket in an SSL context.  sock must be a
SOCK_STREAM socket; other socket types are unsupported.
Internally, function creates a SSLContext with protocol
ssl_version and SSLContext.options set to cert_reqs. If
parameters keyfile, certfile, ca_certs or ciphers are set, then
the values are passed to SSLContext.load_cert_chain(),
SSLContext.load_verify_locations(), and
SSLContext.set_ciphers().
The arguments server_side, do_handshake_on_connect, and
suppress_ragged_eofs have the same meaning as
SSLContext.wrap_socket().

Deprecated since version 3.7: Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() instead of wrap_socket(). The
top-level function is limited and creates an insecure client socket
without server name indication or hostname matching.




Constants¶

All constants are now enum.IntEnum or enum.IntFlag collections.

New in version 3.6.




ssl.CERT_NONE¶
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  Except for PROTOCOL_TLS_CLIENT,
it is the default mode.  With client-side sockets, just about any
cert is accepted.  Validation errors, such as untrusted or expired cert,
are ignored and do not abort the TLS/SSL handshake.
In server mode, no certificate is requested from the client, so the client
does not send any for client cert authentication.
See the discussion of Security considerations below.



ssl.CERT_OPTIONAL¶
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  In client mode, CERT_OPTIONAL
has the same meaning as CERT_REQUIRED. It is recommended to
use CERT_REQUIRED for client-side sockets instead.
In server mode, a client certificate request is sent to the client.  The
client may either ignore the request or send a certificate in order
perform TLS client cert authentication.  If the client chooses to send
a certificate, it is verified.  Any verification error immediately aborts
the TLS handshake.
Use of this setting requires a valid set of CA certificates to
be passed, either to SSLContext.load_verify_locations() or as a
value of the ca_certs parameter to wrap_socket().



ssl.CERT_REQUIRED¶
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  In this mode, certificates are
required from the other side of the socket connection; an SSLError
will be raised if no certificate is provided, or if its validation fails.
This mode is not sufficient to verify a certificate in client mode as
it does not match hostnames.  check_hostname must be
enabled as well to verify the authenticity of a cert.
PROTOCOL_TLS_CLIENT uses CERT_REQUIRED and
enables check_hostname by default.
With server socket, this mode provides mandatory TLS client cert
authentication.  A client certificate request is sent to the client and
the client must provide a valid and trusted certificate.
Use of this setting requires a valid set of CA certificates to
be passed, either to SSLContext.load_verify_locations() or as a
value of the ca_certs parameter to wrap_socket().



class ssl.VerifyMode¶
enum.IntEnum collection of CERT_* constants.

New in version 3.6.




ssl.VERIFY_DEFAULT¶
Possible value for SSLContext.verify_flags. In this mode, certificate
revocation lists (CRLs) are not checked. By default OpenSSL does neither
require nor verify CRLs.

New in version 3.4.




ssl.VERIFY_CRL_CHECK_LEAF¶
Possible value for SSLContext.verify_flags. In this mode, only the
peer cert is check but non of the intermediate CA certificates. The mode
requires a valid CRL that is signed by the peer cert’s issuer (its direct
ancestor CA). If no proper has been loaded
SSLContext.load_verify_locations, validation will fail.

New in version 3.4.




ssl.VERIFY_CRL_CHECK_CHAIN¶
Possible value for SSLContext.verify_flags. In this mode, CRLs of
all certificates in the peer cert chain are checked.

New in version 3.4.




ssl.VERIFY_X509_STRICT¶
Possible value for SSLContext.verify_flags to disable workarounds
for broken X.509 certificates.

New in version 3.4.




ssl.VERIFY_X509_TRUSTED_FIRST¶
Possible value for SSLContext.verify_flags. It instructs OpenSSL to
prefer trusted certificates when building the trust chain to validate a
certificate. This flag is enabled by default.

New in version 3.4.4.




class ssl.VerifyFlags¶
enum.IntFlag collection of VERIFY_* constants.

New in version 3.6.




ssl.PROTOCOL_TLS¶
Selects the highest protocol version that both the client and server support.
Despite the name, this option can select both “SSL” and “TLS” protocols.

New in version 3.6.




ssl.PROTOCOL_TLS_CLIENT¶
Auto-negotiate the highest protocol version like PROTOCOL_TLS,
but only support client-side SSLSocket connections. The protocol
enables CERT_REQUIRED and check_hostname by
default.

New in version 3.6.




ssl.PROTOCOL_TLS_SERVER¶
Auto-negotiate the highest protocol version like PROTOCOL_TLS,
but only support server-side SSLSocket connections.

New in version 3.6.




ssl.PROTOCOL_SSLv23¶
Alias for data:PROTOCOL_TLS.

Deprecated since version 3.6: Use PROTOCOL_TLS instead.




ssl.PROTOCOL_SSLv2¶
Selects SSL version 2 as the channel encryption protocol.
This protocol is not available if OpenSSL is compiled with the
OPENSSL_NO_SSL2 flag.

Warning
SSL version 2 is insecure.  Its use is highly discouraged.


Deprecated since version 3.6: OpenSSL has removed support for SSLv2.




ssl.PROTOCOL_SSLv3¶
Selects SSL version 3 as the channel encryption protocol.
This protocol is not be available if OpenSSL is compiled with the
OPENSSL_NO_SSLv3 flag.

Warning
SSL version 3 is insecure.  Its use is highly discouraged.


Deprecated since version 3.6: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.




ssl.PROTOCOL_TLSv1¶
Selects TLS version 1.0 as the channel encryption protocol.

Deprecated since version 3.6: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.




ssl.PROTOCOL_TLSv1_1¶
Selects TLS version 1.1 as the channel encryption protocol.
Available only with openssl version 1.0.1+.

New in version 3.4.


Deprecated since version 3.6: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.




ssl.PROTOCOL_TLSv1_2¶
Selects TLS version 1.2 as the channel encryption protocol. This is the
most modern version, and probably the best choice for maximum protection,
if both sides can speak it.  Available only with openssl version 1.0.1+.

New in version 3.4.


Deprecated since version 3.6: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.




ssl.OP_ALL¶
Enables workarounds for various bugs present in other SSL implementations.
This option is set by default.  It does not necessarily set the same
flags as OpenSSL’s SSL_OP_ALL constant.

New in version 3.2.




ssl.OP_NO_SSLv2¶
Prevents an SSLv2 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing SSLv2 as the protocol version.

New in version 3.2.


Deprecated since version 3.6: SSLv2 is deprecated




ssl.OP_NO_SSLv3¶
Prevents an SSLv3 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing SSLv3 as the protocol version.

New in version 3.2.


Deprecated since version 3.6: SSLv3 is deprecated




ssl.OP_NO_TLSv1¶
Prevents a TLSv1 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing TLSv1 as the protocol version.

New in version 3.2.


Deprecated since version 3.7: The option is deprecated since OpenSSL 1.1.0, use the new
SSLContext.minimum_version and
SSLContext.maximum_version instead.




ssl.OP_NO_TLSv1_1¶
Prevents a TLSv1.1 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.1 as
the protocol version. Available only with openssl version 1.0.1+.

New in version 3.4.


Deprecated since version 3.7: The option is deprecated since OpenSSL 1.1.0.




ssl.OP_NO_TLSv1_2¶
Prevents a TLSv1.2 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.2 as
the protocol version. Available only with openssl version 1.0.1+.

New in version 3.4.


Deprecated since version 3.7: The option is deprecated since OpenSSL 1.1.0.




ssl.OP_NO_TLSv1_3¶
Prevents a TLSv1.3 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.3 as
the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later.
When Python has been compiled against an older version of OpenSSL, the
flag defaults to 0.

New in version 3.7.


Deprecated since version 3.7: The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15,
3.6.3 and 3.7.0 for backwards compatibility with OpenSSL 1.0.2.




ssl.OP_NO_RENEGOTIATION¶
Disable all renegotiation in TLSv1.2 and earlier. Do not send
HelloRequest messages, and ignore renegotiation requests via ClientHello.
This option is only available with OpenSSL 1.1.0h and later.

New in version 3.7.




ssl.OP_CIPHER_SERVER_PREFERENCE¶
Use the server’s cipher ordering preference, rather than the client’s.
This option has no effect on client sockets and SSLv2 server sockets.

New in version 3.3.




ssl.OP_SINGLE_DH_USE¶
Prevents re-use of the same DH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.

New in version 3.3.




ssl.OP_SINGLE_ECDH_USE¶
Prevents re-use of the same ECDH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.

New in version 3.3.




ssl.OP_ENABLE_MIDDLEBOX_COMPAT¶
Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make
a TLS 1.3 connection look more like a TLS 1.2 connection.
This option is only available with OpenSSL 1.1.1 and later.

New in version 3.8.




ssl.OP_NO_COMPRESSION¶
Disable compression on the SSL channel.  This is useful if the application
protocol supports its own compression scheme.
This option is only available with OpenSSL 1.0.0 and later.

New in version 3.3.




class ssl.Options¶
enum.IntFlag collection of OP_* constants.



ssl.OP_NO_TICKET¶
Prevent client side from requesting a session ticket.

New in version 3.6.




ssl.HAS_ALPN¶
Whether the OpenSSL library has built-in support for the Application-Layer
Protocol Negotiation TLS extension as described in RFC 7301.

New in version 3.5.




ssl.HAS_NEVER_CHECK_COMMON_NAME¶
Whether the OpenSSL library has built-in support not checking subject
common name and SSLContext.hostname_checks_common_name is
writeable.

New in version 3.7.




ssl.HAS_ECDH¶
Whether the OpenSSL library has built-in support for the Elliptic Curve-based
Diffie-Hellman key exchange.  This should be true unless the feature was
explicitly disabled by the distributor.

New in version 3.3.




ssl.HAS_SNI¶
Whether the OpenSSL library has built-in support for the Server Name
Indication extension (as defined in RFC 6066).

New in version 3.2.




ssl.HAS_NPN¶
Whether the OpenSSL library has built-in support for the Next Protocol
Negotiation as described in the Application Layer Protocol
Negotiation.
When true, you can use the SSLContext.set_npn_protocols() method to advertise
which protocols you want to support.

New in version 3.3.




ssl.HAS_SSLv2¶
Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.

New in version 3.7.




ssl.HAS_SSLv3¶
Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.

New in version 3.7.




ssl.HAS_TLSv1¶
Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.

New in version 3.7.




ssl.HAS_TLSv1_1¶
Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.

New in version 3.7.




ssl.HAS_TLSv1_2¶
Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.

New in version 3.7.




ssl.HAS_TLSv1_3¶
Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.

New in version 3.7.




ssl.CHANNEL_BINDING_TYPES¶
List of supported TLS channel binding types.  Strings in this list
can be used as arguments to SSLSocket.get_channel_binding().

New in version 3.3.




ssl.OPENSSL_VERSION¶
The version string of the OpenSSL library loaded by the interpreter:
>>> ssl.OPENSSL_VERSION
'OpenSSL 1.0.2k  26 Jan 2017'



New in version 3.2.




ssl.OPENSSL_VERSION_INFO¶
A tuple of five integers representing version information about the
OpenSSL library:
>>> ssl.OPENSSL_VERSION_INFO
(1, 0, 2, 11, 15)



New in version 3.2.




ssl.OPENSSL_VERSION_NUMBER¶
The raw version number of the OpenSSL library, as a single integer:
>>> ssl.OPENSSL_VERSION_NUMBER
268443839
>>> hex(ssl.OPENSSL_VERSION_NUMBER)
'0x100020bf'



New in version 3.2.




ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE¶

ssl.ALERT_DESCRIPTION_INTERNAL_ERROR¶

ALERT_DESCRIPTION_*
Alert Descriptions from RFC 5246 and others. The IANA TLS Alert Registry
contains this list and references to the RFCs where their meaning is defined.
Used as the return value of the callback function in
SSLContext.set_servername_callback().

New in version 3.4.




class ssl.AlertDescription¶
enum.IntEnum collection of ALERT_DESCRIPTION_* constants.

New in version 3.6.




Purpose.SERVER_AUTH¶
Option for create_default_context() and
SSLContext.load_default_certs().  This value indicates that the
context may be used to authenticate Web servers (therefore, it will
be used to create client-side sockets).

New in version 3.4.




Purpose.CLIENT_AUTH¶
Option for create_default_context() and
SSLContext.load_default_certs().  This value indicates that the
context may be used to authenticate Web clients (therefore, it will
be used to create server-side sockets).

New in version 3.4.




class ssl.SSLErrorNumber¶
enum.IntEnum collection of SSL_ERROR_* constants.

New in version 3.6.




class ssl.TLSVersion¶
enum.IntEnum collection of SSL and TLS versions for
SSLContext.maximum_version and SSLContext.minimum_version.

New in version 3.7.




TLSVersion.MINIMUM_SUPPORTED¶



TLSVersion.MAXIMUM_SUPPORTED¶
The minimum or maximum supported SSL or TLS version. These are magic
constants. Their values don’t reflect the lowest and highest available
TLS/SSL versions.



TLSVersion.SSLv3¶



TLSVersion.TLSv1¶



TLSVersion.TLSv1_1¶



TLSVersion.TLSv1_2¶



TLSVersion.TLSv1_3¶
SSL 3.0 to TLS 1.3.


