link:
library/ctypes.html#calling-functions

docs:

Calling functionsÂ¶
You can call these functions like any other Python callable. This example uses
the time() function, which returns system time in seconds since the Unix
epoch, and the GetModuleHandleA() function, which returns a win32 module
handle.
This example calls both functions with a NULL pointer (None should be used
as the NULL pointer):
>>> print(libc.time(None))  
1150640792
>>> print(hex(windll.kernel32.GetModuleHandleA(None)))  
0x1d000000
>>>



Note
ctypes may raise a ValueError after calling the function, if
it detects that an invalid number of arguments were passed.  This behavior
should not be relied upon.  It is deprecated in 3.6.2, and will be removed
in 3.7.

ValueError is raised when you call an stdcall function with the
cdecl calling convention, or vice versa:
>>> cdll.kernel32.GetModuleHandleA(None)  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with not enough arguments (4 bytes missing)
>>>

>>> windll.msvcrt.printf(b"spam")  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Procedure probably called with too many arguments (4 bytes in excess)
>>>


To find out the correct calling convention you have to look into the C header
file or the documentation for the function you want to call.
On Windows, ctypes uses win32 structured exception handling to prevent
crashes from general protection faults when functions are called with invalid
argument values:
>>> windll.kernel32.GetModuleHandleA(32)  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OSError: exception: access violation reading 0x00000020
>>>


There are, however, enough ways to crash Python with ctypes, so you
should be careful anyway.  The faulthandler module can be helpful in
debugging crashes (e.g. from segmentation faults produced by erroneous C library
calls).
None, integers, bytes objects and (unicode) strings are the only native
Python objects that can directly be used as parameters in these function calls.
None is passed as a C NULL pointer, bytes objects and strings are passed
as pointer to the memory block that contains their data (char * or
wchar_t *).  Python integers are passed as the platforms default C
int type, their value is masked to fit into the C type.
Before we move on calling functions with other parameter types, we have to learn
more about ctypes data types.
