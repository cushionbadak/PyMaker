link:
library/types.html#dynamic-type-creation

docs:

Dynamic Type Creation¶


types.new_class(name, bases=(), kwds=None, exec_body=None)¶
Creates a class object dynamically using the appropriate metaclass.
The first three arguments are the components that make up a class
definition header: the class name, the base classes (in order), the
keyword arguments (such as metaclass).
The exec_body argument is a callback that is used to populate the
freshly created class namespace. It should accept the class namespace
as its sole argument and update the namespace directly with the class
contents. If no callback is provided, it has the same effect as passing
in lambda ns: ns.

New in version 3.3.




types.prepare_class(name, bases=(), kwds=None)¶
Calculates the appropriate metaclass and creates the class namespace.
The arguments are the components that make up a class definition header:
the class name, the base classes (in order) and the keyword arguments
(such as metaclass).
The return value is a 3-tuple: metaclass, namespace, kwds
metaclass is the appropriate metaclass, namespace is the
prepared class namespace and kwds is an updated copy of the passed
in kwds argument with any 'metaclass' entry removed. If no kwds
argument is passed in, this will be an empty dict.

New in version 3.3.


Changed in version 3.6: The default value for the namespace element of the returned
tuple has changed.  Now an insertion-order-preserving mapping is
used when the metaclass does not have a __prepare__ method.



See also

Metaclasses
Full details of the class creation process supported by these functions
PEP 3115 - Metaclasses in Python 3000
Introduced the __prepare__ namespace hook




types.resolve_bases(bases)¶
Resolve MRO entries dynamically as specified by PEP 560.
This function looks for items in bases that are not instances of
type, and returns a tuple where each such object that has
an __mro_entries__ method is replaced with an unpacked result of
calling this method.  If a bases item is an instance of type,
or it doesn’t have an __mro_entries__ method, then it is included in
the return tuple unchanged.

New in version 3.7.



See also
PEP 560 - Core support for typing module and generic types

