link:
library/telnetlib.html#telnetlib.Telnet.expect

docs:

<dt id="telnetlib.Telnet.expect">
<code class="descclassname">Telnet.</code><code class="descname">expect</code><span class="sig-paren">(</span><em>list</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#telnetlib.Telnet.expect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read until one from a list of a regular expressions matches.</p>
<p>The first argument is a list of regular expressions, either compiled
(<a class="reference internal" href="re.html#re-objects"><span class="std std-ref">regex objects</span></a>) or uncompiled (byte strings). The
optional second argument is a timeout, in seconds; the default is to block
indefinitely.</p>
<p>Return a tuple of three items: the index in the list of the first regular
expression that matches; the match object returned; and the bytes read up
till and including the match.</p>
<p>If end of file is found and no bytes were read, raise <a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a>.
Otherwise, when nothing matches, return <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">None,</span> <span class="pre">data)</span></code> where <em>data</em> is
the bytes received so far (may be empty bytes if a timeout happened).</p>
<p>If a regular expression ends with a greedy match (such as <code class="docutils literal notranslate"><span class="pre">.*</span></code>) or if more
than one expression can match the same input, the results are
non-deterministic, and may depend on the I/O timing.</p>
</dd>