link:
library/unittest.mock-examples.html#mocking-a-dictionary-with-magicmock

docs:

Mocking a dictionary with MagicMock¶
You may want to mock a dictionary, or other container object, recording all
access to it whilst having it still behave like a dictionary.
We can do this with MagicMock, which will behave like a dictionary,
and using side_effect to delegate dictionary access to a real
underlying dictionary that is under our control.
When the __getitem__() and __setitem__() methods of our MagicMock are called
(normal dictionary access) then side_effect is called with the key (and in
the case of __setitem__ the value too). We can also control what is returned.
After the MagicMock has been used we can use attributes like
call_args_list to assert about how the dictionary was used:
>>> my_dict = {'a': 1, 'b': 2, 'c': 3}
>>> def getitem(name):
...      return my_dict[name]
...
>>> def setitem(name, val):
...     my_dict[name] = val
...
>>> mock = MagicMock()
>>> mock.__getitem__.side_effect = getitem
>>> mock.__setitem__.side_effect = setitem



Note
An alternative to using MagicMock is to use Mock and only provide
the magic methods you specifically want:
>>> mock = Mock()
>>> mock.__getitem__ = Mock(side_effect=getitem)
>>> mock.__setitem__ = Mock(side_effect=setitem)


A third option is to use MagicMock but passing in dict as the spec
(or spec_set) argument so that the MagicMock created only has
dictionary magic methods available:
>>> mock = MagicMock(spec_set=dict)
>>> mock.__getitem__.side_effect = getitem
>>> mock.__setitem__.side_effect = setitem



With these side effect functions in place, the mock will behave like a normal
dictionary but recording the access. It even raises a KeyError if you try
to access a key that doesn’t exist.
>>> mock['a']
1
>>> mock['c']
3
>>> mock['d']
Traceback (most recent call last):
    ...
KeyError: 'd'
>>> mock['b'] = 'fish'
>>> mock['d'] = 'eggs'
>>> mock['b']
'fish'
>>> mock['d']
'eggs'


After it has been used you can make assertions about the access using the normal
mock methods and attributes:
>>> mock.__getitem__.call_args_list
[call('a'), call('c'), call('d'), call('b'), call('d')]
>>> mock.__setitem__.call_args_list
[call('b', 'fish'), call('d', 'eggs')]
>>> my_dict
{'a': 1, 'c': 3, 'b': 'fish', 'd': 'eggs'}


