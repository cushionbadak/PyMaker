link:
library/tkinter.ttk.html#ttk-styling

docs:

Ttk Styling¶
Each widget in ttk is assigned a style, which specifies the set of
elements making up the widget and how they are arranged, along with dynamic
and default settings for element options. By default the style name is the
same as the widget’s class name, but it may be overridden by the widget’s style
option. If you don’t know the class name of a widget, use the method
Misc.winfo_class() (somewidget.winfo_class()).

See also

Tcl‘2004 conference presentation
This document explains how the theme engine works




class tkinter.ttk.Style¶
This class is used to manipulate the style database.


configure(style, query_opt=None, **kw)¶
Query or set the default value of the specified option(s) in style.
Each key in kw is an option and each value is a string identifying
the value for that option.
For example, to change every default button to be a flat button with
some padding and a different background color:
from tkinter import ttk
import tkinter

root = tkinter.Tk()

ttk.Style().configure("TButton", padding=6, relief="flat",
   background="#ccc")

btn = ttk.Button(text="Sample")
btn.pack()

root.mainloop()





map(style, query_opt=None, **kw)¶
Query or sets dynamic values of the specified option(s) in style.
Each key in kw is an option and each value should be a list or a
tuple (usually) containing statespecs grouped in tuples, lists, or
some other preference. A statespec is a compound of one
or more states and then a value.
An example may make it more understandable:
import tkinter
from tkinter import ttk

root = tkinter.Tk()

style = ttk.Style()
style.map("C.TButton",
    foreground=[('pressed', 'red'), ('active', 'blue')],
    background=[('pressed', '!disabled', 'black'), ('active', 'white')]
    )

colored_btn = ttk.Button(text="Test", style="C.TButton").pack()

root.mainloop()


Note that the order of the (states, value) sequences for an option does
matter, if the order is changed to [('active', 'blue'), ('pressed',
'red')] in the foreground option, for example, the result would be a
blue foreground when the widget were in active or pressed states.



lookup(style, option, state=None, default=None)¶
Returns the value specified for option in style.
If state is specified, it is expected to be a sequence of one or more
states. If the default argument is set, it is used as a fallback value
in case no specification for option is found.
To check what font a Button uses by default:
from tkinter import ttk

print(ttk.Style().lookup("TButton", "font"))





layout(style, layoutspec=None)¶
Define the widget layout for given style. If layoutspec is omitted,
return the layout specification for given style.
layoutspec, if specified, is expected to be a list or some other
sequence type (excluding strings), where each item should be a tuple and
the first item is the layout name and the second item should have the
format described in Layouts.
To understand the format, see the following example (it is not
intended to do anything useful):
from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.layout("TMenubutton", [
   ("Menubutton.background", None),
   ("Menubutton.button", {"children":
       [("Menubutton.focus", {"children":
           [("Menubutton.padding", {"children":
               [("Menubutton.label", {"side": "left", "expand": 1})]
           })]
       })]
   }),
])

mbtn = ttk.Menubutton(text='Text')
mbtn.pack()
root.mainloop()





element_create(elementname, etype, *args, **kw)¶
Create a new element in the current theme, of the given etype which is
expected to be either “image”, “from” or “vsapi”. The latter is only
available in Tk 8.6a for Windows XP and Vista and is not described here.
If “image” is used, args should contain the default image name followed
by statespec/value pairs (this is the imagespec), and kw may have the
following options:



border=padding
padding is a list of up to four integers, specifying the left, top,
right, and bottom borders, respectively.



height=height
Specifies a minimum height for the element. If less than zero, the
base image’s height is used as a default.



padding=padding
Specifies the element’s interior padding. Defaults to border’s value
if not specified.



sticky=spec
Specifies how the image is placed within the final parcel. spec
contains zero or more characters “n”, “s”, “w”, or “e”.



width=width
Specifies a minimum width for the element. If less than zero, the
base image’s width is used as a default.




If “from” is used as the value of etype,
element_create() will clone an existing
element. args is expected to contain a themename, from which
the element will be cloned, and optionally an element to clone from.
If this element to clone from is not specified, an empty element will
be used. kw is discarded.



element_names()¶
Returns the list of elements defined in the current theme.



element_options(elementname)¶
Returns the list of elementname’s options.



theme_create(themename, parent=None, settings=None)¶
Create a new theme.
It is an error if themename already exists. If parent is specified,
the new theme will inherit styles, elements and layouts from the parent
theme. If settings are present they are expected to have the same
syntax used for theme_settings().



theme_settings(themename, settings)¶
Temporarily sets the current theme to themename, apply specified
settings and then restore the previous theme.
Each key in settings is a style and each value may contain the keys
‘configure’, ‘map’, ‘layout’ and ‘element create’ and they are expected
to have the same format as specified by the methods
Style.configure(), Style.map(), Style.layout() and
Style.element_create() respectively.
As an example, let’s change the Combobox for the default theme a bit:
from tkinter import ttk
import tkinter

root = tkinter.Tk()

style = ttk.Style()
style.theme_settings("default", {
   "TCombobox": {
       "configure": {"padding": 5},
       "map": {
           "background": [("active", "green2"),
                          ("!disabled", "green4")],
           "fieldbackground": [("!disabled", "green3")],
           "foreground": [("focus", "OliveDrab1"),
                          ("!disabled", "OliveDrab2")]
       }
   }
})

combo = ttk.Combobox().pack()

root.mainloop()





theme_names()¶
Returns a list of all known themes.



theme_use(themename=None)¶
If themename is not given, returns the theme in use.  Otherwise, sets
the current theme to themename, refreshes all widgets and emits a
<<ThemeChanged>> event.



Layouts¶
A layout can be just None, if it takes no options, or a dict of
options specifying how to arrange the element. The layout mechanism
uses a simplified version of the pack geometry manager: given an
initial cavity, each element is allocated a parcel. Valid
options/values are:



side: whichside
Specifies which side of the cavity to place the element; one of
top, right, bottom or left. If omitted, the element occupies the
entire cavity.



sticky: nswe
Specifies where the element is placed inside its allocated parcel.



unit: 0 or 1
If set to 1, causes the element and all of its descendants to be treated as
a single element for the purposes of Widget.identify() et al. It’s
used for things like scrollbar thumbs with grips.



children: [sublayout… ]
Specifies a list of elements to place inside the element. Each
element is a tuple (or other sequence type) where the first item is
the layout name, and the other is a Layout.





