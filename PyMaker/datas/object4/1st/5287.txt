link:
library/ssl.html#memory-bio-support

docs:

Memory BIO Support¶

New in version 3.5.

Ever since the SSL module was introduced in Python 2.6, the SSLSocket
class has provided two related but distinct areas of functionality:

SSL protocol handling
Network IO

The network IO API is identical to that provided by socket.socket,
from which SSLSocket also inherits. This allows an SSL socket to be
used as a drop-in replacement for a regular socket, making it very easy to add
SSL support to an existing application.
Combining SSL protocol handling and network IO usually works well, but there
are some cases where it doesn’t. An example is async IO frameworks that want to
use a different IO multiplexing model than the “select/poll on a file
descriptor” (readiness based) model that is assumed by socket.socket
and by the internal OpenSSL socket IO routines. This is mostly relevant for
platforms like Windows where this model is not efficient. For this purpose, a
reduced scope variant of SSLSocket called SSLObject is
provided.


class ssl.SSLObject¶
A reduced-scope variant of SSLSocket representing an SSL protocol
instance that does not contain any network IO methods. This class is
typically used by framework authors that want to implement asynchronous IO
for SSL through memory buffers.
This class implements an interface on top of a low-level SSL object as
implemented by OpenSSL. This object captures the state of an SSL connection
but does not provide any network IO itself. IO needs to be performed through
separate “BIO” objects which are OpenSSL’s IO abstraction layer.
This class has no public constructor.  An SSLObject instance
must be created using the wrap_bio() method. This
method will create the SSLObject instance and bind it to a
pair of BIOs. The incoming BIO is used to pass data from Python to the
SSL protocol instance, while the outgoing BIO is used to pass data the
other way around.
The following methods are available:

context
server_side
server_hostname
session
session_reused
read()
write()
getpeercert()
selected_npn_protocol()
cipher()
shared_ciphers()
compression()
pending()
do_handshake()
unwrap()
get_channel_binding()

When compared to SSLSocket, this object lacks the following
features:

Any form of network IO; recv() and send() read and write only to
the underlying MemoryBIO buffers.
There is no do_handshake_on_connect machinery. You must always manually
call do_handshake() to start the handshake.
There is no handling of suppress_ragged_eofs. All end-of-file conditions
that are in violation of the protocol are reported via the
SSLEOFError exception.
The method unwrap() call does not return anything,
unlike for an SSL socket where it returns the underlying socket.
The server_name_callback callback passed to
SSLContext.set_servername_callback() will get an SSLObject
instance instead of a SSLSocket instance as its first parameter.

Some notes related to the use of SSLObject:

All IO on an SSLObject is non-blocking.
This means that for example read() will raise an
SSLWantReadError if it needs more data than the incoming BIO has
available.
There is no module-level wrap_bio() call like there is for
wrap_socket(). An SSLObject is always created
via an SSLContext.


Changed in version 3.7: SSLObject instances must to created with
wrap_bio(). In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.


An SSLObject communicates with the outside world using memory buffers. The
class MemoryBIO provides a memory buffer that can be used for this
purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:


class ssl.MemoryBIO¶
A memory buffer that can be used to pass data between Python and an SSL
protocol instance.


pending¶
Return the number of bytes currently in the memory buffer.



eof¶
A boolean indicating whether the memory BIO is current at the end-of-file
position.



read(n=-1)¶
Read up to n bytes from the memory buffer. If n is not specified or
negative, all bytes are returned.



write(buf)¶
Write the bytes from buf to the memory BIO. The buf argument must be an
object supporting the buffer protocol.
The return value is the number of bytes written, which is always equal to
the length of buf.



write_eof()¶
Write an EOF marker to the memory BIO. After this method has been called, it
is illegal to call write(). The attribute eof will
become true after all data currently in the buffer has been read.


