link:
library/http.client.html#http.client.HTTPConnection.request

docs:

<dt id="http.client.HTTPConnection.request">
<code class="descclassname">HTTPConnection.</code><code class="descname">request</code><span class="sig-paren">(</span><em>method</em>, <em>url</em>, <em>body=None</em>, <em>headers={}</em>, <em>*</em>, <em>encode_chunked=False</em><span class="sig-paren">)</span><a class="headerlink" href="#http.client.HTTPConnection.request" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This will send a request to the server using the HTTP request
method <em>method</em> and the selector <em>url</em>.</p>
<p>If <em>body</em> is specified, the specified data is sent after the headers are
finished.  It may be a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>, an
open <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>, or an iterable of <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.  If <em>body</em>
is a string, it is encoded as ISO-8859-1, the default for HTTP.  If it
is a bytes-like object, the bytes are sent as is.  If it is a <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file
object</span></a>, the contents of the file is sent; this file object should
support at least the <code class="docutils literal notranslate"><span class="pre">read()</span></code> method.  If the file object is an
instance of <a class="reference internal" href="io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>, the data returned by the <code class="docutils literal notranslate"><span class="pre">read()</span></code>
method will be encoded as ISO-8859-1, otherwise the data returned by
<code class="docutils literal notranslate"><span class="pre">read()</span></code> is sent as is.  If <em>body</em> is an iterable, the elements of the
iterable are sent as is until the iterable is exhausted.</p>
<p>The <em>headers</em> argument should be a mapping of extra HTTP headers to send
with the request.</p>
<p>If <em>headers</em> contains neither Content-Length nor Transfer-Encoding,
but there is a request body, one of those
header fields will be added automatically.  If
<em>body</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the Content-Length header is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> for
methods that expect a body (<code class="docutils literal notranslate"><span class="pre">PUT</span></code>, <code class="docutils literal notranslate"><span class="pre">POST</span></code>, and <code class="docutils literal notranslate"><span class="pre">PATCH</span></code>).  If
<em>body</em> is a string or a bytes-like object that is not also a
<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file</span></a>, the Content-Length header is
set to its length.  Any other type of <em>body</em> (files
and iterables in general) will be chunk-encoded, and the
Transfer-Encoding header will automatically be set instead of
Content-Length.</p>
<p>The <em>encode_chunked</em> argument is only relevant if Transfer-Encoding is
specified in <em>headers</em>.  If <em>encode_chunked</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the
HTTPConnection object assumes that all encoding is handled by the
calling code.  If it is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the body will be chunk-encoded.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Chunked transfer encoding has been added to the HTTP protocol
version 1.1.  Unless the HTTP server is known to handle HTTP 1.1,
the caller must either specify the Content-Length, or must pass a
<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or bytes-like object that is not also a file as the
body representation.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2: </span><em>body</em> can now be an iterable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.6: </span>If neither Content-Length nor Transfer-Encoding are set in
<em>headers</em>, file and iterable <em>body</em> objects are now chunk-encoded.
The <em>encode_chunked</em> argument was added.
No attempt is made to determine the Content-Length for file
objects.</p>
</div>
</dd>