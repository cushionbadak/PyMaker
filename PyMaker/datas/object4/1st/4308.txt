link:
library/multiprocessing.html#multiprocessing.connection.Connection.recv_bytes_into

docs:

<dt id="multiprocessing.connection.Connection.recv_bytes_into">
<code class="descname">recv_bytes_into</code><span class="sig-paren">(</span><em>buffer</em><span class="optional">[</span>, <em>offset</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#multiprocessing.connection.Connection.recv_bytes_into" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read into <em>buffer</em> a complete message of byte data sent from the other end
of the connection and return the number of bytes in the message.  Blocks
until there is something to receive.  Raises
<a class="reference internal" href="exceptions.html#EOFError" title="EOFError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">EOFError</span></code></a> if there is nothing left to receive and the other end was
closed.</p>
<p><em>buffer</em> must be a writable <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.  If
<em>offset</em> is given then the message will be written into the buffer from
that position.  Offset must be a non-negative integer less than the
length of <em>buffer</em> (in bytes).</p>
<p>If the buffer is too short then a <code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferTooShort</span></code> exception is
raised and the complete message is available as <code class="docutils literal notranslate"><span class="pre">e.args[0]</span></code> where <code class="docutils literal notranslate"><span class="pre">e</span></code>
is the exception instance.</p>
</dd>