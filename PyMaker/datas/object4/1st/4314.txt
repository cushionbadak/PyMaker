link:
library/multiprocessing.html#multiprocessing.Lock

docs:


class multiprocessing.Lock¶
A non-recursive lock object: a close analog of threading.Lock.
Once a process or thread has acquired a lock, subsequent attempts to
acquire it from any process or thread will block until it is released;
any process or thread may release it.  The concepts and behaviors of
threading.Lock as it applies to threads are replicated here in
multiprocessing.Lock as it applies to either processes or threads,
except as noted.
Note that Lock is actually a factory function which returns an
instance of multiprocessing.synchronize.Lock initialized with a
default context.
Lock supports the context manager protocol and thus may be
used in with statements.


acquire(block=True, timeout=None)¶
Acquire a lock, blocking or non-blocking.
With the block argument set to True (the default), the method call
will block until the lock is in an unlocked state, then set it to locked
and return True.  Note that the name of this first argument differs
from that in threading.Lock.acquire().
With the block argument set to False, the method call does not
block.  If the lock is currently in a locked state, return False;
otherwise set the lock to a locked state and return True.
When invoked with a positive, floating-point value for timeout, block
for at most the number of seconds specified by timeout as long as
the lock can not be acquired.  Invocations with a negative value for
timeout are equivalent to a timeout of zero.  Invocations with a
timeout value of None (the default) set the timeout period to
infinite.  Note that the treatment of negative or None values for
timeout differs from the implemented behavior in
threading.Lock.acquire().  The timeout argument has no practical
implications if the block argument is set to False and is thus
ignored.  Returns True if the lock has been acquired or False if
the timeout period has elapsed.



release()¶
Release a lock.  This can be called from any process or thread, not only
the process or thread which originally acquired the lock.
Behavior is the same as in threading.Lock.release() except that
when invoked on an unlocked lock, a ValueError is raised.

