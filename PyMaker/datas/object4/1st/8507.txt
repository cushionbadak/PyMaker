link:
library/unittest.html#loading-and-running-tests

docs:

Loading and running tests¶


class unittest.TestLoader¶
The TestLoader class is used to create test suites from classes and
modules.  Normally, there is no need to create an instance of this class; the
unittest module provides an instance that can be shared as
unittest.defaultTestLoader.  Using a subclass or instance, however,
allows customization of some configurable properties.
TestLoader objects have the following attributes:


errors¶
A list of the non-fatal errors encountered while loading tests. Not reset
by the loader at any point. Fatal errors are signalled by the relevant
a method raising an exception to the caller. Non-fatal errors are also
indicated by a synthetic test that will raise the original error when
run.

New in version 3.5.


TestLoader objects have the following methods:


loadTestsFromTestCase(testCaseClass)¶
Return a suite of all test cases contained in the TestCase-derived
testCaseClass.
A test case instance is created for each method named by
getTestCaseNames(). By default these are the method names
beginning with test. If getTestCaseNames() returns no
methods, but the runTest() method is implemented, a single test
case is created for that method instead.



loadTestsFromModule(module, pattern=None)¶
Return a suite of all test cases contained in the given module. This
method searches module for classes derived from TestCase and
creates an instance of the class for each test method defined for the
class.

Note
While using a hierarchy of TestCase-derived classes can be
convenient in sharing fixtures and helper functions, defining test
methods on base classes that are not intended to be instantiated
directly does not play well with this method.  Doing so, however, can
be useful when the fixtures are different and defined in subclasses.

If a module provides a load_tests function it will be called to
load the tests. This allows modules to customize test loading.
This is the load_tests protocol.  The pattern argument is passed as
the third argument to load_tests.

Changed in version 3.2: Support for load_tests added.


Changed in version 3.5: The undocumented and unofficial use_load_tests default argument is
deprecated and ignored, although it is still accepted for backward
compatibility.  The method also now accepts a keyword-only argument
pattern which is passed to load_tests as the third argument.




loadTestsFromName(name, module=None)¶
Return a suite of all test cases given a string specifier.
The specifier name is a “dotted name” that may resolve either to a
module, a test case class, a test method within a test case class, a
TestSuite instance, or a callable object which returns a
TestCase or TestSuite instance.  These checks are
applied in the order listed here; that is, a method on a possible test
case class will be picked up as “a test method within a test case class”,
rather than “a callable object”.
For example, if you have a module SampleTests containing a
TestCase-derived class SampleTestCase with three test
methods (test_one(), test_two(), and test_three()), the
specifier 'SampleTests.SampleTestCase' would cause this method to
return a suite which will run all three test methods. Using the specifier
'SampleTests.SampleTestCase.test_two' would cause it to return a test
suite which will run only the test_two() test method. The specifier
can refer to modules and packages which have not been imported; they will
be imported as a side-effect.
The method optionally resolves name relative to the given module.

Changed in version 3.5: If an ImportError or AttributeError occurs while traversing
name then a synthetic test that raises that error when run will be
returned. These errors are included in the errors accumulated by
self.errors.




loadTestsFromNames(names, module=None)¶
Similar to loadTestsFromName(), but takes a sequence of names rather
than a single name.  The return value is a test suite which supports all
the tests defined for each name.



getTestCaseNames(testCaseClass)¶
Return a sorted sequence of method names found within testCaseClass;
this should be a subclass of TestCase.



discover(start_dir, pattern='test*.py', top_level_dir=None)¶
Find all the test modules by recursing into subdirectories from the
specified start directory, and return a TestSuite object containing them.
Only test files that match pattern will be loaded. (Using shell style
pattern matching.) Only module names that are importable (i.e. are valid
Python identifiers) will be loaded.
All test modules must be importable from the top level of the project. If
the start directory is not the top level directory then the top level
directory must be specified separately.
If importing a module fails, for example due to a syntax error, then
this will be recorded as a single error and discovery will continue.  If
the import failure is due to SkipTest being raised, it will be
recorded as a skip instead of an error.
If a package (a directory containing a file named __init__.py) is
found, the package will be checked for a load_tests function. If this
exists then it will be called
package.load_tests(loader, tests, pattern). Test discovery takes care
to ensure that a package is only checked for tests once during an
invocation, even if the load_tests function itself calls
loader.discover.
If load_tests exists then discovery does not recurse into the
package, load_tests is responsible for loading all tests in the
package.
The pattern is deliberately not stored as a loader attribute so that
packages can continue discovery themselves. top_level_dir is stored so
load_tests does not need to pass this argument in to
loader.discover().
start_dir can be a dotted module name as well as a directory.

New in version 3.2.


Changed in version 3.4: Modules that raise SkipTest on import are recorded as skips,
  not errors.
Discovery works for namespace packages.
Paths are sorted before being imported so that execution order is
  the same even if the underlying file system’s ordering is not
  dependent on file name.


Changed in version 3.5: Found packages are now checked for load_tests regardless of
whether their path matches pattern, because it is impossible for
a package name to match the default pattern.


The following attributes of a TestLoader can be configured either by
subclassing or assignment on an instance:


testMethodPrefix¶
String giving the prefix of method names which will be interpreted as test
methods.  The default value is 'test'.
This affects getTestCaseNames() and all the loadTestsFrom*()
methods.



sortTestMethodsUsing¶
Function to be used to compare method names when sorting them in
getTestCaseNames() and all the loadTestsFrom*() methods.



suiteClass¶
Callable object that constructs a test suite from a list of tests. No
methods on the resulting object are needed.  The default value is the
TestSuite class.
This affects all the loadTestsFrom*() methods.



testNamePatterns¶
List of Unix shell-style wildcard test name patterns that test methods
have to match to be included in test suites (see -v option).
If this attribute is not None (the default), all test methods to be
included in test suites must match one of the patterns in this list.
Note that matches are always performed using fnmatch.fnmatchcase(),
so unlike patterns passed to the -v option, simple substring patterns
will have to be converted using * wildcards.
This affects all the loadTestsFrom*() methods.

New in version 3.7.





class unittest.TestResult¶
This class is used to compile information about which tests have succeeded
and which have failed.
A TestResult object stores the results of a set of tests.  The
TestCase and TestSuite classes ensure that results are
properly recorded; test authors do not need to worry about recording the
outcome of tests.
Testing frameworks built on top of unittest may want access to the
TestResult object generated by running a set of tests for reporting
purposes; a TestResult instance is returned by the
TestRunner.run() method for this purpose.
TestResult instances have the following attributes that will be of
interest when inspecting the results of running a set of tests:


errors¶
A list containing 2-tuples of TestCase instances and strings
holding formatted tracebacks. Each tuple represents a test which raised an
unexpected exception.



failures¶
A list containing 2-tuples of TestCase instances and strings
holding formatted tracebacks. Each tuple represents a test where a failure
was explicitly signalled using the TestCase.assert*() methods.



skipped¶
A list containing 2-tuples of TestCase instances and strings
holding the reason for skipping the test.

New in version 3.1.




expectedFailures¶
A list containing 2-tuples of TestCase instances and strings
holding formatted tracebacks.  Each tuple represents an expected failure
of the test case.



unexpectedSuccesses¶
A list containing TestCase instances that were marked as expected
failures, but succeeded.



shouldStop¶
Set to True when the execution of tests should stop by stop().



testsRun¶
The total number of tests run so far.



buffer¶
If set to true, sys.stdout and sys.stderr will be buffered in between
startTest() and stopTest() being called. Collected output will
only be echoed onto the real sys.stdout and sys.stderr if the test
fails or errors. Any output is also attached to the failure / error message.

New in version 3.2.




failfast¶
If set to true stop() will be called on the first failure or error,
halting the test run.

New in version 3.2.




tb_locals¶
If set to true then local variables will be shown in tracebacks.

New in version 3.5.




wasSuccessful()¶
Return True if all tests run so far have passed, otherwise returns
False.

Changed in version 3.4: Returns False if there were any unexpectedSuccesses
from tests marked with the expectedFailure() decorator.




stop()¶
This method can be called to signal that the set of tests being run should
be aborted by setting the shouldStop attribute to True.
TestRunner objects should respect this flag and return without
running any additional tests.
For example, this feature is used by the TextTestRunner class to
stop the test framework when the user signals an interrupt from the
keyboard.  Interactive tools which provide TestRunner
implementations can use this in a similar manner.

The following methods of the TestResult class are used to maintain
the internal data structures, and may be extended in subclasses to support
additional reporting requirements.  This is particularly useful in building
tools which support interactive reporting while tests are being run.


startTest(test)¶
Called when the test case test is about to be run.



stopTest(test)¶
Called after the test case test has been executed, regardless of the
outcome.



startTestRun()¶
Called once before any tests are executed.

New in version 3.1.




stopTestRun()¶
Called once after all tests are executed.

New in version 3.1.




addError(test, err)¶
Called when the test case test raises an unexpected exception. err is a
tuple of the form returned by sys.exc_info(): (type, value,
traceback).
The default implementation appends a tuple (test, formatted_err) to
the instance’s errors attribute, where formatted_err is a
formatted traceback derived from err.



addFailure(test, err)¶
Called when the test case test signals a failure. err is a tuple of
the form returned by sys.exc_info(): (type, value, traceback).
The default implementation appends a tuple (test, formatted_err) to
the instance’s failures attribute, where formatted_err is a
formatted traceback derived from err.



addSuccess(test)¶
Called when the test case test succeeds.
The default implementation does nothing.



addSkip(test, reason)¶
Called when the test case test is skipped.  reason is the reason the
test gave for skipping.
The default implementation appends a tuple (test, reason) to the
instance’s skipped attribute.



addExpectedFailure(test, err)¶
Called when the test case test fails, but was marked with the
expectedFailure() decorator.
The default implementation appends a tuple (test, formatted_err) to
the instance’s expectedFailures attribute, where formatted_err
is a formatted traceback derived from err.



addUnexpectedSuccess(test)¶
Called when the test case test was marked with the
expectedFailure() decorator, but succeeded.
The default implementation appends the test to the instance’s
unexpectedSuccesses attribute.



addSubTest(test, subtest, outcome)¶
Called when a subtest finishes.  test is the test case
corresponding to the test method.  subtest is a custom
TestCase instance describing the subtest.
If outcome is None, the subtest succeeded.  Otherwise,
it failed with an exception where outcome is a tuple of the form
returned by sys.exc_info(): (type, value, traceback).
The default implementation does nothing when the outcome is a
success, and records subtest failures as normal failures.

New in version 3.4.





class unittest.TextTestResult(stream, descriptions, verbosity)¶
A concrete implementation of TestResult used by the
TextTestRunner.

New in version 3.2: This class was previously named _TextTestResult. The old name still
exists as an alias but is deprecated.




unittest.defaultTestLoader¶
Instance of the TestLoader class intended to be shared.  If no
customization of the TestLoader is needed, this instance can be used
instead of repeatedly creating new instances.



class unittest.TextTestRunner(stream=None, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None, warnings=None, *, tb_locals=False)¶
A basic test runner implementation that outputs results to a stream. If stream
is None, the default, sys.stderr is used as the output stream. This class
has a few configurable parameters, but is essentially very simple.  Graphical
applications which run test suites should provide alternate implementations. Such
implementations should accept **kwargs as the interface to construct runners
changes when features are added to unittest.
By default this runner shows DeprecationWarning,
PendingDeprecationWarning, ResourceWarning and
ImportWarning even if they are ignored by default. Deprecation warnings caused by deprecated unittest
methods are also special-cased and, when the warning
filters are 'default' or 'always', they will appear only once
per-module, in order to avoid too many warning messages.  This behavior can
be overridden using Python’s -Wd or -Wa options
(see Warning control) and leaving
warnings to None.

Changed in version 3.2: Added the warnings argument.


Changed in version 3.2: The default stream is set to sys.stderr at instantiation time rather
than import time.


Changed in version 3.5: Added the tb_locals parameter.



_makeResult()¶
This method returns the instance of TestResult used by run().
It is not intended to be called directly, but can be overridden in
subclasses to provide a custom TestResult.
_makeResult() instantiates the class or callable passed in the
TextTestRunner constructor as the resultclass argument. It
defaults to TextTestResult if no resultclass is provided.
The result class is instantiated with the following arguments:
stream, descriptions, verbosity





run(test)¶
This method is the main public interface to the TextTestRunner. This
method takes a TestSuite or TestCase instance. A
TestResult is created by calling
_makeResult() and the test(s) are run and the
results printed to stdout.




unittest.main(module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=unittest.defaultTestLoader, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None)¶
A command-line program that loads a set of tests from module and runs them;
this is primarily for making test modules conveniently executable.
The simplest use for this function is to include the following line at the
end of a test script:
if __name__ == '__main__':
    unittest.main()


You can run tests with more detailed information by passing in the verbosity
argument:
if __name__ == '__main__':
    unittest.main(verbosity=2)


The defaultTest argument is either the name of a single test or an
iterable of test names to run if no test names are specified via argv.  If
not specified or None and no test names are provided via argv, all
tests found in module are run.
The argv argument can be a list of options passed to the program, with the
first element being the program name.  If not specified or None,
the values of sys.argv are used.
The testRunner argument can either be a test runner class or an already
created instance of it. By default main calls sys.exit() with
an exit code indicating success or failure of the tests run.
The testLoader argument has to be a TestLoader instance,
and defaults to defaultTestLoader.
main supports being used from the interactive interpreter by passing in the
argument exit=False. This displays the result on standard output without
calling sys.exit():
>>> from unittest import main
>>> main(module='test_module', exit=False)


The failfast, catchbreak and buffer parameters have the same
effect as the same-name command-line options.
The warnings argument specifies the warning filter
that should be used while running the tests.  If it’s not specified, it will
remain None if a -W option is passed to python
(see Warning control),
otherwise it will be set to 'default'.
Calling main actually returns an instance of the TestProgram class.
This stores the result of the tests run as the result attribute.

Changed in version 3.1: The exit parameter was added.


Changed in version 3.2: The verbosity, failfast, catchbreak, buffer
and warnings parameters were added.


Changed in version 3.4: The defaultTest parameter was changed to also accept an iterable of
test names.



load_tests Protocol¶

New in version 3.2.

Modules or packages can customize how tests are loaded from them during normal
test runs or test discovery by implementing a function called load_tests.
If a test module defines load_tests it will be called by
TestLoader.loadTestsFromModule() with the following arguments:
load_tests(loader, standard_tests, pattern)


where pattern is passed straight through from loadTestsFromModule.  It
defaults to None.
It should return a TestSuite.
loader is the instance of TestLoader doing the loading.
standard_tests are the tests that would be loaded by default from the
module. It is common for test modules to only want to add or remove tests
from the standard set of tests.
The third argument is used when loading packages as part of test discovery.
A typical load_tests function that loads tests from a specific set of
TestCase classes may look like:
test_cases = (TestCase1, TestCase2, TestCase3)

def load_tests(loader, tests, pattern):
    suite = TestSuite()
    for test_class in test_cases:
        tests = loader.loadTestsFromTestCase(test_class)
        suite.addTests(tests)
    return suite


If discovery is started in a directory containing a package, either from the
command line or by calling TestLoader.discover(), then the package
__init__.py will be checked for load_tests.  If that function does
not exist, discovery will recurse into the package as though it were just
another directory.  Otherwise, discovery of the package’s tests will be left up
to load_tests which is called with the following arguments:
load_tests(loader, standard_tests, pattern)


This should return a TestSuite representing all the tests
from the package. (standard_tests will only contain tests
collected from __init__.py.)
Because the pattern is passed into load_tests the package is free to
continue (and potentially modify) test discovery. A ‘do nothing’
load_tests function for a test package would look like:
def load_tests(loader, standard_tests, pattern):
    # top level directory cached on loader instance
    this_dir = os.path.dirname(__file__)
    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)
    standard_tests.addTests(package_tests)
    return standard_tests



Changed in version 3.5: Discovery no longer checks package names for matching pattern due to the
impossibility of package names matching the default pattern.


