link:
library/socket.html#socket-families

docs:

Socket families¶
Depending on the system and the build options, various socket families
are supported by this module.
The address format required by a particular socket object is automatically
selected based on the address family specified when the socket object was
created.  Socket addresses are represented as follows:

The address of an AF_UNIX socket bound to a file system node
is represented as a string, using the file system encoding and the
'surrogateescape' error handler (see PEP 383).  An address in
Linux’s abstract namespace is returned as a bytes-like object with
an initial null byte; note that sockets in this namespace can
communicate with normal file system sockets, so programs intended to
run on Linux may need to deal with both types of address.  A string or
bytes-like object can be used for either type of address when
passing it as an argument.


Changed in version 3.3: Previously, AF_UNIX socket paths were assumed to use UTF-8
encoding.


Changed in version 3.5: Writable bytes-like object is now accepted.





A pair (host, port) is used for the AF_INET address family,
where host is a string representing either a hostname in Internet domain
notation like 'daring.cwi.nl' or an IPv4 address like '100.50.200.5',
and port is an integer.

For IPv4 addresses, two special forms are accepted instead of a host
address: '' represents INADDR_ANY, which is used to bind to all
interfaces, and the string '<broadcast>' represents
INADDR_BROADCAST.  This behavior is not compatible with IPv6,
therefore, you may want to avoid these if you intend to support IPv6 with your
Python programs.


For AF_INET6 address family, a four-tuple (host, port, flowinfo,
scopeid) is used, where flowinfo and scopeid represent the sin6_flowinfo
and sin6_scope_id members in struct sockaddr_in6 in C.  For
socket module methods, flowinfo and scopeid can be omitted just for
backward compatibility.  Note, however, omission of scopeid can cause problems
in manipulating scoped IPv6 addresses.

Changed in version 3.7: For multicast addresses (with scopeid meaningful) address may not contain
%scope (or zone id) part. This information is superfluous and may
be safely omitted (recommended).


AF_NETLINK sockets are represented as pairs (pid, groups).

Linux-only support for TIPC is available using the AF_TIPC
address family.  TIPC is an open, non-IP based networked protocol designed
for use in clustered computer environments.  Addresses are represented by a
tuple, and the fields depend on the address type. The general tuple form is
(addr_type, v1, v2, v3 [, scope]), where:

addr_type is one of TIPC_ADDR_NAMESEQ, TIPC_ADDR_NAME,
or TIPC_ADDR_ID.

scope is one of TIPC_ZONE_SCOPE, TIPC_CLUSTER_SCOPE, and
TIPC_NODE_SCOPE.

If addr_type is TIPC_ADDR_NAME, then v1 is the server type, v2 is
the port identifier, and v3 should be 0.
If addr_type is TIPC_ADDR_NAMESEQ, then v1 is the server type, v2
is the lower port number, and v3 is the upper port number.
If addr_type is TIPC_ADDR_ID, then v1 is the node, v2 is the
reference, and v3 should be set to 0.



A tuple (interface, ) is used for the AF_CAN address family,
where interface is a string representing a network interface name like
'can0'. The network interface name '' can be used to receive packets
from all network interfaces of this family.

CAN_ISOTP protocol require a tuple (interface, rx_addr, tx_addr)
where both additional parameters are unsigned long integer that represent a
CAN identifier (standard or extended).


A string or a tuple (id, unit) is used for the SYSPROTO_CONTROL
protocol of the PF_SYSTEM family. The string is the name of a
kernel control using a dynamically-assigned ID. The tuple can be used if ID
and unit number of the kernel control are known or if a registered ID is
used.

New in version 3.3.


AF_BLUETOOTH supports the following protocols and address
formats:

BTPROTO_L2CAP accepts (bdaddr, psm) where bdaddr is
the Bluetooth address as a string and psm is an integer.

BTPROTO_RFCOMM accepts (bdaddr, channel) where bdaddr
is the Bluetooth address as a string and channel is an integer.

BTPROTO_HCI accepts (device_id,) where device_id is
either an integer or a string with the Bluetooth address of the
interface. (This depends on your OS; NetBSD and DragonFlyBSD expect
a Bluetooth address while everything else expects an integer.)

Changed in version 3.2: NetBSD and DragonFlyBSD support added.


BTPROTO_SCO accepts bdaddr where bdaddr is a
bytes object containing the Bluetooth address in a
string format. (ex. b'12:23:34:45:56:67') This protocol is not
supported under FreeBSD.



AF_ALG is a Linux-only socket based interface to Kernel
cryptography. An algorithm socket is configured with a tuple of two to four
elements (type, name [, feat [, mask]]), where:

type is the algorithm type as string, e.g. aead, hash,
skcipher or rng.
name is the algorithm name and operation mode as string, e.g.
sha256, hmac(sha256), cbc(aes) or drbg_nopr_ctr_aes256.
feat and mask are unsigned 32bit integers.

Availability: Linux 2.6.38, some algorithm types require more recent Kernels.

New in version 3.6.


AF_VSOCK allows communication between virtual machines and
their hosts. The sockets are represented as a (CID, port) tuple
where the context ID or CID and port are integers.
Availability: Linux >= 4.8 QEMU >= 2.8 ESX >= 4.0 ESX Workstation >= 6.5.

New in version 3.7.


AF_PACKET is a low-level interface directly to network devices.
The packets are represented by the tuple
(ifname, proto[, pkttype[, hatype[, addr]]]) where:

ifname - String specifying the device name.
proto - An in network-byte-order integer specifying the Ethernet
protocol number.
pkttype - Optional integer specifying the packet type:
PACKET_HOST (the default) - Packet addressed to the local host.
PACKET_BROADCAST - Physical-layer broadcast packet.
PACKET_MULTIHOST - Packet sent to a physical-layer multicast address.
PACKET_OTHERHOST - Packet to some other host that has been caught by
a device driver in promiscuous mode.
PACKET_OUTGOING - Packet originating from the local host that is
looped back to a packet socket.


hatype - Optional integer specifying the ARP hardware address type.
addr - Optional bytes-like object specifying the hardware physical
address, whose interpretation depends on the device.



If you use a hostname in the host portion of IPv4/v6 socket address, the
program may show a nondeterministic behavior, as Python uses the first address
returned from the DNS resolution.  The socket address will be resolved
differently into an actual IPv4/v6 address, depending on the results from DNS
resolution and/or the host configuration.  For deterministic behavior use a
numeric address in host portion.
All errors raise exceptions.  The normal exceptions for invalid argument types
and out-of-memory conditions can be raised; starting from Python 3.3, errors
related to socket or address semantics raise OSError or one of its
subclasses (they used to raise socket.error).
Non-blocking mode is supported through setblocking().  A
generalization of this based on timeouts is supported through
settimeout().
