link:
library/ssl.html#socket-creation

docs:

Socket creationÂ¶
Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() of an SSLContext instance to wrap
sockets as SSLSocket objects. The helper functions
create_default_context() returns a new context with secure default
settings. The old wrap_socket() function is deprecated since it is
both inefficient and has no support for server name indication (SNI) and
hostname matching.
Client socket example with default context and IPv4/IPv6 dual stack:
import socket
import ssl

hostname = 'www.python.org'
context = ssl.create_default_context()

with socket.create_connection((hostname, 443)) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print(ssock.version())


Client socket example with custom context and IPv4:
hostname = 'www.python.org'
# PROTOCOL_TLS_CLIENT requires valid cert chain and hostname
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.load_verify_locations('path/to/cabundle.pem')

with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print(ssock.version())


Server socket example listening on localhost IPv4:
context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain('/path/to/certchain.pem', '/path/to/private.key')

with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
    sock.bind(('127.0.0.1', 8443))
    sock.listen(5)
    with context.wrap_socket(sock, server_side=True) as ssock:
        conn, addr = ssock.accept()
        ...


