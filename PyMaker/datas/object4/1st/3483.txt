link:
library/logging.html#logger-objects

docs:

Logger Objects¶
Loggers have the following attributes and methods.  Note that Loggers are never
instantiated directly, but always through the module-level function
logging.getLogger(name).  Multiple calls to getLogger() with the same
name will always return a reference to the same Logger object.
The name is potentially a period-separated hierarchical value, like
foo.bar.baz (though it could also be just plain foo, for example).
Loggers that are further down in the hierarchical list are children of loggers
higher up in the list.  For example, given a logger with a name of foo,
loggers with names of foo.bar, foo.bar.baz, and foo.bam are all
descendants of foo.  The logger name hierarchy is analogous to the Python
package hierarchy, and identical to it if you organise your loggers on a
per-module basis using the recommended construction
logging.getLogger(__name__).  That’s because in a module, __name__
is the module’s name in the Python package namespace.


class logging.Logger¶


propagate¶
If this attribute evaluates to true, events logged to this logger will be
passed to the handlers of higher level (ancestor) loggers, in addition to
any handlers attached to this logger. Messages are passed directly to the
ancestor loggers’ handlers - neither the level nor filters of the ancestor
loggers in question are considered.
If this evaluates to false, logging messages are not passed to the handlers
of ancestor loggers.
The constructor sets this attribute to True.

Note
If you attach a handler to a logger and one or more of its
ancestors, it may emit the same record multiple times. In general, you
should not need to attach a handler to more than one logger - if you just
attach it to the appropriate logger which is highest in the logger
hierarchy, then it will see all events logged by all descendant loggers,
provided that their propagate setting is left set to True. A common
scenario is to attach handlers only to the root logger, and to let
propagation take care of the rest.




setLevel(level)¶
Sets the threshold for this logger to level. Logging messages which are less
severe than level will be ignored; logging messages which have severity level
or higher will be emitted by whichever handler or handlers service this logger,
unless a handler’s level has been set to a higher severity level than level.
When a logger is created, the level is set to NOTSET (which causes
all messages to be processed when the logger is the root logger, or delegation
to the parent when the logger is a non-root logger). Note that the root logger
is created with level WARNING.
The term ‘delegation to the parent’ means that if a logger has a level of
NOTSET, its chain of ancestor loggers is traversed until either an ancestor with
a level other than NOTSET is found, or the root is reached.
If an ancestor is found with a level other than NOTSET, then that ancestor’s
level is treated as the effective level of the logger where the ancestor search
began, and is used to determine how a logging event is handled.
If the root is reached, and it has a level of NOTSET, then all messages will be
processed. Otherwise, the root’s level will be used as the effective level.
See Logging Levels for a list of levels.

Changed in version 3.2: The level parameter now accepts a string representation of the
level such as ‘INFO’ as an alternative to the integer constants
such as INFO. Note, however, that levels are internally stored
as integers, and methods such as e.g. getEffectiveLevel() and
isEnabledFor() will return/expect to be passed integers.




isEnabledFor(lvl)¶
Indicates if a message of severity lvl would be processed by this logger.
This method checks first the module-level level set by
logging.disable(lvl) and then the logger’s effective level as determined
by getEffectiveLevel().



getEffectiveLevel()¶
Indicates the effective level for this logger. If a value other than
NOTSET has been set using setLevel(), it is returned. Otherwise,
the hierarchy is traversed towards the root until a value other than
NOTSET is found, and that value is returned. The value returned is
an integer, typically one of logging.DEBUG, logging.INFO
etc.



getChild(suffix)¶
Returns a logger which is a descendant to this logger, as determined by the suffix.
Thus, logging.getLogger('abc').getChild('def.ghi') would return the same
logger as would be returned by logging.getLogger('abc.def.ghi'). This is a
convenience method, useful when the parent logger is named using e.g. __name__
rather than a literal string.

New in version 3.2.




debug(msg, *args, **kwargs)¶
Logs a message with level DEBUG on this logger. The msg is the
message format string, and the args are the arguments which are merged into
msg using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
There are three keyword arguments in kwargs which are inspected:
exc_info, stack_info, and extra.
If exc_info does not evaluate as false, it causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
sys.exc_info()) or an exception instance is provided, it is used;
otherwise, sys.exc_info() is called to get the exception information.
The second optional keyword argument is stack_info, which defaults to
False. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying exc_info: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.
You can specify stack_info independently of exc_info, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:
Stack (most recent call last):


This mimics the Traceback (most recent call last): which is used when
displaying exception frames.
The third keyword argument is extra which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:
FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logger = logging.getLogger('tcpserver')
logger.warning('Protocol problem: %s', 'connection reset', extra=d)


would print something like
2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset


The keys in the dictionary passed in extra should not clash with the keys used
by the logging system. (See the Formatter documentation for more
information on which keys are used by the logging system.)
If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the Formatter has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the extra dictionary with these keys.
While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
Formatters would be used with particular Handlers.

New in version 3.2: The stack_info parameter was added.


Changed in version 3.5: The exc_info parameter can now accept exception instances.




info(msg, *args, **kwargs)¶
Logs a message with level INFO on this logger. The arguments are
interpreted as for debug().



warning(msg, *args, **kwargs)¶
Logs a message with level WARNING on this logger. The arguments are
interpreted as for debug().

Note
There is an obsolete method warn which is functionally
identical to warning. As warn is deprecated, please do not use
it - use warning instead.




error(msg, *args, **kwargs)¶
Logs a message with level ERROR on this logger. The arguments are
interpreted as for debug().



critical(msg, *args, **kwargs)¶
Logs a message with level CRITICAL on this logger. The arguments are
interpreted as for debug().



log(lvl, msg, *args, **kwargs)¶
Logs a message with integer level lvl on this logger. The other arguments are
interpreted as for debug().



exception(msg, *args, **kwargs)¶
Logs a message with level ERROR on this logger. The arguments are
interpreted as for debug(). Exception info is added to the logging
message. This method should only be called from an exception handler.



addFilter(filter)¶
Adds the specified filter filter to this logger.



removeFilter(filter)¶
Removes the specified filter filter from this logger.



filter(record)¶
Applies this logger’s filters to the record and returns a true value if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be processed (passed to handlers). If one returns a false value, no
further processing of the record occurs.



addHandler(hdlr)¶
Adds the specified handler hdlr to this logger.



removeHandler(hdlr)¶
Removes the specified handler hdlr from this logger.



findCaller(stack_info=False)¶
Finds the caller’s source filename and line number. Returns the filename, line
number, function name and stack information as a 4-element tuple. The stack
information is returned as None unless stack_info is True.



handle(record)¶
Handles a record by passing it to all handlers associated with this logger and
its ancestors (until a false value of propagate is found). This method is used
for unpickled records received from a socket, as well as those created locally.
Logger-level filtering is applied using filter().



makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)¶
This is a factory method which can be overridden in subclasses to create
specialized LogRecord instances.



hasHandlers()¶
Checks to see if this logger has any handlers configured. This is done by
looking for handlers in this logger and its parents in the logger hierarchy.
Returns True if a handler was found, else False. The method stops searching
up the hierarchy whenever a logger with the ‘propagate’ attribute set to
false is found - that will be the last logger which is checked for the
existence of handlers.

New in version 3.2.



Changed in version 3.7: Loggers can now be pickled and unpickled.


