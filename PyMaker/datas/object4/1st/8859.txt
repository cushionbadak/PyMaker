link:
library/test.html#module-test.support.script_helper

docs:

test.support.script_helper — Utilities for the Python execution tests¶
The test.support.script_helper module provides support for Python’s
script execution tests.


test.support.script_helper.interpreter_requires_environment()¶
Return True if sys.executable interpreter requires environment
variables in order to be able to run at all.
This is designed to be used with @unittest.skipIf() to annotate tests
that need to use an assert_python*() function to launch an isolated
mode (-I) or no environment mode (-E) sub-interpreter process.
A normal build & test does not run into this situation but it can happen
when trying to run the standard library test suite from an interpreter that
doesn’t have an obvious home with Python’s current home finding logic.
Setting PYTHONHOME is one way to get most of the testsuite to run
in that situation.  PYTHONPATH or PYTHONUSERSITE are
other common environment variables that might impact whether or not the
interpreter can start.



test.support.script_helper.run_python_until_end(*args, **env_vars)¶
Set up the environment based on env_vars for running the interpreter
in a subprocess.  The values can include __isolated, __cleanenv,
__cwd, and TERM.



test.support.script_helper.assert_python_ok(*args, **env_vars)¶
Assert that running the interpreter with args and optional environment
variables env_vars succeeds (rc == 0) and return a (return code,
stdout, stderr) tuple.
If the __cleanenv keyword is set, env_vars is used as a fresh
environment.
Python is started in isolated mode (command line option -I),
except if the __isolated keyword is set to False.



test.support.script_helper.assert_python_failure(*args, **env_vars)¶
Assert that running the interpreter with args and optional environment
variables env_vars fails (rc != 0) and return a (return code,
stdout, stderr) tuple.
See assert_python_ok() for more options.



test.support.script_helper.spawn_python(*args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw)¶
Run a Python subprocess with the given arguments.
kw is extra keyword args to pass to subprocess.Popen(). Returns a
subprocess.Popen object.



test.support.script_helper.kill_python(p)¶
Run the given subprocess.Popen process until completion and return
stdout.



test.support.script_helper.make_script(script_dir, script_basename, source, omit_suffix=False)¶
Create script containing source in path script_dir and script_basename.
If omit_suffix is False, append .py to the name.  Return the full
script path.



test.support.script_helper.make_zip_script(zip_dir, zip_basename, script_name, name_in_zip=None)¶
Create zip file at zip_dir and zip_basename with extension zip which
contains the files in script_name. name_in_zip is the archive name.
Return a tuple containing (full path, full path of archive name).



test.support.script_helper.make_pkg(pkg_dir, init_source='')¶
Create a directory named pkg_dir containing an __init__ file with
init_source as its contents.



test.support.script_helper.make_zip_pkg(zip_dir, zip_basename, pkg_name, script_basename, source, depth=1, compiled=False)¶
Create a zip package directory with a path of zip_dir and zip_basename
containing an empty __init__ file and a file script_basename
containing the source.  If compiled is True, both source files will
be compiled and added to the zip package.  Return a tuple of the full zip
path and the archive name for the zip file.

