link:
library/socketserver.html#socketserver.BaseRequestHandler

docs:

<dt id="socketserver.BaseRequestHandler">
<em class="property">class </em><code class="descclassname">socketserver.</code><code class="descname">BaseRequestHandler</code><a class="headerlink" href="#socketserver.BaseRequestHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the superclass of all request handler objects.  It defines
the interface, given below.  A concrete request handler subclass must
define a new <a class="reference internal" href="#socketserver.BaseRequestHandler.handle" title="socketserver.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle()</span></code></a> method, and can override any of
the other methods.  A new instance of the subclass is created for each
request.</p>
<dl class="method">
<dt id="socketserver.BaseRequestHandler.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socketserver.BaseRequestHandler.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before the <a class="reference internal" href="#socketserver.BaseRequestHandler.handle" title="socketserver.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle()</span></code></a> method to perform any initialization actions
required.  The default implementation does nothing.</p>
</dd></dl>
<dl class="method">
<dt id="socketserver.BaseRequestHandler.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socketserver.BaseRequestHandler.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>This function must do all the work required to service a request.  The
default implementation does nothing.  Several instance attributes are
available to it; the request is available as <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.request</span></code>; the client
address as <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.client_address</span></code>; and the server instance as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self.server</span></code>, in case it needs access to per-server information.</p>
<p>The type of <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.request</span></code> is different for datagram or stream
services.  For stream services, <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.request</span></code> is a socket object; for
datagram services, <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.request</span></code> is a pair of string and socket.</p>
</dd></dl>
<dl class="method">
<dt id="socketserver.BaseRequestHandler.finish">
<code class="descname">finish</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#socketserver.BaseRequestHandler.finish" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after the <a class="reference internal" href="#socketserver.BaseRequestHandler.handle" title="socketserver.BaseRequestHandler.handle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle()</span></code></a> method to perform any clean-up actions
required.  The default implementation does nothing.  If <a class="reference internal" href="#socketserver.BaseRequestHandler.setup" title="socketserver.BaseRequestHandler.setup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setup()</span></code></a>
raises an exception, this function will not be called.</p>
</dd></dl>
</dd>