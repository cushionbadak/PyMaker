link:
library/logging.config.html#access-to-internal-objects

docs:

Access to internal objectsÂ¶
As well as external objects, there is sometimes also a need to refer
to objects in the configuration.  This will be done implicitly by the
configuration system for things that it knows about.  For example, the
string value 'DEBUG' for a level in a logger or handler will
automatically be converted to the value logging.DEBUG, and the
handlers, filters and formatter entries will take an
object id and resolve to the appropriate destination object.
However, a more generic mechanism is needed for user-defined
objects which are not known to the logging module.  For
example, consider logging.handlers.MemoryHandler, which takes
a target argument which is another handler to delegate to. Since
the system already knows about this class, then in the configuration,
the given target just needs to be the object id of the relevant
target handler, and the system will resolve to the handler from the
id.  If, however, a user defines a my.package.MyHandler which has
an alternate handler, the configuration system would not know that
the alternate referred to a handler.  To cater for this, a generic
resolution system allows the user to specify:
handlers:
  file:
    # configuration of file handler goes here

  custom:
    (): my.package.MyHandler
    alternate: cfg://handlers.file


The literal string 'cfg://handlers.file' will be resolved in an
analogous way to strings with the ext:// prefix, but looking
in the configuration itself rather than the import namespace.  The
mechanism allows access by dot or by index, in a similar way to
that provided by str.format.  Thus, given the following snippet:
handlers:
  email:
    class: logging.handlers.SMTPHandler
    mailhost: localhost
    fromaddr: my_app@domain.tld
    toaddrs:
      - support_team@domain.tld
      - dev_team@domain.tld
    subject: Houston, we have a problem.


in the configuration, the string 'cfg://handlers' would resolve to
the dict with key handlers, the string 'cfg://handlers.email
would resolve to the dict with key email in the handlers dict,
and so on.  The string 'cfg://handlers.email.toaddrs[1] would
resolve to 'dev_team.domain.tld' and the string
'cfg://handlers.email.toaddrs[0]' would resolve to the value
'support_team@domain.tld'. The subject value could be accessed
using either 'cfg://handlers.email.subject' or, equivalently,
'cfg://handlers.email[subject]'.  The latter form only needs to be
used if the key contains spaces or non-alphanumeric characters.  If an
index value consists only of decimal digits, access will be attempted
using the corresponding integer value, falling back to the string
value if needed.
Given a string cfg://handlers.myhandler.mykey.123, this will
resolve to config_dict['handlers']['myhandler']['mykey']['123'].
If the string is specified as cfg://handlers.myhandler.mykey[123],
the system will attempt to retrieve the value from
config_dict['handlers']['myhandler']['mykey'][123], and fall back
to config_dict['handlers']['myhandler']['mykey']['123'] if that
fails.
