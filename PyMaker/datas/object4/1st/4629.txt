link:
library/asyncio-task.html#asyncio.Task

docs:


class asyncio.Task(coro, *, loop=None)¶
A Future-like object that runs a Python
coroutine.  Not thread-safe.
Tasks are used to run coroutines in event loops.
If a coroutine awaits on a Future, the Task suspends
the execution of the coroutine and waits for the completion
of the Future.  When the Future is done, the execution of
the wrapped coroutine resumes.
Event loops use cooperative scheduling: an event loop runs
one Task at a time.  While a Task awaits for the completion of a
Future, the event loop runs other Tasks, callbacks, or performs
IO operations.
Use the high-level asyncio.create_task() function to create
Tasks, or the low-level loop.create_task() or
ensure_future() functions.  Manual instantiation of Tasks
is discouraged.
To cancel a running Task use the cancel() method.  Calling it
will cause the Task to throw a CancelledError exception into
the wrapped coroutine.  If a coroutine is awaiting on a Future
object during cancellation, the Future object will be cancelled.
cancelled() can be used to check if the Task was cancelled.
The method returns True if the wrapped coroutine did not
suppress the CancelledError exception and was actually
cancelled.
asyncio.Task inherits from Future all of its
APIs except Future.set_result() and
Future.set_exception().
Tasks support the contextvars module.  When a Task
is created it copies the current context and later runs its
coroutine in the copied context.

Changed in version 3.7: Added support for the contextvars module.



cancel()¶
Request the Task to be cancelled.
This arranges for a CancelledError exception to be thrown
into the wrapped coroutine on the next cycle of the event loop.
The coroutine then has a chance to clean up or even deny the
request by suppressing the exception with a try …
… except CancelledError … finally block.
Therefore, unlike Future.cancel(), Task.cancel() does
not guarantee that the Task will be cancelled, although
suppressing cancellation completely is not common and is actively
discouraged.
The following example illustrates how coroutines can intercept
the cancellation request:
async def cancel_me():
    print('cancel_me(): before sleep')

    try:
        # Wait for 1 hour
        await asyncio.sleep(3600)
    except asyncio.CancelledError:
        print('cancel_me(): cancel sleep')
        raise
    finally:
        print('cancel_me(): after sleep')

async def main():
    # Create a "cancel_me" Task
    task = asyncio.create_task(cancel_me())

    # Wait for 1 second
    await asyncio.sleep(1)

    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("main(): cancel_me is cancelled now")

asyncio.run(main())

# Expected output:
#
#     cancel_me(): before sleep
#     cancel_me(): cancel sleep
#     cancel_me(): after sleep
#     main(): cancel_me is cancelled now





cancelled()¶
Return True if the Task is cancelled.
The Task is cancelled when the cancellation was requested with
cancel() and the wrapped coroutine propagated the
CancelledError exception thrown into it.



done()¶
Return True if the Task is done.
A Task is done when the wrapped coroutine either returned
a value, raised an exception, or the Task was cancelled.



result()¶
Return the result of the Task.
If the Task is done, the result of the wrapped coroutine
is returned (or if the coroutine raised an exception, that
exception is re-raised.)
If the Task has been cancelled, this method raises
a CancelledError exception.
If the Task’s result isn’t yet available, this method raises
a InvalidStateError exception.



exception()¶
Return the exception of the Task.
If the wrapped coroutine raised an exception that exception
is returned.  If the wrapped coroutine returned normally
this method returns None.
If the Task has been cancelled, this method raises a
CancelledError exception.
If the Task isn’t done yet, this method raises an
InvalidStateError exception.



add_done_callback(callback, *, context=None)¶
Add a callback to be run when the Task is done.
This method should only be used in low-level callback-based code.
See the documentation of Future.add_done_callback()
for more details.



remove_done_callback(callback)¶
Remove callback from the callbacks list.
This method should only be used in low-level callback-based code.
See the documentation of Future.remove_done_callback()
for more details.



get_stack(*, limit=None)¶
Return the list of stack frames for this Task.
If the wrapped coroutine is not done, this returns the stack
where it is suspended.  If the coroutine has completed
successfully or was cancelled, this returns an empty list.
If the coroutine was terminated by an exception, this returns
the list of traceback frames.
The frames are always ordered from oldest to newest.
Only one stack frame is returned for a suspended coroutine.
The optional limit argument sets the maximum number of frames
to return; by default all available frames are returned.
The ordering of the returned list differs depending on whether
a stack or a traceback is returned: the newest frames of a
stack are returned, but the oldest frames of a traceback are
returned.  (This matches the behavior of the traceback module.)



print_stack(*, limit=None, file=None)¶
Print the stack or traceback for this Task.
This produces output similar to that of the traceback module
for the frames retrieved by get_stack().
The limit argument is passed to get_stack() directly.
The file argument is an I/O stream to which the output
is written; by default output is written to sys.stderr.



classmethod all_tasks(loop=None)¶
Return a set of all tasks for an event loop.
By default all tasks for the current event loop are returned.
If loop is None, the get_event_loop() function
is used to get the current loop.
This method is deprecated and will be removed in
Python 3.9.  Use the asyncio.all_tasks() function instead.



classmethod current_task(loop=None)¶
Return the currently running task or None.
If loop is None, the get_event_loop() function
is used to get the current loop.
This method is deprecated and will be removed in
Python 3.9.  Use the asyncio.current_task() function
instead.

