link:
faq/library.html#input-and-output

docs:

Input and Output¶

How do I delete a file? (And other file questions…)¶
Use os.remove(filename) or os.unlink(filename); for documentation, see
the os module.  The two functions are identical; unlink() is simply
the name of the Unix system call for this function.
To remove a directory, use os.rmdir(); use os.mkdir() to create one.
os.makedirs(path) will create any intermediate directories in path that
don’t exist. os.removedirs(path) will remove intermediate directories as
long as they’re empty; if you want to delete an entire directory tree and its
contents, use shutil.rmtree().
To rename a file, use os.rename(old_path, new_path).
To truncate a file, open it using f = open(filename, "rb+"), and use
f.truncate(offset); offset defaults to the current seek position.  There’s
also os.ftruncate(fd, offset) for files opened with os.open(), where
fd is the file descriptor (a small integer).
The shutil module also contains a number of functions to work on files
including copyfile(), copytree(), and
rmtree().


How do I copy a file?¶
The shutil module contains a copyfile() function.  Note
that on MacOS 9 it doesn’t copy the resource fork and Finder info.


How do I read (or write) binary data?¶
To read or write complex binary data formats, it’s best to use the struct
module.  It allows you to take a string containing binary data (usually numbers)
and convert it to Python objects; and vice versa.
For example, the following code reads two 2-byte integers and one 4-byte integer
in big-endian format from a file:
import struct

with open(filename, "rb") as f:
    s = f.read(8)
    x, y, z = struct.unpack(">hhl", s)


The ‘>’ in the format string forces big-endian data; the letter ‘h’ reads one
“short integer” (2 bytes), and ‘l’ reads one “long integer” (4 bytes) from the
string.
For data that is more regular (e.g. a homogeneous list of ints or floats),
you can also use the array module.

Note
To read and write binary data, it is mandatory to open the file in
binary mode (here, passing "rb" to open()).  If you use
"r" instead (the default), the file will be open in text mode
and f.read() will return str objects rather than
bytes objects.



I can’t seem to use os.read() on a pipe created with os.popen(); why?¶
os.read() is a low-level function which takes a file descriptor, a small
integer representing the opened file.  os.popen() creates a high-level
file object, the same type returned by the built-in open() function.
Thus, to read n bytes from a pipe p created with os.popen(), you need to
use p.read(n).


How do I access the serial (RS232) port?¶
For Win32, POSIX (Linux, BSD, etc.), Jython:

http://pyserial.sourceforge.net
For Unix, see a Usenet post by Mitch Chapman:

https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com


Why doesn’t closing sys.stdout (stdin, stderr) really close it?¶
Python file objects are a high-level layer of
abstraction on low-level C file descriptors.
For most file objects you create in Python via the built-in open()
function, f.close() marks the Python file object as being closed from
Python’s point of view, and also arranges to close the underlying C file
descriptor.  This also happens automatically in f’s destructor, when
f becomes garbage.
But stdin, stdout and stderr are treated specially by Python, because of the
special status also given to them by C.  Running sys.stdout.close() marks
the Python-level file object as being closed, but does not close the
associated C file descriptor.
To close the underlying C file descriptor for one of these three, you should
first be sure that’s what you really want to do (e.g., you may confuse
extension modules trying to do I/O).  If it is, use os.close():
os.close(stdin.fileno())
os.close(stdout.fileno())
os.close(stderr.fileno())


Or you can use the numeric constants 0, 1 and 2, respectively.

