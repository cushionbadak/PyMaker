link:
library/socket.html#socket.socket

docs:

<dt id="socket.socket">
<code class="descclassname">socket.</code><code class="descname">socket</code><span class="sig-paren">(</span><em>family=AF_INET</em>, <em>type=SOCK_STREAM</em>, <em>proto=0</em>, <em>fileno=None</em><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a new socket using the given address family, socket type and protocol
number.  The address family should be <a class="reference internal" href="#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> (the default),
<a class="reference internal" href="#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>, <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a>, <a class="reference internal" href="#socket.AF_PACKET" title="socket.AF_PACKET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_PACKET</span></code></a>,
or <a class="reference internal" href="#socket.AF_RDS" title="socket.AF_RDS"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_RDS</span></code></a>. The socket type should be <a class="reference internal" href="#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a> (the
default), <a class="reference internal" href="#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>, <a class="reference internal" href="#socket.SOCK_RAW" title="socket.SOCK_RAW"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_RAW</span></code></a> or perhaps one of the other
<code class="docutils literal notranslate"><span class="pre">SOCK_</span></code> constants. The protocol number is usually zero and may be omitted
or in the case where the address family is <a class="reference internal" href="#socket.AF_CAN" title="socket.AF_CAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_CAN</span></code></a> the protocol
should be one of <code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_RAW</span></code>, <a class="reference internal" href="#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a> or <a class="reference internal" href="#socket.CAN_ISOTP" title="socket.CAN_ISOTP"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_ISOTP</span></code></a>.</p>
<p>If <em>fileno</em> is specified, the values for <em>family</em>, <em>type</em>, and <em>proto</em> are
auto-detected from the specified file descriptor.  Auto-detection can be
overruled by calling the function with explicit <em>family</em>, <em>type</em>, or <em>proto</em>
arguments.  This only affects how Python represents e.g. the return value
of <a class="reference internal" href="#socket.socket.getpeername" title="socket.socket.getpeername"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getpeername()</span></code></a> but not the actual OS resource.  Unlike
<a class="reference internal" href="#socket.fromfd" title="socket.fromfd"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromfd()</span></code></a>, <em>fileno</em> will return the same socket and not a
duplicate. This may help close a detached socket using
<a class="reference internal" href="#socket.close" title="socket.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.close()</span></code></a>.</p>
<p>The newly created socket is <a class="reference internal" href="os.html#fd-inheritance"><span class="std std-ref">non-inheritable</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>The AF_CAN family was added.
The AF_RDS family was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.4: </span>The CAN_BCM protocol was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.4: </span>The returned socket is now non-inheritable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.7: </span>The CAN_ISOTP protocol was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.7: </span>When <a class="reference internal" href="#socket.SOCK_NONBLOCK" title="socket.SOCK_NONBLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code></a> or <a class="reference internal" href="#socket.SOCK_CLOEXEC" title="socket.SOCK_CLOEXEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_CLOEXEC</span></code></a>
bit flags are applied to <em>type</em> they are cleared, and
<a class="reference internal" href="#socket.socket.type" title="socket.socket.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">socket.type</span></code></a> will not reflect them.  They are still passed
to the underlying system <cite>socket()</cite> call.  Therefore::</p>
<blockquote>
<div><dl class="docutils">
<dt>sock = socket.socket(</dt>
<dd>socket.AF_INET,
socket.SOCK_STREAM | socket.SOCK_NONBLOCK)</dd>
</dl>
</div></blockquote>
<p>will still create a non-blocking socket on OSes that support
<code class="docutils literal notranslate"><span class="pre">SOCK_NONBLOCK</span></code>, but <code class="docutils literal notranslate"><span class="pre">sock.type</span></code> will be set to
<code class="docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code>.</p>
</div>
</dd>