link:
library/pickle.html#pickling-class-instances

docs:

Pickling Class Instances¶
In this section, we describe the general mechanisms available to you to define,
customize, and control how class instances are pickled and unpickled.
In most cases, no additional code is needed to make instances picklable.  By
default, pickle will retrieve the class and the attributes of an instance via
introspection. When a class instance is unpickled, its __init__() method
is usually not invoked.  The default behaviour first creates an uninitialized
instance and then restores the saved attributes.  The following code shows an
implementation of this behaviour:
def save(obj):
    return (obj.__class__, obj.__dict__)

def load(cls, attributes):
    obj = cls.__new__(cls)
    obj.__dict__.update(attributes)
    return obj


Classes can alter the default behaviour by providing one or several special
methods:


object.__getnewargs_ex__()¶
In protocols 2 and newer, classes that implements the
__getnewargs_ex__() method can dictate the values passed to the
__new__() method upon unpickling.  The method must return a pair
(args, kwargs) where args is a tuple of positional arguments
and kwargs a dictionary of named arguments for constructing the
object.  Those will be passed to the __new__() method upon
unpickling.
You should implement this method if the __new__() method of your
class requires keyword-only arguments.  Otherwise, it is recommended for
compatibility to implement __getnewargs__().

Changed in version 3.6: __getnewargs_ex__() is now used in protocols 2 and 3.




object.__getnewargs__()¶
This method serves a similar purpose as __getnewargs_ex__(), but
supports only positional arguments.  It must return a tuple of arguments
args which will be passed to the __new__() method upon unpickling.
__getnewargs__() will not be called if __getnewargs_ex__() is
defined.

Changed in version 3.6: Before Python 3.6, __getnewargs__() was called instead of
__getnewargs_ex__() in protocols 2 and 3.




object.__getstate__()¶
Classes can further influence how their instances are pickled; if the class
defines the method __getstate__(), it is called and the returned object
is pickled as the contents for the instance, instead of the contents of the
instance’s dictionary.  If the __getstate__() method is absent, the
instance’s __dict__ is pickled as usual.



object.__setstate__(state)¶
Upon unpickling, if the class defines __setstate__(), it is called with
the unpickled state.  In that case, there is no requirement for the state
object to be a dictionary.  Otherwise, the pickled state must be a dictionary
and its items are assigned to the new instance’s dictionary.

Note
If __getstate__() returns a false value, the __setstate__()
method will not be called upon unpickling.


Refer to the section Handling Stateful Objects for more information about how to use
the methods __getstate__() and __setstate__().

Note
At unpickling time, some methods like __getattr__(),
__getattribute__(), or __setattr__() may be called upon the
instance.  In case those methods rely on some internal invariant being
true, the type should implement __getnewargs__() or
__getnewargs_ex__() to establish such an invariant; otherwise,
neither __new__() nor __init__() will be called.

As we shall see, pickle does not use directly the methods described above.  In
fact, these methods are part of the copy protocol which implements the
__reduce__() special method.  The copy protocol provides a unified
interface for retrieving the data necessary for pickling and copying
objects. [4]
Although powerful, implementing __reduce__() directly in your classes is
error prone.  For this reason, class designers should use the high-level
interface (i.e., __getnewargs_ex__(), __getstate__() and
__setstate__()) whenever possible.  We will show, however, cases where
using __reduce__() is the only option or leads to more efficient pickling
or both.


object.__reduce__()¶
The interface is currently defined as follows.  The __reduce__() method
takes no argument and shall return either a string or preferably a tuple (the
returned object is often referred to as the “reduce value”).
If a string is returned, the string should be interpreted as the name of a
global variable.  It should be the object’s local name relative to its
module; the pickle module searches the module namespace to determine the
object’s module.  This behaviour is typically useful for singletons.
When a tuple is returned, it must be between two and five items long.
Optional items can either be omitted, or None can be provided as their
value.  The semantics of each item are in order:

A callable object that will be called to create the initial version of the
object.
A tuple of arguments for the callable object.  An empty tuple must be given
if the callable does not accept any argument.
Optionally, the object’s state, which will be passed to the object’s
__setstate__() method as previously described.  If the object has no
such method then, the value must be a dictionary and it will be added to
the object’s __dict__ attribute.
Optionally, an iterator (and not a sequence) yielding successive items.
These items will be appended to the object either using
obj.append(item) or, in batch, using obj.extend(list_of_items).
This is primarily used for list subclasses, but may be used by other
classes as long as they have append() and extend() methods with
the appropriate signature.  (Whether append() or extend() is
used depends on which pickle protocol version is used as well as the number
of items to append, so both must be supported.)
Optionally, an iterator (not a sequence) yielding successive key-value
pairs.  These items will be stored to the object using obj[key] =
value.  This is primarily used for dictionary subclasses, but may be used
by other classes as long as they implement __setitem__().




object.__reduce_ex__(protocol)¶
Alternatively, a __reduce_ex__() method may be defined.  The only
difference is this method should take a single integer argument, the protocol
version.  When defined, pickle will prefer it over the __reduce__()
method.  In addition, __reduce__() automatically becomes a synonym for
the extended version.  The main use for this method is to provide
backwards-compatible reduce values for older Python releases.


Persistence of External Objects¶
For the benefit of object persistence, the pickle module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a persistent ID, which should be either a string of
alphanumeric characters (for protocol 0) [5] or just an arbitrary object (for
any newer protocol).
The resolution of such persistent IDs is not defined by the pickle
module; it will delegate this resolution to the user defined methods on the
pickler and unpickler, persistent_id() and
persistent_load() respectively.
To pickle objects that have an external persistent id, the pickler must have a
custom persistent_id() method that takes an object as an
argument and returns either None or the persistent id for that object.
When None is returned, the pickler simply pickles the object as normal.
When a persistent ID string is returned, the pickler will pickle that object,
along with a marker so that the unpickler will recognize it as a persistent ID.
To unpickle external objects, the unpickler must have a custom
persistent_load() method that takes a persistent ID object and
returns the referenced object.
Here is a comprehensive example presenting how persistent ID can be used to
pickle external objects by reference.
# Simple example presenting how persistent ID can be used to pickle
# external objects by reference.

import pickle
import sqlite3
from collections import namedtuple

# Simple class representing a record in our database.
MemoRecord = namedtuple("MemoRecord", "key, task")

class DBPickler(pickle.Pickler):

    def persistent_id(self, obj):
        # Instead of pickling MemoRecord as a regular class instance, we emit a
        # persistent ID.
        if isinstance(obj, MemoRecord):
            # Here, our persistent ID is simply a tuple, containing a tag and a
            # key, which refers to a specific record in the database.
            return ("MemoRecord", obj.key)
        else:
            # If obj does not have a persistent ID, return None. This means obj
            # needs to be pickled as usual.
            return None


class DBUnpickler(pickle.Unpickler):

    def __init__(self, file, connection):
        super().__init__(file)
        self.connection = connection

    def persistent_load(self, pid):
        # This method is invoked whenever a persistent ID is encountered.
        # Here, pid is the tuple returned by DBPickler.
        cursor = self.connection.cursor()
        type_tag, key_id = pid
        if type_tag == "MemoRecord":
            # Fetch the referenced record from the database and return it.
            cursor.execute("SELECT * FROM memos WHERE key=?", (str(key_id),))
            key, task = cursor.fetchone()
            return MemoRecord(key, task)
        else:
            # Always raises an error if you cannot return the correct object.
            # Otherwise, the unpickler will think None is the object referenced
            # by the persistent ID.
            raise pickle.UnpicklingError("unsupported persistent object")


def main():
    import io
    import pprint

    # Initialize and populate our database.
    conn = sqlite3.connect(":memory:")
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)")
    tasks = (
        'give food to fish',
        'prepare group meeting',
        'fight with a zebra',
        )
    for task in tasks:
        cursor.execute("INSERT INTO memos VALUES(NULL, ?)", (task,))

    # Fetch the records to be pickled.
    cursor.execute("SELECT * FROM memos")
    memos = [MemoRecord(key, task) for key, task in cursor]
    # Save the records using our custom DBPickler.
    file = io.BytesIO()
    DBPickler(file).dump(memos)

    print("Pickled records:")
    pprint.pprint(memos)

    # Update a record, just for good measure.
    cursor.execute("UPDATE memos SET task='learn italian' WHERE key=1")

    # Load the records from the pickle data stream.
    file.seek(0)
    memos = DBUnpickler(file, conn).load()

    print("Unpickled records:")
    pprint.pprint(memos)


if __name__ == '__main__':
    main()




Dispatch Tables¶
If one wants to customize pickling of some classes without disturbing
any other code which depends on pickling, then one can create a
pickler with a private dispatch table.
The global dispatch table managed by the copyreg module is
available as copyreg.dispatch_table.  Therefore, one may
choose to use a modified copy of copyreg.dispatch_table as a
private dispatch table.
For example
f = io.BytesIO()
p = pickle.Pickler(f)
p.dispatch_table = copyreg.dispatch_table.copy()
p.dispatch_table[SomeClass] = reduce_SomeClass


creates an instance of pickle.Pickler with a private dispatch
table which handles the SomeClass class specially.  Alternatively,
the code
class MyPickler(pickle.Pickler):
    dispatch_table = copyreg.dispatch_table.copy()
    dispatch_table[SomeClass] = reduce_SomeClass
f = io.BytesIO()
p = MyPickler(f)


does the same, but all instances of MyPickler will by default
share the same dispatch table.  The equivalent code using the
copyreg module is
copyreg.pickle(SomeClass, reduce_SomeClass)
f = io.BytesIO()
p = pickle.Pickler(f)




Handling Stateful Objects¶
Here’s an example that shows how to modify pickling behavior for a class.
The TextReader class opens a text file, and returns the line number and
line contents each time its readline() method is called. If a
TextReader instance is pickled, all attributes except the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The __setstate__() and
__getstate__() methods are used to implement this behavior.
class TextReader:
    """Print and number lines in a text file."""

    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename)
        self.lineno = 0

    def readline(self):
        self.lineno += 1
        line = self.file.readline()
        if not line:
            return None
        if line.endswith('\n'):
            line = line[:-1]
        return "%i: %s" % (self.lineno, line)

    def __getstate__(self):
        # Copy the object's state from self.__dict__ which contains
        # all our instance attributes. Always use the dict.copy()
        # method to avoid modifying the original state.
        state = self.__dict__.copy()
        # Remove the unpicklable entries.
        del state['file']
        return state

    def __setstate__(self, state):
        # Restore instance attributes (i.e., filename and lineno).
        self.__dict__.update(state)
        # Restore the previously opened file's state. To do so, we need to
        # reopen it and read from it until the line count is restored.
        file = open(self.filename)
        for _ in range(self.lineno):
            file.readline()
        # Finally, save the file.
        self.file = file


A sample usage might be something like this:
>>> reader = TextReader("hello.txt")
>>> reader.readline()
'1: Hello world!'
>>> reader.readline()
'2: I am line number two.'
>>> new_reader = pickle.loads(pickle.dumps(reader))
>>> new_reader.readline()
'3: Goodbye!'



