link:
library/ssl.html#notes-on-non-blocking-sockets

docs:

Notes on non-blocking sockets¶
SSL sockets behave slightly different than regular sockets in
non-blocking mode. When working with non-blocking sockets, there are
thus several things you need to be aware of:

Most SSLSocket methods will raise either
SSLWantWriteError or SSLWantReadError instead of
BlockingIOError if an I/O operation would
block. SSLWantReadError will be raised if a read operation on
the underlying socket is necessary, and SSLWantWriteError for
a write operation on the underlying socket. Note that attempts to
write to an SSL socket may require reading from the underlying
socket first, and attempts to read from the SSL socket may require
a prior write to the underlying socket.

Changed in version 3.5: In earlier Python versions, the SSLSocket.send() method
returned zero instead of raising SSLWantWriteError or
SSLWantReadError.


Calling select() tells you that the OS-level socket can be
read from (or written to), but it does not imply that there is sufficient
data at the upper SSL layer.  For example, only part of an SSL frame might
have arrived.  Therefore, you must be ready to handle SSLSocket.recv()
and SSLSocket.send() failures, and retry after another call to
select().

Conversely, since the SSL layer has its own framing, a SSL socket may
still have data available for reading without select()
being aware of it.  Therefore, you should first call
SSLSocket.recv() to drain any potentially available data, and then
only block on a select() call if still necessary.
(of course, similar provisions apply when using other primitives such as
poll(), or those in the selectors module)

The SSL handshake itself will be non-blocking: the
SSLSocket.do_handshake() method has to be retried until it returns
successfully.  Here is a synopsis using select() to wait for
the socket’s readiness:
while True:
    try:
        sock.do_handshake()
        break
    except ssl.SSLWantReadError:
        select.select([sock], [], [])
    except ssl.SSLWantWriteError:
        select.select([], [sock], [])





See also
The asyncio module supports non-blocking SSL sockets and provides a
higher level API. It polls for events using the selectors module and
handles SSLWantWriteError, SSLWantReadError and
BlockingIOError exceptions. It runs the SSL handshake asynchronously
as well.

