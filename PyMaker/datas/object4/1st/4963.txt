link:
library/asyncio-policy.html#process-watchers

docs:

Process Watchers¶
A process watcher allows customization of how an event loop monitors
child processes on Unix. Specifically, the event loop needs to know
when a child process has exited.
In asyncio, child processes are created with
create_subprocess_exec() and loop.subprocess_exec()
functions.
asyncio defines the AbstractChildWatcher abstract base class,
which child watchers should implement, and has two different
implementations: SafeChildWatcher (configured to be used
by default) and FastChildWatcher.
See also the Subprocess and Threads
section.
The following two functions can be used to customize the child process watcher
implementation used by the asyncio event loop:


asyncio.get_child_watcher()¶
Return the current child watcher for the current policy.



asyncio.set_child_watcher(watcher)¶
Set the current child watcher to watcher for the current
policy.  watcher must implement methods defined in the
AbstractChildWatcher base class.


Note
Third-party event loops implementations might not support
custom child watchers.  For such event loops, using
set_child_watcher() might be prohibited or have no effect.



class asyncio.AbstractChildWatcher¶


add_child_handler(pid, callback, *args)¶
Register a new child handler.
Arrange for callback(pid, returncode, *args) to be called
when a process with PID equal to pid terminates.  Specifying
another callback for the same process replaces the previous
handler.
The callback callable must be thread-safe.



remove_child_handler(pid)¶
Removes the handler for process with PID equal to pid.
The function returns True if the handler was successfully
removed, False if there was nothing to remove.



attach_loop(loop)¶
Attach the watcher to an event loop.
If the watcher was previously attached to an event loop, then
it is first detached before attaching to the new loop.
Note: loop may be None.



close()¶
Close the watcher.
This method has to be called to ensure that underlying
resources are cleaned-up.




class asyncio.SafeChildWatcher¶
This implementation avoids disrupting other code spawning processes
by polling every process explicitly on a SIGCHLD signal.
This is a safe solution but it has a significant overhead when
handling a big number of processes (O(n) each time a
SIGCHLD is received).
asyncio uses this safe implementation by default.



class asyncio.FastChildWatcher¶
This implementation reaps every terminated processes by calling
os.waitpid(-1) directly, possibly breaking other code spawning
processes and waiting for their termination.
There is no noticeable overhead when handling a big number of
children (O(1) each time a child terminates).

