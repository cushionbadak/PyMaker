link:
library/importlib.html#module-importlib.util

docs:

importlib.util – Utility code for importers¶
Source code: Lib/importlib/util.py

This module contains the various objects that help in the construction of
an importer.


importlib.util.MAGIC_NUMBER¶
The bytes which represent the bytecode version number. If you need help with
loading/writing bytecode then consider importlib.abc.SourceLoader.

New in version 3.4.




importlib.util.cache_from_source(path, debug_override=None, *, optimization=None)¶
Return the PEP 3147/PEP 488 path to the byte-compiled file associated
with the source path.  For example, if path is /foo/bar/baz.py the return
value would be /foo/bar/__pycache__/baz.cpython-32.pyc for Python 3.2.
The cpython-32 string comes from the current magic tag (see
get_tag(); if sys.implementation.cache_tag is not defined then
NotImplementedError will be raised).
The optimization parameter is used to specify the optimization level of the
bytecode file. An empty string represents no optimization, so
/foo/bar/baz.py with an optimization of '' will result in a
bytecode path of /foo/bar/__pycache__/baz.cpython-32.pyc. None causes
the interpter’s optimization level to be used. Any other value’s string
representation being used, so /foo/bar/baz.py with an optimization of
2 will lead to the bytecode path of
/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc. The string representation
of optimization can only be alphanumeric, else ValueError is raised.
The debug_override parameter is deprecated and can be used to override
the system’s value for __debug__. A True value is the equivalent of
setting optimization to the empty string. A False value is the same as
setting optimization to 1. If both debug_override an optimization
are not None then TypeError is raised.

New in version 3.4.


Changed in version 3.5: The optimization parameter was added and the debug_override parameter
was deprecated.


Changed in version 3.6: Accepts a path-like object.




importlib.util.source_from_cache(path)¶
Given the path to a PEP 3147 file name, return the associated source code
file path.  For example, if path is
/foo/bar/__pycache__/baz.cpython-32.pyc the returned path would be
/foo/bar/baz.py.  path need not exist, however if it does not conform
to PEP 3147 or PEP 488 format, a ValueError is raised. If
sys.implementation.cache_tag is not defined,
NotImplementedError is raised.

New in version 3.4.


Changed in version 3.6: Accepts a path-like object.




importlib.util.decode_source(source_bytes)¶
Decode the given bytes representing source code and return it as a string
with universal newlines (as required by
importlib.abc.InspectLoader.get_source()).

New in version 3.4.




importlib.util.resolve_name(name, package)¶
Resolve a relative module name to an absolute one.
If  name has no leading dots, then name is simply returned. This
allows for usage such as
importlib.util.resolve_name('sys', __package__) without doing a
check to see if the package argument is needed.
ValueError is raised if name is a relative module name but
package is a false value (e.g. None or the empty string).
ValueError is also raised a relative name would escape its containing
package (e.g. requesting ..bacon from within the spam package).

New in version 3.3.




importlib.util.find_spec(name, package=None)¶
Find the spec for a module, optionally relative to
the specified package name. If the module is in sys.modules,
then sys.modules[name].__spec__ is returned (unless the spec would be
None or is not set, in which case ValueError is raised).
Otherwise a search using sys.meta_path is done. None is
returned if no spec is found.
If name is for a submodule (contains a dot), the parent module is
automatically imported.
name and package work the same as for import_module().

New in version 3.4.


Changed in version 3.7: Raises ModuleNotFoundError instead of AttributeError if
package is in fact not a package (i.e. lacks a __path__
attribute).




importlib.util.module_from_spec(spec)¶
Create a new module based on spec and
spec.loader.create_module.
If spec.loader.create_module
does not return None, then any pre-existing attributes will not be reset.
Also, no AttributeError will be raised if triggered while accessing
spec or setting an attribute on the module.
This function is preferred over using types.ModuleType to create a
new module as spec is used to set as many import-controlled attributes on
the module as possible.

New in version 3.5.




@importlib.util.module_for_loader¶
A decorator for importlib.abc.Loader.load_module()
to handle selecting the proper
module object to load with. The decorated method is expected to have a call
signature taking two positional arguments
(e.g. load_module(self, module)) for which the second argument
will be the module object to be used by the loader.
Note that the decorator will not work on static methods because of the
assumption of two arguments.
The decorated method will take in the name of the module to be loaded
as expected for a loader. If the module is not found in
sys.modules then a new one is constructed. Regardless of where the
module came from, __loader__ set to self and __package__
is set based on what importlib.abc.InspectLoader.is_package() returns
(if available). These attributes are set unconditionally to support
reloading.
If an exception is raised by the decorated method and a module was added to
sys.modules, then the module will be removed to prevent a partially
initialized module from being in left in sys.modules. If the module
was already in sys.modules then it is left alone.

Changed in version 3.3: __loader__ and __package__ are automatically set
(when possible).


Changed in version 3.4: Set __name__, __loader__ __package__
unconditionally to support reloading.


Deprecated since version 3.4: The import machinery now directly performs all the functionality
provided by this function.




@importlib.util.set_loader¶
A decorator for importlib.abc.Loader.load_module()
to set the __loader__
attribute on the returned module. If the attribute is already set the
decorator does nothing. It is assumed that the first positional argument to
the wrapped method (i.e. self) is what __loader__ should be set
to.

Changed in version 3.4: Set __loader__ if set to None, as if the attribute does not
exist.


Deprecated since version 3.4: The import machinery takes care of this automatically.




@importlib.util.set_package¶
A decorator for importlib.abc.Loader.load_module() to set the
__package__ attribute on the returned module. If __package__
is set and has a value other than None it will not be changed.

Deprecated since version 3.4: The import machinery takes care of this automatically.




importlib.util.spec_from_loader(name, loader, *, origin=None, is_package=None)¶
A factory function for creating a ModuleSpec instance based
on a loader.  The parameters have the same meaning as they do for
ModuleSpec.  The function uses available loader APIs, such as
InspectLoader.is_package(), to fill in any missing
information on the spec.

New in version 3.4.




importlib.util.spec_from_file_location(name, location, *, loader=None, submodule_search_locations=None)¶
A factory function for creating a ModuleSpec instance based
on the path to a file.  Missing information will be filled in on the
spec by making use of loader APIs and by the implication that the
module will be file-based.

New in version 3.4.


Changed in version 3.6: Accepts a path-like object.




importlib.util.source_hash(source_bytes)¶
Return the hash of source_bytes as bytes. A hash-based .pyc file embeds
the source_hash() of the corresponding source file’s contents in its
header.

New in version 3.7.




class importlib.util.LazyLoader(loader)¶
A class which postpones the execution of the loader of a module until the
module has an attribute accessed.
This class only works with loaders that define
exec_module() as control over what module type
is used for the module is required. For those same reasons, the loader’s
create_module() method must return None or a
type for which its __class__ attribute can be mutated along with not
using slots. Finally, modules which substitute the object
placed into sys.modules will not work as there is no way to properly
replace the module references throughout the interpreter safely;
ValueError is raised if such a substitution is detected.

Note
For projects where startup time is critical, this class allows for
potentially minimizing the cost of loading a module if it is never used.
For projects where startup time is not essential then use of this class is
heavily discouraged due to error messages created during loading being
postponed and thus occurring out of context.


New in version 3.5.


Changed in version 3.6: Began calling create_module(), removing the
compatibility warning for importlib.machinery.BuiltinImporter and
importlib.machinery.ExtensionFileLoader.



classmethod factory(loader)¶
A static method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.
suffixes = importlib.machinery.SOURCE_SUFFIXES
loader = importlib.machinery.SourceFileLoader
lazy_loader = importlib.util.LazyLoader.factory(loader)
finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))




