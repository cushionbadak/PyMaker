link:
library/urllib.request.html#urllib.request.urlopen

docs:

<dt id="urllib.request.urlopen">
<code class="descclassname">urllib.request.</code><code class="descname">urlopen</code><span class="sig-paren">(</span><em>url</em>, <em>data=None</em>, <span class="optional">[</span><em>timeout</em>, <span class="optional">]</span><em>*</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadefault=False</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#urllib.request.urlopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the URL <em>url</em>, which can be either a string or a
<a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> object.</p>
<p><em>data</em> must be an object specifying additional data to be sent to the
server, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no such data is needed.  See <a class="reference internal" href="#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a>
for details.</p>
<p>urllib.request module uses HTTP/1.1 and includes <code class="docutils literal notranslate"><span class="pre">Connection:close</span></code> header
in its HTTP requests.</p>
<p>The optional <em>timeout</em> parameter specifies a timeout in seconds for
blocking operations like the connection attempt (if not specified,
the global default timeout setting will be used).  This actually
only works for HTTP, HTTPS and FTP connections.</p>
<p>If <em>context</em> is specified, it must be a <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> instance
describing the various SSL options. See <a class="reference internal" href="http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a>
for more details.</p>
<p>The optional <em>cafile</em> and <em>capath</em> parameters specify a set of trusted
CA certificates for HTTPS requests.  <em>cafile</em> should point to a single
file containing a bundle of CA certificates, whereas <em>capath</em> should
point to a directory of hashed certificate files.  More information can
be found in <a class="reference internal" href="ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>.</p>
<p>The <em>cadefault</em> parameter is ignored.</p>
<p>This function always returns an object which can work as a
<a class="reference internal" href="../glossary.html#term-context-manager"><span class="xref std std-term">context manager</span></a> and has methods such as</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">geturl()</span></code> — return the URL of the resource retrieved,
commonly used to determine if a redirect was followed</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code> — return the meta-information of the page, such as headers,
in the form of an <a class="reference internal" href="email.parser.html#email.message_from_string" title="email.message_from_string"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.message_from_string()</span></code></a> instance (see
<a class="reference external" href="http://jkorpela.fi/http.html">Quick Reference to HTTP Headers</a>)</li>
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">getcode()</span></code> – return the HTTP status code of the response.</li>
</ul>
<p>For HTTP and HTTPS URLs, this function returns a
<a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">http.client.HTTPResponse</span></code></a> object slightly modified. In addition
to the three new methods above, the msg attribute contains the
same information as the <a class="reference internal" href="http.client.html#http.client.HTTPResponse.reason" title="http.client.HTTPResponse.reason"><code class="xref py py-attr docutils literal notranslate"><span class="pre">reason</span></code></a>
attribute — the reason phrase returned by server — instead of
the response headers as it is specified in the documentation for
<a class="reference internal" href="http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a>.</p>
<p>For FTP, file, and data URLs and requests explicitly handled by legacy
<a class="reference internal" href="#urllib.request.URLopener" title="urllib.request.URLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLopener</span></code></a> and <a class="reference internal" href="#urllib.request.FancyURLopener" title="urllib.request.FancyURLopener"><code class="xref py py-class docutils literal notranslate"><span class="pre">FancyURLopener</span></code></a> classes, this function
returns a <code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.response.addinfourl</span></code> object.</p>
<p>Raises <a class="reference internal" href="urllib.error.html#urllib.error.URLError" title="urllib.error.URLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">URLError</span></code></a> on protocol errors.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">None</span></code> may be returned if no handler handles the request (though
the default installed global <a class="reference internal" href="#urllib.request.OpenerDirector" title="urllib.request.OpenerDirector"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenerDirector</span></code></a> uses
<a class="reference internal" href="#urllib.request.UnknownHandler" title="urllib.request.UnknownHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnknownHandler</span></code></a> to ensure this never happens).</p>
<p>In addition, if proxy settings are detected (for example, when a <code class="docutils literal notranslate"><span class="pre">*_proxy</span></code>
environment variable like <span class="target" id="index-0"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">http_proxy</span></code> is set),
<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> is default installed and makes sure the requests are
handled through the proxy.</p>
<p>The legacy <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code> function from Python 2.6 and earlier has been
discontinued; <a class="reference internal" href="#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.request.urlopen()</span></code></a> corresponds to the old
<code class="docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code>.  Proxy handling, which was done by passing a dictionary
parameter to <code class="docutils literal notranslate"><span class="pre">urllib.urlopen</span></code>, can be obtained by using
<a class="reference internal" href="#urllib.request.ProxyHandler" title="urllib.request.ProxyHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProxyHandler</span></code></a> objects.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.2: </span><em>cafile</em> and <em>capath</em> were added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.2: </span>HTTPS virtual hosts are now supported if possible (that is, if
<a class="reference internal" href="ssl.html#ssl.HAS_SNI" title="ssl.HAS_SNI"><code class="xref py py-data docutils literal notranslate"><span class="pre">ssl.HAS_SNI</span></code></a> is true).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2: </span><em>data</em> can be an iterable object.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span><em>cadefault</em> was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.4.3: </span><em>context</em> was added.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 3.6: </span><em>cafile</em>, <em>capath</em> and <em>cadefault</em> are deprecated in favor of <em>context</em>.
Please use <a class="reference internal" href="ssl.html#ssl.SSLContext.load_cert_chain" title="ssl.SSLContext.load_cert_chain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.load_cert_chain()</span></code></a> instead, or let
<a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> select the system’s trusted CA
certificates for you.</p>
</div>
</dd>