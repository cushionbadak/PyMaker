link:
library/ast.html#ast-helpers

docs:

ast Helpers¶
Apart from the node classes, the ast module defines these utility functions
and classes for traversing abstract syntax trees:


ast.parse(source, filename='<unknown>', mode='exec')¶
Parse the source into an AST node.  Equivalent to compile(source,
filename, mode, ast.PyCF_ONLY_AST).

Warning
It is possible to crash the Python interpreter with a
sufficiently large/complex string due to stack depth limitations
in Python’s AST compiler.




ast.literal_eval(node_or_string)¶
Safely evaluate an expression node or a string containing a Python literal or
container display.  The string or node provided may only consist of the
following Python literal structures: strings, bytes, numbers, tuples, lists,
dicts, sets, booleans, and None.
This can be used for safely evaluating strings containing Python values from
untrusted sources without the need to parse the values oneself.  It is not
capable of evaluating arbitrarily complex expressions, for example involving
operators or indexing.

Warning
It is possible to crash the Python interpreter with a
sufficiently large/complex string due to stack depth limitations
in Python’s AST compiler.


Changed in version 3.2: Now allows bytes and set literals.




ast.get_docstring(node, clean=True)¶
Return the docstring of the given node (which must be a
FunctionDef, AsyncFunctionDef, ClassDef,
or Module node), or None if it has no docstring.
If clean is true, clean up the docstring’s indentation with
inspect.cleandoc().

Changed in version 3.5: AsyncFunctionDef is now supported.




ast.fix_missing_locations(node)¶
When you compile a node tree with compile(), the compiler expects
lineno and col_offset attributes for every node that supports
them.  This is rather tedious to fill in for generated nodes, so this helper
adds these attributes recursively where not already set, by setting them to
the values of the parent node.  It works recursively starting at node.



ast.increment_lineno(node, n=1)¶
Increment the line number of each node in the tree starting at node by n.
This is useful to “move code” to a different location in a file.



ast.copy_location(new_node, old_node)¶
Copy source location (lineno and col_offset) from old_node
to new_node if possible, and return new_node.



ast.iter_fields(node)¶
Yield a tuple of (fieldname, value) for each field in node._fields
that is present on node.



ast.iter_child_nodes(node)¶
Yield all direct child nodes of node, that is, all fields that are nodes
and all items of fields that are lists of nodes.



ast.walk(node)¶
Recursively yield all descendant nodes in the tree starting at node
(including node itself), in no specified order.  This is useful if you only
want to modify nodes in place and don’t care about the context.



class ast.NodeVisitor¶
A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.  This function may return a value
which is forwarded by the visit() method.
This class is meant to be subclassed, with the subclass adding visitor
methods.


visit(node)¶
Visit a node.  The default implementation calls the method called
self.visit_classname where classname is the name of the node
class, or generic_visit() if that method doesn’t exist.



generic_visit(node)¶
This visitor calls visit() on all children of the node.
Note that child nodes of nodes that have a custom visitor method won’t be
visited unless the visitor calls generic_visit() or visits them
itself.

Don’t use the NodeVisitor if you want to apply changes to nodes
during traversal.  For this a special visitor exists
(NodeTransformer) that allows modifications.



class ast.NodeTransformer¶
A NodeVisitor subclass that walks the abstract syntax tree and
allows modification of nodes.
The NodeTransformer will walk the AST and use the return value of
the visitor methods to replace or remove the old node.  If the return value
of the visitor method is None, the node will be removed from its
location, otherwise it is replaced with the return value.  The return value
may be the original node in which case no replacement takes place.
Here is an example transformer that rewrites all occurrences of name lookups
(foo) to data['foo']:
class RewriteName(NodeTransformer):

    def visit_Name(self, node):
        return copy_location(Subscript(
            value=Name(id='data', ctx=Load()),
            slice=Index(value=Str(s=node.id)),
            ctx=node.ctx
        ), node)


Keep in mind that if the node you’re operating on has child nodes you must
either transform the child nodes yourself or call the generic_visit()
method for the node first.
For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.
Usually you use the transformer like this:
node = YourTransformer().visit(node)





ast.dump(node, annotate_fields=True, include_attributes=False)¶
Return a formatted dump of the tree in node.  This is mainly useful for
debugging purposes.  The returned string will show the names and the values
for fields.  This makes the code impossible to evaluate, so if evaluation is
wanted annotate_fields must be set to False.  Attributes such as line
numbers and column offsets are not dumped by default.  If this is wanted,
include_attributes can be set to True.


See also
Green Tree Snakes, an external documentation resource, has good
details on working with Python ASTs.

