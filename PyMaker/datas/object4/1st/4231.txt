link:
library/threading.html#threading.Barrier

docs:

<dt id="threading.Barrier">
<em class="property">class </em><code class="descclassname">threading.</code><code class="descname">Barrier</code><span class="sig-paren">(</span><em>parties</em>, <em>action=None</em>, <em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a barrier object for <em>parties</em> number of threads.  An <em>action</em>, when
provided, is a callable to be called by one of the threads when they are
released.  <em>timeout</em> is the default timeout value if none is specified for
the <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p>
<dl class="method">
<dt id="threading.Barrier.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass the barrier.  When all the threads party to the barrier have called
this function, they are all released simultaneously.  If a <em>timeout</em> is
provided, it is used in preference to any that was supplied to the class
constructor.</p>
<p>The return value is an integer in the range 0 to <em>parties</em> – 1, different
for each thread.  This can be used to select a thread to do some special
housekeeping, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">barrier</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># Only one thread needs to print this</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"passed the barrier"</span><span class="p">)</span>
</pre></div>
</div>
<p>If an <em>action</em> was provided to the constructor, one of the threads will
have called it prior to being released.  Should this call raise an error,
the barrier is put into the broken state.</p>
<p>If the call times out, the barrier is put into the broken state.</p>
<p>This method may raise a <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a> exception if the
barrier is broken or reset while a thread is waiting.</p>
</dd></dl>
<dl class="method">
<dt id="threading.Barrier.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the barrier to the default, empty state.  Any threads waiting on it
will receive the <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a> exception.</p>
<p>Note that using this function may can require some external
synchronization if there are other threads whose state is unknown.  If a
barrier is broken it may be better to just leave it and create a new one.</p>
</dd></dl>
<dl class="method">
<dt id="threading.Barrier.abort">
<code class="descname">abort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#threading.Barrier.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Put the barrier into a broken state.  This causes any active or future
calls to <a class="reference internal" href="#threading.Barrier.wait" title="threading.Barrier.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> to fail with the <a class="reference internal" href="#threading.BrokenBarrierError" title="threading.BrokenBarrierError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BrokenBarrierError</span></code></a>.  Use
this for example if one of the needs to abort, to avoid deadlocking the
application.</p>
<p>It may be preferable to simply create the barrier with a sensible
<em>timeout</em> value to automatically guard against one of the threads going
awry.</p>
</dd></dl>
<dl class="attribute">
<dt id="threading.Barrier.parties">
<code class="descname">parties</code><a class="headerlink" href="#threading.Barrier.parties" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of threads required to pass the barrier.</p>
</dd></dl>
<dl class="attribute">
<dt id="threading.Barrier.n_waiting">
<code class="descname">n_waiting</code><a class="headerlink" href="#threading.Barrier.n_waiting" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of threads currently waiting in the barrier.</p>
</dd></dl>
<dl class="attribute">
<dt id="threading.Barrier.broken">
<code class="descname">broken</code><a class="headerlink" href="#threading.Barrier.broken" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean that is <code class="docutils literal notranslate"><span class="pre">True</span></code> if the barrier is in the broken state.</p>
</dd></dl>
</dd>