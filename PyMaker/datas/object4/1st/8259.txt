link:
library/typing.html#user-defined-generic-types

docs:

User-defined generic typesÂ¶
A user-defined class can be defined as a generic class.
from typing import TypeVar, Generic
from logging import Logger

T = TypeVar('T')

class LoggedVar(Generic[T]):
    def __init__(self, value: T, name: str, logger: Logger) -> None:
        self.name = name
        self.logger = logger
        self.value = value

    def set(self, new: T) -> None:
        self.log('Set ' + repr(self.value))
        self.value = new

    def get(self) -> T:
        self.log('Get ' + repr(self.value))
        return self.value

    def log(self, message: str) -> None:
        self.logger.info('%s: %s', self.name, message)


Generic[T] as a base class defines that the class LoggedVar takes a
single type parameter T . This also makes T valid as a type within the
class body.
The Generic base class uses a metaclass that defines
__getitem__() so that LoggedVar[t] is valid as a type:
from typing import Iterable

def zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:
    for var in vars:
        var.set(0)


A generic type can have any number of type variables, and type variables may
be constrained:
from typing import TypeVar, Generic
...

T = TypeVar('T')
S = TypeVar('S', int, str)

class StrangePair(Generic[T, S]):
    ...


Each type variable argument to Generic must be distinct.
This is thus invalid:
from typing import TypeVar, Generic
...

T = TypeVar('T')

class Pair(Generic[T, T]):   # INVALID
    ...


You can use multiple inheritance with Generic:
from typing import TypeVar, Generic, Sized

T = TypeVar('T')

class LinkedList(Sized, Generic[T]):
    ...


When inheriting from generic classes, some type variables could be fixed:
from typing import TypeVar, Mapping

T = TypeVar('T')

class MyDict(Mapping[str, T]):
    ...


In this case MyDict has a single parameter, T.
Using a generic class without specifying type parameters assumes
Any for each position. In the following example, MyIterable is
not generic but implicitly inherits from Iterable[Any]:
from typing import Iterable

class MyIterable(Iterable): # Same as Iterable[Any]


User defined generic type aliases are also supported. Examples:
from typing import TypeVar, Iterable, Tuple, Union
S = TypeVar('S')
Response = Union[Iterable[S], int]

# Return type here is same as Union[Iterable[str], int]
def response(query: str) -> Response[str]:
    ...

T = TypeVar('T', int, float, complex)
Vec = Iterable[Tuple[T, T]]

def inproduct(v: Vec[T]) -> T: # Same as Iterable[Tuple[T, T]]
    return sum(x*y for x, y in v)


The metaclass used by Generic is a subclass of abc.ABCMeta.
A generic class can be an ABC by including abstract methods or properties,
and generic classes can also have ABCs as base classes without a metaclass
conflict. Generic metaclasses are not supported. The outcome of parameterizing
generics is cached, and most types in the typing module are hashable and
comparable for equality.
