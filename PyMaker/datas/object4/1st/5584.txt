link:
library/email.policy.html#email.policy.EmailPolicy

docs:

<dt id="email.policy.EmailPolicy">
<em class="property">class </em><code class="descclassname">email.policy.</code><code class="descname">EmailPolicy</code><span class="sig-paren">(</span><em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy" title="Permalink to this definition">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a> provides behavior that is intended to be fully
compliant with the current email RFCs.  These include (but are not limited
to) <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>, and the current MIME RFCs.</p>
<p>This policy adds new header parsing and folding algorithms.  Instead of
simple strings, headers are <code class="docutils literal notranslate"><span class="pre">str</span></code> subclasses with attributes that depend
on the type of the field.  The parsing and folding algorithm fully implement
<span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> and <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.</p>
<p>The default value for the <a class="reference internal" href="#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code class="xref py py-attr docutils literal notranslate"><span class="pre">message_factory</span></code></a>
attribute is <a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>.</p>
<p>In addition to the settable attributes listed above that apply to all
policies, this policy adds the following additional attributes:</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.6: </span><a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
</div>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.utf8">
<code class="descname">utf8</code><a class="headerlink" href="#email.policy.EmailPolicy.utf8" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, follow <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, supporting non-ASCII characters in
headers by encoding them as “encoded words”.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>, follow
<span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html"><strong>RFC 6532</strong></a> and use <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> encoding for headers.  Messages
formatted in this way may be passed to SMTP servers that support
the <code class="docutils literal notranslate"><span class="pre">SMTPUTF8</span></code> extension (<span class="target" id="index-8"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html"><strong>RFC 6531</strong></a>).</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.refold_source">
<code class="descname">refold_source</code><a class="headerlink" href="#email.policy.EmailPolicy.refold_source" title="Permalink to this definition">¶</a></dt>
<dd><p>If the value for a header in the <code class="docutils literal notranslate"><span class="pre">Message</span></code> object originated from a
<a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">parser</span></code></a> (as opposed to being set by a program), this
attribute indicates whether or not a generator should refold that value
when transforming the message back into serialized form.  The possible
values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%"/>
<col width="89%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">none</span></code></td>
<td>all source values use original folding</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">long</span></code></td>
<td>source values that have any line that is longer than
<code class="docutils literal notranslate"><span class="pre">max_line_length</span></code> will be refolded</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">all</span></code></td>
<td>all values are refolded.</td>
</tr>
</tbody>
</table>
<p>The default is <code class="docutils literal notranslate"><span class="pre">long</span></code>.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.header_factory">
<code class="descname">header_factory</code><a class="headerlink" href="#email.policy.EmailPolicy.header_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A callable that takes two arguments, <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>, where
<code class="docutils literal notranslate"><span class="pre">name</span></code> is a header field name and <code class="docutils literal notranslate"><span class="pre">value</span></code> is an unfolded header field
value, and returns a string subclass that represents that header.  A
default <code class="docutils literal notranslate"><span class="pre">header_factory</span></code> (see <a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><code class="xref py py-mod docutils literal notranslate"><span class="pre">headerregistry</span></code></a>) is provided
that supports custom parsing for the various address and date <span class="target" id="index-9"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
header field types, and the major MIME header field stypes.  Support for
additional custom parsing will be added in the future.</p>
</dd></dl>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.content_manager">
<code class="descname">content_manager</code><a class="headerlink" href="#email.policy.EmailPolicy.content_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>An object with at least two methods: get_content and set_content.  When
the <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> or
<a class="reference internal" href="email.message.html#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_content()</span></code></a> method of an
<a class="reference internal" href="email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> object is called, it calls the
corresponding method of this object, passing it the message object as its
first argument, and any arguments or keywords that were passed to it as
additional arguments.  By default <code class="docutils literal notranslate"><span class="pre">content_manager</span></code> is set to
<a class="reference internal" href="email.contentmanager.html#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><code class="xref py py-data docutils literal notranslate"><span class="pre">raw_data_manager</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.</span></p>
</div>
</dd></dl>
<p>The class provides the following concrete implementations of the abstract
methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Policy</span></code></a>:</p>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_max_count">
<code class="descname">header_max_count</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_max_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the
<a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_count</span></code></a> attribute of the
specialized class used to represent the header with the given name.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_source_parse">
<code class="descname">header_source_parse</code><span class="sig-paren">(</span><em>sourcelines</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_source_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The name is parsed as everything up to the ‘<code class="docutils literal notranslate"><span class="pre">:</span></code>’ and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_store_parse">
<code class="descname">header_store_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_store_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The name is returned unchanged.  If the input value has a <code class="docutils literal notranslate"><span class="pre">name</span></code>
attribute and it matches <em>name</em> ignoring case, the value is returned
unchanged.  Otherwise the <em>name</em> and <em>value</em> are passed to
<code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting header object is returned as
the value.  In this case a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> is raised if the input value
contains CR or LF characters.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_fetch_parse">
<code class="descname">header_fetch_parse</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.header_fetch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>If the value has a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute, it is returned to unmodified.
Otherwise the <em>name</em>, and the <em>value</em> with any CR or LF characters
removed, are passed to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>, and the resulting
header object is returned.  Any surrogateescaped bytes get turned into
the unicode unknown-character glyph.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.EmailPolicy.fold">
<code class="descname">fold</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Header folding is controlled by the <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><code class="xref py py-attr docutils literal notranslate"><span class="pre">refold_source</span></code></a> policy setting.
A value is considered to be a ‘source value’ if and only if it does not
have a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute (having a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute means it is a
header object of some sort).  If a source value needs to be refolded
according to the policy, it is converted into a header object by
passing the <em>name</em> and the <em>value</em> with any CR and LF characters removed
to the <code class="docutils literal notranslate"><span class="pre">header_factory</span></code>.  Folding of a header object is done by
calling its <code class="docutils literal notranslate"><span class="pre">fold</span></code> method with the current policy.</p>
<p>Source values are split into lines using <a class="reference internal" href="stdtypes.html#str.splitlines" title="str.splitlines"><code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code></a>.  If
the value is not to be refolded, the lines are rejoined using the
<code class="docutils literal notranslate"><span class="pre">linesep</span></code> from the policy and returned.  The exception is lines
containing non-ascii binary data.  In that case the value is refolded
regardless of the <code class="docutils literal notranslate"><span class="pre">refold_source</span></code> setting, which causes the binary data
to be CTE encoded using the <code class="docutils literal notranslate"><span class="pre">unknown-8bit</span></code> charset.</p>
</dd></dl>
<dl class="method">
<dt id="email.policy.EmailPolicy.fold_binary">
<code class="descname">fold_binary</code><span class="sig-paren">(</span><em>name</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#email.policy.EmailPolicy.fold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fold()</span></code></a> if <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">7bit</span></code>, except
that the returned value is bytes.</p>
<p>If <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cte_type</span></code></a> is <code class="docutils literal notranslate"><span class="pre">8bit</span></code>, non-ASCII binary data is
converted back
into bytes.  Headers with binary data are not refolded, regardless of the
<code class="docutils literal notranslate"><span class="pre">refold_header</span></code> setting, since there is no way to know whether the
binary data consists of single byte characters or multibyte characters.</p>
</dd></dl>
</dd>