link:
library/email.policy.html#email.policy.EmailPolicy

docs:


class email.policy.EmailPolicy(**kw)¶
This concrete Policy provides behavior that is intended to be fully
compliant with the current email RFCs.  These include (but are not limited
to) RFC 5322, RFC 2047, and the current MIME RFCs.
This policy adds new header parsing and folding algorithms.  Instead of
simple strings, headers are str subclasses with attributes that depend
on the type of the field.  The parsing and folding algorithm fully implement
RFC 2047 and RFC 5322.
The default value for the message_factory
attribute is EmailMessage.
In addition to the settable attributes listed above that apply to all
policies, this policy adds the following additional attributes:

New in version 3.6: [1]



utf8¶
If False, follow RFC 5322, supporting non-ASCII characters in
headers by encoding them as “encoded words”.  If True, follow
RFC 6532 and use utf-8 encoding for headers.  Messages
formatted in this way may be passed to SMTP servers that support
the SMTPUTF8 extension (RFC 6531).



refold_source¶
If the value for a header in the Message object originated from a
parser (as opposed to being set by a program), this
attribute indicates whether or not a generator should refold that value
when transforming the message back into serialized form.  The possible
values are:






none
all source values use original folding

long
source values that have any line that is longer than
max_line_length will be refolded

all
all values are refolded.



The default is long.



header_factory¶
A callable that takes two arguments, name and value, where
name is a header field name and value is an unfolded header field
value, and returns a string subclass that represents that header.  A
default header_factory (see headerregistry) is provided
that supports custom parsing for the various address and date RFC 5322
header field types, and the major MIME header field stypes.  Support for
additional custom parsing will be added in the future.



content_manager¶
An object with at least two methods: get_content and set_content.  When
the get_content() or
set_content() method of an
EmailMessage object is called, it calls the
corresponding method of this object, passing it the message object as its
first argument, and any arguments or keywords that were passed to it as
additional arguments.  By default content_manager is set to
raw_data_manager.

New in version 3.4.


The class provides the following concrete implementations of the abstract
methods of Policy:


header_max_count(name)¶
Returns the value of the
max_count attribute of the
specialized class used to represent the header with the given name.



header_source_parse(sourcelines)¶
The name is parsed as everything up to the ‘:’ and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.



header_store_parse(name, value)¶
The name is returned unchanged.  If the input value has a name
attribute and it matches name ignoring case, the value is returned
unchanged.  Otherwise the name and value are passed to
header_factory, and the resulting header object is returned as
the value.  In this case a ValueError is raised if the input value
contains CR or LF characters.



header_fetch_parse(name, value)¶
If the value has a name attribute, it is returned to unmodified.
Otherwise the name, and the value with any CR or LF characters
removed, are passed to the header_factory, and the resulting
header object is returned.  Any surrogateescaped bytes get turned into
the unicode unknown-character glyph.



fold(name, value)¶
Header folding is controlled by the refold_source policy setting.
A value is considered to be a ‘source value’ if and only if it does not
have a name attribute (having a name attribute means it is a
header object of some sort).  If a source value needs to be refolded
according to the policy, it is converted into a header object by
passing the name and the value with any CR and LF characters removed
to the header_factory.  Folding of a header object is done by
calling its fold method with the current policy.
Source values are split into lines using splitlines().  If
the value is not to be refolded, the lines are rejoined using the
linesep from the policy and returned.  The exception is lines
containing non-ascii binary data.  In that case the value is refolded
regardless of the refold_source setting, which causes the binary data
to be CTE encoded using the unknown-8bit charset.



fold_binary(name, value)¶
The same as fold() if cte_type is 7bit, except
that the returned value is bytes.
If cte_type is 8bit, non-ASCII binary data is
converted back
into bytes.  Headers with binary data are not refolded, regardless of the
refold_header setting, since there is no way to know whether the
binary data consists of single byte characters or multibyte characters.

