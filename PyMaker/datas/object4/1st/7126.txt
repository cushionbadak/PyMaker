link:
library/socketserver.html#server-creation-notes

docs:

Server Creation Notes¶
There are five classes in an inheritance diagram, four of which represent
synchronous servers of four types:
+------------+
| BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |------->| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |------->| UnixDatagramServer |
+-----------+        +--------------------+


Note that UnixDatagramServer derives from UDPServer, not from
UnixStreamServer — the only difference between an IP and a Unix
stream server is the address family, which is simply repeated in both Unix
server classes.


class socketserver.ForkingMixIn¶

class socketserver.ThreadingMixIn¶
Forking and threading versions of each type of server can be created
using these mix-in classes.  For instance, ThreadingUDPServer
is created as follows:
class ThreadingUDPServer(ThreadingMixIn, UDPServer):
    pass


The mix-in class comes first, since it overrides a method defined in
UDPServer.  Setting the various attributes also changes the
behavior of the underlying server mechanism.
ForkingMixIn and the Forking classes mentioned below are
only available on POSIX platforms that support fork().
socketserver.ForkingMixIn.server_close() waits until all child
processes complete, except if
socketserver.ForkingMixIn.block_on_close attribute is false.
socketserver.ThreadingMixIn.server_close() waits until all non-daemon
threads complete, except if
socketserver.ThreadingMixIn.block_on_close attribute is false. Use
daemonic threads by setting
ThreadingMixIn.daemon_threads to True to not wait until threads
complete.

Changed in version 3.7: socketserver.ForkingMixIn.server_close() and
socketserver.ThreadingMixIn.server_close() now waits until all
child processes and non-daemonic threads complete.
Add a new socketserver.ForkingMixIn.block_on_close class
attribute to opt-in for the pre-3.7 behaviour.




class socketserver.ForkingTCPServer¶

class socketserver.ForkingUDPServer¶

class socketserver.ThreadingTCPServer¶

class socketserver.ThreadingUDPServer¶
These classes are pre-defined using the mix-in classes.

To implement a service, you must derive a class from BaseRequestHandler
and redefine its handle() method.
You can then run various versions of
the service by combining one of the server classes with your request handler
class.  The request handler class must be different for datagram or stream
services.  This can be hidden by using the handler subclasses
StreamRequestHandler or DatagramRequestHandler.
Of course, you still have to use your head!  For instance, it makes no sense to
use a forking server if the service contains state in memory that can be
modified by different requests, since the modifications in the child process
would never reach the initial state kept in the parent process and passed to
each child.  In this case, you can use a threading server, but you will probably
have to use locks to protect the integrity of the shared data.
On the other hand, if you are building an HTTP server where all data is stored
externally (for instance, in the file system), a synchronous class will
essentially render the service “deaf” while one request is being handled –
which may be for a very long time if a client is slow to receive all the data it
has requested.  Here a threading or forking server is appropriate.
In some cases, it may be appropriate to process part of a request synchronously,
but to finish processing in a forked child depending on the request data.  This
can be implemented by using a synchronous server and doing an explicit fork in
the request handler class handle() method.
Another approach to handling multiple simultaneous requests in an environment
that supports neither threads nor fork() (or where these are too
expensive or inappropriate for the service) is to maintain an explicit table of
partially finished requests and to use selectors to decide which
request to work on next (or whether to handle a new incoming request).  This is
particularly important for stream services where each client can potentially be
connected for a long time (if threads or subprocesses cannot be used).  See
asyncore for another way to manage this.
