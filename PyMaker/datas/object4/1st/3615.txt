link:
library/logging.handlers.html#logging.handlers.SocketHandler

docs:

<dt id="logging.handlers.SocketHandler">
<em class="property">class </em><code class="descclassname">logging.handlers.</code><code class="descname">SocketHandler</code><span class="sig-paren">(</span><em>host</em>, <em>port</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new instance of the <a class="reference internal" href="#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> class intended to
communicate with a remote machine whose address is given by <em>host</em> and <em>port</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.4: </span>If <code class="docutils literal notranslate"><span class="pre">port</span></code> is specified as <code class="docutils literal notranslate"><span class="pre">None</span></code>, a Unix domain socket is created
using the value in <code class="docutils literal notranslate"><span class="pre">host</span></code> - otherwise, a TCP socket is created.</p>
</div>
<dl class="method">
<dt id="logging.handlers.SocketHandler.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the socket.</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.emit">
<code class="descname">emit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.emit" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickles the record’s attribute dictionary and writes it to the socket in
binary format. If there is an error with the socket, silently drops the
packet. If the connection was previously lost, re-establishes the
connection. To unpickle the record at the receiving end into a
<a class="reference internal" href="logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a>, use the <a class="reference internal" href="logging.html#logging.makeLogRecord" title="logging.makeLogRecord"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeLogRecord()</span></code></a>
function.</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.handleError">
<code class="descname">handleError</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.handleError" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles an error which has occurred during <a class="reference internal" href="#logging.handlers.SocketHandler.emit" title="logging.handlers.SocketHandler.emit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code></a>. The most likely
cause is a lost connection. Closes the socket so that we can retry on the
next event.</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.makeSocket">
<code class="descname">makeSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makeSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a factory method which allows subclasses to define the precise
type of socket they want. The default implementation creates a TCP socket
(<a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a>).</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.makePickle">
<code class="descname">makePickle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.makePickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickles the record’s attribute dictionary in binary format with a length
prefix, and returns it ready for transmission across the socket.</p>
<p>Note that pickles aren’t completely secure. If you are concerned about
security, you may want to override this method to implement a more secure
mechanism. For example, you can sign pickles using HMAC and then verify
them on the receiving end, or alternatively you can disable unpickling of
global objects on the receiving end.</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>packet</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a pickled string <em>packet</em> to the socket. This function allows for
partial sends which can happen when the network is busy.</p>
</dd></dl>
<dl class="method">
<dt id="logging.handlers.SocketHandler.createSocket">
<code class="descname">createSocket</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.handlers.SocketHandler.createSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to create a socket; on failure, uses an exponential back-off
algorithm.  On initial failure, the handler will drop the message it was
trying to send.  When subsequent messages are handled by the same
instance, it will not try connecting until some time has passed.  The
default parameters are such that the initial delay is one second, and if
after that delay the connection still can’t be made, the handler will
double the delay each time up to a maximum of 30 seconds.</p>
<p>This behaviour is controlled by the following handler attributes:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">retryStart</span></code> (initial delay, defaulting to 1.0 seconds).</li>
<li><code class="docutils literal notranslate"><span class="pre">retryFactor</span></code> (multiplier, defaulting to 2.0).</li>
<li><code class="docutils literal notranslate"><span class="pre">retryMax</span></code> (maximum delay, defaulting to 30.0 seconds).</li>
</ul>
<p>This means that if the remote listener starts up <em>after</em> the handler has
been used, you could lose messages (since the handler won’t even attempt
a connection until the delay has elapsed, but just silently drop messages
during the delay period).</p>
</dd></dl>
</dd>