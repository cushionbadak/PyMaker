link:
library/importlib.html#module-importlib.abc

docs:

importlib.abc – Abstract base classes related to import¶
Source code: Lib/importlib/abc.py

The importlib.abc module contains all of the core abstract base classes
used by import. Some subclasses of the core abstract base classes
are also provided to help in implementing the core ABCs.
ABC hierarchy:
object
 +-- Finder (deprecated)
 |    +-- MetaPathFinder
 |    +-- PathEntryFinder
 +-- Loader
      +-- ResourceLoader --------+
      +-- InspectLoader          |
           +-- ExecutionLoader --+
                                 +-- FileLoader
                                 +-- SourceLoader




class importlib.abc.Finder¶
An abstract base class representing a finder.

Deprecated since version 3.3: Use MetaPathFinder or PathEntryFinder instead.



abstractmethod find_module(fullname, path=None)¶
An abstract method for finding a loader for the specified
module.  Originally specified in PEP 302, this method was meant
for use in sys.meta_path and in the path-based import subsystem.

Changed in version 3.4: Returns None when called instead of raising
NotImplementedError.





class importlib.abc.MetaPathFinder¶
An abstract base class representing a meta path finder. For
compatibility, this is a subclass of Finder.

New in version 3.3.



find_spec(fullname, path, target=None)¶
An abstract method for finding a spec for
the specified module.  If this is a top-level import, path will
be None.  Otherwise, this is a search for a subpackage or
module and path will be the value of __path__ from the
parent package. If a spec cannot be found, None is returned.
When passed in, target is a module object that the finder may
use to make a more educated guess about what spec to return.

New in version 3.4.




find_module(fullname, path)¶
A legacy method for finding a loader for the specified
module.  If this is a top-level import, path will be None.
Otherwise, this is a search for a subpackage or module and path
will be the value of __path__ from the parent
package. If a loader cannot be found, None is returned.
If find_spec() is defined, backwards-compatible functionality is
provided.

Changed in version 3.4: Returns None when called instead of raising
NotImplementedError. Can use find_spec() to provide
functionality.


Deprecated since version 3.4: Use find_spec() instead.




invalidate_caches()¶
An optional method which, when called, should invalidate any internal
cache used by the finder. Used by importlib.invalidate_caches()
when invalidating the caches of all finders on sys.meta_path.

Changed in version 3.4: Returns None when called instead of NotImplemented.





class importlib.abc.PathEntryFinder¶
An abstract base class representing a path entry finder.  Though
it bears some similarities to MetaPathFinder, PathEntryFinder
is meant for use only within the path-based import subsystem provided
by PathFinder. This ABC is a subclass of Finder for
compatibility reasons only.

New in version 3.3.



find_spec(fullname, target=None)¶
An abstract method for finding a spec for
the specified module.  The finder will search for the module only
within the path entry to which it is assigned.  If a spec
cannot be found, None is returned.  When passed in, target
is a module object that the finder may use to make a more educated
guess about what spec to return.

New in version 3.4.




find_loader(fullname)¶
A legacy method for finding a loader for the specified
module.  Returns a 2-tuple of (loader, portion) where portion
is a sequence of file system locations contributing to part of a namespace
package. The loader may be None while specifying portion to
signify the contribution of the file system locations to a namespace
package. An empty list can be used for portion to signify the loader
is not part of a namespace package. If loader is None and
portion is the empty list then no loader or location for a namespace
package were found (i.e. failure to find anything for the module).
If find_spec() is defined then backwards-compatible functionality is
provided.

Changed in version 3.4: Returns (None, []) instead of raising NotImplementedError.
Uses find_spec() when available to provide functionality.


Deprecated since version 3.4: Use find_spec() instead.




find_module(fullname)¶
A concrete implementation of Finder.find_module() which is
equivalent to self.find_loader(fullname)[0].

Deprecated since version 3.4: Use find_spec() instead.




invalidate_caches()¶
An optional method which, when called, should invalidate any internal
cache used by the finder. Used by PathFinder.invalidate_caches()
when invalidating the caches of all cached finders.




class importlib.abc.Loader¶
An abstract base class for a loader.
See PEP 302 for the exact definition for a loader.
Loaders that wish to support resource reading should implement a
get_resource_reader(fullname) method as specified by
importlib.abc.ResourceReader.

Changed in version 3.7: Introduced the optional get_resource_reader() method.



create_module(spec)¶
A method that returns the module object to use when
importing a module.  This method may return None,
indicating that default module creation semantics should take place.

New in version 3.4.


Changed in version 3.5: Starting in Python 3.6, this method will not be optional when
exec_module() is defined.




exec_module(module)¶
An abstract method that executes the module in its own namespace
when a module is imported or reloaded.  The module should already
be initialized when exec_module() is called. When this method exists,
create_module() must be defined.

New in version 3.4.


Changed in version 3.6: create_module() must also be defined.




load_module(fullname)¶
A legacy method for loading a module. If the module cannot be
loaded, ImportError is raised, otherwise the loaded module is
returned.
If the requested module already exists in sys.modules, that
module should be used and reloaded.
Otherwise the loader should create a new module and insert it into
sys.modules before any loading begins, to prevent recursion
from the import. If the loader inserted a module and the load fails, it
must be removed by the loader from sys.modules; modules already
in sys.modules before the loader began execution should be left
alone (see importlib.util.module_for_loader()).
The loader should set several attributes on the module.
(Note that some of these attributes can change when a module is
reloaded):


__name__
The name of the module.



__file__
The path to where the module data is stored (not set for built-in
modules).



__cached__
The path to where a compiled version of the module is/should be
stored (not set when the attribute would be inappropriate).



__path__
A list of strings specifying the search path within a
package. This attribute is not set on modules.



__package__
The parent package for the module/package. If the module is
top-level then it has a value of the empty string. The
importlib.util.module_for_loader() decorator can handle the
details for __package__.



__loader__
The loader used to load the module. The
importlib.util.module_for_loader() decorator can handle the
details for __package__.



When exec_module() is available then backwards-compatible
functionality is provided.

Changed in version 3.4: Raise ImportError when called instead of
NotImplementedError. Functionality provided when
exec_module() is available.


Deprecated since version 3.4: The recommended API for loading a module is exec_module()
(and create_module()).  Loaders should implement
it instead of load_module().  The import machinery takes care of
all the other responsibilities of load_module() when exec_module()
is implemented.




module_repr(module)¶
A legacy method which when implemented calculates and returns the
given module’s repr, as a string. The module type’s default repr() will
use the result of this method as appropriate.

New in version 3.3.


Changed in version 3.4: Made optional instead of an abstractmethod.


Deprecated since version 3.4: The import machinery now takes care of this automatically.





class importlib.abc.ResourceReader¶
An abstract base class to provide the ability to read
resources.
From the perspective of this ABC, a resource is a binary
artifact that is shipped within a package. Typically this is
something like a data file that lives next to the __init__.py
file of the package. The purpose of this class is to help abstract
out the accessing of such data files so that it does not matter if
the package and its data file(s) are stored in a e.g. zip file
versus on the file system.
For any of methods of this class, a resource argument is
expected to be a path-like object which represents
conceptually just a file name. This means that no subdirectory
paths should be included in the resource argument. This is
because the location of the package the reader is for, acts as the
“directory”. Hence the metaphor for directories and file
names is packages and resources, respectively. This is also why
instances of this class are expected to directly correlate to
a specific package (instead of potentially representing multiple
packages or a module).
Loaders that wish to support resource reading are expected to
provide a method called get_resource_loader(fullname) which
returns an object implementing this ABC’s interface. If the module
specified by fullname is not a package, this method should return
None. An object compatible with this ABC should only be
returned when the specified module is a package.

New in version 3.7.



abstractmethod open_resource(resource)¶
Returns an opened, file-like object for binary reading
of the resource.
If the resource cannot be found, FileNotFoundError is
raised.



abstractmethod resource_path(resource)¶
Returns the file system path to the resource.
If the resource does not concretely exist on the file system,
raise FileNotFoundError.



abstractmethod is_resource(name)¶
Returns True if the named name is considered a resource.
FileNotFoundError is raised if name does not exist.



abstractmethod contents()¶
Returns an iterable of strings over the contents of
the package. Do note that it is not required that all names
returned by the iterator be actual resources, e.g. it is
acceptable to return names for which is_resource() would
be false.
Allowing non-resource names to be returned is to allow for
situations where how a package and its resources are stored
are known a priori and the non-resource names would be useful.
For instance, returning subdirectory names is allowed so that
when it is known that the package and resources are stored on
the file system then those subdirectory names can be used
directly.
The abstract method returns an iterable of no items.




class importlib.abc.ResourceLoader¶
An abstract base class for a loader which implements the optional
PEP 302 protocol for loading arbitrary resources from the storage
back-end.

Deprecated since version 3.7: This ABC is deprecated in favour of supporting resource loading
through importlib.abc.ResourceReader.



abstractmethod get_data(path)¶
An abstract method to return the bytes for the data located at path.
Loaders that have a file-like storage back-end
that allows storing arbitrary data
can implement this abstract method to give direct access
to the data stored. OSError is to be raised if the path cannot
be found. The path is expected to be constructed using a module’s
__file__ attribute or an item from a package’s __path__.

Changed in version 3.4: Raises OSError instead of NotImplementedError.





class importlib.abc.InspectLoader¶
An abstract base class for a loader which implements the optional
PEP 302 protocol for loaders that inspect modules.


get_code(fullname)¶
Return the code object for a module, or None if the module does not
have a code object (as would be the case, for example, for a built-in
module).  Raise an ImportError if loader cannot find the
requested module.

Note
While the method has a default implementation, it is suggested that
it be overridden if possible for performance.


Changed in version 3.4: No longer abstract and a concrete implementation is provided.




abstractmethod get_source(fullname)¶
An abstract method to return the source of a module. It is returned as
a text string using universal newlines, translating all
recognized line separators into '\n' characters.  Returns None
if no source is available (e.g. a built-in module). Raises
ImportError if the loader cannot find the module specified.

Changed in version 3.4: Raises ImportError instead of NotImplementedError.




is_package(fullname)¶
An abstract method to return a true value if the module is a package, a
false value otherwise. ImportError is raised if the
loader cannot find the module.

Changed in version 3.4: Raises ImportError instead of NotImplementedError.




static source_to_code(data, path='<string>')¶
Create a code object from Python source.
The data argument can be whatever the compile() function
supports (i.e. string or bytes). The path argument should be
the “path” to where the source code originated from, which can be an
abstract concept (e.g. location in a zip file).
With the subsequent code object one can execute it in a module by
running exec(code, module.__dict__).

New in version 3.4.


Changed in version 3.5: Made the method static.




exec_module(module)¶
Implementation of Loader.exec_module().

New in version 3.4.




load_module(fullname)¶
Implementation of Loader.load_module().

Deprecated since version 3.4: use exec_module() instead.





class importlib.abc.ExecutionLoader¶
An abstract base class which inherits from InspectLoader that,
when implemented, helps a module to be executed as a script. The ABC
represents an optional PEP 302 protocol.


abstractmethod get_filename(fullname)¶
An abstract method that is to return the value of __file__ for
the specified module. If no path is available, ImportError is
raised.
If source code is available, then the method should return the path to
the source file, regardless of whether a bytecode was used to load the
module.

Changed in version 3.4: Raises ImportError instead of NotImplementedError.





class importlib.abc.FileLoader(fullname, path)¶
An abstract base class which inherits from ResourceLoader and
ExecutionLoader, providing concrete implementations of
ResourceLoader.get_data() and ExecutionLoader.get_filename().
The fullname argument is a fully resolved name of the module the loader is
to handle. The path argument is the path to the file for the module.

New in version 3.3.



name¶
The name of the module the loader can handle.



path¶
Path to the file of the module.



load_module(fullname)¶
Calls super’s load_module().

Deprecated since version 3.4: Use Loader.exec_module() instead.




abstractmethod get_filename(fullname)¶
Returns path.



abstractmethod get_data(path)¶
Reads path as a binary file and returns the bytes from it.




class importlib.abc.SourceLoader¶
An abstract base class for implementing source (and optionally bytecode)
file loading. The class inherits from both ResourceLoader and
ExecutionLoader, requiring the implementation of:

ResourceLoader.get_data()

ExecutionLoader.get_filename()
Should only return the path to the source file; sourceless
loading is not supported.



The abstract methods defined by this class are to add optional bytecode
file support. Not implementing these optional methods (or causing them to
raise NotImplementedError) causes the loader to
only work with source code. Implementing the methods allows the loader to
work with source and bytecode files; it does not allow for sourceless
loading where only bytecode is provided.  Bytecode files are an
optimization to speed up loading by removing the parsing step of Python’s
compiler, and so no bytecode-specific API is exposed.


path_stats(path)¶
Optional abstract method which returns a dict containing
metadata about the specified path.  Supported dictionary keys are:

'mtime' (mandatory): an integer or floating-point number
representing the modification time of the source code;
'size' (optional): the size in bytes of the source code.

Any other keys in the dictionary are ignored, to allow for future
extensions. If the path cannot be handled, OSError is raised.

New in version 3.3.


Changed in version 3.4: Raise OSError instead of NotImplementedError.




path_mtime(path)¶
Optional abstract method which returns the modification time for the
specified path.

Deprecated since version 3.3: This method is deprecated in favour of path_stats().  You don’t
have to implement it, but it is still available for compatibility
purposes. Raise OSError if the path cannot be handled.


Changed in version 3.4: Raise OSError instead of NotImplementedError.




set_data(path, data)¶
Optional abstract method which writes the specified bytes to a file
path. Any intermediate directories which do not exist are to be created
automatically.
When writing to the path fails because the path is read-only
(errno.EACCES/PermissionError), do not propagate the
exception.

Changed in version 3.4: No longer raises NotImplementedError when called.




get_code(fullname)¶
Concrete implementation of InspectLoader.get_code().



exec_module(module)¶
Concrete implementation of Loader.exec_module().

New in version 3.4.




load_module(fullname)¶
Concrete implementation of Loader.load_module().

Deprecated since version 3.4: Use exec_module() instead.




get_source(fullname)¶
Concrete implementation of InspectLoader.get_source().



is_package(fullname)¶
Concrete implementation of InspectLoader.is_package(). A module
is determined to be a package if its file path (as provided by
ExecutionLoader.get_filename()) is a file named
__init__ when the file extension is removed and the module name
itself does not end in __init__.


