link:
library/doctest.html#how-it-works

docs:

How It Works¶
This section examines in detail how doctest works: which docstrings it looks at,
how it finds interactive examples, what execution context it uses, how it
handles exceptions, and how option flags can be used to control its behavior.
This is the information that you need to know to write doctest examples; for
information about actually running doctest on these examples, see the following
sections.

Which Docstrings Are Examined?¶
The module docstring, and all function, class and method docstrings are
searched.  Objects imported into the module are not searched.
In addition, if M.__test__ exists and “is true”, it must be a dict, and each
entry maps a (string) name to a function object, class object, or string.
Function and class object docstrings found from M.__test__ are searched, and
strings are treated as if they were docstrings.  In output, a key K in
M.__test__ appears with name
<name of M>.__test__.K


Any classes found are recursively searched similarly, to test docstrings in
their contained methods and nested classes.

CPython implementation detail: Prior to version 3.4, extension modules written in C were not fully
searched by doctest.



How are Docstring Examples Recognized?¶
In most cases a copy-and-paste of an interactive console session works fine,
but doctest isn’t trying to do an exact emulation of any specific Python shell.
>>> # comments are ignored
>>> x = 12
>>> x
12
>>> if x == 13:
...     print("yes")
... else:
...     print("no")
...     print("NO")
...     print("NO!!!")
...
no
NO
NO!!!
>>>


Any expected output must immediately follow the final '>>> ' or '... '
line containing the code, and the expected output (if any) extends to the next
'>>> ' or all-whitespace line.
The fine print:

Expected output cannot contain an all-whitespace line, since such a line is
taken to signal the end of expected output.  If expected output does contain a
blank line, put <BLANKLINE> in your doctest example each place a blank line
is expected.

All hard tab characters are expanded to spaces, using 8-column tab stops.
Tabs in output generated by the tested code are not modified.  Because any
hard tabs in the sample output are expanded, this means that if the code
output includes hard tabs, the only way the doctest can pass is if the
NORMALIZE_WHITESPACE option or directive
is in effect.
Alternatively, the test can be rewritten to capture the output and compare it
to an expected value as part of the test.  This handling of tabs in the
source was arrived at through trial and error, and has proven to be the least
error prone way of handling them.  It is possible to use a different
algorithm for handling tabs by writing a custom DocTestParser class.

Output to stdout is captured, but not output to stderr (exception tracebacks
are captured via a different means).

If you continue a line via backslashing in an interactive session, or for any
other reason use a backslash, you should use a raw docstring, which will
preserve your backslashes exactly as you type them:
>>> def f(x):
...     r'''Backslashes in a raw docstring: m\n'''
>>> print(f.__doc__)
Backslashes in a raw docstring: m\n


Otherwise, the backslash will be interpreted as part of the string. For example,
the \n above would be interpreted as a newline character.  Alternatively, you
can double each backslash in the doctest version (and not use a raw string):
>>> def f(x):
...     '''Backslashes in a raw docstring: m\\n'''
>>> print(f.__doc__)
Backslashes in a raw docstring: m\n



The starting column doesn’t matter:
>>> assert "Easy!"
      >>> import math
          >>> math.floor(1.9)
          1


and as many leading whitespace characters are stripped from the expected output
as appeared in the initial '>>> ' line that started the example.




What’s the Execution Context?¶
By default, each time doctest finds a docstring to test, it uses a
shallow copy of M’s globals, so that running tests doesn’t change the
module’s real globals, and so that one test in M can’t leave behind
crumbs that accidentally allow another test to work.  This means examples can
freely use any names defined at top-level in M, and names defined earlier
in the docstring being run. Examples cannot see names defined in other
docstrings.
You can force use of your own dict as the execution context by passing
globs=your_dict to testmod() or testfile() instead.


What About Exceptions?¶
No problem, provided that the traceback is the only output produced by the
example:  just paste in the traceback. [1] Since tracebacks contain details
that are likely to change rapidly (for example, exact file paths and line
numbers), this is one case where doctest works hard to be flexible in what it
accepts.
Simple example:
>>> [1, 2, 3].remove(42)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list


That doctest succeeds if ValueError is raised, with the list.remove(x):
x not in list detail as shown.
The expected output for an exception must start with a traceback header, which
may be either of the following two lines, indented the same as the first line of
the example:
Traceback (most recent call last):
Traceback (innermost last):


The traceback header is followed by an optional traceback stack, whose contents
are ignored by doctest.  The traceback stack is typically omitted, or copied
verbatim from an interactive session.
The traceback stack is followed by the most interesting part: the line(s)
containing the exception type and detail.  This is usually the last line of a
traceback, but can extend across multiple lines if the exception has a
multi-line detail:
>>> raise ValueError('multi\n    line\ndetail')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: multi
    line
detail


The last three lines (starting with ValueError) are compared against the
exception’s type and detail, and the rest are ignored.
Best practice is to omit the traceback stack, unless it adds significant
documentation value to the example.  So the last example is probably better as:
>>> raise ValueError('multi\n    line\ndetail')
Traceback (most recent call last):
    ...
ValueError: multi
    line
detail


Note that tracebacks are treated very specially.  In particular, in the
rewritten example, the use of ... is independent of doctest’s
ELLIPSIS option.  The ellipsis in that example could be left out, or
could just as well be three (or three hundred) commas or digits, or an indented
transcript of a Monty Python skit.
Some details you should read once, but won’t need to remember:

Doctest can’t guess whether your expected output came from an exception
traceback or from ordinary printing.  So, e.g., an example that expects
ValueError: 42 is prime will pass whether ValueError is actually
raised or if the example merely prints that traceback text.  In practice,
ordinary output rarely begins with a traceback header line, so this doesn’t
create real problems.
Each line of the traceback stack (if present) must be indented further than
the first line of the example, or start with a non-alphanumeric character.
The first line following the traceback header indented the same and starting
with an alphanumeric is taken to be the start of the exception detail.  Of
course this does the right thing for genuine tracebacks.
When the IGNORE_EXCEPTION_DETAIL doctest option is specified,
everything following the leftmost colon and any module information in the
exception name is ignored.
The interactive shell omits the traceback header line for some
SyntaxErrors.  But doctest uses the traceback header line to
distinguish exceptions from non-exceptions.  So in the rare case where you need
to test a SyntaxError that omits the traceback header, you will need to
manually add the traceback header line to your test example.


For some SyntaxErrors, Python displays the character position of the
syntax error, using a ^ marker:
>>> 1 1
  File "<stdin>", line 1
    1 1
      ^
SyntaxError: invalid syntax


Since the lines showing the position of the error come before the exception type
and detail, they are not checked by doctest.  For example, the following test
would pass, even though it puts the ^ marker in the wrong location:
>>> 1 1
  File "<stdin>", line 1
    1 1
    ^
SyntaxError: invalid syntax






Option Flags¶
A number of option flags control various aspects of doctest’s behavior.
Symbolic names for the flags are supplied as module constants, which can be
bitwise ORed together and passed to various functions.
The names can also be used in doctest directives,
and may be passed to the doctest command line interface via the -o option.

New in version 3.4: The -o command line option.

The first group of options define test semantics, controlling aspects of how
doctest decides whether actual output matches an example’s expected output:


doctest.DONT_ACCEPT_TRUE_FOR_1¶
By default, if an expected output block contains just 1, an actual output
block containing just 1 or just True is considered to be a match, and
similarly for 0 versus False.  When DONT_ACCEPT_TRUE_FOR_1 is
specified, neither substitution is allowed.  The default behavior caters to that
Python changed the return type of many functions from integer to boolean;
doctests expecting “little integer” output still work in these cases.  This
option will probably go away, but not for several years.



doctest.DONT_ACCEPT_BLANKLINE¶
By default, if an expected output block contains a line containing only the
string <BLANKLINE>, then that line will match a blank line in the actual
output.  Because a genuinely blank line delimits the expected output, this is
the only way to communicate that a blank line is expected.  When
DONT_ACCEPT_BLANKLINE is specified, this substitution is not allowed.



doctest.NORMALIZE_WHITESPACE¶
When specified, all sequences of whitespace (blanks and newlines) are treated as
equal.  Any sequence of whitespace within the expected output will match any
sequence of whitespace within the actual output. By default, whitespace must
match exactly. NORMALIZE_WHITESPACE is especially useful when a line of
expected output is very long, and you want to wrap it across multiple lines in
your source.



doctest.ELLIPSIS¶
When specified, an ellipsis marker (...) in the expected output can match
any substring in the actual output.  This includes substrings that span line
boundaries, and empty substrings, so it’s best to keep usage of this simple.
Complicated uses can lead to the same kinds of “oops, it matched too much!”
surprises that .* is prone to in regular expressions.



doctest.IGNORE_EXCEPTION_DETAIL¶
When specified, an example that expects an exception passes if an exception of
the expected type is raised, even if the exception detail does not match.  For
example, an example expecting ValueError: 42 will pass if the actual
exception raised is ValueError: 3*14, but will fail, e.g., if
TypeError is raised.
It will also ignore the module name used in Python 3 doctest reports. Hence
both of these variations will work with the flag specified, regardless of
whether the test is run under Python 2.7 or Python 3.2 (or later versions):
>>> raise CustomError('message')
Traceback (most recent call last):
CustomError: message

>>> raise CustomError('message')
Traceback (most recent call last):
my_module.CustomError: message


Note that ELLIPSIS can also be used to ignore the
details of the exception message, but such a test may still fail based
on whether or not the module details are printed as part of the
exception name. Using IGNORE_EXCEPTION_DETAIL and the details
from Python 2.3 is also the only clear way to write a doctest that doesn’t
care about the exception detail yet continues to pass under Python 2.3 or
earlier (those releases do not support doctest directives and ignore them as irrelevant comments). For example:
>>> (1, 2)[3] = 'moo'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object doesn't support item assignment


passes under Python 2.3 and later Python versions with the flag specified,
even though the detail
changed in Python 2.4 to say “does not” instead of “doesn’t”.

Changed in version 3.2: IGNORE_EXCEPTION_DETAIL now also ignores any information relating
to the module containing the exception under test.




doctest.SKIP¶
When specified, do not run the example at all.  This can be useful in contexts
where doctest examples serve as both documentation and test cases, and an
example should be included for documentation purposes, but should not be
checked.  E.g., the example’s output might be random; or the example might
depend on resources which would be unavailable to the test driver.
The SKIP flag can also be used for temporarily “commenting out” examples.



doctest.COMPARISON_FLAGS¶
A bitmask or’ing together all the comparison flags above.

The second group of options controls how test failures are reported:


doctest.REPORT_UDIFF¶
When specified, failures that involve multi-line expected and actual outputs are
displayed using a unified diff.



doctest.REPORT_CDIFF¶
When specified, failures that involve multi-line expected and actual outputs
will be displayed using a context diff.



doctest.REPORT_NDIFF¶
When specified, differences are computed by difflib.Differ, using the same
algorithm as the popular ndiff.py utility. This is the only method that
marks differences within lines as well as across lines.  For example, if a line
of expected output contains digit 1 where actual output contains letter
l, a line is inserted with a caret marking the mismatching column positions.



doctest.REPORT_ONLY_FIRST_FAILURE¶
When specified, display the first failing example in each doctest, but suppress
output for all remaining examples.  This will prevent doctest from reporting
correct examples that break because of earlier failures; but it might also hide
incorrect examples that fail independently of the first failure.  When
REPORT_ONLY_FIRST_FAILURE is specified, the remaining examples are
still run, and still count towards the total number of failures reported; only
the output is suppressed.



doctest.FAIL_FAST¶
When specified, exit after the first failing example and don’t attempt to run
the remaining examples. Thus, the number of failures reported will be at most
1.  This flag may be useful during debugging, since examples after the first
failure won’t even produce debugging output.
The doctest command line accepts the option -f as a shorthand for -o
FAIL_FAST.

New in version 3.4.




doctest.REPORTING_FLAGS¶
A bitmask or’ing together all the reporting flags above.

There is also a way to register new option flag names, though this isn’t
useful unless you intend to extend doctest internals via subclassing:


doctest.register_optionflag(name)¶
Create a new option flag with a given name, and return the new flag’s integer
value.  register_optionflag() can be used when subclassing
OutputChecker or DocTestRunner to create new options that are
supported by your subclasses.  register_optionflag() should always be
called using the following idiom:
MY_FLAG = register_optionflag('MY_FLAG')





Directives¶
Doctest directives may be used to modify the option flags for an individual example.  Doctest directives are
special Python comments following an example’s source code:

directive             ::=  "#" "doctest:" directive_options
directive_options     ::=  directive_option ("," directive_option)\*
directive_option      ::=  on_or_off directive_option_name
on_or_off             ::=  "+" \| "-"
directive_option_name ::=  "DONT_ACCEPT_BLANKLINE" \| "NORMALIZE_WHITESPACE" \| ...

Whitespace is not allowed between the + or - and the directive option
name.  The directive option name can be any of the option flag names explained
above.
An example’s doctest directives modify doctest’s behavior for that single
example.  Use + to enable the named behavior, or - to disable it.
For example, this test passes:
>>> print(list(range(20))) 
[0,   1,  2,  3,  4,  5,  6,  7,  8,  9,
10,  11, 12, 13, 14, 15, 16, 17, 18, 19]


Without the directive it would fail, both because the actual output doesn’t have
two blanks before the single-digit list elements, and because the actual output
is on a single line.  This test also passes, and also requires a directive to do
so:
>>> print(list(range(20))) 
[0, 1, ..., 18, 19]


Multiple directives can be used on a single physical line, separated by
commas:
>>> print(list(range(20))) 
[0,    1, ...,   18,    19]


If multiple directive comments are used for a single example, then they are
combined:
>>> print(list(range(20))) 
...                        
[0,    1, ...,   18,    19]


As the previous example shows, you can add ... lines to your example
containing only directives.  This can be useful when an example is too long for
a directive to comfortably fit on the same line:
>>> print(list(range(5)) + list(range(10, 20)) + list(range(30, 40)))
... 
[0, ..., 4, 10, ..., 19, 30, ..., 39]


Note that since all options are disabled by default, and directives apply only
to the example they appear in, enabling options (via + in a directive) is
usually the only meaningful choice.  However, option flags can also be passed to
functions that run doctests, establishing different defaults.  In such cases,
disabling an option via - in a directive can be useful.


Warnings¶
doctest is serious about requiring exact matches in expected output.  If
even a single character doesn’t match, the test fails.  This will probably
surprise you a few times, as you learn exactly what Python does and doesn’t
guarantee about output.  For example, when printing a set, Python doesn’t
guarantee that the element is printed in any particular order, so a test like
>>> foo()
{"Hermione", "Harry"}


is vulnerable!  One workaround is to do
>>> foo() == {"Hermione", "Harry"}
True


instead.  Another is to do
>>> d = sorted(foo())
>>> d
['Harry', 'Hermione']



Note
Before Python 3.6, when printing a dict, Python did not guarantee that
the key-value pairs was printed in any particular order.

There are others, but you get the idea.
Another bad idea is to print things that embed an object address, like
>>> id(1.0) # certain to fail some of the time
7948648
>>> class C: pass
>>> C()   # the default repr() for instances embeds an address
<__main__.C instance at 0x00AC18F0>


The ELLIPSIS directive gives a nice approach for the last example:
>>> C() 
<__main__.C instance at 0x...>


Floating-point numbers are also subject to small output variations across
platforms, because Python defers to the platform C library for float formatting,
and C libraries vary widely in quality here.
>>> 1./7  # risky
0.14285714285714285
>>> print(1./7) # safer
0.142857142857
>>> print(round(1./7, 6)) # much safer
0.142857


Numbers of the form I/2.**J are safe across all platforms, and I often
contrive doctest examples to produce numbers of that form:
>>> 3./4  # utterly safe
0.75


Simple fractions are also easier for people to understand, and that makes for
better documentation.

