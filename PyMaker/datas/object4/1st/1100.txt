link:
library/datetime.html#datetime-objects

docs:

datetime Objects¶
A datetime object is a single object containing all the information
from a date object and a time object.  Like a date
object, datetime assumes the current Gregorian calendar extended in
both directions; like a time object, datetime assumes there are exactly
3600*24 seconds in every day.
Constructor:


class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)¶
The year, month and day arguments are required.  tzinfo may be None, or an
instance of a tzinfo subclass.  The remaining arguments may be integers,
in the following ranges:

MINYEAR <= year <= MAXYEAR,
1 <= month <= 12,
1 <= day <= number of days in the given month and year,
0 <= hour < 24,
0 <= minute < 60,
0 <= second < 60,
0 <= microsecond < 1000000,
fold in [0, 1].

If an argument outside those ranges is given, ValueError is raised.

New in version 3.6: Added the fold argument.


Other constructors, all class methods:


classmethod datetime.today()¶
Return the current local datetime, with tzinfo None. This is
equivalent to datetime.fromtimestamp(time.time()). See also now(),
fromtimestamp().



classmethod datetime.now(tz=None)¶
Return the current local date and time.  If optional argument tz is None
or not specified, this is like today(), but, if possible, supplies more
precision than can be gotten from going through a time.time() timestamp
(for example, this may be possible on platforms supplying the C
gettimeofday() function).
If tz is not None, it must be an instance of a tzinfo subclass, and the
current date and time are converted to tz’s time zone.  In this case the
result is equivalent to tz.fromutc(datetime.utcnow().replace(tzinfo=tz)).
See also today(), utcnow().



classmethod datetime.utcnow()¶
Return the current UTC date and time, with tzinfo None. This is like
now(), but returns the current UTC date and time, as a naive
datetime object.  An aware current UTC datetime can be obtained by
calling datetime.now(timezone.utc).  See also now().



classmethod datetime.fromtimestamp(timestamp, tz=None)¶
Return the local date and time corresponding to the POSIX timestamp, such as is
returned by time.time(). If optional argument tz is None or not
specified, the timestamp is converted to the platform’s local date and time, and
the returned datetime object is naive.
If tz is not None, it must be an instance of a tzinfo subclass, and the
timestamp is converted to tz’s time zone.  In this case the result is
equivalent to
tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz)).
fromtimestamp() may raise OverflowError, if the timestamp is out of
the range of values supported by the platform C localtime() or
gmtime() functions, and OSError on localtime() or
gmtime() failure.
It’s common for this to be restricted to years in
1970 through 2038. Note that on non-POSIX systems that include leap seconds in
their notion of a timestamp, leap seconds are ignored by fromtimestamp(),
and then it’s possible to have two timestamps differing by a second that yield
identical datetime objects. See also utcfromtimestamp().

Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp
is out of the range of values supported by the platform C
localtime() or gmtime() functions. Raise OSError
instead of ValueError on localtime() or gmtime()
failure.


Changed in version 3.6: fromtimestamp() may return instances with fold set to 1.




classmethod datetime.utcfromtimestamp(timestamp)¶
Return the UTC datetime corresponding to the POSIX timestamp, with
tzinfo None. This may raise OverflowError, if the timestamp is
out of the range of values supported by the platform C gmtime() function,
and OSError on gmtime() failure.
It’s common for this to be restricted to years in 1970 through 2038.
To get an aware datetime object, call fromtimestamp():
datetime.fromtimestamp(timestamp, timezone.utc)


On the POSIX compliant platforms, it is equivalent to the following
expression:
datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)


except the latter formula always supports the full years range: between
MINYEAR and MAXYEAR inclusive.

Changed in version 3.3: Raise OverflowError instead of ValueError if the timestamp
is out of the range of values supported by the platform C
gmtime() function. Raise OSError instead of
ValueError on gmtime() failure.




classmethod datetime.fromordinal(ordinal)¶
Return the datetime corresponding to the proleptic Gregorian ordinal,
where January 1 of year 1 has ordinal 1. ValueError is raised unless 1
<= ordinal <= datetime.max.toordinal().  The hour, minute, second and
microsecond of the result are all 0, and tzinfo is None.



classmethod datetime.combine(date, time, tzinfo=self.tzinfo)¶
Return a new datetime object whose date components are equal to the
given date object’s, and whose time components
are equal to the given time object’s.  If the tzinfo
argument is provided, its value is used to set the tzinfo attribute
of the result, otherwise the tzinfo attribute of the time argument
is used.
For any datetime object d,
d == datetime.combine(d.date(), d.time(), d.tzinfo).  If date is a
datetime object, its time components and tzinfo attributes
are ignored.

Changed in version 3.6: Added the tzinfo argument.




classmethod datetime.fromisoformat(date_string)¶
Return a datetime corresponding to a date_string in one of the
formats emitted by date.isoformat() and datetime.isoformat().
Specifically, this function supports strings in the format(s)
YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]],
where * can match any single character.

Caution
This does not support parsing arbitrary ISO 8601 strings - it is only intended
as the inverse operation of datetime.isoformat().


New in version 3.7.




classmethod datetime.strptime(date_string, format)¶
Return a datetime corresponding to date_string, parsed according to
format.  This is equivalent to datetime(*(time.strptime(date_string,
format)[0:6])). ValueError is raised if the date_string and format
can’t be parsed by time.strptime() or if it returns a value which isn’t a
time tuple. For a complete list of formatting directives, see
strftime() and strptime() Behavior.

Class attributes:


datetime.min¶
The earliest representable datetime, datetime(MINYEAR, 1, 1,
tzinfo=None).



datetime.max¶
The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59,
59, 999999, tzinfo=None).



datetime.resolution¶
The smallest possible difference between non-equal datetime objects,
timedelta(microseconds=1).

Instance attributes (read-only):


datetime.year¶
Between MINYEAR and MAXYEAR inclusive.



datetime.month¶
Between 1 and 12 inclusive.



datetime.day¶
Between 1 and the number of days in the given month of the given year.



datetime.hour¶
In range(24).



datetime.minute¶
In range(60).



datetime.second¶
In range(60).



datetime.microsecond¶
In range(1000000).



datetime.tzinfo¶
The object passed as the tzinfo argument to the datetime constructor,
or None if none was passed.



datetime.fold¶
In [0, 1].  Used to disambiguate wall times during a repeated interval.  (A
repeated interval occurs when clocks are rolled back at the end of daylight saving
time or when the UTC offset for the current zone is decreased for political reasons.)
The value 0 (1) represents the earlier (later) of the two moments with the same wall
time representation.

New in version 3.6.


Supported operations:






Operation
Result



datetime2 = datetime1 + timedelta
(1)

datetime2 = datetime1 - timedelta
(2)

timedelta = datetime1 - datetime2
(3)

datetime1 < datetime2
Compares datetime to
datetime. (4)




datetime2 is a duration of timedelta removed from datetime1, moving forward in
time if timedelta.days > 0, or backward if timedelta.days < 0.  The
result has the same tzinfo attribute as the input datetime, and
datetime2 - datetime1 == timedelta after. OverflowError is raised if
datetime2.year would be smaller than MINYEAR or larger than
MAXYEAR. Note that no time zone adjustments are done even if the
input is an aware object.

Computes the datetime2 such that datetime2 + timedelta == datetime1. As for
addition, the result has the same tzinfo attribute as the input
datetime, and no time zone adjustments are done even if the input is aware.

Subtraction of a datetime from a datetime is defined only if
both operands are naive, or if both are aware.  If one is aware and the other is
naive, TypeError is raised.
If both are naive, or both are aware and have the same tzinfo attribute,
the tzinfo attributes are ignored, and the result is a timedelta
object t such that datetime2 + t == datetime1.  No time zone adjustments
are done in this case.
If both are aware and have different tzinfo attributes, a-b acts
as if a and b were first converted to naive UTC datetimes first.  The
result is (a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None)
- b.utcoffset()) except that the implementation never overflows.

datetime1 is considered less than datetime2 when datetime1 precedes
datetime2 in time.
If one comparand is naive and the other is aware, TypeError
is raised if an order comparison is attempted.  For equality
comparisons, naive instances are never equal to aware instances.
If both comparands are aware, and have the same tzinfo attribute, the
common tzinfo attribute is ignored and the base datetimes are
compared.  If both comparands are aware and have different tzinfo
attributes, the comparands are first adjusted by subtracting their UTC
offsets (obtained from self.utcoffset()).

Changed in version 3.3: Equality comparisons between naive and aware datetime
instances don’t raise TypeError.


Note
In order to stop comparison from falling back to the default scheme of comparing
object addresses, datetime comparison normally raises TypeError if the
other comparand isn’t also a datetime object.  However,
NotImplemented is returned instead if the other comparand has a
timetuple() attribute.  This hook gives other kinds of date objects a
chance at implementing mixed-type comparison.  If not, when a datetime
object is compared to an object of a different type, TypeError is raised
unless the comparison is == or !=.  The latter cases return
False or True, respectively.



datetime objects can be used as dictionary keys. In Boolean contexts,
all datetime objects are considered to be true.
Instance methods:


datetime.date()¶
Return date object with same year, month and day.



datetime.time()¶
Return time object with same hour, minute, second, microsecond and fold.
tzinfo is None.  See also method timetz().

Changed in version 3.6: The fold value is copied to the returned time object.




datetime.timetz()¶
Return time object with same hour, minute, second, microsecond, fold, and
tzinfo attributes.  See also method time().

Changed in version 3.6: The fold value is copied to the returned time object.




datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)¶
Return a datetime with the same attributes, except for those attributes given
new values by whichever keyword arguments are specified.  Note that
tzinfo=None can be specified to create a naive datetime from an aware
datetime with no conversion of date and time data.

New in version 3.6: Added the fold argument.




datetime.astimezone(tz=None)¶
Return a datetime object with new tzinfo attribute tz,
adjusting the date and time data so the result is the same UTC time as
self, but in tz’s local time.
If provided, tz must be an instance of a tzinfo subclass, and its
utcoffset() and dst() methods must not return None.  If self
is naive, it is presumed to represent time in the system timezone.
If called without arguments (or with tz=None) the system local
timezone is assumed for the target timezone.  The .tzinfo attribute of the converted
datetime instance will be set to an instance of timezone
with the zone name and offset obtained from the OS.
If self.tzinfo is tz, self.astimezone(tz) is equal to self:  no
adjustment of date or time data is performed. Else the result is local
time in the timezone tz, representing the same UTC time as self:  after
astz = dt.astimezone(tz), astz - astz.utcoffset() will have
the same date and time data as dt - dt.utcoffset().
If you merely want to attach a time zone object tz to a datetime dt without
adjustment of date and time data, use dt.replace(tzinfo=tz).  If you
merely want to remove the time zone object from an aware datetime dt without
conversion of date and time data, use dt.replace(tzinfo=None).
Note that the default tzinfo.fromutc() method can be overridden in a
tzinfo subclass to affect the result returned by astimezone().
Ignoring error cases, astimezone() acts like:
def astimezone(self, tz):
    if self.tzinfo is tz:
        return self
    # Convert self to UTC, and attach the new time zone object.
    utc = (self - self.utcoffset()).replace(tzinfo=tz)
    # Convert from UTC to tz's local time.
    return tz.fromutc(utc)



Changed in version 3.3: tz now can be omitted.


Changed in version 3.6: The astimezone() method can now be called on naive instances that
are presumed to represent system local time.




datetime.utcoffset()¶
If tzinfo is None, returns None, else returns
self.tzinfo.utcoffset(self), and raises an exception if the latter doesn’t
return None or a timedelta object with magnitude less than one day.

Changed in version 3.7: The UTC offset is not restricted to a whole number of minutes.




datetime.dst()¶
If tzinfo is None, returns None, else returns
self.tzinfo.dst(self), and raises an exception if the latter doesn’t return
None or a timedelta object with magnitude less than one day.

Changed in version 3.7: The DST offset is not restricted to a whole number of minutes.




datetime.tzname()¶
If tzinfo is None, returns None, else returns
self.tzinfo.tzname(self), raises an exception if the latter doesn’t return
None or a string object,



datetime.timetuple()¶
Return a time.struct_time such as returned by time.localtime().
d.timetuple() is equivalent to time.struct_time((d.year, d.month, d.day,
d.hour, d.minute, d.second, d.weekday(), yday, dst)), where yday =
d.toordinal() - date(d.year, 1, 1).toordinal() + 1 is the day number within
the current year starting with 1 for January 1st. The tm_isdst flag
of the result is set according to the dst() method: tzinfo is
None or dst() returns None, tm_isdst is set to -1;
else if dst() returns a non-zero value, tm_isdst is set to 1;
else tm_isdst is set to 0.



datetime.utctimetuple()¶
If datetime instance d is naive, this is the same as
d.timetuple() except that tm_isdst is forced to 0 regardless of what
d.dst() returns.  DST is never in effect for a UTC time.
If d is aware, d is normalized to UTC time, by subtracting
d.utcoffset(), and a time.struct_time for the
normalized time is returned.  tm_isdst is forced to 0. Note
that an OverflowError may be raised if d.year was
MINYEAR or MAXYEAR and UTC adjustment spills over a year
boundary.



datetime.toordinal()¶
Return the proleptic Gregorian ordinal of the date.  The same as
self.date().toordinal().



datetime.timestamp()¶
Return POSIX timestamp corresponding to the datetime
instance.  The return value is a float similar to that
returned by time.time().
Naive datetime instances are assumed to represent local
time and this method relies on the platform C mktime()
function to perform the conversion.  Since datetime
supports wider range of values than mktime() on many
platforms, this method may raise OverflowError for times far
in the past or far in the future.
For aware datetime instances, the return value is computed
as:
(dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()



New in version 3.3.


Changed in version 3.6: The timestamp() method uses the fold attribute to
disambiguate the times during a repeated interval.


Note
There is no method to obtain the POSIX timestamp directly from a
naive datetime instance representing UTC time.  If your
application uses this convention and your system timezone is not
set to UTC, you can obtain the POSIX timestamp by supplying
tzinfo=timezone.utc:
timestamp = dt.replace(tzinfo=timezone.utc).timestamp()


or by calculating the timestamp directly:
timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)






datetime.weekday()¶
Return the day of the week as an integer, where Monday is 0 and Sunday is 6.
The same as self.date().weekday(). See also isoweekday().



datetime.isoweekday()¶
Return the day of the week as an integer, where Monday is 1 and Sunday is 7.
The same as self.date().isoweekday(). See also weekday(),
isocalendar().



datetime.isocalendar()¶
Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The same as
self.date().isocalendar().



datetime.isoformat(sep='T', timespec='auto')¶
Return a string representing the date and time in ISO 8601 format,
YYYY-MM-DDTHH:MM:SS.ffffff or, if microsecond is 0,
YYYY-MM-DDTHH:MM:SS
If utcoffset() does not return None, a string is
appended, giving the UTC offset:
YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if microsecond
is 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]].
The optional argument sep (default 'T') is a one-character separator,
placed between the date and time portions of the result.  For example,
>>> from datetime import tzinfo, timedelta, datetime
>>> class TZ(tzinfo):
...     def utcoffset(self, dt): return timedelta(minutes=-399)
...
>>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')
'2002-12-25 00:00:00-06:39'


The optional argument timespec specifies the number of additional
components of the time to include (the default is 'auto').
It can be one of the following:

'auto': Same as 'seconds' if microsecond is 0,
same as 'microseconds' otherwise.
'hours': Include the hour in the two-digit HH format.
'minutes': Include hour and minute in HH:MM format.
'seconds': Include hour, minute, and second
in HH:MM:SS format.
'milliseconds': Include full time, but truncate fractional second
part to milliseconds. HH:MM:SS.sss format.
'microseconds': Include full time in HH:MM:SS.ffffff format.


Note
Excluded time components are truncated, not rounded.

ValueError will be raised on an invalid timespec argument.
>>> from datetime import datetime
>>> datetime.now().isoformat(timespec='minutes')   # doctest: +SKIP
'2002-12-25T00:00'
>>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)
>>> dt.isoformat(timespec='microseconds')
'2015-01-01T12:30:59.000000'



New in version 3.6: Added the timespec argument.




datetime.__str__()¶
For a datetime instance d, str(d) is equivalent to
d.isoformat(' ').



datetime.ctime()¶
Return a string representing the date and time, for example datetime(2002, 12,
4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40 2002'. d.ctime() is
equivalent to time.ctime(time.mktime(d.timetuple())) on platforms where the
native C ctime() function (which time.ctime() invokes, but which
datetime.ctime() does not invoke) conforms to the C standard.



datetime.strftime(format)¶
Return a string representing the date and time, controlled by an explicit format
string.  For a complete list of formatting directives, see
strftime() and strptime() Behavior.



datetime.__format__(format)¶
Same as datetime.strftime().  This makes it possible to specify a format
string for a datetime object in formatted string
literals and when using str.format().  For a
complete list of formatting directives, see
strftime() and strptime() Behavior.

Examples of working with datetime objects:
>>> from datetime import datetime, date, time
>>> # Using datetime.combine()
>>> d = date(2005, 7, 14)
>>> t = time(12, 30)
>>> datetime.combine(d, t)
datetime.datetime(2005, 7, 14, 12, 30)
>>> # Using datetime.now() or datetime.utcnow()
>>> datetime.now()   
datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1
>>> datetime.utcnow()   
datetime.datetime(2007, 12, 6, 15, 29, 43, 79060)
>>> # Using datetime.strptime()
>>> dt = datetime.strptime("21/11/06 16:30", "%d/%m/%y %H:%M")
>>> dt
datetime.datetime(2006, 11, 21, 16, 30)
>>> # Using datetime.timetuple() to get tuple of all attributes
>>> tt = dt.timetuple()
>>> for it in tt:   
...     print(it)
...
2006    # year
11      # month
21      # day
16      # hour
30      # minute
0       # second
1       # weekday (0 = Monday)
325     # number of days since 1st January
-1      # dst - method tzinfo.dst() returned None
>>> # Date in ISO format
>>> ic = dt.isocalendar()
>>> for it in ic:   
...     print(it)
...
2006    # ISO year
47      # ISO week
2       # ISO weekday
>>> # Formatting datetime
>>> dt.strftime("%A, %d. %B %Y %I:%M%p")
'Tuesday, 21. November 2006 04:30PM'
>>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, "day", "month", "time")
'The day is 21, the month is November, the time is 04:30PM.'


Using datetime with tzinfo:
>>> from datetime import timedelta, datetime, tzinfo
>>> class GMT1(tzinfo):
...     def utcoffset(self, dt):
...         return timedelta(hours=1) + self.dst(dt)
...     def dst(self, dt):
...         # DST starts last Sunday in March
...         d = datetime(dt.year, 4, 1)   # ends last Sunday in October
...         self.dston = d - timedelta(days=d.weekday() + 1)
...         d = datetime(dt.year, 11, 1)
...         self.dstoff = d - timedelta(days=d.weekday() + 1)
...         if self.dston <=  dt.replace(tzinfo=None) < self.dstoff:
...             return timedelta(hours=1)
...         else:
...             return timedelta(0)
...     def tzname(self,dt):
...          return "GMT +1"
...
>>> class GMT2(tzinfo):
...     def utcoffset(self, dt):
...         return timedelta(hours=2) + self.dst(dt)
...     def dst(self, dt):
...         d = datetime(dt.year, 4, 1)
...         self.dston = d - timedelta(days=d.weekday() + 1)
...         d = datetime(dt.year, 11, 1)
...         self.dstoff = d - timedelta(days=d.weekday() + 1)
...         if self.dston <=  dt.replace(tzinfo=None) < self.dstoff:
...             return timedelta(hours=1)
...         else:
...             return timedelta(0)
...     def tzname(self,dt):
...         return "GMT +2"
...
>>> gmt1 = GMT1()
>>> # Daylight Saving Time
>>> dt1 = datetime(2006, 11, 21, 16, 30, tzinfo=gmt1)
>>> dt1.dst()
datetime.timedelta(0)
>>> dt1.utcoffset()
datetime.timedelta(seconds=3600)
>>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=gmt1)
>>> dt2.dst()
datetime.timedelta(seconds=3600)
>>> dt2.utcoffset()
datetime.timedelta(seconds=7200)
>>> # Convert datetime to another time zone
>>> dt3 = dt2.astimezone(GMT2())
>>> dt3     # doctest: +ELLIPSIS
datetime.datetime(2006, 6, 14, 14, 0, tzinfo=<GMT2 object at 0x...>)
>>> dt2     # doctest: +ELLIPSIS
datetime.datetime(2006, 6, 14, 13, 0, tzinfo=<GMT1 object at 0x...>)
>>> dt2.utctimetuple() == dt3.utctimetuple()
True


