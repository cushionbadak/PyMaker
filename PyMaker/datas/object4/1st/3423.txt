link:
library/argparse.html#the-add-argument-method

docs:

The add_argument() method¶


ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])¶
Define how a single command-line argument should be parsed.  Each parameter
has its own more detailed description below, but in short they are:

name or flags - Either a name or a list of option strings, e.g. foo
or -f, --foo.
action - The basic type of action to be taken when this argument is
encountered at the command line.
nargs - The number of command-line arguments that should be consumed.
const - A constant value required by some action and nargs selections.
default - The value produced if the argument is absent from the
command line.
type - The type to which the command-line argument should be converted.
choices - A container of the allowable values for the argument.
required - Whether or not the command-line option may be omitted
(optionals only).
help - A brief description of what the argument does.
metavar - A name for the argument in usage messages.
dest - The name of the attribute to be added to the object returned by
parse_args().


The following sections describe how each of these are used.

name or flags¶
The add_argument() method must know whether an optional
argument, like -f or --foo, or a positional argument, like a list of
filenames, is expected.  The first arguments passed to
add_argument() must therefore be either a series of
flags, or a simple argument name.  For example, an optional argument could
be created like:
>>> parser.add_argument('-f', '--foo')


while a positional argument could be created like:
>>> parser.add_argument('bar')


When parse_args() is called, optional arguments will be
identified by the - prefix, and the remaining arguments will be assumed to
be positional:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-f', '--foo')
>>> parser.add_argument('bar')
>>> parser.parse_args(['BAR'])
Namespace(bar='BAR', foo=None)
>>> parser.parse_args(['BAR', '--foo', 'FOO'])
Namespace(bar='BAR', foo='FOO')
>>> parser.parse_args(['--foo', 'FOO'])
usage: PROG [-h] [-f FOO] bar
PROG: error: the following arguments are required: bar




action¶
ArgumentParser objects associate command-line arguments with actions.  These
actions can do just about anything with the command-line arguments associated with
them, though most actions simply add an attribute to the object returned by
parse_args().  The action keyword argument specifies
how the command-line arguments should be handled. The supplied actions are:

'store' - This just stores the argument’s value.  This is the default
action. For example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.parse_args('--foo 1'.split())
Namespace(foo='1')



'store_const' - This stores the value specified by the const keyword
argument.  The 'store_const' action is most commonly used with
optional arguments that specify some sort of flag.  For example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_const', const=42)
>>> parser.parse_args(['--foo'])
Namespace(foo=42)



'store_true' and 'store_false' - These are special cases of
'store_const' used for storing the values True and False
respectively.  In addition, they create default values of False and
True respectively.  For example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='store_true')
>>> parser.add_argument('--bar', action='store_false')
>>> parser.add_argument('--baz', action='store_false')
>>> parser.parse_args('--foo --bar'.split())
Namespace(foo=True, bar=False, baz=True)



'append' - This stores a list, and appends each argument value to the
list.  This is useful to allow an option to be specified multiple times.
Example usage:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action='append')
>>> parser.parse_args('--foo 1 --foo 2'.split())
Namespace(foo=['1', '2'])



'append_const' - This stores a list, and appends the value specified by
the const keyword argument to the list.  (Note that the const keyword
argument defaults to None.)  The 'append_const' action is typically
useful when multiple arguments need to store constants to the same list. For
example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--str', dest='types', action='append_const', const=str)
>>> parser.add_argument('--int', dest='types', action='append_const', const=int)
>>> parser.parse_args('--str --int'.split())
Namespace(types=[<class 'str'>, <class 'int'>])



'count' - This counts the number of times a keyword argument occurs. For
example, this is useful for increasing verbosity levels:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--verbose', '-v', action='count')
>>> parser.parse_args(['-vvv'])
Namespace(verbose=3)



'help' - This prints a complete help message for all the options in the
current parser and then exits. By default a help action is automatically
added to the parser. See ArgumentParser for details of how the
output is created.

'version' - This expects a version= keyword argument in the
add_argument() call, and prints version information
and exits when invoked:
>>> import argparse
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')
>>> parser.parse_args(['--version'])
PROG 2.0




You may also specify an arbitrary action by passing an Action subclass or
other object that implements the same interface.  The recommended way to do
this is to extend Action, overriding the __call__ method
and optionally the __init__ method.
An example of a custom action:
>>> class FooAction(argparse.Action):
...     def __init__(self, option_strings, dest, nargs=None, **kwargs):
...         if nargs is not None:
...             raise ValueError("nargs not allowed")
...         super(FooAction, self).__init__(option_strings, dest, **kwargs)
...     def __call__(self, parser, namespace, values, option_string=None):
...         print('%r %r %r' % (namespace, values, option_string))
...         setattr(namespace, self.dest, values)
...
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', action=FooAction)
>>> parser.add_argument('bar', action=FooAction)
>>> args = parser.parse_args('1 --foo 2'.split())
Namespace(bar=None, foo=None) '1' None
Namespace(bar='1', foo=None) '2' '--foo'
>>> args
Namespace(bar='1', foo='2')


For more details, see Action.


nargs¶
ArgumentParser objects usually associate a single command-line argument with a
single action to be taken.  The nargs keyword argument associates a
different number of command-line arguments with a single action.  The supported
values are:

N (an integer).  N arguments from the command line will be gathered
together into a list.  For example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs=2)
>>> parser.add_argument('bar', nargs=1)
>>> parser.parse_args('c --foo a b'.split())
Namespace(bar=['c'], foo=['a', 'b'])


Note that nargs=1 produces a list of one item.  This is different from
the default, in which the item is produced by itself.



'?'. One argument will be consumed from the command line if possible, and
produced as a single item.  If no command-line argument is present, the value from
default will be produced.  Note that for optional arguments, there is an
additional case - the option string is present but not followed by a
command-line argument.  In this case the value from const will be produced.  Some
examples to illustrate this:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs='?', const='c', default='d')
>>> parser.add_argument('bar', nargs='?', default='d')
>>> parser.parse_args(['XX', '--foo', 'YY'])
Namespace(bar='XX', foo='YY')
>>> parser.parse_args(['XX', '--foo'])
Namespace(bar='XX', foo='c')
>>> parser.parse_args([])
Namespace(bar='d', foo='d')


One of the more common uses of nargs='?' is to allow optional input and
output files:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
...                     default=sys.stdin)
>>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),
...                     default=sys.stdout)
>>> parser.parse_args(['input.txt', 'output.txt'])
Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,
          outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)
>>> parser.parse_args([])
Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,
          outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)





'*'.  All command-line arguments present are gathered into a list.  Note that
it generally doesn’t make much sense to have more than one positional argument
with nargs='*', but multiple optional arguments with nargs='*' is
possible.  For example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', nargs='*')
>>> parser.add_argument('--bar', nargs='*')
>>> parser.add_argument('baz', nargs='*')
>>> parser.parse_args('a b --foo x y --bar 1 2'.split())
Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])





'+'. Just like '*', all command-line args present are gathered into a
list.  Additionally, an error message will be generated if there wasn’t at
least one command-line argument present.  For example:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('foo', nargs='+')
>>> parser.parse_args(['a', 'b'])
Namespace(foo=['a', 'b'])
>>> parser.parse_args([])
usage: PROG [-h] foo [foo ...]
PROG: error: the following arguments are required: foo





argparse.REMAINDER.  All the remaining command-line arguments are gathered
into a list.  This is commonly useful for command line utilities that dispatch
to other command line utilities:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('--foo')
>>> parser.add_argument('command')
>>> parser.add_argument('args', nargs=argparse.REMAINDER)
>>> print(parser.parse_args('--foo B cmd --arg1 XX ZZ'.split()))
Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')




If the nargs keyword argument is not provided, the number of arguments consumed
is determined by the action.  Generally this means a single command-line argument
will be consumed and a single item (not a list) will be produced.


const¶
The const argument of add_argument() is used to hold
constant values that are not read from the command line but are required for
the various ArgumentParser actions.  The two most common uses of it are:

When add_argument() is called with
action='store_const' or action='append_const'.  These actions add the
const value to one of the attributes of the object returned by
parse_args(). See the action description for examples.
When add_argument() is called with option strings
(like -f or --foo) and nargs='?'.  This creates an optional
argument that can be followed by zero or one command-line arguments.
When parsing the command line, if the option string is encountered with no
command-line argument following it, the value of const will be assumed instead.
See the nargs description for examples.

With the 'store_const' and 'append_const' actions, the const
keyword argument must be given.  For other actions, it defaults to None.


default¶
All optional arguments and some positional arguments may be omitted at the
command line.  The default keyword argument of
add_argument(), whose value defaults to None,
specifies what value should be used if the command-line argument is not present.
For optional arguments, the default value is used when the option string
was not present at the command line:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default=42)
>>> parser.parse_args(['--foo', '2'])
Namespace(foo='2')
>>> parser.parse_args([])
Namespace(foo=42)


If the default value is a string, the parser parses the value as if it
were a command-line argument.  In particular, the parser applies any type
conversion argument, if provided, before setting the attribute on the
Namespace return value.  Otherwise, the parser uses the value as is:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--length', default='10', type=int)
>>> parser.add_argument('--width', default=10.5, type=int)
>>> parser.parse_args()
Namespace(length=10, width=10.5)


For positional arguments with nargs equal to ? or *, the default value
is used when no command-line argument was present:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', nargs='?', default=42)
>>> parser.parse_args(['a'])
Namespace(foo='a')
>>> parser.parse_args([])
Namespace(foo=42)


Providing default=argparse.SUPPRESS causes no attribute to be added if the
command-line argument was not present:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', default=argparse.SUPPRESS)
>>> parser.parse_args([])
Namespace()
>>> parser.parse_args(['--foo', '1'])
Namespace(foo='1')




type¶
By default, ArgumentParser objects read command-line arguments in as simple
strings. However, quite often the command-line string should instead be
interpreted as another type, like a float or int.  The
type keyword argument of add_argument() allows any
necessary type-checking and type conversions to be performed.  Common built-in
types and functions can be used directly as the value of the type argument:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('foo', type=int)
>>> parser.add_argument('bar', type=open)
>>> parser.parse_args('2 temp.txt'.split())
Namespace(bar=<_io.TextIOWrapper name='temp.txt' encoding='UTF-8'>, foo=2)


See the section on the default keyword argument for information on when the
type argument is applied to default arguments.
To ease the use of various types of files, the argparse module provides the
factory FileType which takes the mode=, bufsize=, encoding= and
errors= arguments of the open() function.  For example,
FileType('w') can be used to create a writable file:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('bar', type=argparse.FileType('w'))
>>> parser.parse_args(['out.txt'])
Namespace(bar=<_io.TextIOWrapper name='out.txt' encoding='UTF-8'>)


type= can take any callable that takes a single string argument and returns
the converted value:
>>> def perfect_square(string):
...     value = int(string)
...     sqrt = math.sqrt(value)
...     if sqrt != int(sqrt):
...         msg = "%r is not a perfect square" % string
...         raise argparse.ArgumentTypeError(msg)
...     return value
...
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('foo', type=perfect_square)
>>> parser.parse_args(['9'])
Namespace(foo=9)
>>> parser.parse_args(['7'])
usage: PROG [-h] foo
PROG: error: argument foo: '7' is not a perfect square


The choices keyword argument may be more convenient for type checkers that
simply check against a range of values:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('foo', type=int, choices=range(5, 10))
>>> parser.parse_args(['7'])
Namespace(foo=7)
>>> parser.parse_args(['11'])
usage: PROG [-h] {5,6,7,8,9}
PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)


See the choices section for more details.


choices¶
Some command-line arguments should be selected from a restricted set of values.
These can be handled by passing a container object as the choices keyword
argument to add_argument().  When the command line is
parsed, argument values will be checked, and an error message will be displayed
if the argument was not one of the acceptable values:
>>> parser = argparse.ArgumentParser(prog='game.py')
>>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
>>> parser.parse_args(['rock'])
Namespace(move='rock')
>>> parser.parse_args(['fire'])
usage: game.py [-h] {rock,paper,scissors}
game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',
'paper', 'scissors')


Note that inclusion in the choices container is checked after any type
conversions have been performed, so the type of the objects in the choices
container should match the type specified:
>>> parser = argparse.ArgumentParser(prog='doors.py')
>>> parser.add_argument('door', type=int, choices=range(1, 4))
>>> print(parser.parse_args(['3']))
Namespace(door=3)
>>> parser.parse_args(['4'])
usage: doors.py [-h] {1,2,3}
doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)


Any object that supports the in operator can be passed as the choices
value, so dict objects, set objects, custom containers,
etc. are all supported.


required¶
In general, the argparse module assumes that flags like -f and --bar
indicate optional arguments, which can always be omitted at the command line.
To make an option required, True can be specified for the required=
keyword argument to add_argument():
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', required=True)
>>> parser.parse_args(['--foo', 'BAR'])
Namespace(foo='BAR')
>>> parser.parse_args([])
usage: argparse.py [-h] [--foo FOO]
argparse.py: error: option --foo is required


As the example shows, if an option is marked as required,
parse_args() will report an error if that option is not
present at the command line.

Note
Required options are generally considered bad form because users expect
options to be optional, and thus they should be avoided when possible.



help¶
The help value is a string containing a brief description of the argument.
When a user requests help (usually by using -h or --help at the
command line), these help descriptions will be displayed with each
argument:
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('--foo', action='store_true',
...                     help='foo the bars before frobbling')
>>> parser.add_argument('bar', nargs='+',
...                     help='one of the bars to be frobbled')
>>> parser.parse_args(['-h'])
usage: frobble [-h] [--foo] bar [bar ...]

positional arguments:
 bar     one of the bars to be frobbled

optional arguments:
 -h, --help  show this help message and exit
 --foo   foo the bars before frobbling


The help strings can include various format specifiers to avoid repetition
of things like the program name or the argument default.  The available
specifiers include the program name, %(prog)s and most keyword arguments to
add_argument(), e.g. %(default)s, %(type)s, etc.:
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('bar', nargs='?', type=int, default=42,
...                     help='the bar to %(prog)s (default: %(default)s)')
>>> parser.print_help()
usage: frobble [-h] [bar]

positional arguments:
 bar     the bar to frobble (default: 42)

optional arguments:
 -h, --help  show this help message and exit


As the help string supports %-formatting, if you want a literal % to appear
in the help string, you must escape it as %%.
argparse supports silencing the help entry for certain options, by
setting the help value to argparse.SUPPRESS:
>>> parser = argparse.ArgumentParser(prog='frobble')
>>> parser.add_argument('--foo', help=argparse.SUPPRESS)
>>> parser.print_help()
usage: frobble [-h]

optional arguments:
  -h, --help  show this help message and exit




metavar¶
When ArgumentParser generates help messages, it needs some way to refer
to each expected argument.  By default, ArgumentParser objects use the dest
value as the “name” of each object.  By default, for positional argument
actions, the dest value is used directly, and for optional argument actions,
the dest value is uppercased.  So, a single positional argument with
dest='bar' will be referred to as bar. A single
optional argument --foo that should be followed by a single command-line argument
will be referred to as FOO.  An example:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo')
>>> parser.add_argument('bar')
>>> parser.parse_args('X --foo Y'.split())
Namespace(bar='X', foo='Y')
>>> parser.print_help()
usage:  [-h] [--foo FOO] bar

positional arguments:
 bar

optional arguments:
 -h, --help  show this help message and exit
 --foo FOO


An alternative name can be specified with metavar:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', metavar='YYY')
>>> parser.add_argument('bar', metavar='XXX')
>>> parser.parse_args('X --foo Y'.split())
Namespace(bar='X', foo='Y')
>>> parser.print_help()
usage:  [-h] [--foo YYY] XXX

positional arguments:
 XXX

optional arguments:
 -h, --help  show this help message and exit
 --foo YYY


Note that metavar only changes the displayed name - the name of the
attribute on the parse_args() object is still determined
by the dest value.
Different values of nargs may cause the metavar to be used multiple times.
Providing a tuple to metavar specifies a different display for each of the
arguments:
>>> parser = argparse.ArgumentParser(prog='PROG')
>>> parser.add_argument('-x', nargs=2)
>>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))
>>> parser.print_help()
usage: PROG [-h] [-x X X] [--foo bar baz]

optional arguments:
 -h, --help     show this help message and exit
 -x X X
 --foo bar baz




dest¶
Most ArgumentParser actions add some value as an attribute of the
object returned by parse_args().  The name of this
attribute is determined by the dest keyword argument of
add_argument().  For positional argument actions,
dest is normally supplied as the first argument to
add_argument():
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('bar')
>>> parser.parse_args(['XXX'])
Namespace(bar='XXX')


For optional argument actions, the value of dest is normally inferred from
the option strings.  ArgumentParser generates the value of dest by
taking the first long option string and stripping away the initial --
string.  If no long option strings were supplied, dest will be derived from
the first short option string by stripping the initial - character.  Any
internal - characters will be converted to _ characters to make sure
the string is a valid attribute name.  The examples below illustrate this
behavior:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('-f', '--foo-bar', '--foo')
>>> parser.add_argument('-x', '-y')
>>> parser.parse_args('-f 1 -x 2'.split())
Namespace(foo_bar='1', x='2')
>>> parser.parse_args('--foo 1 -y 2'.split())
Namespace(foo_bar='1', x='2')


dest allows a custom attribute name to be provided:
>>> parser = argparse.ArgumentParser()
>>> parser.add_argument('--foo', dest='bar')
>>> parser.parse_args('--foo XXX'.split())
Namespace(bar='XXX')




Action classes¶
Action classes implement the Action API, a callable which returns a callable
which processes arguments from the command-line. Any object which follows
this API may be passed as the action parameter to
add_argument().


class argparse.Action(option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)¶

Action objects are used by an ArgumentParser to represent the information
needed to parse a single argument from one or more strings from the
command line. The Action class must accept the two positional arguments
plus any keyword arguments passed to ArgumentParser.add_argument()
except for the action itself.
Instances of Action (or return value of any callable to the action
parameter) should have attributes “dest”, “option_strings”, “default”, “type”,
“required”, “help”, etc. defined. The easiest way to ensure these attributes
are defined is to call Action.__init__.
Action instances should be callable, so subclasses must override the
__call__ method, which should accept four parameters:

parser - The ArgumentParser object which contains this action.
namespace - The Namespace object that will be returned by
parse_args().  Most actions add an attribute to this
object using setattr().
values - The associated command-line arguments, with any type conversions
applied.  Type conversions are specified with the type keyword argument to
add_argument().
option_string - The option string that was used to invoke this action.
The option_string argument is optional, and will be absent if the action
is associated with a positional argument.

The __call__ method may perform arbitrary actions, but will typically set
attributes on the namespace based on dest and values.

