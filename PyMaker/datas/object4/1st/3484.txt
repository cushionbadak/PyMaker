link:
library/logging.html#logging.Logger

docs:

<dt id="logging.Logger">
<em class="property">class </em><code class="descclassname">logging.</code><code class="descname">Logger</code><a class="headerlink" href="#logging.Logger" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="logging.Logger.propagate">
<code class="descname">propagate</code><a class="headerlink" href="#logging.Logger.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>If this attribute evaluates to true, events logged to this logger will be
passed to the handlers of higher level (ancestor) loggers, in addition to
any handlers attached to this logger. Messages are passed directly to the
ancestor loggers’ handlers - neither the level nor filters of the ancestor
loggers in question are considered.</p>
<p>If this evaluates to false, logging messages are not passed to the handlers
of ancestor loggers.</p>
<p>The constructor sets this attribute to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you attach a handler to a logger <em>and</em> one or more of its
ancestors, it may emit the same record multiple times. In general, you
should not need to attach a handler to more than one logger - if you just
attach it to the appropriate logger which is highest in the logger
hierarchy, then it will see all events logged by all descendant loggers,
provided that their propagate setting is left set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. A common
scenario is to attach handlers only to the root logger, and to let
propagation take care of the rest.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.setLevel">
<code class="descname">setLevel</code><span class="sig-paren">(</span><em>level</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.setLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the threshold for this logger to <em>level</em>. Logging messages which are less
severe than <em>level</em> will be ignored; logging messages which have severity <em>level</em>
or higher will be emitted by whichever handler or handlers service this logger,
unless a handler’s level has been set to a higher severity level than <em>level</em>.</p>
<p>When a logger is created, the level is set to <code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> (which causes
all messages to be processed when the logger is the root logger, or delegation
to the parent when the logger is a non-root logger). Note that the root logger
is created with level <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code>.</p>
<p>The term ‘delegation to the parent’ means that if a logger has a level of
NOTSET, its chain of ancestor loggers is traversed until either an ancestor with
a level other than NOTSET is found, or the root is reached.</p>
<p>If an ancestor is found with a level other than NOTSET, then that ancestor’s
level is treated as the effective level of the logger where the ancestor search
began, and is used to determine how a logging event is handled.</p>
<p>If the root is reached, and it has a level of NOTSET, then all messages will be
processed. Otherwise, the root’s level will be used as the effective level.</p>
<p>See <a class="reference internal" href="#levels"><span class="std std-ref">Logging Levels</span></a> for a list of levels.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.2: </span>The <em>level</em> parameter now accepts a string representation of the
level such as ‘INFO’ as an alternative to the integer constants
such as <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code>. Note, however, that levels are internally stored
as integers, and methods such as e.g. <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a> and
<a class="reference internal" href="#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a> will return/expect to be passed integers.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.isEnabledFor">
<code class="descname">isEnabledFor</code><span class="sig-paren">(</span><em>lvl</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.isEnabledFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates if a message of severity <em>lvl</em> would be processed by this logger.
This method checks first the module-level level set by
<code class="docutils literal notranslate"><span class="pre">logging.disable(lvl)</span></code> and then the logger’s effective level as determined
by <a class="reference internal" href="#logging.Logger.getEffectiveLevel" title="logging.Logger.getEffectiveLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEffectiveLevel()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.getEffectiveLevel">
<code class="descname">getEffectiveLevel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getEffectiveLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the effective level for this logger. If a value other than
<code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> has been set using <a class="reference internal" href="#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a>, it is returned. Otherwise,
the hierarchy is traversed towards the root until a value other than
<code class="xref py py-const docutils literal notranslate"><span class="pre">NOTSET</span></code> is found, and that value is returned. The value returned is
an integer, typically one of <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.DEBUG</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">logging.INFO</span></code>
etc.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.getChild">
<code class="descname">getChild</code><span class="sig-paren">(</span><em>suffix</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.getChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a logger which is a descendant to this logger, as determined by the suffix.
Thus, <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc').getChild('def.ghi')</span></code> would return the same
logger as would be returned by <code class="docutils literal notranslate"><span class="pre">logging.getLogger('abc.def.ghi')</span></code>. This is a
convenience method, useful when the parent logger is named using e.g. <code class="docutils literal notranslate"><span class="pre">__name__</span></code>
rather than a literal string.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">DEBUG</span></code> on this logger. The <em>msg</em> is the
message format string, and the <em>args</em> are the arguments which are merged into
<em>msg</em> using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)</p>
<p>There are three keyword arguments in <em>kwargs</em> which are inspected:
<em>exc_info</em>, <em>stack_info</em>, and <em>extra</em>.</p>
<p>If <em>exc_info</em> does not evaluate as false, it causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
<a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>) or an exception instance is provided, it is used;
otherwise, <a class="reference internal" href="sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> is called to get the exception information.</p>
<p>The second optional keyword argument is <em>stack_info</em>, which defaults to
<code class="docutils literal notranslate"><span class="pre">False</span></code>. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying <em>exc_info</em>: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.</p>
<p>You can specify <em>stack_info</em> independently of <em>exc_info</em>, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stack (most recent call last):
</pre></div>
</div>
<p>This mimics the <code class="docutils literal notranslate"><span class="pre">Traceback</span> <span class="pre">(most</span> <span class="pre">recent</span> <span class="pre">call</span> <span class="pre">last):</span></code> which is used when
displaying exception frames.</p>
<p>The third keyword argument is <em>extra</em> which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">FORMAT</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%(asctime)-15s</span><span class="s1"> </span><span class="si">%(clientip)s</span><span class="s1"> </span><span class="si">%(user)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">'</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'clientip'</span><span class="p">:</span> <span class="s1">'192.168.0.1'</span><span class="p">,</span> <span class="s1">'user'</span><span class="p">:</span> <span class="s1">'fbloggs'</span><span class="p">}</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'tcpserver'</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">'Protocol problem: </span><span class="si">%s</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'connection reset'</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p>would print something like</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset
</pre></div>
</div>
<p>The keys in the dictionary passed in <em>extra</em> should not clash with the keys used
by the logging system. (See the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> documentation for more
information on which keys are used by the logging system.)</p>
<p>If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the <a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the <em>extra</em> dictionary with these keys.</p>
<p>While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
<a class="reference internal" href="#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a>s would be used with particular <a class="reference internal" href="#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a>s.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2: </span>The <em>stack_info</em> parameter was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.5: </span>The <em>exc_info</em> parameter can now accept exception instances.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.info">
<code class="descname">info</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">INFO</span></code> on this logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.warning">
<code class="descname">warning</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">WARNING</span></code> on this logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is an obsolete method <code class="docutils literal notranslate"><span class="pre">warn</span></code> which is functionally
identical to <code class="docutils literal notranslate"><span class="pre">warning</span></code>. As <code class="docutils literal notranslate"><span class="pre">warn</span></code> is deprecated, please do not use
it - use <code class="docutils literal notranslate"><span class="pre">warning</span></code> instead.</p>
</div>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> on this logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.critical">
<code class="descname">critical</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.critical" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">CRITICAL</span></code> on this logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>lvl</em>, <em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with integer level <em>lvl</em> on this logger. The other arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.exception">
<code class="descname">exception</code><span class="sig-paren">(</span><em>msg</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.exception" title="Permalink to this definition">¶</a></dt>
<dd><p>Logs a message with level <code class="xref py py-const docutils literal notranslate"><span class="pre">ERROR</span></code> on this logger. The arguments are
interpreted as for <a class="reference internal" href="#logging.debug" title="logging.debug"><code class="xref py py-meth docutils literal notranslate"><span class="pre">debug()</span></code></a>. Exception info is added to the logging
message. This method should only be called from an exception handler.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.addFilter">
<code class="descname">addFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the specified filter <em>filter</em> to this logger.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.removeFilter">
<code class="descname">removeFilter</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the specified filter <em>filter</em> from this logger.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies this logger’s filters to the record and returns a true value if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be processed (passed to handlers). If one returns a false value, no
further processing of the record occurs.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.addHandler">
<code class="descname">addHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.addHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the specified handler <em>hdlr</em> to this logger.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.removeHandler">
<code class="descname">removeHandler</code><span class="sig-paren">(</span><em>hdlr</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.removeHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the specified handler <em>hdlr</em> from this logger.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.findCaller">
<code class="descname">findCaller</code><span class="sig-paren">(</span><em>stack_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.findCaller" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the caller’s source filename and line number. Returns the filename, line
number, function name and stack information as a 4-element tuple. The stack
information is returned as <code class="docutils literal notranslate"><span class="pre">None</span></code> unless <em>stack_info</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.handle">
<code class="descname">handle</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.handle" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles a record by passing it to all handlers associated with this logger and
its ancestors (until a false value of <em>propagate</em> is found). This method is used
for unpickled records received from a socket, as well as those created locally.
Logger-level filtering is applied using <a class="reference internal" href="#logging.Logger.filter" title="logging.Logger.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.makeRecord">
<code class="descname">makeRecord</code><span class="sig-paren">(</span><em>name</em>, <em>lvl</em>, <em>fn</em>, <em>lno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>extra=None</em>, <em>sinfo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.makeRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a factory method which can be overridden in subclasses to create
specialized <a class="reference internal" href="#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> instances.</p>
</dd></dl>
<dl class="method">
<dt id="logging.Logger.hasHandlers">
<code class="descname">hasHandlers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#logging.Logger.hasHandlers" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if this logger has any handlers configured. This is done by
looking for handlers in this logger and its parents in the logger hierarchy.
Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if a handler was found, else <code class="docutils literal notranslate"><span class="pre">False</span></code>. The method stops searching
up the hierarchy whenever a logger with the ‘propagate’ attribute set to
false is found - that will be the last logger which is checked for the
existence of handlers.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.7: </span>Loggers can now be pickled and unpickled.</p>
</div>
</dd>