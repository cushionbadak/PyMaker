link:
library/stdtypes.html#set

docs:

<dt id="set">
<em class="property">class </em><code class="descname">set</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set" title="Permalink to this definition">¶</a></dt>
<dt id="frozenset">
<em class="property">class </em><code class="descname">frozenset</code><span class="sig-paren">(</span><span class="optional">[</span><em>iterable</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new set or frozenset object whose elements are taken from
<em>iterable</em>.  The elements of a set must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.  To
represent sets of sets, the inner sets must be <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
objects.  If <em>iterable</em> is not specified, a new empty set is
returned.</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> provide the following
operations:</p>
<dl class="describe">
<dt>
<code class="descname">len(s)</code></dt>
<dd><p>Return the number of elements in set <em>s</em> (cardinality of <em>s</em>).</p>
</dd></dl>
<dl class="describe">
<dt>
<code class="descname">x in s</code></dt>
<dd><p>Test <em>x</em> for membership in <em>s</em>.</p>
</dd></dl>
<dl class="describe">
<dt>
<code class="descname">x not in s</code></dt>
<dd><p>Test <em>x</em> for non-membership in <em>s</em>.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the set has no elements in common with <em>other</em>.  Sets are
disjoint if and only if their intersection is the empty set.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issubset" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set &lt;= other</code></dt>
<dd><p>Test whether every element in the set is in <em>other</em>.</p>
</dd></dl>
<dl class="method">
<dt>
<code class="descname">set &lt; other</code></dt>
<dd><p>Test whether the set is a proper subset of <em>other</em>, that is,
<code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&lt;=</span> <span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.issuperset" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set &gt;= other</code></dt>
<dd><p>Test whether every element in <em>other</em> is in the set.</p>
</dd></dl>
<dl class="method">
<dt>
<code class="descname">set &gt; other</code></dt>
<dd><p>Test whether the set is a proper superset of <em>other</em>, that is, <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&gt;=</span>
<span class="pre">other</span> <span class="pre">and</span> <span class="pre">set</span> <span class="pre">!=</span> <span class="pre">other</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.union" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set | other | ...</code></dt>
<dd><p>Return a new set with elements from the set and all others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set &amp; other &amp; ...</code></dt>
<dd><p>Return a new set with elements common to the set and all others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set - other - ...</code></dt>
<dd><p>Return a new set with elements in the set that are not in the others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set ^ other</code></dt>
<dd><p>Return a new set with elements in either the set or <em>other</em> but not both.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy of the set.</p>
</dd></dl>
<p>Note, the non-operator versions of <a class="reference internal" href="#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a>, <a class="reference internal" href="#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code></a>,
<a class="reference internal" href="#frozenset.difference" title="frozenset.difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference()</span></code></a>, and <a class="reference internal" href="#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference()</span></code></a>, <a class="reference internal" href="#frozenset.issubset" title="frozenset.issubset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code></a>, and
<a class="reference internal" href="#frozenset.issuperset" title="frozenset.issuperset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code></a> methods will accept any iterable as an argument.  In
contrast, their operator based counterparts require their arguments to be
sets.  This precludes error-prone constructions like <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">&amp;</span> <span class="pre">'cbs'</span></code>
in favor of the more readable <code class="docutils literal notranslate"><span class="pre">set('abc').intersection('cbs')</span></code>.</p>
<p>Both <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> and <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> support set to set comparisons. Two
sets are equal if and only if every element of each set is contained in the
other (each is a subset of the other). A set is less than another set if and
only if the first set is a proper subset of the second set (is a subset, but
is not equal). A set is greater than another set if and only if the first set
is a proper superset of the second set (is a superset, but is not equal).</p>
<p>Instances of <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> are compared to instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
based on their members.  For example, <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">==</span> <span class="pre">frozenset('abc')</span></code>
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> and so does <code class="docutils literal notranslate"><span class="pre">set('abc')</span> <span class="pre">in</span> <span class="pre">set([frozenset('abc')])</span></code>.</p>
<p>The subset and equality comparisons do not generalize to a total ordering
function.  For example, any two nonempty disjoint sets are not equal and are not
subsets of each other, so <em>all</em> of the following return <code class="docutils literal notranslate"><span class="pre">False</span></code>: <code class="docutils literal notranslate"><span class="pre">a&lt;b</span></code>,
<code class="docutils literal notranslate"><span class="pre">a==b</span></code>, or <code class="docutils literal notranslate"><span class="pre">a&gt;b</span></code>.</p>
<p>Since sets only define partial ordering (subset relationships), the output of
the <a class="reference internal" href="#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> method is undefined for lists of sets.</p>
<p>Set elements, like dictionary keys, must be <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
<p>Binary operations that mix <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> instances with <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>
return the type of the first operand.  For example: <code class="docutils literal notranslate"><span class="pre">frozenset('ab')</span> <span class="pre">|</span>
<span class="pre">set('bc')</span></code> returns an instance of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>.</p>
<p>The following table lists operations available for <a class="reference internal" href="#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> that do not
apply to immutable instances of <a class="reference internal" href="#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>:</p>
<dl class="method">
<dt id="frozenset.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.update" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set |= other | ...</code></dt>
<dd><p>Update the set, adding elements from all others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.intersection_update" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set &amp;= other &amp; ...</code></dt>
<dd><p>Update the set, keeping only elements found in it and all others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.difference_update" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set -= other | ...</code></dt>
<dd><p>Update the set, removing elements found in others.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.symmetric_difference_update" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">set ^= other</code></dt>
<dd><p>Update the set, keeping only elements found in either set, but not in both.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add element <em>elem</em> to the set.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set.  Raises <a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if <em>elem</em> is
not contained in the set.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>elem</em><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove element <em>elem</em> from the set if it is present.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return an arbitrary element from the set.  Raises
<a class="reference internal" href="exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> if the set is empty.</p>
</dd></dl>
<dl class="method">
<dt id="frozenset.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frozenset.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements from the set.</p>
</dd></dl>
<p>Note, the non-operator versions of the <a class="reference internal" href="#frozenset.update" title="frozenset.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a>,
<a class="reference internal" href="#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code></a>, <a class="reference internal" href="#frozenset.difference_update" title="frozenset.difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difference_update()</span></code></a>, and
<a class="reference internal" href="#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code></a> methods will accept any iterable as an
argument.</p>
<p>Note, the <em>elem</em> argument to the <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, <a class="reference internal" href="#frozenset.remove" title="frozenset.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, and
<a class="reference internal" href="#frozenset.discard" title="frozenset.discard"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discard()</span></code></a> methods may be a set.  To support searching for an equivalent
frozenset, a temporary one is created from <em>elem</em>.</p>
</dd>