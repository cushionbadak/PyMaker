link:
library/ssl.html#ssl.SSLSocket.get_channel_binding

docs:

<dt id="ssl.SSLSocket.get_channel_binding">
<code class="descclassname">SSLSocket.</code><code class="descname">get_channel_binding</code><span class="sig-paren">(</span><em>cb_type="tls-unique"</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.get_channel_binding" title="Permalink to this definition">¶</a></dt>
<dd><p>Get channel binding data for current connection, as a bytes object.  Returns
<code class="docutils literal notranslate"><span class="pre">None</span></code> if not connected or the handshake has not been completed.</p>
<p>The <em>cb_type</em> parameter allow selection of the desired channel binding
type. Valid channel binding types are listed in the
<a class="reference internal" href="#ssl.CHANNEL_BINDING_TYPES" title="ssl.CHANNEL_BINDING_TYPES"><code class="xref py py-data docutils literal notranslate"><span class="pre">CHANNEL_BINDING_TYPES</span></code></a> list.  Currently only the ‘tls-unique’ channel
binding, defined by <span class="target" id="index-12"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc5929.html"><strong>RFC 5929</strong></a>, is supported.  <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> will be
raised if an unsupported channel binding type is requested.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd>