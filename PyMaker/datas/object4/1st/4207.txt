link:
library/threading.html#condition-objects

docs:

Condition Objects¶
A condition variable is always associated with some kind of lock; this can be
passed in or one will be created by default.  Passing one in is useful when
several condition variables must share the same lock.  The lock is part of
the condition object: you don’t have to track it separately.
A condition variable obeys the context management protocol:
using the with statement acquires the associated lock for the duration of
the enclosed block.  The acquire() and
release() methods also call the corresponding methods of
the associated lock.
Other methods must be called with the associated lock held.  The
wait() method releases the lock, and then blocks until
another thread awakens it by calling notify() or
notify_all().  Once awakened, wait()
re-acquires the lock and returns.  It is also possible to specify a timeout.
The notify() method wakes up one of the threads waiting for
the condition variable, if any are waiting.  The notify_all()
method wakes up all threads waiting for the condition variable.
Note: the notify() and notify_all() methods
don’t release the lock; this means that the thread or threads awakened will
not return from their wait() call immediately, but only when
the thread that called notify() or notify_all()
finally relinquishes ownership of the lock.
The typical programming style using condition variables uses the lock to
synchronize access to some shared state; threads that are interested in a
particular change of state call wait() repeatedly until they
see the desired state, while threads that modify the state call
notify() or notify_all() when they change
the state in such a way that it could possibly be a desired state for one
of the waiters.  For example, the following code is a generic
producer-consumer situation with unlimited buffer capacity:
# Consume one item
with cv:
    while not an_item_is_available():
        cv.wait()
    get_an_available_item()

# Produce one item
with cv:
    make_an_item_available()
    cv.notify()


The while loop checking for the application’s condition is necessary
because wait() can return after an arbitrary long time,
and the condition which prompted the notify() call may
no longer hold true.  This is inherent to multi-threaded programming.  The
wait_for() method can be used to automate the condition
checking, and eases the computation of timeouts:
# Consume an item
with cv:
    cv.wait_for(an_item_is_available)
    get_an_available_item()


To choose between notify() and notify_all(),
consider whether one state change can be interesting for only one or several
waiting threads.  E.g. in a typical producer-consumer situation, adding one
item to the buffer only needs to wake up one consumer thread.


class threading.Condition(lock=None)¶
This class implements condition variable objects.  A condition variable
allows one or more threads to wait until they are notified by another thread.
If the lock argument is given and not None, it must be a Lock
or RLock object, and it is used as the underlying lock.  Otherwise,
a new RLock object is created and used as the underlying lock.

Changed in version 3.3: changed from a factory function to a class.



acquire(*args)¶
Acquire the underlying lock. This method calls the corresponding method on
the underlying lock; the return value is whatever that method returns.



release()¶
Release the underlying lock. This method calls the corresponding method on
the underlying lock; there is no return value.



wait(timeout=None)¶
Wait until notified or until a timeout occurs. If the calling thread has
not acquired the lock when this method is called, a RuntimeError is
raised.
This method releases the underlying lock, and then blocks until it is
awakened by a notify() or notify_all() call for the same
condition variable in another thread, or until the optional timeout
occurs.  Once awakened or timed out, it re-acquires the lock and returns.
When the timeout argument is present and not None, it should be a
floating point number specifying a timeout for the operation in seconds
(or fractions thereof).
When the underlying lock is an RLock, it is not released using
its release() method, since this may not actually unlock the lock
when it was acquired multiple times recursively.  Instead, an internal
interface of the RLock class is used, which really unlocks it
even when it has been recursively acquired several times. Another internal
interface is then used to restore the recursion level when the lock is
reacquired.
The return value is True unless a given timeout expired, in which
case it is False.

Changed in version 3.2: Previously, the method always returned None.




wait_for(predicate, timeout=None)¶
Wait until a condition evaluates to true.  predicate should be a
callable which result will be interpreted as a boolean value.
A timeout may be provided giving the maximum time to wait.
This utility method may call wait() repeatedly until the predicate
is satisfied, or until a timeout occurs. The return value is
the last return value of the predicate and will evaluate to
False if the method timed out.
Ignoring the timeout feature, calling this method is roughly equivalent to
writing:
while not predicate():
    cv.wait()


Therefore, the same rules apply as with wait(): The lock must be
held when called and is re-acquired on return.  The predicate is evaluated
with the lock held.

New in version 3.2.




notify(n=1)¶
By default, wake up one thread waiting on this condition, if any.  If the
calling thread has not acquired the lock when this method is called, a
RuntimeError is raised.
This method wakes up at most n of the threads waiting for the condition
variable; it is a no-op if no threads are waiting.
The current implementation wakes up exactly n threads, if at least n
threads are waiting.  However, it’s not safe to rely on this behavior.
A future, optimized implementation may occasionally wake up more than
n threads.
Note: an awakened thread does not actually return from its wait()
call until it can reacquire the lock.  Since notify() does not
release the lock, its caller should.



notify_all()¶
Wake up all threads waiting on this condition.  This method acts like
notify(), but wakes up all waiting threads instead of one. If the
calling thread has not acquired the lock when this method is called, a
RuntimeError is raised.


