link:
reference/datamodel.html#customizing-class-creation

docs:

3.3.3. Customizing class creation¶
Whenever a class inherits from another class, __init_subclass__ is
called on that class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to, __init_subclass__ solely applies to future subclasses of the
class defining the method.


classmethod object.__init_subclass__(cls)¶
This method is called whenever the containing class is subclassed.
cls is then the new subclass. If defined as a normal instance method,
this method is implicitly converted to a class method.
Keyword arguments which are given to a new class are passed to
the parent’s class __init_subclass__. For compatibility with
other classes using __init_subclass__, one should take out the
needed keyword arguments and pass the others over to the base
class, as in:
class Philosopher:
    def __init_subclass__(cls, default_name, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.default_name = default_name

class AustralianPhilosopher(Philosopher, default_name="Bruce"):
    pass


The default implementation object.__init_subclass__ does
nothing, but raises an error if it is called with any arguments.

Note
The metaclass hint metaclass is consumed by the rest of the type
machinery, and is never passed to __init_subclass__ implementations.
The actual metaclass (rather than the explicit hint) can be accessed as
type(cls).


New in version 3.6.



3.3.3.1. Metaclasses¶
By default, classes are constructed using type(). The class body is
executed in a new namespace and the class name is bound locally to the
result of type(name, bases, namespace).
The class creation process can be customized by passing the metaclass
keyword argument in the class definition line, or by inheriting from an
existing class that included such an argument. In the following example,
both MyClass and MySubclass are instances of Meta:
class Meta(type):
    pass

class MyClass(metaclass=Meta):
    pass

class MySubclass(MyClass):
    pass


Any other keyword arguments that are specified in the class definition are
passed through to all metaclass operations described below.
When a class definition is executed, the following steps occur:

MRO entries are resolved;
the appropriate metaclass is determined;
the class namespace is prepared;
the class body is executed;
the class object is created.



3.3.3.2. Resolving MRO entries¶
If a base that appears in class definition is not an instance of type,
then an __mro_entries__ method is searched on it. If found, it is called
with the original bases tuple. This method must return a tuple of classes that
will be used instead of this base. The tuple may be empty, in such case
the original base is ignored.

See also
PEP 560 - Core support for typing module and generic types



3.3.3.3. Determining the appropriate metaclass¶
The appropriate metaclass for a class definition is determined as follows:

if no bases and no explicit metaclass are given, then type() is used;
if an explicit metaclass is given and it is not an instance of
type(), then it is used directly as the metaclass;
if an instance of type() is given as the explicit metaclass, or
bases are defined, then the most derived metaclass is used.

The most derived metaclass is selected from the explicitly specified
metaclass (if any) and the metaclasses (i.e. type(cls)) of all specified
base classes. The most derived metaclass is one which is a subtype of all
of these candidate metaclasses. If none of the candidate metaclasses meets
that criterion, then the class definition will fail with TypeError.


3.3.3.4. Preparing the class namespace¶
Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a __prepare__ attribute, it is called
as namespace = metaclass.__prepare__(name, bases, **kwds) (where the
additional keyword arguments, if any, come from the class definition).
If the metaclass has no __prepare__ attribute, then the class namespace
is initialised as an empty ordered mapping.

See also

PEP 3115 - Metaclasses in Python 3000
Introduced the __prepare__ namespace hook




3.3.3.5. Executing the class body¶
The class body is executed (approximately) as
exec(body, globals(), namespace). The key difference from a normal
call to exec() is that lexical scoping allows the class body (including
any methods) to reference names from the current and outer scopes when the
class definition occurs inside a function.
However, even when the class definition occurs inside the function, methods
defined inside the class still cannot see names defined at the class scope.
Class variables must be accessed through the first parameter of instance or
class methods, or through the implicit lexically scoped __class__ reference
described in the next section.


3.3.3.6. Creating the class object¶
Once the class namespace has been populated by executing the class body,
the class object is created by calling
metaclass(name, bases, namespace, **kwds) (the additional keywords
passed here are the same as those passed to __prepare__).
This class object is the one that will be referenced by the zero-argument
form of super(). __class__ is an implicit closure reference
created by the compiler if any methods in a class body refer to either
__class__ or super. This allows the zero argument form of
super() to correctly identify the class being defined based on
lexical scoping, while the class or instance that was used to make the
current call is identified based on the first argument passed to the method.

CPython implementation detail: In CPython 3.6 and later, the __class__ cell is passed to the metaclass
as a __classcell__ entry in the class namespace. If present, this must
be propagated up to the type.__new__ call in order for the class to be
initialised correctly.
Failing to do so will result in a DeprecationWarning in Python 3.6,
and a RuntimeError in Python 3.8.

When using the default metaclass type, or any metaclass that ultimately
calls type.__new__, the following additional customisation steps are
invoked after creating the class object:

first, type.__new__ collects all of the descriptors in the class
namespace that define a __set_name__() method;
second, all of these __set_name__ methods are called with the class
being defined and the assigned name of that particular descriptor;
finally, the __init_subclass__() hook is called on the
immediate parent of the new class in its method resolution order.

After the class object is created, it is passed to the class decorators
included in the class definition (if any) and the resulting object is bound
in the local namespace as the defined class.
When a new class is created by type.__new__, the object provided as the
namespace parameter is copied to a new ordered mapping and the original
object is discarded. The new copy is wrapped in a read-only proxy, which
becomes the __dict__ attribute of the class object.

See also

PEP 3135 - New super
Describes the implicit __class__ closure reference




3.3.3.7. Uses for metaclasses¶
The potential uses for metaclasses are boundless. Some ideas that have been
explored include enum, logging, interface checking, automatic delegation,
automatic property creation, proxies, frameworks, and automatic resource
locking/synchronization.

