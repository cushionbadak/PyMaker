link:
library/logging.config.html#configuration-functions

docs:

Configuration functions¶
The following functions configure the logging module. They are located in the
logging.config module.  Their use is optional — you can configure the
logging module using these functions or by making calls to the main API (defined
in logging itself) and defining handlers which are declared either in
logging or logging.handlers.


logging.config.dictConfig(config)¶

Takes the logging configuration from a dictionary.  The contents of
this dictionary are described in Configuration dictionary schema
below.
If an error is encountered during configuration, this function will
raise a ValueError, TypeError, AttributeError
or ImportError with a suitably descriptive message.  The
following is a (possibly incomplete) list of conditions which will
raise an error:

A level which is not a string or which is a string not
corresponding to an actual logging level.
A propagate value which is not a boolean.
An id which does not have a corresponding destination.
A non-existent handler id found during an incremental call.
An invalid logger name.
Inability to resolve to an internal or external object.

Parsing is performed by the DictConfigurator class, whose
constructor is passed the dictionary used for configuration, and
has a configure() method.  The logging.config module
has a callable attribute dictConfigClass
which is initially set to DictConfigurator.
You can replace the value of dictConfigClass with a
suitable implementation of your own.
dictConfig() calls dictConfigClass passing
the specified dictionary, and then calls the configure() method on
the returned object to put the configuration into effect:
def dictConfig(config):
    dictConfigClass(config).configure()


For example, a subclass of DictConfigurator could call
DictConfigurator.__init__() in its own __init__(), then
set up custom prefixes which would be usable in the subsequent
configure() call. dictConfigClass would be bound to
this new subclass, and then dictConfig() could be called exactly as
in the default, uncustomized state.


New in version 3.2.




logging.config.fileConfig(fname, defaults=None, disable_existing_loggers=True)¶
Reads the logging configuration from a configparser-format file. The
format of the file should be as described in
Configuration file format.
This function can be called several times from an application, allowing an
end user to select from various pre-canned configurations (if the developer
provides a mechanism to present the choices and load the chosen
configuration).




Parameters:
fname – A filename, or a file-like object, or an instance derived
from RawConfigParser. If a
RawConfigParser-derived instance is passed, it is used as
is. Otherwise, a Configparser is
instantiated, and the configuration read by it from the
object passed in fname. If that has a readline()
method, it is assumed to be a file-like object and read using
read_file(); otherwise,
it is assumed to be a filename and passed to
read().
defaults – Defaults to be passed to the ConfigParser can be specified
in this argument.
disable_existing_loggers – If specified as False, loggers which
exist when this call is made are left
enabled. The default is True because this
enables old behaviour in a
backward-compatible way. This behaviour is to
disable any existing non-root loggers unless
they or their ancestors are explicitly named
in the logging configuration.






Changed in version 3.4: An instance of a subclass of RawConfigParser is
now accepted as a value for fname. This facilitates:

Use of a configuration file where logging configuration is just part
of the overall application configuration.
Use of a configuration read from a file, and then modified by the using
application (e.g. based on command-line parameters or other aspects
of the runtime environment) before being passed to fileConfig.





logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT, verify=None)¶
Starts up a socket server on the specified port, and listens for new
configurations. If no port is specified, the module’s default
DEFAULT_LOGGING_CONFIG_PORT is used. Logging configurations will be
sent as a file suitable for processing by dictConfig() or
fileConfig(). Returns a Thread instance on which
you can call start() to start the server, and which
you can join() when appropriate. To stop the server,
call stopListening().
The verify argument, if specified, should be a callable which should
verify whether bytes received across the socket are valid and should be
processed. This could be done by encrypting and/or signing what is sent
across the socket, such that the verify callable can perform
signature verification and/or decryption. The verify callable is called
with a single argument - the bytes received across the socket - and should
return the bytes to be processed, or None to indicate that the bytes should
be discarded. The returned bytes could be the same as the passed in bytes
(e.g. when only verification is done), or they could be completely different
(perhaps if decryption were performed).
To send a configuration to the socket, read in the configuration file and
send it to the socket as a sequence of bytes preceded by a four-byte length
string packed in binary using struct.pack('>L', n).

Note
Because portions of the configuration are passed through
eval(), use of this function may open its users to a security risk.
While the function only binds to a socket on localhost, and so does
not accept connections from remote machines, there are scenarios where
untrusted code could be run under the account of the process which calls
listen(). Specifically, if the process calling listen() runs
on a multi-user machine where users cannot trust each other, then a
malicious user could arrange to run essentially arbitrary code in a
victim user’s process, simply by connecting to the victim’s
listen() socket and sending a configuration which runs whatever
code the attacker wants to have executed in the victim’s process. This is
especially easy to do if the default port is used, but not hard even if a
different port is used). To avoid the risk of this happening, use the
verify argument to listen() to prevent unrecognised
configurations from being applied.


Changed in version 3.4: The verify argument was added.


Note
If you want to send configurations to the listener which don’t
disable existing loggers, you will need to use a JSON format for
the configuration, which will use dictConfig() for configuration.
This method allows you to specify disable_existing_loggers as
False in the configuration you send.




logging.config.stopListening()¶
Stops the listening server which was created with a call to listen().
This is typically called before calling join() on the return value from
listen().

