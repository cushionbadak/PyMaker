link:
library/2to3.html#using-2to3

docs:

Using 2to3¶
2to3 will usually be installed with the Python interpreter as a script.  It is
also located in the Tools/scripts directory of the Python root.
2to3’s basic arguments are a list of files or directories to transform.  The
directories are recursively traversed for Python sources.
Here is a sample Python 2.x source file, example.py:
def greet(name):
    print "Hello, {0}!".format(name)
print "What's your name?"
name = raw_input()
greet(name)


It can be converted to Python 3.x code via 2to3 on the command line:
$ 2to3 example.py


A diff against the original source file is printed.  2to3 can also write the
needed modifications right back to the source file.  (A backup of the original
file is made unless -n is also given.)  Writing the changes back is
enabled with the -w flag:
$ 2to3 -w example.py


After transformation, example.py looks like this:
def greet(name):
    print("Hello, {0}!".format(name))
print("What's your name?")
name = input()
greet(name)


Comments and exact indentation are preserved throughout the translation process.
By default, 2to3 runs a set of predefined fixers.  The
-l flag lists all available fixers.  An explicit set of fixers to run
can be given with -f.  Likewise the -x explicitly disables a
fixer.  The following example runs only the imports and has_key fixers:
$ 2to3 -f imports -f has_key example.py


This command runs every fixer except the apply fixer:
$ 2to3 -x apply example.py


Some fixers are explicit, meaning they aren’t run by default and must be
listed on the command line to be run.  Here, in addition to the default fixers,
the idioms fixer is run:
$ 2to3 -f all -f idioms example.py


Notice how passing all enables all default fixers.
Sometimes 2to3 will find a place in your source code that needs to be changed,
but 2to3 cannot fix automatically.  In this case, 2to3 will print a warning
beneath the diff for a file.  You should address the warning in order to have
compliant 3.x code.
2to3 can also refactor doctests.  To enable this mode, use the -d
flag.  Note that only doctests will be refactored.  This also doesn’t require
the module to be valid Python.  For example, doctest like examples in a reST
document could also be refactored with this option.
The -v option enables output of more information on the translation
process.
Since some print statements can be parsed as function calls or statements, 2to3
cannot always read files containing the print function.  When 2to3 detects the
presence of the from __future__ import print_function compiler directive, it
modifies its internal grammar to interpret print() as a function.  This
change can also be enabled manually with the -p flag.  Use
-p to run fixers on code that already has had its print statements
converted.
The -o or --output-dir option allows specification of an
alternate directory for processed output files to be written to.  The
-n flag is required when using this as backup files do not make sense
when not overwriting the input files.

New in version 3.2.3: The -o option was added.

The -W or --write-unchanged-files flag tells 2to3 to always
write output files even if no changes were required to the file.  This is most
useful with -o so that an entire Python source tree is copied with
translation from one directory to another.
This option implies the -w flag as it would not make sense otherwise.

New in version 3.2.3: The -W flag was added.

The --add-suffix option specifies a string to append to all output
filenames.  The -n flag is required when specifying this as backups
are not necessary when writing to different filenames.  Example:
$ 2to3 -n -W --add-suffix=3 example.py


Will cause a converted file named example.py3 to be written.

New in version 3.2.3: The --add-suffix option was added.

To translate an entire project from one directory tree to another use:
$ 2to3 --output-dir=python3-version/mycode -W -n python2-version/mycode


