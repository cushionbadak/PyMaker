link:
reference/lexical_analysis.html#formatted-string-literals

docs:

2.4.3. Formatted string literalsÂ¶

New in version 3.6.

A formatted string literal or f-string is a string literal
that is prefixed with 'f' or 'F'.  These strings may contain
replacement fields, which are expressions delimited by curly braces {}.
While other string literals always have a constant value, formatted strings
are really expressions evaluated at run time.
Escape sequences are decoded like in ordinary string literals (except when
a literal is also marked as a raw string).  After decoding, the grammar
for the contents of the string is:

f_string          ::=  (literal_char | "{{" | "}}" | replacement_field)*
replacement_field ::=  "{" f_expression ["!" conversion] [":" format_spec] "}"
f_expression      ::=  (conditional_expression | "*" or_expr)
                         ("," conditional_expression | "," "*" or_expr)* [","]
                       | yield_expression
conversion        ::=  "s" | "r" | "a"
format_spec       ::=  (literal_char | NULL | replacement_field)*
literal_char      ::=  <any code point except "{", "}" or NULL>

The parts of the string outside curly braces are treated literally,
except that any doubled curly braces '{{' or '}}' are replaced
with the corresponding single curly brace.  A single opening curly
bracket '{' marks a replacement field, which starts with a
Python expression.  After the expression, there may be a conversion field,
introduced by an exclamation point '!'.  A format specifier may also
be appended, introduced by a colon ':'.  A replacement field ends
with a closing curly bracket '}'.
Expressions in formatted string literals are treated like regular
Python expressions surrounded by parentheses, with a few exceptions.
An empty expression is not allowed, and a lambda expression
must be surrounded by explicit parentheses.  Replacement expressions
can contain line breaks (e.g. in triple-quoted strings), but they
cannot contain comments.  Each expression is evaluated in the context
where the formatted string literal appears, in order from left to right.
If a conversion is specified, the result of evaluating the expression
is converted before formatting.  Conversion '!s' calls str() on
the result, '!r' calls repr(), and '!a' calls ascii().
The result is then formatted using the format() protocol.  The
format specifier is passed to the __format__() method of the
expression or conversion result.  An empty string is passed when the
format specifier is omitted.  The formatted result is then included in
the final value of the whole string.
Top-level format specifiers may include nested replacement fields. These nested
fields may include their own conversion fields and format specifiers, but may not include more deeply-nested replacement fields. The
format specifier mini-language is the same as that used by
the string .format() method.
Formatted string literals may be concatenated, but replacement fields
cannot be split across literals.
Some examples of formatted string literals:
>>> name = "Fred"
>>> f"He said his name is {name!r}."
"He said his name is 'Fred'."
>>> f"He said his name is {repr(name)}."  # repr() is equivalent to !r
"He said his name is 'Fred'."
>>> width = 10
>>> precision = 4
>>> value = decimal.Decimal("12.34567")
>>> f"result: {value:{width}.{precision}}"  # nested fields
'result:      12.35'
>>> today = datetime(year=2017, month=1, day=27)
>>> f"{today:%B %d, %Y}"  # using date format specifier
'January 27, 2017'
>>> number = 1024
>>> f"{number:#0x}"  # using integer format specifier
'0x400'


A consequence of sharing the same syntax as regular string literals is
that characters in the replacement fields must not conflict with the
quoting used in the outer formatted string literal:
f"abc {a["x"]} def"    # error: outer string literal ended prematurely
f"abc {a['x']} def"    # workaround: use different quoting


Backslashes are not allowed in format expressions and will raise
an error:
f"newline: {ord('\n')}"  # raises SyntaxError


To include a value in which a backslash escape is required, create
a temporary variable.
>>> newline = ord('\n')
>>> f"newline: {newline}"
'newline: 10'


Formatted string literals cannot be used as docstrings, even if they do not
include expressions.
>>> def foo():
...     f"Not a docstring"
...
>>> foo.__doc__ is None
True


See also PEP 498 for the proposal that added formatted string literals,
and str.format(), which uses a related format string mechanism.
