link:
library/concurrent.futures.html#concurrent.futures.Executor

docs:


class concurrent.futures.Executor¶
An abstract class that provides methods to execute calls asynchronously.  It
should not be used directly, but through its concrete subclasses.



submit(fn, *args, **kwargs)¶
Schedules the callable, fn, to be executed as fn(*args **kwargs)
and returns a Future object representing the execution of the
callable.
with ThreadPoolExecutor(max_workers=1) as executor:
    future = executor.submit(pow, 323, 1235)
    print(future.result())





map(func, *iterables, timeout=None, chunksize=1)¶
Similar to map(func, *iterables) except:

the iterables are collected immediately rather than lazily;
func is executed asynchronously and several calls to
func may be made concurrently.

The returned iterator raises a concurrent.futures.TimeoutError
if __next__() is called and the result isn’t available
after timeout seconds from the original call to Executor.map().
timeout can be an int or a float.  If timeout is not specified or
None, there is no limit to the wait time.
If a func call raises an exception, then that exception will be
raised when its value is retrieved from the iterator.
When using ProcessPoolExecutor, this method chops iterables
into a number of chunks which it submits to the pool as separate
tasks.  The (approximate) size of these chunks can be specified by
setting chunksize to a positive integer.  For very long iterables,
using a large value for chunksize can significantly improve
performance compared to the default size of 1.  With
ThreadPoolExecutor, chunksize has no effect.

Changed in version 3.5: Added the chunksize argument.




shutdown(wait=True)¶
Signal the executor that it should free any resources that it is using
when the currently pending futures are done executing.  Calls to
Executor.submit() and Executor.map() made after shutdown will
raise RuntimeError.
If wait is True then this method will not return until all the
pending futures are done executing and the resources associated with the
executor have been freed.  If wait is False then this method will
return immediately and the resources associated with the executor will be
freed when all pending futures are done executing.  Regardless of the
value of wait, the entire Python program will not exit until all
pending futures are done executing.
You can avoid having to call this method explicitly if you use the
with statement, which will shutdown the Executor
(waiting as if Executor.shutdown() were called with wait set to
True):
import shutil
with ThreadPoolExecutor(max_workers=4) as e:
    e.submit(shutil.copy, 'src1.txt', 'dest1.txt')
    e.submit(shutil.copy, 'src2.txt', 'dest2.txt')
    e.submit(shutil.copy, 'src3.txt', 'dest3.txt')
    e.submit(shutil.copy, 'src4.txt', 'dest4.txt')




