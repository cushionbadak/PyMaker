link:
library/socket.html#socket.socket.sendmsg

docs:


socket.sendmsg(buffers[, ancdata[, flags[, address]]])Â¶
Send normal and ancillary data to the socket, gathering the
non-ancillary data from a series of buffers and concatenating it
into a single message.  The buffers argument specifies the
non-ancillary data as an iterable of
bytes-like objects
(e.g. bytes objects); the operating system may set a limit
(sysconf() value SC_IOV_MAX) on the number of buffers
that can be used.  The ancdata argument specifies the ancillary
data (control messages) as an iterable of zero or more tuples
(cmsg_level, cmsg_type, cmsg_data), where cmsg_level and
cmsg_type are integers specifying the protocol level and
protocol-specific type respectively, and cmsg_data is a
bytes-like object holding the associated data.  Note that
some systems (in particular, systems without CMSG_SPACE())
might support sending only one control message per call.  The
flags argument defaults to 0 and has the same meaning as for
send().  If address is supplied and not None, it sets a
destination address for the message.  The return value is the
number of bytes of non-ancillary data sent.
The following function sends the list of file descriptors fds
over an AF_UNIX socket, on systems which support the
SCM_RIGHTS mechanism.  See also recvmsg().
import socket, array

def send_fds(sock, msg, fds):
    return sock.sendmsg([msg], [(socket.SOL_SOCKET, socket.SCM_RIGHTS, array.array("i", fds))])


Availability: most Unix platforms, possibly others.

New in version 3.3.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).

