link:
library/socket.html#socket.socket.sendmsg

docs:

<dt id="socket.socket.sendmsg">
<code class="descclassname">socket.</code><code class="descname">sendmsg</code><span class="sig-paren">(</span><em>buffers</em><span class="optional">[</span>, <em>ancdata</em><span class="optional">[</span>, <em>flags</em><span class="optional">[</span>, <em>address</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#socket.socket.sendmsg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send normal and ancillary data to the socket, gathering the
non-ancillary data from a series of buffers and concatenating it
into a single message.  The <em>buffers</em> argument specifies the
non-ancillary data as an iterable of
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>
(e.g. <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects); the operating system may set a limit
(<a class="reference internal" href="os.html#os.sysconf" title="os.sysconf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconf()</span></code></a> value <code class="docutils literal notranslate"><span class="pre">SC_IOV_MAX</span></code>) on the number of buffers
that can be used.  The <em>ancdata</em> argument specifies the ancillary
data (control messages) as an iterable of zero or more tuples
<code class="docutils literal notranslate"><span class="pre">(cmsg_level,</span> <span class="pre">cmsg_type,</span> <span class="pre">cmsg_data)</span></code>, where <em>cmsg_level</em> and
<em>cmsg_type</em> are integers specifying the protocol level and
protocol-specific type respectively, and <em>cmsg_data</em> is a
bytes-like object holding the associated data.  Note that
some systems (in particular, systems without <a class="reference internal" href="#socket.CMSG_SPACE" title="socket.CMSG_SPACE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CMSG_SPACE()</span></code></a>)
might support sending only one control message per call.  The
<em>flags</em> argument defaults to 0 and has the same meaning as for
<a class="reference internal" href="#socket.socket.send" title="socket.socket.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a>.  If <em>address</em> is supplied and not <code class="docutils literal notranslate"><span class="pre">None</span></code>, it sets a
destination address for the message.  The return value is the
number of bytes of non-ancillary data sent.</p>
<p>The following function sends the list of file descriptors <em>fds</em>
over an <a class="reference internal" href="#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> socket, on systems which support the
<code class="xref py py-const docutils literal notranslate"><span class="pre">SCM_RIGHTS</span></code> mechanism.  See also <a class="reference internal" href="#socket.socket.recvmsg" title="socket.socket.recvmsg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a>.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">array</span>

<span class="k">def</span> <span class="nf">send_fds</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">fds</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sock</span><span class="o">.</span><span class="n">sendmsg</span><span class="p">([</span><span class="n">msg</span><span class="p">],</span> <span class="p">[(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SCM_RIGHTS</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s2">"i"</span><span class="p">,</span> <span class="n">fds</span><span class="p">))])</span>
</pre></div>
</div>
<p class="availability"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: most Unix platforms, possibly others.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.5: </span>If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an <a class="reference internal" href="exceptions.html#InterruptedError" title="InterruptedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">InterruptedError</span></code></a> exception (see <span class="target" id="index-13"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a> for the rationale).</p>
</div>
</dd>