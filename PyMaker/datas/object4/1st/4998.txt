link:
library/asyncio-dev.html#concurrency-and-multithreading

docs:

Concurrency and Multithreading¶
An event loop runs in a thread (typically the main thread) and executes
all callbacks and Tasks in its thread.  While a Task is running in the
event loop, no other Tasks can run in the same thread.  When a Task
executes an await expression, the running Task gets suspended, and
the event loop executes the next Task.
To schedule a callback from a different OS thread, the
loop.call_soon_threadsafe() method should be used. Example:
loop.call_soon_threadsafe(callback, *args)


Almost all asyncio objects are not thread safe, which is typically
not a problem unless there is code that works with them from outside
of a Task or a callback.  If there’s a need for such code to call a
low-level asyncio API, the loop.call_soon_threadsafe() method
should be used, e.g.:
loop.call_soon_threadsafe(fut.cancel)


To schedule a coroutine object from a different OS thread, the
run_coroutine_threadsafe() function should be used. It returns a
concurrent.futures.Future to access the result:
async def coro_func():
     return await asyncio.sleep(1, 42)

# Later in another OS thread:

future = asyncio.run_coroutine_threadsafe(coro_func(), loop)
# Wait for the result:
result = future.result()


To handle signals and to execute subprocesses, the event loop must be
run in the main thread.
The loop.run_in_executor() method can be used with a
concurrent.futures.ThreadPoolExecutor to execute
blocking code in a different OS thread without blocking the OS thread
that the event loop runs in.
