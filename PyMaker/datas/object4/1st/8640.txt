link:
library/unittest.mock-examples.html#setting-return-values-and-attributes

docs:

Setting Return Values and Attributes¶
Setting the return values on a mock object is trivially easy:
>>> mock = Mock()
>>> mock.return_value = 3
>>> mock()
3


Of course you can do the same for methods on the mock:
>>> mock = Mock()
>>> mock.method.return_value = 3
>>> mock.method()
3


The return value can also be set in the constructor:
>>> mock = Mock(return_value=3)
>>> mock()
3


If you need an attribute setting on your mock, just do it:
>>> mock = Mock()
>>> mock.x = 3
>>> mock.x
3


Sometimes you want to mock up a more complex situation, like for example
mock.connection.cursor().execute("SELECT 1"). If we wanted this call to
return a list, then we have to configure the result of the nested call.
We can use call to construct the set of calls in a “chained call” like
this for easy assertion afterwards:
>>> mock = Mock()
>>> cursor = mock.connection.cursor.return_value
>>> cursor.execute.return_value = ['foo']
>>> mock.connection.cursor().execute("SELECT 1")
['foo']
>>> expected = call.connection.cursor().execute("SELECT 1").call_list()
>>> mock.mock_calls
[call.connection.cursor(), call.connection.cursor().execute('SELECT 1')]
>>> mock.mock_calls == expected
True


It is the call to .call_list() that turns our call object into a list of
calls representing the chained calls.
