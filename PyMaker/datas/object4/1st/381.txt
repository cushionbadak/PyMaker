link:
library/stdtypes.html#numeric-types-int-float-complex

docs:

Numeric Types — int, float, complex¶
There are three distinct numeric types: integers, floating
point numbers, and complex numbers.  In addition, Booleans are a
subtype of integers.  Integers have unlimited precision.  Floating point
numbers are usually implemented using double in C; information
about the precision and internal representation of floating point
numbers for the machine on which your program is running is available
in sys.float_info.  Complex numbers have a real and imaginary
part, which are each a floating point number.  To extract these parts
from a complex number z, use z.real and z.imag. (The standard
library includes additional numeric types, fractions that hold
rationals, and decimal that hold floating-point numbers with
user-definable precision.)
Numbers are created by numeric literals or as the result of built-in functions
and operators.  Unadorned integer literals (including hex, octal and binary
numbers) yield integers.  Numeric literals containing a decimal point or an
exponent sign yield floating point numbers.  Appending 'j' or 'J' to a
numeric literal yields an imaginary number (a complex number with a zero real
part) which you can add to an integer or float to get a complex number with real
and imaginary parts.
Python fully supports mixed arithmetic: when a binary arithmetic operator has
operands of different numeric types, the operand with the “narrower” type is
widened to that of the other, where integer is narrower than floating point,
which is narrower than complex.  Comparisons between numbers of mixed type use
the same rule. [2] The constructors int(), float(), and
complex() can be used to produce numbers of a specific type.
All numeric types (except complex) support the following operations, sorted by
ascending priority (all numeric operations have a higher priority than
comparison operations):








Operation
Result
Notes
Full documentation



x + y
sum of x and y
 
 

x - y
difference of x and y
 
 

x * y
product of x and y
 
 

x / y
quotient of x and y
 
 

x // y
floored quotient of x and
y
(1)
 

x % y
remainder of x / y
(2)
 

-x
x negated
 
 

+x
x unchanged
 
 

abs(x)
absolute value or magnitude of
x
 
abs()

int(x)
x converted to integer
(3)(6)
int()

float(x)
x converted to floating point
(4)(6)
float()

complex(re, im)
a complex number with real part
re, imaginary part im.
im defaults to zero.
(6)
complex()

c.conjugate()
conjugate of the complex number
c
 
 

divmod(x, y)
the pair (x // y, x % y)
(2)
divmod()

pow(x, y)
x to the power y
(5)
pow()

x ** y
x to the power y
(5)
 



Notes:

Also referred to as integer division.  The resultant value is a whole
integer, though the result’s type is not necessarily int.  The result is
always rounded towards minus infinity: 1//2 is 0, (-1)//2 is
-1, 1//(-2) is -1, and (-1)//(-2) is 0.

Not for complex numbers.  Instead convert to floats using abs() if
appropriate.

Conversion from floating point to integer may round or truncate
as in C; see functions math.floor() and math.ceil() for
well-defined conversions.

float also accepts the strings “nan” and “inf” with an optional prefix “+”
or “-” for Not a Number (NaN) and positive or negative infinity.

Python defines pow(0, 0) and 0 ** 0 to be 1, as is common for
programming languages.

The numeric literals accepted include the digits 0 to 9 or any
Unicode equivalent (code points with the Nd property).
See http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt
for a complete list of code points with the Nd property.


All numbers.Real types (int and float) also include
the following operations:






Operation
Result



math.trunc(x)
x truncated to Integral

round(x[,
n])
x rounded to n digits,
rounding half to even. If n is
omitted, it defaults to 0.

math.floor(x)
the greatest Integral
<= x

math.ceil(x)
the least Integral >= x



For additional numeric operations see the math and cmath
modules.

Bitwise Operations on Integer Types¶
Bitwise operations only make sense for integers. The result of bitwise
operations is calculated as though carried out in two’s complement with an
infinite number of sign bits.
The priorities of the binary bitwise operations are all lower than the numeric
operations and higher than the comparisons; the unary operation ~ has the
same priority as the other unary numeric operations (+ and -).
This table lists the bitwise operations sorted in ascending priority:







Operation
Result
Notes



x | y
bitwise or of x and
y
(4)

x ^ y
bitwise exclusive or of
x and y
(4)

x & y
bitwise and of x and
y
(4)

x << n
x shifted left by n bits
(1)(2)

x >> n
x shifted right by n bits
(1)(3)

~x
the bits of x inverted
 



Notes:

Negative shift counts are illegal and cause a ValueError to be raised.
A left shift by n bits is equivalent to multiplication by pow(2, n)
without overflow check.
A right shift by n bits is equivalent to division by pow(2, n) without
overflow check.
Performing these calculations with at least one extra sign extension bit in
a finite two’s complement representation (a working bit-width of
1 + max(x.bit_length(), y.bit_length()) or more) is sufficient to get the
same result as if there were an infinite number of sign bits.



Additional Methods on Integer Types¶
The int type implements the numbers.Integral abstract base
class. In addition, it provides a few more methods:


int.bit_length()¶
Return the number of bits necessary to represent an integer in binary,
excluding the sign and leading zeros:
>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6


More precisely, if x is nonzero, then x.bit_length() is the
unique positive integer k such that 2**(k-1) <= abs(x) < 2**k.
Equivalently, when abs(x) is small enough to have a correctly
rounded logarithm, then k = 1 + int(log(abs(x), 2)).
If x is zero, then x.bit_length() returns 0.
Equivalent to:
def bit_length(self):
    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
    s = s.lstrip('-0b') # remove leading zeros and minus sign
    return len(s)       # len('100101') --> 6



New in version 3.1.




int.to_bytes(length, byteorder, *, signed=False)¶
Return an array of bytes representing an integer.
>>> (1024).to_bytes(2, byteorder='big')
b'\x04\x00'
>>> (1024).to_bytes(10, byteorder='big')
b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
>>> (-1024).to_bytes(10, byteorder='big', signed=True)
b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
>>> x = 1000
>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')
b'\xe8\x03'


The integer is represented using length bytes.  An OverflowError
is raised if the integer is not representable with the given number of
bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is "big", the most significant byte is at the
beginning of the byte array.  If byteorder is "little", the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use sys.byteorder as the byte order
value.
The signed argument determines whether two’s complement is used to
represent the integer.  If signed is False and a negative integer is
given, an OverflowError is raised. The default value for signed
is False.

New in version 3.2.




classmethod int.from_bytes(bytes, byteorder, *, signed=False)¶
Return the integer represented by the given array of bytes.
>>> int.from_bytes(b'\x00\x10', byteorder='big')
16
>>> int.from_bytes(b'\x00\x10', byteorder='little')
4096
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
-1024
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
64512
>>> int.from_bytes([255, 0, 0], byteorder='big')
16711680


The argument bytes must either be a bytes-like object or an
iterable producing bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is "big", the most significant byte is at the
beginning of the byte array.  If byteorder is "little", the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use sys.byteorder as the byte order
value.
The signed argument indicates whether two’s complement is used to
represent the integer.

New in version 3.2.




Additional Methods on Float¶
The float type implements the numbers.Real abstract base
class. float also has the following additional methods.


float.as_integer_ratio()¶
Return a pair of integers whose ratio is exactly equal to the
original float and with a positive denominator.  Raises
OverflowError on infinities and a ValueError on
NaNs.



float.is_integer()¶
Return True if the float instance is finite with integral
value, and False otherwise:
>>> (-2.0).is_integer()
True
>>> (3.2).is_integer()
False



Two methods support conversion to
and from hexadecimal strings.  Since Python’s floats are stored
internally as binary numbers, converting a float to or from a
decimal string usually involves a small rounding error.  In
contrast, hexadecimal strings allow exact representation and
specification of floating-point numbers.  This can be useful when
debugging, and in numerical work.


float.hex()¶
Return a representation of a floating-point number as a hexadecimal
string.  For finite floating-point numbers, this representation
will always include a leading 0x and a trailing p and
exponent.



classmethod float.fromhex(s)¶
Class method to return the float represented by a hexadecimal
string s.  The string s may have leading and trailing
whitespace.

Note that float.hex() is an instance method, while
float.fromhex() is a class method.
A hexadecimal string takes the form:
[sign] ['0x'] integer ['.' fraction] ['p' exponent]


where the optional sign may by either + or -, integer
and fraction are strings of hexadecimal digits, and exponent
is a decimal integer with an optional leading sign.  Case is not
significant, and there must be at least one hexadecimal digit in
either the integer or the fraction.  This syntax is similar to the
syntax specified in section 6.4.4.2 of the C99 standard, and also to
the syntax used in Java 1.5 onwards.  In particular, the output of
float.hex() is usable as a hexadecimal floating-point literal in
C or Java code, and hexadecimal strings produced by C’s %a format
character or Java’s Double.toHexString are accepted by
float.fromhex().
Note that the exponent is written in decimal rather than hexadecimal,
and that it gives the power of 2 by which to multiply the coefficient.
For example, the hexadecimal string 0x3.a7p10 represents the
floating-point number (3 + 10./16 + 7./16**2) * 2.0**10, or
3740.0:
>>> float.fromhex('0x3.a7p10')
3740.0


Applying the reverse conversion to 3740.0 gives a different
hexadecimal string representing the same number:
>>> float.hex(3740.0)
'0x1.d380000000000p+11'




Hashing of numeric types¶
For numbers x and y, possibly of different types, it’s a requirement
that hash(x) == hash(y) whenever x == y (see the __hash__()
method documentation for more details).  For ease of implementation and
efficiency across a variety of numeric types (including int,
float, decimal.Decimal and fractions.Fraction)
Python’s hash for numeric types is based on a single mathematical function
that’s defined for any rational number, and hence applies to all instances of
int and fractions.Fraction, and all finite instances of
float and decimal.Decimal.  Essentially, this function is
given by reduction modulo P for a fixed prime P.  The value of P is
made available to Python as the modulus attribute of
sys.hash_info.

CPython implementation detail: Currently, the prime used is P = 2**31 - 1 on machines with 32-bit C
longs and P = 2**61 - 1 on machines with 64-bit C longs.

Here are the rules in detail:

If x = m / n is a nonnegative rational number and n is not divisible
by P, define hash(x) as m * invmod(n, P) % P, where invmod(n,
P) gives the inverse of n modulo P.
If x = m / n is a nonnegative rational number and n is
divisible by P (but m is not) then n has no inverse
modulo P and the rule above doesn’t apply; in this case define
hash(x) to be the constant value sys.hash_info.inf.
If x = m / n is a negative rational number define hash(x)
as -hash(-x).  If the resulting hash is -1, replace it with
-2.
The particular values sys.hash_info.inf, -sys.hash_info.inf
and sys.hash_info.nan are used as hash values for positive
infinity, negative infinity, or nans (respectively).  (All hashable
nans have the same hash value.)
For a complex number z, the hash values of the real
and imaginary parts are combined by computing hash(z.real) +
sys.hash_info.imag * hash(z.imag), reduced modulo
2**sys.hash_info.width so that it lies in
range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width -
1)).  Again, if the result is -1, it’s replaced with -2.

To clarify the above rules, here’s some example Python code,
equivalent to the built-in hash, for computing the hash of a rational
number, float, or complex:
import sys, math

def hash_fraction(m, n):
    """Compute the hash of a rational number m / n.

    Assumes m and n are integers, with n positive.
    Equivalent to hash(fractions.Fraction(m, n)).

    """
    P = sys.hash_info.modulus
    # Remove common factors of P.  (Unnecessary if m and n already coprime.)
    while m % P == n % P == 0:
        m, n = m // P, n // P

    if n % P == 0:
        hash_value = sys.hash_info.inf
    else:
        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
        # pow(n, P-2, P) gives the inverse of n modulo P.
        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
    if m < 0:
        hash_value = -hash_value
    if hash_value == -1:
        hash_value = -2
    return hash_value

def hash_float(x):
    """Compute the hash of a float x."""

    if math.isnan(x):
        return sys.hash_info.nan
    elif math.isinf(x):
        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
    else:
        return hash_fraction(*x.as_integer_ratio())

def hash_complex(z):
    """Compute the hash of a complex number z."""

    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
    # do a signed reduction modulo 2**sys.hash_info.width
    M = 2**(sys.hash_info.width - 1)
    hash_value = (hash_value & (M - 1)) - (hash_value & M)
    if hash_value == -1:
        hash_value = -2
    return hash_value



