link:
library/decimal.html#decimal.Context

docs:

<dt id="decimal.Context">
<em class="property">class </em><code class="descclassname">decimal.</code><code class="descname">Context</code><span class="sig-paren">(</span><em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new context.  If a field is not specified or is <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, the
default values are copied from the <a class="reference internal" href="#decimal.DefaultContext" title="decimal.DefaultContext"><code class="xref py py-const docutils literal notranslate"><span class="pre">DefaultContext</span></code></a>.  If the <em>flags</em>
field is not specified or is <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>, all flags are cleared.</p>
<p><em>prec</em> is an integer in the range [<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, <a class="reference internal" href="#decimal.MAX_PREC" title="decimal.MAX_PREC"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_PREC</span></code></a>] that sets
the precision for arithmetic operations in the context.</p>
<p>The <em>rounding</em> option is one of the constants listed in the section
<a class="reference internal" href="#rounding-modes">Rounding Modes</a>.</p>
<p>The <em>traps</em> and <em>flags</em> fields list any signals to be set. Generally, new
contexts should only set traps and leave the flags clear.</p>
<p>The <em>Emin</em> and <em>Emax</em> fields are integers specifying the outer limits allowable
for exponents. <em>Emin</em> must be in the range [<a class="reference internal" href="#decimal.MIN_EMIN" title="decimal.MIN_EMIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MIN_EMIN</span></code></a>, <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>],
<em>Emax</em> in the range [<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>, <a class="reference internal" href="#decimal.MAX_EMAX" title="decimal.MAX_EMAX"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAX_EMAX</span></code></a>].</p>
<p>The <em>capitals</em> field is either <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> (the default). If set to
<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, exponents are printed with a capital <code class="xref py py-const docutils literal notranslate"><span class="pre">E</span></code>; otherwise, a
lowercase <code class="xref py py-const docutils literal notranslate"><span class="pre">e</span></code> is used: <code class="xref py py-const docutils literal notranslate"><span class="pre">Decimal('6.02e+23')</span></code>.</p>
<p>The <em>clamp</em> field is either <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> (the default) or <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>.
If set to <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, the exponent <code class="docutils literal notranslate"><span class="pre">e</span></code> of a <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>
instance representable in this context is strictly limited to the
range <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.  If <em>clamp</em> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code> then a weaker condition holds: the adjusted exponent of
the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance is at most <code class="docutils literal notranslate"><span class="pre">Emax</span></code>.  When <em>clamp</em> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code>, a large normal number will, where possible, have its
exponent reduced and a corresponding number of zeros added to its
coefficient, in order to fit the exponent constraints; this
preserves the value of the number but loses information about
significant trailing zeros.  For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">clamp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">create_decimal</span><span class="p">(</span><span class="s1">'1.23e999'</span><span class="p">)</span>
<span class="go">Decimal('1.23000E+999')</span>
</pre></div>
</div>
<p>A <em>clamp</em> value of <code class="xref py py-const docutils literal notranslate"><span class="pre">1</span></code> allows compatibility with the
fixed-width decimal interchange formats specified in IEEE 754.</p>
<p>The <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> class defines several general purpose methods as well as
a large number of methods for doing arithmetic directly in a given context.
In addition, for each of the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> methods described above (with
the exception of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">adjusted()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code> methods) there is
a corresponding <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method.  For example, for a <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
instance <code class="docutils literal notranslate"><span class="pre">C</span></code> and <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> instance <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">C.exp(x)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">x.exp(context=C)</span></code>.  Each <a class="reference internal" href="#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> method accepts a
Python integer (an instance of <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) anywhere that a
Decimal instance is accepted.</p>
<dl class="method">
<dt id="decimal.Context.clear_flags">
<code class="descname">clear_flags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all of the flags to <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.clear_traps">
<code class="descname">clear_traps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.clear_traps" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all of the traps to <code class="xref py py-const docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a duplicate of the context.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.copy_decimal">
<code class="descname">copy_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_decimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the Decimal instance num.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.create_decimal">
<code class="descname">create_decimal</code><span class="sig-paren">(</span><em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new Decimal instance from <em>num</em> but using <em>self</em> as
context. Unlike the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> constructor, the context precision,
rounding method, flags, and traps are applied to the conversion.</p>
<p>This is useful because constants are often given to a greater precision
than is needed by the application.  Another benefit is that rounding
immediately eliminates unintended effects from digits beyond the current
precision. In the following example, using unrounded inputs means that
adding zero to a sum can change the result:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.4445'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.0023'</span><span class="p">)</span>
<span class="go">Decimal('4.45')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'3.4445'</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'1.0023'</span><span class="p">)</span>
<span class="go">Decimal('4.44')</span>
</pre></div>
</div>
<p>This method implements the to-number operation of the IBM specification.
If the argument is a string, no leading or trailing whitespace or
underscores are permitted.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.create_decimal_from_float">
<code class="descname">create_decimal_from_float</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.create_decimal_from_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new Decimal instance from a float <em>f</em> but rounding using <em>self</em>
as the context.  Unlike the <a class="reference internal" href="#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.from_float()</span></code></a> class method,
the context precision, rounding method, flags, and traps are applied to
the conversion.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">rounding</span><span class="o">=</span><span class="n">ROUND_DOWN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">Decimal('3.1415')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span> <span class="o">=</span> <span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">traps</span><span class="o">=</span><span class="p">[</span><span class="n">Inexact</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">context</span><span class="o">.</span><span class="n">create_decimal_from_float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">decimal.Inexact</span>: <span class="n">None</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.1.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.Etiny">
<code class="descname">Etiny</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etiny" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value equal to <code class="docutils literal notranslate"><span class="pre">Emin</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code> which is the minimum exponent
value for subnormal results.  When underflow occurs, the exponent is set
to <a class="reference internal" href="#decimal.Context.Etiny" title="decimal.Context.Etiny"><code class="xref py py-const docutils literal notranslate"><span class="pre">Etiny</span></code></a>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.Etop">
<code class="descname">Etop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.Etop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value equal to <code class="docutils literal notranslate"><span class="pre">Emax</span> <span class="pre">-</span> <span class="pre">prec</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</dd></dl>
<p>The usual approach to working with decimals is to create <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a>
instances and then apply arithmetic operations which take place within the
current context for the active thread.  An alternative approach is to use
context methods for calculating within a specific context.  The methods are
similar to those for the <a class="reference internal" href="#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> class and are only briefly
recounted here.</p>
<dl class="method">
<dt id="decimal.Context.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute value of <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of <em>x</em> and <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.canonical">
<code class="descname">canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.canonical" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the same Decimal object <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.compare">
<code class="descname">compare</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares <em>x</em> and <em>y</em> numerically.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.compare_signal">
<code class="descname">compare_signal</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the values of the two operands numerically.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.compare_total">
<code class="descname">compare_total</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two operands using their abstract representation.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.compare_total_mag">
<code class="descname">compare_total_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.compare_total_mag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two operands using their abstract representation, ignoring sign.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.copy_abs">
<code class="descname">copy_abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of <em>x</em> with the sign set to 0.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.copy_negate">
<code class="descname">copy_negate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of <em>x</em> with the sign inverted.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.copy_sign">
<code class="descname">copy_sign</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.copy_sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the sign from <em>y</em> to <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.divide">
<code class="descname">divide</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>x</em> divided by <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.divide_int">
<code class="descname">divide_int</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divide_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>x</em> divided by <em>y</em>, truncated to an integer.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.divmod">
<code class="descname">divmod</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.divmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides two numbers and returns the integer part of the result.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>e ** x</cite>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.fma">
<code class="descname">fma</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.fma" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>x</em> multiplied by <em>y</em>, plus <em>z</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_canonical">
<code class="descname">is_canonical</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_canonical" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is canonical; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_finite">
<code class="descname">is_finite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is finite; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_infinite">
<code class="descname">is_infinite</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_infinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is infinite; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_nan">
<code class="descname">is_nan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_nan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is a qNaN or sNaN; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is a normal number; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_qnan">
<code class="descname">is_qnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_qnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is a quiet NaN; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_signed">
<code class="descname">is_signed</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_signed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is negative; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_snan">
<code class="descname">is_snan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_snan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is a signaling NaN; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_subnormal">
<code class="descname">is_subnormal</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_subnormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is subnormal; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.is_zero">
<code class="descname">is_zero</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.is_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>x</em> is a zero; otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.ln">
<code class="descname">ln</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.ln" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the natural (base e) logarithm of <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the base 10 logarithm of <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.logb">
<code class="descname">logb</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the exponent of the magnitude of the operand’s MSD.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.logical_and">
<code class="descname">logical_and</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the logical operation <em>and</em> between each operand’s digits.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.logical_invert">
<code class="descname">logical_invert</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert all the digits in <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.logical_or">
<code class="descname">logical_or</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the logical operation <em>or</em> between each operand’s digits.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.logical_xor">
<code class="descname">logical_xor</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the logical operation <em>xor</em> between each operand’s digits.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two values numerically and returns the maximum.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.max_mag">
<code class="descname">max_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.max_mag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the values numerically with their sign ignored.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two values numerically and returns the minimum.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.min_mag">
<code class="descname">min_mag</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.min_mag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the values numerically with their sign ignored.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.minus">
<code class="descname">minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Minus corresponds to the unary prefix minus operator in Python.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of <em>x</em> and <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.next_minus">
<code class="descname">next_minus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the largest representable number smaller than <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.next_plus">
<code class="descname">next_plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the smallest representable number larger than <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.next_toward">
<code class="descname">next_toward</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.next_toward" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number closest to <em>x</em>, in direction towards <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces <em>x</em> to its simplest form.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.number_class">
<code class="descname">number_class</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.number_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an indication of the class of <em>x</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.plus">
<code class="descname">plus</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Plus corresponds to the unary prefix plus operator in Python.  This
operation applies the context precision and rounding, so it is <em>not</em> an
identity operation.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.power">
<code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">x</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">y</span></code>, reduced modulo <code class="docutils literal notranslate"><span class="pre">modulo</span></code> if given.</p>
<p>With two arguments, compute <code class="docutils literal notranslate"><span class="pre">x**y</span></code>.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is negative then <code class="docutils literal notranslate"><span class="pre">y</span></code>
must be integral.  The result will be inexact unless <code class="docutils literal notranslate"><span class="pre">y</span></code> is integral and
the result is finite and can be expressed exactly in ‘precision’ digits.
The rounding mode of the context is used. Results are always correctly-rounded
in the Python version.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>The C module computes <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> in terms of the correctly-rounded
<a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> functions. The result is well-defined but
only “almost always correctly-rounded”.</p>
</div>
<p>With three arguments, compute <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code>.  For the three argument
form, the following restrictions on the arguments hold:</p>
<blockquote>
<div><ul class="simple">
<li>all three arguments must be integral</li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> must be nonnegative</li>
<li>at least one of <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> must be nonzero</li>
<li><code class="docutils literal notranslate"><span class="pre">modulo</span></code> must be nonzero and have at most ‘precision’ digits</li>
</ul>
</div></blockquote>
<p>The value resulting from <code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> is
equal to the value that would be obtained by computing <code class="docutils literal notranslate"><span class="pre">(x**y)</span>
<span class="pre">%</span> <span class="pre">modulo</span></code> with unbounded precision, but is computed more
efficiently.  The exponent of the result is zero, regardless of
the exponents of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">modulo</span></code>.  The result is
always exact.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.quantize">
<code class="descname">quantize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value equal to <em>x</em> (rounded), having the exponent of <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.radix">
<code class="descname">radix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.radix" title="Permalink to this definition">¶</a></dt>
<dd><p>Just returns 10, as this is Decimal, :)</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.remainder">
<code class="descname">remainder</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the remainder from integer division.</p>
<p>The sign of the result, if non-zero, is the same as that of the original
dividend.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.remainder_near">
<code class="descname">remainder_near</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.remainder_near" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">n</span></code>, where <em>n</em> is the integer nearest the exact value
of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">y</span></code> (if the result is 0 then its sign will be the sign of <em>x</em>).</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotated copy of <em>x</em>, <em>y</em> times.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.same_quantum">
<code class="descname">same_quantum</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.same_quantum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the two operands have the same exponent.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.scaleb">
<code class="descname">scaleb</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.scaleb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first operand after adding the second value its exp.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a shifted copy of <em>x</em>, <em>y</em> times.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Square root of a non-negative number to context precision.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.subtract">
<code class="descname">subtract</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the difference between <em>x</em> and <em>y</em>.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.to_eng_string">
<code class="descname">to_eng_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_eng_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a string, using engineering notation if an exponent is needed.</p>
<p>Engineering notation has an exponent which is a multiple of 3.  This
can leave up to 3 digits to the left of the decimal place and may
require the addition of either one or two trailing zeros.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.to_integral_exact">
<code class="descname">to_integral_exact</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_integral_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds to an integer.</p>
</dd></dl>
<dl class="method">
<dt id="decimal.Context.to_sci_string">
<code class="descname">to_sci_string</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.to_sci_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a number to a string using scientific notation.</p>
</dd></dl>
</dd>