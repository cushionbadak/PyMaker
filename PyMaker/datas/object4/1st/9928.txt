link:
library/tokenize.html#tokenizing-input

docs:

Tokenizing Input¶
The primary entry point is a generator:


tokenize.tokenize(readline)¶
The tokenize() generator requires one argument, readline, which
must be a callable object which provides the same interface as the
io.IOBase.readline() method of file objects.  Each call to the
function should return one line of input as bytes.
The generator produces 5-tuples with these members: the token type; the
token string; a 2-tuple (srow, scol) of ints specifying the row and
column where the token begins in the source; a 2-tuple (erow, ecol) of
ints specifying the row and column where the token ends in the source; and
the line on which the token was found. The line passed (the last tuple item)
is the logical line; continuation lines are included.  The 5 tuple is
returned as a named tuple with the field names:
type string start end line.
The returned named tuple has an additional property named
exact_type that contains the exact operator type for
OP tokens.  For all other token types exact_type
equals the named tuple type field.

Changed in version 3.1: Added support for named tuples.


Changed in version 3.3: Added support for exact_type.

tokenize() determines the source encoding of the file by looking for a
UTF-8 BOM or encoding cookie, according to PEP 263.

All constants from the token module are also exported from
tokenize.
Another function is provided to reverse the tokenization process. This is
useful for creating tools that tokenize a script, modify the token stream, and
write back the modified script.


tokenize.untokenize(iterable)¶
Converts tokens back into Python source code.  The iterable must return
sequences with at least two elements, the token type and the token string.
Any additional sequence elements are ignored.
The reconstructed script is returned as a single string.  The result is
guaranteed to tokenize back to match the input so that the conversion is
lossless and round-trips are assured.  The guarantee applies only to the
token type and token string as the spacing between tokens (column
positions) may change.
It returns bytes, encoded using the ENCODING token, which
is the first token sequence output by tokenize().

tokenize() needs to detect the encoding of source files it tokenizes. The
function it uses to do this is available:


tokenize.detect_encoding(readline)¶
The detect_encoding() function is used to detect the encoding that
should be used to decode a Python source file. It requires one argument,
readline, in the same way as the tokenize() generator.
It will call readline a maximum of twice, and return the encoding used
(as a string) and a list of any lines (not decoded from bytes) it has read
in.
It detects the encoding from the presence of a UTF-8 BOM or an encoding
cookie as specified in PEP 263. If both a BOM and a cookie are present,
but disagree, a SyntaxError will be raised. Note that if the BOM is found,
'utf-8-sig' will be returned as an encoding.
If no encoding is specified, then the default of 'utf-8' will be
returned.
Use open() to open Python source files: it uses
detect_encoding() to detect the file encoding.



tokenize.open(filename)¶
Open a file in read only mode using the encoding detected by
detect_encoding().

New in version 3.2.




exception tokenize.TokenError¶
Raised when either a docstring or expression that may be split over several
lines is not completed anywhere in the file, for example:
"""Beginning of
docstring


or:
[1,
 2,
 3



Note that unclosed single-quoted strings do not cause an error to be
raised. They are tokenized as ERRORTOKEN, followed by the
tokenization of their contents.
