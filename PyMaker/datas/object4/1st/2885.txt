link:
library/secrets.html#generating-tokens

docs:

Generating tokens¶
The secrets module provides functions for generating secure
tokens, suitable for applications such as password resets,
hard-to-guess URLs, and similar.


secrets.token_bytes([nbytes=None])¶
Return a random byte string containing nbytes number of bytes.
If nbytes is None or not supplied, a reasonable default is
used.
>>> token_bytes(16)  
b'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'





secrets.token_hex([nbytes=None])¶
Return a random text string, in hexadecimal.  The string has nbytes
random bytes, each byte converted to two hex digits.  If nbytes is
None or not supplied, a reasonable default is used.
>>> token_hex(16)  
'f9bf78b9a18ce6d46a0cd2b0b86df9da'





secrets.token_urlsafe([nbytes=None])¶
Return a random URL-safe text string, containing nbytes random
bytes.  The text is Base64 encoded, so on average each byte results
in approximately 1.3 characters.  If nbytes is None or not
supplied, a reasonable default is used.
>>> token_urlsafe(16)  
'Drmhze6EPcv0fN_81Bj-nA'




How many bytes should tokens use?¶
To be secure against
brute-force attacks,
tokens need to have sufficient randomness.  Unfortunately, what is
considered sufficient will necessarily increase as computers get more
powerful and able to make more guesses in a shorter period.  As of 2015,
it is believed that 32 bytes (256 bits) of randomness is sufficient for
the typical use-case expected for the secrets module.
For those who want to manage their own token length, you can explicitly
specify how much randomness is used for tokens by giving an int
argument to the various token_* functions.  That argument is taken
as the number of bytes of randomness to use.
Otherwise, if no argument is provided, or if the argument is None,
the token_* functions will use a reasonable default instead.

Note
That default is subject to change at any time, including during
maintenance releases.


