link:
library/struct.html#format-characters

docs:

Format Characters¶
Format characters have the following meaning; the conversion between C and
Python values should be obvious given their types.  The ‘Standard size’ column
refers to the size of the packed value in bytes when using standard size; that
is, when the format string starts with one of '<', '>', '!' or
'='.  When using native size, the size of the packed value is
platform-dependent.









Format
C Type
Python type
Standard size
Notes



x
pad byte
no value
 
 

c
char
bytes of length 1
1
 

b
signed char
integer
1
(1),(3)

B
unsigned char
integer
1
(3)

?
_Bool
bool
1
(1)

h
short
integer
2
(3)

H
unsigned short
integer
2
(3)

i
int
integer
4
(3)

I
unsigned int
integer
4
(3)

l
long
integer
4
(3)

L
unsigned long
integer
4
(3)

q
long long
integer
8
(2), (3)

Q
unsigned long
long
integer
8
(2), (3)

n
ssize_t
integer
 
(4)

N
size_t
integer
 
(4)

e
(7)
float
2
(5)

f
float
float
4
(5)

d
double
float
8
(5)

s
char[]
bytes
 
 

p
char[]
bytes
 
 

P
void *
integer
 
(6)




Changed in version 3.3: Added support for the 'n' and 'N' formats.


Changed in version 3.6: Added support for the 'e' format.

Notes:

The '?' conversion code corresponds to the _Bool type defined by
C99. If this type is not available, it is simulated using a char. In
standard mode, it is always represented by one byte.

The 'q' and 'Q' conversion codes are available in native mode only if
the platform C compiler supports C long long, or, on Windows,
__int64.  They are always available in standard modes.

When attempting to pack a non-integer using any of the integer conversion
codes, if the non-integer has a __index__() method then that method is
called to convert the argument to an integer before packing.

Changed in version 3.2: Use of the __index__() method for non-integers is new in 3.2.


The 'n' and 'N' conversion codes are only available for the native
size (selected as the default or with the '@' byte order character).
For the standard size, you can use whichever of the other integer formats
fits your application.

For the 'f', 'd' and 'e' conversion codes, the packed
representation uses the IEEE 754 binary32, binary64 or binary16 format (for
'f', 'd' or 'e' respectively), regardless of the floating-point
format used by the platform.

The 'P' format character is only available for the native byte ordering
(selected as the default or with the '@' byte order character). The byte
order character '=' chooses to use little- or big-endian ordering based
on the host system. The struct module does not interpret this as native
ordering, so the 'P' format is not available.

The IEEE 754 binary16 “half precision” type was introduced in the 2008
revision of the IEEE 754 standard. It has a sign
bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored),
and can represent numbers between approximately 6.1e-05 and 6.5e+04
at full precision. This type is not widely supported by C compilers: on a
typical machine, an unsigned short can be used for storage, but not for math
operations. See the Wikipedia page on the half-precision floating-point
format for more information.


A format character may be preceded by an integral repeat count.  For example,
the format string '4h' means exactly the same as 'hhhh'.
Whitespace characters between formats are ignored; a count and its format must
not contain whitespace though.
For the 's' format character, the count is interpreted as the length of the
bytes, not a repeat count like for the other format characters; for example,
'10s' means a single 10-byte string, while '10c' means 10 characters.
If a count is not given, it defaults to 1.  For packing, the string is
truncated or padded with null bytes as appropriate to make it fit. For
unpacking, the resulting bytes object always has exactly the specified number
of bytes.  As a special case, '0s' means a single, empty string (while
'0c' means 0 characters).
When packing a value x using one of the integer formats ('b',
'B', 'h', 'H', 'i', 'I', 'l', 'L',
'q', 'Q'), if x is outside the valid range for that format
then struct.error is raised.

Changed in version 3.1: In 3.0, some of the integer formats wrapped out-of-range values and
raised DeprecationWarning instead of struct.error.

The 'p' format character encodes a “Pascal string”, meaning a short
variable-length string stored in a fixed number of bytes, given by the count.
The first byte stored is the length of the string, or 255, whichever is
smaller.  The bytes of the string follow.  If the string passed in to
pack() is too long (longer than the count minus 1), only the leading
count-1 bytes of the string are stored.  If the string is shorter than
count-1, it is padded with null bytes so that exactly count bytes in all
are used.  Note that for unpack(), the 'p' format character consumes
count bytes, but that the string returned can never contain more than 255
bytes.
For the '?' format character, the return value is either True or
False. When packing, the truth value of the argument object is used.
Either 0 or 1 in the native or standard bool representation will be packed, and
any non-zero value will be True when unpacking.
