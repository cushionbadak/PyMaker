link:
library/asyncio-stream.html#asyncio.StreamReader

docs:

<dt id="asyncio.StreamReader">
<em class="property">class </em><code class="descclassname">asyncio.</code><code class="descname">StreamReader</code><a class="headerlink" href="#asyncio.StreamReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a reader object that provides APIs to read data
from the IO stream.</p>
<p>It is not recommended to instantiate <em>StreamReader</em> objects
directly; use <a class="reference internal" href="#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> and <a class="reference internal" href="#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>
instead.</p>
<dl class="method">
<dt id="asyncio.StreamReader.read">
<em class="property">coroutine </em><code class="descname">read</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.StreamReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read up to <em>n</em> bytes.  If <em>n</em> is not provided, or set to <code class="docutils literal notranslate"><span class="pre">-1</span></code>,
read until EOF and return all read bytes.</p>
<p>If EOF was received and the internal buffer is empty,
return an empty <code class="docutils literal notranslate"><span class="pre">bytes</span></code> object.</p>
</dd></dl>
<dl class="method">
<dt id="asyncio.StreamReader.readline">
<em class="property">coroutine </em><code class="descname">readline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.StreamReader.readline" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one line, where “line” is a sequence of bytes
ending with <code class="docutils literal notranslate"><span class="pre">\n</span></code>.</p>
<p>If EOF is received and <code class="docutils literal notranslate"><span class="pre">\n</span></code> was not found, the method
returns partially read data.</p>
<p>If EOF is received and the internal buffer is empty,
return an empty <code class="docutils literal notranslate"><span class="pre">bytes</span></code> object.</p>
</dd></dl>
<dl class="method">
<dt id="asyncio.StreamReader.readexactly">
<em class="property">coroutine </em><code class="descname">readexactly</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.StreamReader.readexactly" title="Permalink to this definition">¶</a></dt>
<dd><p>Read exactly <em>n</em> bytes.</p>
<p>Raise an <a class="reference internal" href="asyncio-exceptions.html#asyncio.IncompleteReadError" title="asyncio.IncompleteReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IncompleteReadError</span></code></a> if EOF is reached before <em>n</em>
can be read.  Use the <a class="reference internal" href="asyncio-exceptions.html#asyncio.IncompleteReadError.partial" title="asyncio.IncompleteReadError.partial"><code class="xref py py-attr docutils literal notranslate"><span class="pre">IncompleteReadError.partial</span></code></a>
attribute to get the partially read data.</p>
</dd></dl>
<dl class="method">
<dt id="asyncio.StreamReader.readuntil">
<em class="property">coroutine </em><code class="descname">readuntil</code><span class="sig-paren">(</span><em>separator=b'\n'</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.StreamReader.readuntil" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from the stream until <em>separator</em> is found.</p>
<p>On success, the data and separator will be removed from the
internal buffer (consumed). Returned data will include the
separator at the end.</p>
<p>If the amount of data read exceeds the configured stream limit, a
<a class="reference internal" href="asyncio-exceptions.html#asyncio.LimitOverrunError" title="asyncio.LimitOverrunError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LimitOverrunError</span></code></a> exception is raised, and the data
is left in the internal buffer and can be read again.</p>
<p>If EOF is reached before the complete separator is found,
an <a class="reference internal" href="asyncio-exceptions.html#asyncio.IncompleteReadError" title="asyncio.IncompleteReadError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IncompleteReadError</span></code></a> exception is raised, and the internal
buffer is reset.  The <a class="reference internal" href="asyncio-exceptions.html#asyncio.IncompleteReadError.partial" title="asyncio.IncompleteReadError.partial"><code class="xref py py-attr docutils literal notranslate"><span class="pre">IncompleteReadError.partial</span></code></a> attribute
may contain a portion of the separator.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.5.2.</span></p>
</div>
</dd></dl>
<dl class="method">
<dt id="asyncio.StreamReader.at_eof">
<code class="descname">at_eof</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.StreamReader.at_eof" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the buffer is empty and <code class="xref py py-meth docutils literal notranslate"><span class="pre">feed_eof()</span></code>
was called.</p>
</dd></dl>
</dd>