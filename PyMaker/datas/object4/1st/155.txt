link:
reference/datamodel.html#coroutines

docs:

3.4. Coroutines¶

3.4.1. Awaitable Objects¶
An awaitable object generally implements an __await__() method.
Coroutine objects returned from async def functions
are awaitable.

Note
The generator iterator objects returned from generators
decorated with types.coroutine() or asyncio.coroutine()
are also awaitable, but they do not implement __await__().



object.__await__(self)¶
Must return an iterator.  Should be used to implement
awaitable objects.  For instance, asyncio.Future implements
this method to be compatible with the await expression.


New in version 3.5.


See also
PEP 492 for additional information about awaitable objects.



3.4.2. Coroutine Objects¶
Coroutine objects are awaitable objects.
A coroutine’s execution can be controlled by calling __await__() and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises StopIteration, and the exception’s
value attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled StopIteration exceptions.
Coroutines also have the methods listed below, which are analogous to
those of generators (see Generator-iterator methods).  However, unlike
generators, coroutines do not directly support iteration.

Changed in version 3.5.2: It is a RuntimeError to await on a coroutine more than once.



coroutine.send(value)¶
Starts or resumes execution of the coroutine.  If value is None,
this is equivalent to advancing the iterator returned by
__await__().  If value is not None, this method delegates
to the send() method of the iterator that caused
the coroutine to suspend.  The result (return value,
StopIteration, or other exception) is the same as when
iterating over the __await__() return value, described above.



coroutine.throw(type[, value[, traceback]])¶
Raises the specified exception in the coroutine.  This method delegates
to the throw() method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, StopIteration, or other exception) is the same as
when iterating over the __await__() return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.



coroutine.close()¶
Causes the coroutine to clean itself up and exit.  If the coroutine
is suspended, this method first delegates to the close()
method of the iterator that caused the coroutine to suspend, if it
has such a method.  Then it raises GeneratorExit at the
suspension point, causing the coroutine to immediately clean itself up.
Finally, the coroutine is marked as having finished executing, even if
it was never started.
Coroutine objects are automatically closed using the above process when
they are about to be destroyed.



3.4.3. Asynchronous Iterators¶
An asynchronous iterator can call asynchronous code in
its __anext__ method.
Asynchronous iterators can be used in an async for statement.


object.__aiter__(self)¶
Must return an asynchronous iterator object.



object.__anext__(self)¶
Must return an awaitable resulting in a next value of the iterator.  Should
raise a StopAsyncIteration error when the iteration is over.

An example of an asynchronous iterable object:
class Reader:
    async def readline(self):
        ...

    def __aiter__(self):
        return self

    async def __anext__(self):
        val = await self.readline()
        if val == b'':
            raise StopAsyncIteration
        return val



New in version 3.5.


Changed in version 3.7: Prior to Python 3.7, __aiter__ could return an awaitable
that would resolve to an
asynchronous iterator.
Starting with Python 3.7, __aiter__ must return an
asynchronous iterator object.  Returning anything else
will result in a TypeError error.



3.4.4. Asynchronous Context Managers¶
An asynchronous context manager is a context manager that is able to
suspend execution in its __aenter__ and __aexit__ methods.
Asynchronous context managers can be used in an async with statement.


object.__aenter__(self)¶
This method is semantically similar to the __enter__(), with only
difference that it must return an awaitable.



object.__aexit__(self, exc_type, exc_value, traceback)¶
This method is semantically similar to the __exit__(), with only
difference that it must return an awaitable.

An example of an asynchronous context manager class:
class AsyncContextManager:
    async def __aenter__(self):
        await log('entering context')

    async def __aexit__(self, exc_type, exc, tb):
        await log('exiting context')



New in version 3.5.

Footnotes



[1]It is possible in some cases to change an object’s type, under certain
controlled conditions. It generally isn’t a good idea though, since it can
lead to some very strange behaviour if it is handled incorrectly.





[2]The __hash__(), __iter__(), __reversed__(), and
__contains__() methods have special handling for this; others
will still raise a TypeError, but may do so by relying on
the behavior that None is not callable.





[3]“Does not support” here means that the class has no such method, or
the method returns NotImplemented.  Do not set the method to
None if you want to force fallback to the right operand’s reflected
method—that will instead have the opposite effect of explicitly
blocking such fallback.





[4]For operands of the same type, it is assumed that if the non-reflected method
(such as __add__()) fails the operation is not supported, which is why the
reflected method is not called.



