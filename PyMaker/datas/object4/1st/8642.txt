link:
library/unittest.mock-examples.html#side-effect-functions-and-iterables

docs:

Side effect functions and iterablesÂ¶
side_effect can also be set to a function or an iterable. The use case for
side_effect as an iterable is where your mock is going to be called several
times, and you want each call to return a different value. When you set
side_effect to an iterable every call to the mock returns the next value
from the iterable:
>>> mock = MagicMock(side_effect=[4, 5, 6])
>>> mock()
4
>>> mock()
5
>>> mock()
6


For more advanced use cases, like dynamically varying the return values
depending on what the mock is called with, side_effect can be a function.
The function will be called with the same arguments as the mock. Whatever the
function returns is what the call returns:
>>> vals = {(1, 2): 1, (2, 3): 2}
>>> def side_effect(*args):
...     return vals[args]
...
>>> mock = MagicMock(side_effect=side_effect)
>>> mock(1, 2)
1
>>> mock(2, 3)
2


