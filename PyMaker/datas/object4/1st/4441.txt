link:
library/subprocess.html#subprocess.run

docs:


subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None)¶
Run the command described by args.  Wait for command to complete, then
return a CompletedProcess instance.
The arguments shown above are merely the most common ones, described below
in Frequently Used Arguments (hence the use of keyword-only notation
in the abbreviated signature). The full function signature is largely the
same as that of the Popen constructor - most of the arguments to
this function are passed through to that interface. (timeout,  input,
check, and capture_output are not.)
If capture_output is true, stdout and stderr will be captured.
When used, the internal Popen object is automatically created with
stdout=PIPE and stderr=PIPE. The stdout and stderr arguments may
not be supplied at the same time as capture_output.  If you wish to capture
and combine both streams into one, use stdout=PIPE and stderr=STDOUT
instead of capture_output.
The timeout argument is passed to Popen.communicate(). If the timeout
expires, the child process will be killed and waited for.  The
TimeoutExpired exception will be re-raised after the child process
has terminated.
The input argument is passed to Popen.communicate() and thus to the
subprocess’s stdin.  If used it must be a byte sequence, or a string if
encoding or errors is specified or text is true.  When
used, the internal Popen object is automatically created with
stdin=PIPE, and the stdin argument may not be used as well.
If check is true, and the process exits with a non-zero exit code, a
CalledProcessError exception will be raised. Attributes of that
exception hold the arguments, the exit code, and stdout and stderr if they
were captured.
If encoding or errors are specified, or text is true,
file objects for stdin, stdout and stderr are opened in text mode using the
specified encoding and errors or the io.TextIOWrapper default.
The universal_newlines argument is equivalent  to text and is provided
for backwards compatibility. By default, file objects are opened in binary mode.
If env is not None, it must be a mapping that defines the environment
variables for the new process; these are used instead of the default
behavior of inheriting the current process’ environment. It is passed directly
to Popen.
Examples:
>>> subprocess.run(["ls", "-l"])  # doesn't capture output
CompletedProcess(args=['ls', '-l'], returncode=0)

>>> subprocess.run("exit 1", shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1

>>> subprocess.run(["ls", "-l", "/dev/null"], capture_output=True)
CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,
stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n', stderr=b'')



New in version 3.5.


Changed in version 3.6: Added encoding and errors parameters


Changed in version 3.7: Added the text parameter, as a more understandable alias of universal_newlines.
Added the capture_output parameter.

