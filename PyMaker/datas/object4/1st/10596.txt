link:
library/imp.html#imp.find_module

docs:

<dt id="imp.find_module">
<code class="descclassname">imp.</code><code class="descname">find_module</code><span class="sig-paren">(</span><em>name</em><span class="optional">[</span>, <em>path</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#imp.find_module" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Try to find the module <em>name</em>.  If <em>path</em> is omitted or <code class="docutils literal notranslate"><span class="pre">None</span></code>, the list of
directory names given by <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> is searched, but first a few special
places are searched: the function tries to find a built-in module with the
given name (<a class="reference internal" href="#imp.C_BUILTIN" title="imp.C_BUILTIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">C_BUILTIN</span></code></a>), then a frozen module (<a class="reference internal" href="#imp.PY_FROZEN" title="imp.PY_FROZEN"><code class="xref py py-const docutils literal notranslate"><span class="pre">PY_FROZEN</span></code></a>),
and on some systems some other places are looked in as well (on Windows, it
looks in the registry which may point to a specific file).</p>
<p>Otherwise, <em>path</em> must be a list of directory names; each directory is
searched for files with any of the suffixes returned by <a class="reference internal" href="#imp.get_suffixes" title="imp.get_suffixes"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_suffixes()</span></code></a>
above.  Invalid names in the list are silently ignored (but all list items
must be strings).</p>
<p>If search is successful, the return value is a 3-element tuple <code class="docutils literal notranslate"><span class="pre">(file,</span>
<span class="pre">pathname,</span> <span class="pre">description)</span></code>:</p>
<p><em>file</em> is an open <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> positioned at the beginning, <em>pathname</em>
is the pathname of the file found, and <em>description</em> is a 3-element tuple as
contained in the list returned by <a class="reference internal" href="#imp.get_suffixes" title="imp.get_suffixes"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_suffixes()</span></code></a> describing the kind of
module found.</p>
<p>If the module does not live in a file, the returned <em>file</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<em>pathname</em> is the empty string, and the <em>description</em> tuple contains empty
strings for its suffix and mode; the module type is indicated as given in
parentheses above.  If the search is unsuccessful, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is
raised.  Other exceptions indicate problems with the arguments or
environment.</p>
<p>If the module is a package, <em>file</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <em>pathname</em> is the package
path and the last item in the <em>description</em> tuple is <a class="reference internal" href="#imp.PKG_DIRECTORY" title="imp.PKG_DIRECTORY"><code class="xref py py-const docutils literal notranslate"><span class="pre">PKG_DIRECTORY</span></code></a>.</p>
<p>This function does not handle hierarchical module names (names containing
dots).  In order to find <em>P.M</em>, that is, submodule <em>M</em> of package <em>P</em>, use
<a class="reference internal" href="#imp.find_module" title="imp.find_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_module()</span></code></a> and <a class="reference internal" href="#imp.load_module" title="imp.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">load_module()</span></code></a> to find and load package <em>P</em>, and
then use <a class="reference internal" href="#imp.find_module" title="imp.find_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_module()</span></code></a> with the <em>path</em> argument set to <code class="docutils literal notranslate"><span class="pre">P.__path__</span></code>.
When <em>P</em> itself has a dotted name, apply this recipe recursively.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 3.3: </span>Use <a class="reference internal" href="importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> instead unless Python 3.3
compatibility is required, in which case use
<a class="reference internal" href="importlib.html#importlib.find_loader" title="importlib.find_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.find_loader()</span></code></a>. For example usage of the former case,
see the <a class="reference internal" href="importlib.html#importlib-examples"><span class="std std-ref">Examples</span></a> section of the <a class="reference internal" href="importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a>
documentation.</p>
</div>
</dd>