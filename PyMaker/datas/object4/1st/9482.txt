link:
library/inspect.html#introspecting-callables-with-the-signature-object

docs:

Introspecting callables with the Signature object¶

New in version 3.3.

The Signature object represents the call signature of a callable object and its
return annotation.  To retrieve a Signature object, use the signature()
function.


inspect.signature(callable, *, follow_wrapped=True)¶
Return a Signature object for the given callable:
>>> from inspect import signature
>>> def foo(a, *, b:int, **kwargs):
...     pass

>>> sig = signature(foo)

>>> str(sig)
'(a, *, b:int, **kwargs)'

>>> str(sig.parameters['b'])
'b:int'

>>> sig.parameters['b'].annotation
<class 'int'>


Accepts a wide range of Python callables, from plain functions and classes to
functools.partial() objects.
Raises ValueError if no signature can be provided, and
TypeError if that type of object is not supported.
A slash(/) in the signature of a function denotes that the parameters prior
to it are positional-only. For more info, see
the FAQ entry on positional-only parameters.

New in version 3.5: follow_wrapped parameter. Pass False to get a signature of
callable specifically (callable.__wrapped__ will not be used to
unwrap decorated callables.)


Note
Some callables may not be introspectable in certain implementations of
Python.  For example, in CPython, some built-in functions defined in
C provide no metadata about their arguments.




class inspect.Signature(parameters=None, *, return_annotation=Signature.empty)¶
A Signature object represents the call signature of a function and its return
annotation.  For each parameter accepted by the function it stores a
Parameter object in its parameters collection.
The optional parameters argument is a sequence of Parameter
objects, which is validated to check that there are no parameters with
duplicate names, and that the parameters are in the right order, i.e.
positional-only first, then positional-or-keyword, and that parameters with
defaults follow parameters without defaults.
The optional return_annotation argument, can be an arbitrary Python object,
is the “return” annotation of the callable.
Signature objects are immutable.  Use Signature.replace() to make a
modified copy.

Changed in version 3.5: Signature objects are picklable and hashable.



empty¶
A special class-level marker to specify absence of a return annotation.



parameters¶
An ordered mapping of parameters’ names to the corresponding
Parameter objects.  Parameters appear in strict definition
order, including keyword-only parameters.

Changed in version 3.7: Python only explicitly guaranteed that it preserved the declaration
order of keyword-only parameters as of version 3.7, although in practice
this order had always been preserved in Python 3.




return_annotation¶
The “return” annotation for the callable.  If the callable has no “return”
annotation, this attribute is set to Signature.empty.



bind(*args, **kwargs)¶
Create a mapping from positional and keyword arguments to parameters.
Returns BoundArguments if *args and **kwargs match the
signature, or raises a TypeError.



bind_partial(*args, **kwargs)¶
Works the same way as Signature.bind(), but allows the omission of
some required arguments (mimics functools.partial() behavior.)
Returns BoundArguments, or raises a TypeError if the
passed arguments do not match the signature.



replace(*[, parameters][, return_annotation])¶
Create a new Signature instance based on the instance replace was invoked
on.  It is possible to pass different parameters and/or
return_annotation to override the corresponding properties of the base
signature.  To remove return_annotation from the copied Signature, pass in
Signature.empty.
>>> def test(a, b):
...     pass
>>> sig = signature(test)
>>> new_sig = sig.replace(return_annotation="new return anno")
>>> str(new_sig)
"(a, b) -> 'new return anno'"





classmethod from_callable(obj, *, follow_wrapped=True)¶
Return a Signature (or its subclass) object for a given callable
obj.  Pass follow_wrapped=False to get a signature of obj
without unwrapping its __wrapped__ chain.
This method simplifies subclassing of Signature:
class MySignature(Signature):
    pass
sig = MySignature.from_callable(min)
assert isinstance(sig, MySignature)



New in version 3.5.





class inspect.Parameter(name, kind, *, default=Parameter.empty, annotation=Parameter.empty)¶
Parameter objects are immutable.  Instead of modifying a Parameter object,
you can use Parameter.replace() to create a modified copy.

Changed in version 3.5: Parameter objects are picklable and hashable.



empty¶
A special class-level marker to specify absence of default values and
annotations.



name¶
The name of the parameter as a string.  The name must be a valid
Python identifier.

CPython implementation detail: CPython generates implicit parameter names of the form .0 on the
code objects used to implement comprehensions and generator
expressions.

Changed in version 3.6: These parameter names are exposed by this module as names like
implicit0.





default¶
The default value for the parameter.  If the parameter has no default
value, this attribute is set to Parameter.empty.



annotation¶
The annotation for the parameter.  If the parameter has no annotation,
this attribute is set to Parameter.empty.



kind¶
Describes how argument values are bound to the parameter.  Possible values
(accessible via Parameter, like Parameter.KEYWORD_ONLY):






Name
Meaning



POSITIONAL_ONLY
Value must be supplied as a positional
argument.
Python has no explicit syntax for defining
positional-only parameters, but many built-in
and extension module functions (especially
those that accept only one or two parameters)
accept them.


POSITIONAL_OR_KEYWORD
Value may be supplied as either a keyword or
positional argument (this is the standard
binding behaviour for functions implemented
in Python.)

VAR_POSITIONAL
A tuple of positional arguments that aren’t
bound to any other parameter. This
corresponds to a *args parameter in a
Python function definition.

KEYWORD_ONLY
Value must be supplied as a keyword argument.
Keyword only parameters are those which
appear after a * or *args entry in a
Python function definition.

VAR_KEYWORD
A dict of keyword arguments that aren’t bound
to any other parameter. This corresponds to a
**kwargs parameter in a Python function
definition.



Example: print all keyword-only arguments without default values:
>>> def foo(a, b, *, c, d=10):
...     pass

>>> sig = signature(foo)
>>> for param in sig.parameters.values():
...     if (param.kind == param.KEYWORD_ONLY and
...                        param.default is param.empty):
...         print('Parameter:', param)
Parameter: c





replace(*[, name][, kind][, default][, annotation])¶

Create a new Parameter instance based on the instance replaced was invoked
on.  To override a Parameter attribute, pass the corresponding
argument.  To remove a default value or/and an annotation from a
Parameter, pass Parameter.empty.
>>> from inspect import Parameter
>>> param = Parameter('foo', Parameter.KEYWORD_ONLY, default=42)
>>> str(param)
'foo=42'

>>> str(param.replace()) # Will create a shallow copy of 'param'
'foo=42'

>>> str(param.replace(default=Parameter.empty, annotation='spam'))
"foo:'spam'"




Changed in version 3.4: In Python 3.3 Parameter objects were allowed to have name set
to None if their kind was set to POSITIONAL_ONLY.
This is no longer permitted.





class inspect.BoundArguments¶
Result of a Signature.bind() or Signature.bind_partial() call.
Holds the mapping of arguments to the function’s parameters.


arguments¶
An ordered, mutable mapping (collections.OrderedDict) of
parameters’ names to arguments’ values.  Contains only explicitly bound
arguments.  Changes in arguments will reflect in args and
kwargs.
Should be used in conjunction with Signature.parameters for any
argument processing purposes.

Note
Arguments for which Signature.bind() or
Signature.bind_partial() relied on a default value are skipped.
However, if needed, use BoundArguments.apply_defaults() to add
them.




args¶
A tuple of positional arguments values.  Dynamically computed from the
arguments attribute.



kwargs¶
A dict of keyword arguments values.  Dynamically computed from the
arguments attribute.



signature¶
A reference to the parent Signature object.



apply_defaults()¶
Set default values for missing arguments.
For variable-positional arguments (*args) the default is an
empty tuple.
For variable-keyword arguments (**kwargs) the default is an
empty dict.
>>> def foo(a, b='ham', *args): pass
>>> ba = inspect.signature(foo).bind('spam')
>>> ba.apply_defaults()
>>> ba.arguments
OrderedDict([('a', 'spam'), ('b', 'ham'), ('args', ())])



New in version 3.5.


The args and kwargs properties can be used to invoke
functions:
def test(a, *, b):
    ...

sig = signature(test)
ba = sig.bind(10, b=20)
test(*ba.args, **ba.kwargs)




See also

PEP 362 - Function Signature Object.
The detailed specification, implementation details and examples.


