link:
library/unittest.mock.html#magic-mock

docs:

Magic Mock¶
There are two MagicMock variants: MagicMock and NonCallableMagicMock.


class unittest.mock.MagicMock(*args, **kw)¶
MagicMock is a subclass of Mock with default implementations
of most of the magic methods. You can use MagicMock without having to
configure the magic methods yourself.
The constructor parameters have the same meaning as for Mock.
If you use the spec or spec_set arguments then only magic methods
that exist in the spec will be created.



class unittest.mock.NonCallableMagicMock(*args, **kw)¶
A non-callable version of MagicMock.
The constructor parameters have the same meaning as for
MagicMock, with the exception of return_value and
side_effect which have no meaning on a non-callable mock.

The magic methods are setup with MagicMock objects, so you can configure them
and use them in the usual way:
>>> mock = MagicMock()
>>> mock[3] = 'fish'
>>> mock.__setitem__.assert_called_with(3, 'fish')
>>> mock.__getitem__.return_value = 'result'
>>> mock[2]
'result'


By default many of the protocol methods are required to return objects of a
specific type. These methods are preconfigured with a default return value, so
that they can be used without you having to do anything if you aren’t interested
in the return value. You can still set the return value manually if you want
to change the default.
Methods and their defaults:

__lt__: NotImplemented
__gt__: NotImplemented
__le__: NotImplemented
__ge__: NotImplemented
__int__: 1
__contains__: False
__len__: 0
__iter__: iter([])
__exit__: False
__complex__: 1j
__float__: 1.0
__bool__: True
__index__: 1
__hash__: default hash for the mock
__str__: default str for the mock
__sizeof__: default sizeof for the mock

For example:
>>> mock = MagicMock()
>>> int(mock)
1
>>> len(mock)
0
>>> list(mock)
[]
>>> object() in mock
False


The two equality methods, __eq__() and __ne__(), are special.
They do the default equality comparison on identity, using the
side_effect attribute, unless you change their return value to
return something else:
>>> MagicMock() == 3
False
>>> MagicMock() != 3
True
>>> mock = MagicMock()
>>> mock.__eq__.return_value = True
>>> mock == 3
True


The return value of MagicMock.__iter__() can be any iterable object and isn’t
required to be an iterator:
>>> mock = MagicMock()
>>> mock.__iter__.return_value = ['a', 'b', 'c']
>>> list(mock)
['a', 'b', 'c']
>>> list(mock)
['a', 'b', 'c']


If the return value is an iterator, then iterating over it once will consume
it and subsequent iterations will result in an empty list:
>>> mock.__iter__.return_value = iter(['a', 'b', 'c'])
>>> list(mock)
['a', 'b', 'c']
>>> list(mock)
[]


MagicMock has all of the supported magic methods configured except for some
of the obscure and obsolete ones. You can still set these up if you want.
Magic methods that are supported but not setup by default in MagicMock are:

__subclasses__
__dir__
__format__
__get__, __set__ and __delete__
__reversed__ and __missing__
__reduce__, __reduce_ex__, __getinitargs__, __getnewargs__,
__getstate__ and __setstate__
__getformat__ and __setformat__




[2]Magic methods should be looked up on the class rather than the
instance. Different versions of Python are inconsistent about applying this
rule. The supported protocol methods should work with all supported versions
of Python.





[3]The function is basically hooked up to the class, but each Mock
instance is kept isolated from the others.


