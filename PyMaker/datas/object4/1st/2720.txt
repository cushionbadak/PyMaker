link:
library/configparser.html#mapping-protocol-access

docs:

Mapping Protocol Access¶

New in version 3.2.

Mapping protocol access is a generic name for functionality that enables using
custom objects as if they were dictionaries.  In case of configparser,
the mapping interface implementation is using the
parser['section']['option'] notation.
parser['section'] in particular returns a proxy for the section’s data in
the parser.  This means that the values are not copied but they are taken from
the original parser on demand.  What’s even more important is that when values
are changed on a section proxy, they are actually mutated in the original
parser.
configparser objects behave as close to actual dictionaries as possible.
The mapping interface is complete and adheres to the
MutableMapping ABC.
However, there are a few differences that should be taken into account:

By default, all keys in sections are accessible in a case-insensitive manner
[1].  E.g. for option in parser["section"] yields only optionxform’ed
option key names.  This means lowercased keys by default.  At the same time,
for a section that holds the key 'a', both expressions return True:
"a" in parser["section"]
"A" in parser["section"]



All sections include DEFAULTSECT values as well which means that
.clear() on a section may not leave the section visibly empty.  This is
because default values cannot be deleted from the section (because technically
they are not there).  If they are overridden in the section, deleting causes
the default value to be visible again.  Trying to delete a default value
causes a KeyError.

DEFAULTSECT cannot be removed from the parser:

trying to delete it raises ValueError,
parser.clear() leaves it intact,
parser.popitem() never returns it.


parser.get(section, option, **kwargs) - the second argument is not
a fallback value.  Note however that the section-level get() methods are
compatible both with the mapping protocol and the classic configparser API.

parser.items() is compatible with the mapping protocol (returns a list of
section_name, section_proxy pairs including the DEFAULTSECT).  However,
this method can also be invoked with arguments: parser.items(section, raw,
vars).  The latter call returns a list of option, value pairs for
a specified section, with all interpolations expanded (unless
raw=True is provided).


The mapping protocol is implemented on top of the existing legacy API so that
subclasses overriding the original interface still should have mappings working
as expected.
