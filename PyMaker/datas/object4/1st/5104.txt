link:
library/socket.html#socket.socket.recvmsg

docs:


socket.recvmsg(bufsize[, ancbufsize[, flags]])Â¶
Receive normal data (up to bufsize bytes) and ancillary data from
the socket.  The ancbufsize argument sets the size in bytes of
the internal buffer used to receive the ancillary data; it defaults
to 0, meaning that no ancillary data will be received.  Appropriate
buffer sizes for ancillary data can be calculated using
CMSG_SPACE() or CMSG_LEN(), and items which do not fit
into the buffer might be truncated or discarded.  The flags
argument defaults to 0 and has the same meaning as for
recv().
The return value is a 4-tuple: (data, ancdata, msg_flags,
address).  The data item is a bytes object holding the
non-ancillary data received.  The ancdata item is a list of zero
or more tuples (cmsg_level, cmsg_type, cmsg_data) representing
the ancillary data (control messages) received: cmsg_level and
cmsg_type are integers specifying the protocol level and
protocol-specific type respectively, and cmsg_data is a
bytes object holding the associated data.  The msg_flags
item is the bitwise OR of various flags indicating conditions on
the received message; see your system documentation for details.
If the receiving socket is unconnected, address is the address of
the sending socket, if available; otherwise, its value is
unspecified.
On some systems, sendmsg() and recvmsg() can be used to
pass file descriptors between processes over an AF_UNIX
socket.  When this facility is used (it is often restricted to
SOCK_STREAM sockets), recvmsg() will return, in its
ancillary data, items of the form (socket.SOL_SOCKET,
socket.SCM_RIGHTS, fds), where fds is a bytes object
representing the new file descriptors as a binary array of the
native C int type.  If recvmsg() raises an
exception after the system call returns, it will first attempt to
close any file descriptors received via this mechanism.
Some systems do not indicate the truncated length of ancillary data
items which have been only partially received.  If an item appears
to extend beyond the end of the buffer, recvmsg() will issue
a RuntimeWarning, and will return the part of it which is
inside the buffer provided it has not been truncated before the
start of its associated data.
On systems which support the SCM_RIGHTS mechanism, the
following function will receive up to maxfds file descriptors,
returning the message data and a list containing the descriptors
(while ignoring unexpected conditions such as unrelated control
messages being received).  See also sendmsg().
import socket, array

def recv_fds(sock, msglen, maxfds):
    fds = array.array("i")   # Array of ints
    msg, ancdata, flags, addr = sock.recvmsg(msglen, socket.CMSG_LEN(maxfds * fds.itemsize))
    for cmsg_level, cmsg_type, cmsg_data in ancdata:
        if (cmsg_level == socket.SOL_SOCKET and cmsg_type == socket.SCM_RIGHTS):
            # Append data, ignoring any truncated integers at the end.
            fds.fromstring(cmsg_data[:len(cmsg_data) - (len(cmsg_data) % fds.itemsize)])
    return msg, list(fds)


Availability: most Unix platforms, possibly others.

New in version 3.3.


Changed in version 3.5: If the system call is interrupted and the signal handler does not raise
an exception, the method now retries the system call instead of raising
an InterruptedError exception (see PEP 475 for the rationale).

