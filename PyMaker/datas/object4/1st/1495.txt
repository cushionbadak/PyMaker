link:
library/enum.html#flag

docs:

Flag¶
The last variation is Flag.  Like IntFlag, Flag
members can be combined using the bitwise operators (&, |, ^, ~).  Unlike
IntFlag, they cannot be combined with, nor compared against, any
other Flag enumeration, nor int.  While it is possible to
specify the values directly it is recommended to use auto as the
value and let Flag select an appropriate value.

New in version 3.6.

Like IntFlag, if a combination of Flag members results in no
flags being set, the boolean evaluation is False:
>>> from enum import Flag, auto
>>> class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
>>> Color.RED & Color.GREEN
<Color.0: 0>
>>> bool(Color.RED & Color.GREEN)
False


Individual flags should have values that are powers of two (1, 2, 4, 8, …),
while combinations of flags won’t:
>>> class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...     WHITE = RED | BLUE | GREEN
...
>>> Color.WHITE
<Color.WHITE: 7>


Giving a name to the “no flags set” condition does not change its boolean
value:
>>> class Color(Flag):
...     BLACK = 0
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
>>> Color.BLACK
<Color.BLACK: 0>
>>> bool(Color.BLACK)
False



Note
For the majority of new code, Enum and Flag are strongly
recommended, since IntEnum and IntFlag break some
semantic promises of an enumeration (by being comparable to integers, and
thus by transitivity to other unrelated enumerations).  IntEnum
and IntFlag should be used only in cases where Enum and
Flag will not do; for example, when integer constants are replaced
with enumerations, or for interoperability with other systems.

