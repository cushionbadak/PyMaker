link:
library/concurrent.futures.html#module-functions

docs:

Module Functions¶


concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)¶
Wait for the Future instances (possibly created by different
Executor instances) given by fs to complete.  Returns a named
2-tuple of sets.  The first set, named done, contains the futures that
completed (finished or were cancelled) before the wait completed.  The second
set, named not_done, contains uncompleted futures.
timeout can be used to control the maximum number of seconds to wait before
returning.  timeout can be an int or float.  If timeout is not specified
or None, there is no limit to the wait time.
return_when indicates when this function should return.  It must be one of
the following constants:






Constant
Description



FIRST_COMPLETED
The function will return when any
future finishes or is cancelled.

FIRST_EXCEPTION
The function will return when any
future finishes by raising an
exception.  If no future raises an
exception then it is equivalent to
ALL_COMPLETED.

ALL_COMPLETED
The function will return when all
futures finish or are cancelled.






concurrent.futures.as_completed(fs, timeout=None)¶
Returns an iterator over the Future instances (possibly created by
different Executor instances) given by fs that yields futures as
they complete (finished or were cancelled). Any futures given by fs that
are duplicated will be returned once. Any futures that completed before
as_completed() is called will be yielded first.  The returned iterator
raises a concurrent.futures.TimeoutError if __next__()
is called and the result isn’t available after timeout seconds from the
original call to as_completed().  timeout can be an int or float. If
timeout is not specified or None, there is no limit to the wait time.


See also

PEP 3148 – futures - execute computations asynchronously
The proposal which described this feature for inclusion in the Python
standard library.


