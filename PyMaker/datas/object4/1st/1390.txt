link:
library/weakref.html#comparing-finalizers-with-del-methods

docs:

Comparing finalizers with __del__() methods¶
Suppose we want to create a class whose instances represent temporary
directories.  The directories should be deleted with their contents
when the first of the following events occurs:

the object is garbage collected,
the object’s remove() method is called, or
the program exits.

We might try to implement the class using a __del__() method as
follows:
class TempDir:
    def __init__(self):
        self.name = tempfile.mkdtemp()

    def remove(self):
        if self.name is not None:
            shutil.rmtree(self.name)
            self.name = None

    @property
    def removed(self):
        return self.name is None

    def __del__(self):
        self.remove()


Starting with Python 3.4, __del__() methods no longer prevent
reference cycles from being garbage collected, and module globals are
no longer forced to None during interpreter shutdown.
So this code should work without any issues on CPython.
However, handling of __del__() methods is notoriously implementation
specific, since it depends on internal details of the interpreter’s garbage
collector implementation.
A more robust alternative can be to define a finalizer which only references
the specific functions and objects that it needs, rather than having access
to the full state of the object:
class TempDir:
    def __init__(self):
        self.name = tempfile.mkdtemp()
        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)

    def remove(self):
        self._finalizer()

    @property
    def removed(self):
        return not self._finalizer.alive


Defined like this, our finalizer only receives a reference to the details
it needs to clean up the directory appropriately. If the object never gets
garbage collected the finalizer will still be called at exit.
The other advantage of weakref based finalizers is that they can be used to
register finalizers for classes where the definition is controlled by a
third party, such as running code when a module is unloaded:
import weakref, sys
def unloading_module():
    # implicit reference to the module globals from the function body
weakref.finalize(sys.modules[__name__], unloading_module)



Note
If you create a finalizer object in a daemonic thread just as the program
exits then there is the possibility that the finalizer
does not get called at exit.  However, in a daemonic thread
atexit.register(), try: ... finally: ... and with: ...
do not guarantee that cleanup occurs either.

