link:
library/multiprocessing.html#proxy-objects

docs:

Proxy Objects¶
A proxy is an object which refers to a shared object which lives (presumably)
in a different process.  The shared object is said to be the referent of the
proxy.  Multiple proxy objects may have the same referent.
A proxy object has methods which invoke corresponding methods of its referent
(although not every method of the referent will necessarily be available through
the proxy).  In this way, a proxy can be used just like its referent can:
>>> from multiprocessing import Manager
>>> manager = Manager()
>>> l = manager.list([i*i for i in range(10)])
>>> print(l)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> print(repr(l))
<ListProxy object, typeid 'list' at 0x...>
>>> l[4]
16
>>> l[2:5]
[4, 9, 16]


Notice that applying str() to a proxy will return the representation of
the referent, whereas applying repr() will return the representation of
the proxy.
An important feature of proxy objects is that they are picklable so they can be
passed between processes.  As such, a referent can contain
Proxy Objects.  This permits nesting of these managed
lists, dicts, and other Proxy Objects:
>>> a = manager.list()
>>> b = manager.list()
>>> a.append(b)         # referent of a now contains referent of b
>>> print(a, b)
[<ListProxy object, typeid 'list' at ...>] []
>>> b.append('hello')
>>> print(a[0], b)
['hello'] ['hello']


Similarly, dict and list proxies may be nested inside one another:
>>> l_outer = manager.list([ manager.dict() for i in range(2) ])
>>> d_first_inner = l_outer[0]
>>> d_first_inner['a'] = 1
>>> d_first_inner['b'] = 2
>>> l_outer[1]['c'] = 3
>>> l_outer[1]['z'] = 26
>>> print(l_outer[0])
{'a': 1, 'b': 2}
>>> print(l_outer[1])
{'c': 3, 'z': 26}


If standard (non-proxy) list or dict objects are contained
in a referent, modifications to those mutable values will not be propagated
through the manager because the proxy has no way of knowing when the values
contained within are modified.  However, storing a value in a container proxy
(which triggers a __setitem__ on the proxy object) does propagate through
the manager and so to effectively modify such an item, one could re-assign the
modified value to the container proxy:
# create a list proxy and append a mutable object (a dictionary)
lproxy = manager.list()
lproxy.append({})
# now mutate the dictionary
d = lproxy[0]
d['a'] = 1
d['b'] = 2
# at this point, the changes to d are not yet synced, but by
# updating the dictionary, the proxy is notified of the change
lproxy[0] = d


This approach is perhaps less convenient than employing nested
Proxy Objects for most use cases but also
demonstrates a level of control over the synchronization.

Note
The proxy types in multiprocessing do nothing to support comparisons
by value.  So, for instance, we have:
>>> manager.list([1,2,3]) == [1,2,3]
False


One should just use a copy of the referent instead when making comparisons.



class multiprocessing.managers.BaseProxy¶
Proxy objects are instances of subclasses of BaseProxy.


_callmethod(methodname[, args[, kwds]])¶
Call and return the result of a method of the proxy’s referent.
If proxy is a proxy whose referent is obj then the expression
proxy._callmethod(methodname, args, kwds)


will evaluate the expression
getattr(obj, methodname)(*args, **kwds)


in the manager’s process.
The returned value will be a copy of the result of the call or a proxy to
a new shared object – see documentation for the method_to_typeid
argument of BaseManager.register().
If an exception is raised by the call, then is re-raised by
_callmethod().  If some other exception is raised in the manager’s
process then this is converted into a RemoteError exception and is
raised by _callmethod().
Note in particular that an exception will be raised if methodname has
not been exposed.
An example of the usage of _callmethod():
>>> l = manager.list(range(10))
>>> l._callmethod('__len__')
10
>>> l._callmethod('__getitem__', (slice(2, 7),)) # equivalent to l[2:7]
[2, 3, 4, 5, 6]
>>> l._callmethod('__getitem__', (20,))          # equivalent to l[20]
Traceback (most recent call last):
...
IndexError: list index out of range





_getvalue()¶
Return a copy of the referent.
If the referent is unpicklable then this will raise an exception.



__repr__()¶
Return a representation of the proxy object.



__str__()¶
Return the representation of the referent.



Cleanup¶
A proxy object uses a weakref callback so that when it gets garbage collected it
deregisters itself from the manager which owns its referent.
A shared object gets deleted from the manager process when there are no longer
any proxies referring to it.

