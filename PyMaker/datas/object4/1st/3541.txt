link:
library/logging.html#module-level-functions

docs:

Module-Level Functions¶
In addition to the classes described above, there are a number of module-level
functions.


logging.getLogger(name=None)¶
Return a logger with the specified name or, if name is None, return a
logger which is the root logger of the hierarchy. If specified, the name is
typically a dot-separated hierarchical name like ‘a’, ‘a.b’ or ‘a.b.c.d’.
Choice of these names is entirely up to the developer who is using logging.
All calls to this function with a given name return the same logger instance.
This means that logger instances never need to be passed between different parts
of an application.



logging.getLoggerClass()¶
Return either the standard Logger class, or the last class passed to
setLoggerClass(). This function may be called from within a new class
definition, to ensure that installing a customized Logger class will
not undo customizations already applied by other code. For example:
class MyLogger(logging.getLoggerClass()):
    # ... override behaviour here





logging.getLogRecordFactory()¶
Return a callable which is used to create a LogRecord.

New in version 3.2: This function has been provided, along with setLogRecordFactory(),
to allow developers more control over how the LogRecord
representing a logging event is constructed.

See setLogRecordFactory() for more information about the how the
factory is called.



logging.debug(msg, *args, **kwargs)¶
Logs a message with level DEBUG on the root logger. The msg is the
message format string, and the args are the arguments which are merged into
msg using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
There are three keyword arguments in kwargs which are inspected: exc_info
which, if it does not evaluate as false, causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
sys.exc_info()) or an exception instance is provided, it is used;
otherwise, sys.exc_info() is called to get the exception information.
The second optional keyword argument is stack_info, which defaults to
False. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying exc_info: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.
You can specify stack_info independently of exc_info, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:
Stack (most recent call last):


This mimics the Traceback (most recent call last): which is used when
displaying exception frames.
The third optional keyword argument is extra which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:
FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
logging.basicConfig(format=FORMAT)
d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
logging.warning('Protocol problem: %s', 'connection reset', extra=d)


would print something like:
2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset


The keys in the dictionary passed in extra should not clash with the keys used
by the logging system. (See the Formatter documentation for more
information on which keys are used by the logging system.)
If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the Formatter has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the extra dictionary with these keys.
While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
Formatters would be used with particular Handlers.

New in version 3.2: The stack_info parameter was added.




logging.info(msg, *args, **kwargs)¶
Logs a message with level INFO on the root logger. The arguments are
interpreted as for debug().



logging.warning(msg, *args, **kwargs)¶
Logs a message with level WARNING on the root logger. The arguments
are interpreted as for debug().

Note
There is an obsolete function warn which is functionally
identical to warning. As warn is deprecated, please do not use
it - use warning instead.




logging.error(msg, *args, **kwargs)¶
Logs a message with level ERROR on the root logger. The arguments are
interpreted as for debug().



logging.critical(msg, *args, **kwargs)¶
Logs a message with level CRITICAL on the root logger. The arguments
are interpreted as for debug().



logging.exception(msg, *args, **kwargs)¶
Logs a message with level ERROR on the root logger. The arguments are
interpreted as for debug(). Exception info is added to the logging
message. This function should only be called from an exception handler.



logging.log(level, msg, *args, **kwargs)¶
Logs a message with level level on the root logger. The other arguments are
interpreted as for debug().

Note
The above module-level convenience functions, which delegate to the
root logger, call basicConfig() to ensure that at least one handler
is available. Because of this, they should not be used in threads,
in versions of Python earlier than 2.7.1 and 3.2, unless at least one
handler has been added to the root logger before the threads are
started. In earlier versions of Python, due to a thread safety shortcoming
in basicConfig(), this can (under rare circumstances) lead to
handlers being added multiple times to the root logger, which can in turn
lead to multiple messages for the same event.




logging.disable(lvl=CRITICAL)¶
Provides an overriding level lvl for all loggers which takes precedence over
the logger’s own level. When the need arises to temporarily throttle logging
output down across the whole application, this function can be useful. Its
effect is to disable all logging calls of severity lvl and below, so that
if you call it with a value of INFO, then all INFO and DEBUG events would be
discarded, whereas those of severity WARNING and above would be processed
according to the logger’s effective level. If
logging.disable(logging.NOTSET) is called, it effectively removes this
overriding level, so that logging output again depends on the effective
levels of individual loggers.
Note that if you have defined any custom logging level higher than
CRITICAL (this is not recommended), you won’t be able to rely on the
default value for the lvl parameter, but will have to explicitly supply a
suitable value.

Changed in version 3.7: The lvl parameter was defaulted to level CRITICAL. See Issue
#28524 for more information about this change.




logging.addLevelName(lvl, levelName)¶
Associates level lvl with text levelName in an internal dictionary, which is
used to map numeric levels to a textual representation, for example when a
Formatter formats a message. This function can also be used to define
your own levels. The only constraints are that all levels used must be
registered using this function, levels should be positive integers and they
should increase in increasing order of severity.

Note
If you are thinking of defining your own levels, please see the
section on Custom Levels.




logging.getLevelName(lvl)¶
Returns the textual representation of logging level lvl. If the level is one
of the predefined levels CRITICAL, ERROR, WARNING,
INFO or DEBUG then you get the corresponding string. If you
have associated levels with names using addLevelName() then the name you
have associated with lvl is returned. If a numeric value corresponding to one
of the defined levels is passed in, the corresponding string representation is
returned. Otherwise, the string ‘Level %s’ % lvl is returned.

Note
Levels are internally integers (as they need to be compared in the
logging logic). This function is used to convert between an integer level
and the level name displayed in the formatted log output by means of the
%(levelname)s format specifier (see LogRecord attributes).


Changed in version 3.4: In Python versions earlier than 3.4, this function could also be passed a
text level, and would return the corresponding numeric value of the level.
This undocumented behaviour was considered a mistake, and was removed in
Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility.




logging.makeLogRecord(attrdict)¶
Creates and returns a new LogRecord instance whose attributes are
defined by attrdict. This function is useful for taking a pickled
LogRecord attribute dictionary, sent over a socket, and reconstituting
it as a LogRecord instance at the receiving end.



logging.basicConfig(**kwargs)¶
Does basic configuration for the logging system by creating a
StreamHandler with a default Formatter and adding it to the
root logger. The functions debug(), info(), warning(),
error() and critical() will call basicConfig() automatically
if no handlers are defined for the root logger.
This function does nothing if the root logger already has handlers
configured for it.

Note
This function should be called from the main thread
before other threads are started. In versions of Python prior to
2.7.1 and 3.2, if this function is called from multiple threads,
it is possible (in rare circumstances) that a handler will be added
to the root logger more than once, leading to unexpected results
such as messages being duplicated in the log.

The following keyword arguments are supported.






Format
Description



filename
Specifies that a FileHandler be created,
using the specified filename, rather than a
StreamHandler.

filemode
If filename is specified, open the file
in this mode. Defaults
to 'a'.

format
Use the specified format string for the
handler.

datefmt
Use the specified date/time format, as
accepted by time.strftime().

style
If format is specified, use this style
for the format string. One of '%',
'{' or '$' for printf-style,
str.format() or
string.Template respectively.
Defaults to '%'.

level
Set the root logger level to the specified
level.

stream
Use the specified stream to initialize the
StreamHandler. Note that this argument is
incompatible with filename - if both
are present, a ValueError is raised.

handlers
If specified, this should be an iterable of
already created handlers to add to the root
logger. Any handlers which don’t already
have a formatter set will be assigned the
default formatter created in this function.
Note that this argument is incompatible
with filename or stream - if both
are present, a ValueError is raised.




Changed in version 3.2: The style argument was added.


Changed in version 3.3: The handlers argument was added. Additional checks were added to
catch situations where incompatible arguments are specified (e.g.
handlers together with stream or filename, or stream
together with filename).




logging.shutdown()¶
Informs the logging system to perform an orderly shutdown by flushing and
closing all handlers. This should be called at application exit and no
further use of the logging system should be made after this call.



logging.setLoggerClass(klass)¶
Tells the logging system to use the class klass when instantiating a logger.
The class should define __init__() such that only a name argument is
required, and the __init__() should call Logger.__init__(). This
function is typically called before any loggers are instantiated by applications
which need to use custom logger behavior.



logging.setLogRecordFactory(factory)¶
Set a callable which is used to create a LogRecord.




Parameters:factory – The factory callable to be used to instantiate a log record.




New in version 3.2: This function has been provided, along with getLogRecordFactory(), to
allow developers more control over how the LogRecord representing
a logging event is constructed.

The factory has the following signature:
factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, **kwargs)





name:The logger name.

level:The logging level (numeric).

fn:The full pathname of the file where the logging call was made.

lno:The line number in the file where the logging call was made.

msg:The logging message.

args:The arguments for the logging message.

exc_info:An exception tuple, or None.

func:The name of the function or method which invoked the logging
call.

sinfo:A stack traceback such as is provided by
traceback.print_stack(), showing the call hierarchy.

kwargs:Additional keyword arguments.





