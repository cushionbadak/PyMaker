link:
library/pathlib.html#pathlib.PurePath

docs:


class pathlib.PurePath(*pathsegments)¶
A generic class that represents the system’s path flavour (instantiating
it creates either a PurePosixPath or a PureWindowsPath):
>>> PurePath('setup.py')      # Running on a Unix machine
PurePosixPath('setup.py')


Each element of pathsegments can be either a string representing a
path segment, an object implementing the os.PathLike interface
which returns a string, or another path object:
>>> PurePath('foo', 'some/path', 'bar')
PurePosixPath('foo/some/path/bar')
>>> PurePath(Path('foo'), Path('bar'))
PurePosixPath('foo/bar')


When pathsegments is empty, the current directory is assumed:
>>> PurePath()
PurePosixPath('.')


When several absolute paths are given, the last is taken as an anchor
(mimicking os.path.join()’s behaviour):
>>> PurePath('/etc', '/usr', 'lib64')
PurePosixPath('/usr/lib64')
>>> PureWindowsPath('c:/Windows', 'd:bar')
PureWindowsPath('d:bar')


However, in a Windows path, changing the local root doesn’t discard the
previous drive setting:
>>> PureWindowsPath('c:/Windows', '/Program Files')
PureWindowsPath('c:/Program Files')


Spurious slashes and single dots are collapsed, but double dots ('..')
are not, since this would change the meaning of a path in the face of
symbolic links:
>>> PurePath('foo//bar')
PurePosixPath('foo/bar')
>>> PurePath('foo/./bar')
PurePosixPath('foo/bar')
>>> PurePath('foo/../bar')
PurePosixPath('foo/../bar')


(a naïve approach would make PurePosixPath('foo/../bar') equivalent
to PurePosixPath('bar'), which is wrong if foo is a symbolic link
to another directory)
Pure path objects implement the os.PathLike interface, allowing them
to be used anywhere the interface is accepted.

Changed in version 3.6: Added support for the os.PathLike interface.

