link:
library/multiprocessing.html#managers

docs:

Managers¶
Managers provide a way to create data which can be shared between different
processes, including sharing over a network between processes running on
different machines. A manager object controls a server process which manages
shared objects.  Other processes can access the shared objects by using
proxies.


multiprocessing.Manager()¶
Returns a started SyncManager object which
can be used for sharing objects between processes.  The returned manager
object corresponds to a spawned child process and has methods which will
create shared objects and return corresponding proxies.

Manager processes will be shutdown as soon as they are garbage collected or
their parent process exits.  The manager classes are defined in the
multiprocessing.managers module:


class multiprocessing.managers.BaseManager([address[, authkey]])¶
Create a BaseManager object.
Once created one should call start() or get_server().serve_forever() to ensure
that the manager object refers to a started manager process.
address is the address on which the manager process listens for new
connections.  If address is None then an arbitrary one is chosen.
authkey is the authentication key which will be used to check the
validity of incoming connections to the server process.  If
authkey is None then current_process().authkey is used.
Otherwise authkey is used and it must be a byte string.


start([initializer[, initargs]])¶
Start a subprocess to start the manager.  If initializer is not None
then the subprocess will call initializer(*initargs) when it starts.



get_server()¶
Returns a Server object which represents the actual server under
the control of the Manager. The Server object supports the
serve_forever() method:
>>> from multiprocessing.managers import BaseManager
>>> manager = BaseManager(address=('', 50000), authkey=b'abc')
>>> server = manager.get_server()
>>> server.serve_forever()


Server additionally has an address attribute.



connect()¶
Connect a local manager object to a remote manager process:
>>> from multiprocessing.managers import BaseManager
>>> m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')
>>> m.connect()





shutdown()¶
Stop the process used by the manager.  This is only available if
start() has been used to start the server process.
This can be called multiple times.



register(typeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])¶
A classmethod which can be used for registering a type or callable with
the manager class.
typeid is a “type identifier” which is used to identify a particular
type of shared object.  This must be a string.
callable is a callable used for creating objects for this type
identifier.  If a manager instance will be connected to the
server using the connect() method, or if the
create_method argument is False then this can be left as
None.
proxytype is a subclass of BaseProxy which is used to create
proxies for shared objects with this typeid.  If None then a proxy
class is created automatically.
exposed is used to specify a sequence of method names which proxies for
this typeid should be allowed to access using
BaseProxy._callmethod().  (If exposed is None then
proxytype._exposed_ is used instead if it exists.)  In the case
where no exposed list is specified, all “public methods” of the shared
object will be accessible.  (Here a “public method” means any attribute
which has a __call__() method and whose name does not begin
with '_'.)
method_to_typeid is a mapping used to specify the return type of those
exposed methods which should return a proxy.  It maps method names to
typeid strings.  (If method_to_typeid is None then
proxytype._method_to_typeid_ is used instead if it exists.)  If a
method’s name is not a key of this mapping or if the mapping is None
then the object returned by the method will be copied by value.
create_method determines whether a method should be created with name
typeid which can be used to tell the server process to create a new
shared object and return a proxy for it.  By default it is True.

BaseManager instances also have one read-only property:


address¶
The address used by the manager.


Changed in version 3.3: Manager objects support the context management protocol – see
Context Manager Types.  __enter__() starts the
server process (if it has not already started) and then returns the
manager object.  __exit__() calls shutdown().
In previous versions __enter__() did not start the
manager’s server process if it was not already started.




class multiprocessing.managers.SyncManager¶
A subclass of BaseManager which can be used for the synchronization
of processes.  Objects of this type are returned by
multiprocessing.Manager().
Its methods create and return Proxy Objects for a
number of commonly used data types to be synchronized across processes.
This notably includes shared lists and dictionaries.


Barrier(parties[, action[, timeout]])¶
Create a shared threading.Barrier object and return a
proxy for it.

New in version 3.3.




BoundedSemaphore([value])¶
Create a shared threading.BoundedSemaphore object and return a
proxy for it.



Condition([lock])¶
Create a shared threading.Condition object and return a proxy for
it.
If lock is supplied then it should be a proxy for a
threading.Lock or threading.RLock object.

Changed in version 3.3: The wait_for() method was added.




Event()¶
Create a shared threading.Event object and return a proxy for it.



Lock()¶
Create a shared threading.Lock object and return a proxy for it.



Namespace()¶
Create a shared Namespace object and return a proxy for it.



Queue([maxsize])¶
Create a shared queue.Queue object and return a proxy for it.



RLock()¶
Create a shared threading.RLock object and return a proxy for it.



Semaphore([value])¶
Create a shared threading.Semaphore object and return a proxy for
it.



Array(typecode, sequence)¶
Create an array and return a proxy for it.



Value(typecode, value)¶
Create an object with a writable value attribute and return a proxy
for it.



dict()¶

dict(mapping)

dict(sequence)
Create a shared dict object and return a proxy for it.



list()¶

list(sequence)
Create a shared list object and return a proxy for it.


Changed in version 3.6: Shared objects are capable of being nested.  For example, a shared
container object such as a shared list can contain other shared objects
which will all be managed and synchronized by the SyncManager.




class multiprocessing.managers.Namespace¶
A type that can register with SyncManager.
A namespace object has no public methods, but does have writable attributes.
Its representation shows the values of its attributes.
However, when using a proxy for a namespace object, an attribute beginning
with '_' will be an attribute of the proxy and not an attribute of the
referent:
>>> manager = multiprocessing.Manager()
>>> Global = manager.Namespace()
>>> Global.x = 10
>>> Global.y = 'hello'
>>> Global._z = 12.3    # this is an attribute of the proxy
>>> print(Global)
Namespace(x=10, y='hello')




Customized managers¶
To create one’s own manager, one creates a subclass of BaseManager and
uses the register() classmethod to register new types or
callables with the manager class.  For example:
from multiprocessing.managers import BaseManager

class MathsClass:
    def add(self, x, y):
        return x + y
    def mul(self, x, y):
        return x * y

class MyManager(BaseManager):
    pass

MyManager.register('Maths', MathsClass)

if __name__ == '__main__':
    with MyManager() as manager:
        maths = manager.Maths()
        print(maths.add(4, 3))         # prints 7
        print(maths.mul(7, 8))         # prints 56




Using a remote manager¶
It is possible to run a manager server on one machine and have clients use it
from other machines (assuming that the firewalls involved allow it).
Running the following commands creates a server for a single shared queue which
remote clients can access:
>>> from multiprocessing.managers import BaseManager
>>> from queue import Queue
>>> queue = Queue()
>>> class QueueManager(BaseManager): pass
>>> QueueManager.register('get_queue', callable=lambda:queue)
>>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')
>>> s = m.get_server()
>>> s.serve_forever()


One client can access the server as follows:
>>> from multiprocessing.managers import BaseManager
>>> class QueueManager(BaseManager): pass
>>> QueueManager.register('get_queue')
>>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')
>>> m.connect()
>>> queue = m.get_queue()
>>> queue.put('hello')


Another client can also use it:
>>> from multiprocessing.managers import BaseManager
>>> class QueueManager(BaseManager): pass
>>> QueueManager.register('get_queue')
>>> m = QueueManager(address=('foo.bar.org', 50000), authkey=b'abracadabra')
>>> m.connect()
>>> queue = m.get_queue()
>>> queue.get()
'hello'


Local processes can also access that queue, using the code from above on the
client to access it remotely:
>>> from multiprocessing import Process, Queue
>>> from multiprocessing.managers import BaseManager
>>> class Worker(Process):
...     def __init__(self, q):
...         self.q = q
...         super(Worker, self).__init__()
...     def run(self):
...         self.q.put('local hello')
...
>>> queue = Queue()
>>> w = Worker(queue)
>>> w.start()
>>> class QueueManager(BaseManager): pass
...
>>> QueueManager.register('get_queue', callable=lambda: queue)
>>> m = QueueManager(address=('', 50000), authkey=b'abracadabra')
>>> s = m.get_server()
>>> s.serve_forever()



