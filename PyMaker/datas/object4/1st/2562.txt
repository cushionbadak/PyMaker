link:
library/zipfile.html#pyzipfile-objects

docs:

PyZipFile Objects¶
The PyZipFile constructor takes the same parameters as the
ZipFile constructor, and one additional parameter, optimize.


class zipfile.PyZipFile(file, mode='r', compression=ZIP_STORED, allowZip64=True, optimize=-1)¶

New in version 3.2: The optimize parameter.


Changed in version 3.4: ZIP64 extensions are enabled by default.

Instances have one method in addition to those of ZipFile objects:


writepy(pathname, basename='', filterfunc=None)¶
Search for files *.py and add the corresponding file to the
archive.
If the optimize parameter to PyZipFile was not given or -1,
the corresponding file is a *.pyc file, compiling if necessary.
If the optimize parameter to PyZipFile was 0, 1 or
2, only files with that optimization level (see compile()) are
added to the archive, compiling if necessary.
If pathname is a file, the filename must end with .py, and
just the (corresponding *.pyc) file is added at the top level
(no path information).  If pathname is a file that does not end with
.py, a RuntimeError will be raised.  If it is a directory,
and the directory is not a package directory, then all the files
*.pyc are added at the top level.  If the directory is a
package directory, then all *.pyc are added under the package
name as a file path, and if any subdirectories are package directories,
all of these are added recursively in sorted order.
basename is intended for internal use only.
filterfunc, if given, must be a function taking a single string
argument.  It will be passed each path (including each individual full
file path) before it is added to the archive.  If filterfunc returns a
false value, the path will not be added, and if it is a directory its
contents will be ignored.  For example, if our test files are all either
in test directories or start with the string test_, we can use a
filterfunc to exclude them:
>>> zf = PyZipFile('myprog.zip')
>>> def notests(s):
...     fn = os.path.basename(s)
...     return (not (fn == 'test' or fn.startswith('test_')))
>>> zf.writepy('myprog', filterfunc=notests)


The writepy() method makes archives with file names like
this:
string.pyc                   # Top level name
test/__init__.pyc            # Package directory
test/testall.pyc             # Module test.testall
test/bogus/__init__.pyc      # Subpackage directory
test/bogus/myfile.pyc        # Submodule test.bogus.myfile



New in version 3.4: The filterfunc parameter.


Changed in version 3.6.2: The pathname parameter accepts a path-like object.


Changed in version 3.7: Recursion sorts directory entries.



