link:
library/zipapp.html#zipapp.create_archive

docs:


zipapp.create_archive(source, target=None, interpreter=None, main=None, filter=None, compressed=False)¶
Create an application archive from source.  The source can be any
of the following:

The name of a directory, or a path-like object referring
to a directory, in which case a new application archive will be
created from the content of that directory.
The name of an existing application archive file, or a path-like object
referring to such a file, in which case the file is copied to
the target (modifying it to reflect the value given for the interpreter
argument).  The file name should include the .pyz extension, if required.
A file object open for reading in bytes mode.  The content of the
file should be an application archive, and the file object is
assumed to be positioned at the start of the archive.

The target argument determines where the resulting archive will be
written:

If it is the name of a file, or a path-like object,
the archive will be written to that file.
If it is an open file object, the archive will be written to that
file object, which must be open for writing in bytes mode.
If the target is omitted (or None), the source must be a directory
and the target will be a file with the same name as the source, with
a .pyz extension added.

The interpreter argument specifies the name of the Python
interpreter with which the archive will be executed.  It is written as
a “shebang” line at the start of the archive.  On POSIX, this will be
interpreted by the OS, and on Windows it will be handled by the Python
launcher.  Omitting the interpreter results in no shebang line being
written.  If an interpreter is specified, and the target is a
filename, the executable bit of the target file will be set.
The main argument specifies the name of a callable which will be
used as the main program for the archive.  It can only be specified if
the source is a directory, and the source does not already contain a
__main__.py file.  The main argument should take the form
“pkg.module:callable” and the archive will be run by importing
“pkg.module” and executing the given callable with no arguments.  It
is an error to omit main if the source is a directory and does not
contain a __main__.py file, as otherwise the resulting archive
would not be executable.
The optional filter argument specifies a callback function that
is passed a Path object representing the path to the file being added
(relative to the source directory).  It should return True if the
file is to be added.
The optional compressed argument determines whether files are
compressed.  If set to True, files in the archive are compressed
with the deflate method; otherwise, files are stored uncompressed.
This argument has no effect when copying an existing archive.
If a file object is specified for source or target, it is the
caller’s responsibility to close it after calling create_archive.
When copying an existing archive, file objects supplied only need
read and readline, or write methods.  When creating an
archive from a directory, if the target is a file object it will be
passed to the zipfile.ZipFile class, and must supply the methods
needed by that class.

New in version 3.7: Added the filter and compressed arguments.

