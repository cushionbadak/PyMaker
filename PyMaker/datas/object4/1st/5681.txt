link:
library/email.compat32-message.html#email.message.Message.get_payload

docs:

<dt id="email.message.Message.get_payload">
<code class="descname">get_payload</code><span class="sig-paren">(</span><em>i=None</em>, <em>decode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#email.message.Message.get_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current payload, which will be a list of
<a class="reference internal" href="#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> objects when <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, or a
string when <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.  If the payload is a list
and you mutate the list object, you modify the message’s payload in place.</p>
<p>With optional argument <em>i</em>, <a class="reference internal" href="#email.message.Message.get_payload" title="email.message.Message.get_payload"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code></a> will return the <em>i</em>-th
element of the payload, counting from zero, if <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>.  An <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> will be raised if <em>i</em> is less than 0 or
greater than or equal to the number of items in the payload.  If the
payload is a string (i.e.  <a class="reference internal" href="#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code></a> is <code class="docutils literal notranslate"><span class="pre">False</span></code>) and <em>i</em> is
given, a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> is raised.</p>
<p>Optional <em>decode</em> is a flag indicating whether the payload should be
decoded or not, according to the <em class="mailheader">Content-Transfer-Encoding</em>
header. When <code class="docutils literal notranslate"><span class="pre">True</span></code> and the message is not a multipart, the payload will
be decoded if this header’s value is <code class="docutils literal notranslate"><span class="pre">quoted-printable</span></code> or <code class="docutils literal notranslate"><span class="pre">base64</span></code>.
If some other encoding is used, or <em class="mailheader">Content-Transfer-Encoding</em>
header is missing, the payload is
returned as-is (undecoded).  In all cases the returned value is binary
data.  If the message is a multipart and the <em>decode</em> flag is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
then <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.  If the payload is base64 and it was not
perfectly formed (missing padding, characters outside the base64
alphabet), then an appropriate defect will be added to the message’s
defect property (<code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64PaddingDefect</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">InvalidBase64CharactersDefect</span></code>, respectively).</p>
<p>When <em>decode</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (the default) the body is returned as a string
without decoding the <em class="mailheader">Content-Transfer-Encoding</em>.  However,
for a <em class="mailheader">Content-Transfer-Encoding</em> of 8bit, an attempt is made
to decode the original bytes using the <code class="docutils literal notranslate"><span class="pre">charset</span></code> specified by the
<em class="mailheader">Content-Type</em> header, using the <code class="docutils literal notranslate"><span class="pre">replace</span></code> error handler.
If no <code class="docutils literal notranslate"><span class="pre">charset</span></code> is specified, or if the <code class="docutils literal notranslate"><span class="pre">charset</span></code> given is not
recognized by the email package, the body is decoded using the default
ASCII charset.</p>
<p>This is a legacy method.  On the
<code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code> class its functionality is
replaced by <a class="reference internal" href="email.message.html#email.message.EmailMessage.get_content" title="email.message.EmailMessage.get_content"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_content()</span></code></a> and
<a class="reference internal" href="email.message.html#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter_parts()</span></code></a>.</p>
</dd>