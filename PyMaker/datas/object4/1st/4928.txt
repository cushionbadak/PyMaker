link:
library/asyncio-protocol.html#streaming-protocols

docs:

Streaming Protocols¶
Event methods, such as loop.create_server(),
loop.create_unix_server(), loop.create_connection(),
loop.create_unix_connection(), loop.connect_accepted_socket(),
loop.connect_read_pipe(), and loop.connect_write_pipe()
accept factories that return streaming protocols.


Protocol.data_received(data)¶
Called when some data is received.  data is a non-empty bytes
object containing the incoming data.
Whether the data is buffered, chunked or reassembled depends on
the transport.  In general, you shouldn’t rely on specific semantics
and instead make your parsing generic and flexible. However,
data is always received in the correct order.
The method can be called an arbitrary number of times while
a connection is open.
However, protocol.eof_received()
is called at most once.  Once eof_received() is called,
data_received() is not called anymore.



Protocol.eof_received()¶
Called when the other end signals it won’t send any more data
(for example by calling transport.write_eof(), if the other end also uses
asyncio).
This method may return a false value (including None), in which case
the transport will close itself.  Conversely, if this method returns a
true value, the protocol used determines whether to close the transport.
Since the default implementation returns None, it implicitly closes the
connection.
Some transports, including SSL, don’t support half-closed connections,
in which case returning true from this method will result in the connection
being closed.

State machine:
start -> connection_made
    [-> data_received]*
    [-> eof_received]?
-> connection_lost -> end


