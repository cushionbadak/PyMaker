link:
library/asyncio-eventloop.html#asyncio.loop.sock_sendall

docs:

<dt id="asyncio.loop.sock_sendall">
<em class="property">coroutine </em><code class="descclassname">loop.</code><code class="descname">sock_sendall</code><span class="sig-paren">(</span><em>sock</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Send <em>data</em> to the <em>sock</em> socket. Asynchronous version of
<a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a>.</p>
<p>This method continues to send to the socket until either all data
in <em>data</em> has been sent or an error occurs.  <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned
on success.  On error, an exception is raised. Additionally, there is no way
to determine how much data, if any, was successfully processed by the
receiving end of the connection.</p>
<p><em>sock</em> must be a non-blocking socket.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.7: </span>Even though the method was always documented as a coroutine
method, before Python 3.7 it returned an <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>.
Since Python 3.7, this is an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> method.</p>
</div>
</dd>