link:
library/io.html#performance

docs:

Performance¶
This section discusses the performance of the provided concrete I/O
implementations.

Binary I/O¶
By reading and writing only large chunks of data even when the user asks for a
single byte, buffered I/O hides any inefficiency in calling and executing the
operating system’s unbuffered I/O routines.  The gain depends on the OS and the
kind of I/O which is performed.  For example, on some modern OSes such as Linux,
unbuffered disk I/O can be as fast as buffered I/O.  The bottom line, however,
is that buffered I/O offers predictable performance regardless of the platform
and the backing device.  Therefore, it is almost always preferable to use
buffered I/O rather than unbuffered I/O for binary data.


Text I/O¶
Text I/O over a binary storage (such as a file) is significantly slower than
binary I/O over the same storage, because it requires conversions between
unicode and binary data using a character codec.  This can become noticeable
handling huge amounts of text data like large log files.  Also,
TextIOWrapper.tell() and TextIOWrapper.seek() are both quite slow
due to the reconstruction algorithm used.
StringIO, however, is a native in-memory unicode container and will
exhibit similar speed to BytesIO.


Multi-threading¶
FileIO objects are thread-safe to the extent that the operating system
calls (such as read(2) under Unix) they wrap are thread-safe too.
Binary buffered objects (instances of BufferedReader,
BufferedWriter, BufferedRandom and BufferedRWPair)
protect their internal structures using a lock; it is therefore safe to call
them from multiple threads at once.
TextIOWrapper objects are not thread-safe.


Reentrancy¶
Binary buffered objects (instances of BufferedReader,
BufferedWriter, BufferedRandom and BufferedRWPair)
are not reentrant.  While reentrant calls will not happen in normal situations,
they can arise from doing I/O in a signal handler.  If a thread tries to
re-enter a buffered object which it is already accessing, a RuntimeError
is raised.  Note this doesn’t prohibit a different thread from entering the
buffered object.
The above implicitly extends to text files, since the open() function
will wrap a buffered object inside a TextIOWrapper.  This includes
standard streams and therefore affects the built-in function print() as
well.

