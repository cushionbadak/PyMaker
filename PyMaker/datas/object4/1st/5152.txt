link:
library/ssl.html#certificate-handling

docs:

Certificate handling¶


ssl.match_hostname(cert, hostname)¶
Verify that cert (in decoded format as returned by
SSLSocket.getpeercert()) matches the given hostname.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in RFC 2818, RFC 5280 and RFC 6125.  In addition to HTTPS, this
function should be suitable for checking the identity of servers in
various SSL-based protocols such as FTPS, IMAPS, POPS and others.
CertificateError is raised on failure. On success, the function
returns nothing:
>>> cert = {'subject': ((('commonName', 'example.com'),),)}
>>> ssl.match_hostname(cert, "example.com")
>>> ssl.match_hostname(cert, "example.org")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/py3k/Lib/ssl.py", line 130, in match_hostname
ssl.CertificateError: hostname 'example.org' doesn't match 'example.com'



New in version 3.2.


Changed in version 3.3.3: The function now follows RFC 6125, section 6.4.3 and does neither
match multiple wildcards (e.g. *.*.com or *a*.example.org) nor
a wildcard inside an internationalized domain names (IDN) fragment.
IDN A-labels such as www*.xn--pthon-kva.org are still supported,
but x*.python.org no longer matches xn--tda.python.org.


Changed in version 3.5: Matching of IP addresses, when present in the subjectAltName field
of the certificate, is now supported.


Changed in version 3.7: The function is no longer used to TLS connections. Hostname matching
is now performed by OpenSSL.
Allow wildcard when it is the leftmost and the only character
in that segment. Partial wildcards like www*.example.com are no
longer supported.


Deprecated since version 3.7.




ssl.cert_time_to_seconds(cert_time)¶
Return the time in seconds since the Epoch, given the cert_time
string representing the “notBefore” or “notAfter” date from a
certificate in "%b %d %H:%M:%S %Y %Z" strptime format (C
locale).
Here’s an example:
>>> import ssl
>>> timestamp = ssl.cert_time_to_seconds("Jan  5 09:34:43 2018 GMT")
>>> timestamp  
1515144883
>>> from datetime import datetime
>>> print(datetime.utcfromtimestamp(timestamp))  
2018-01-05 09:34:43


“notBefore” or “notAfter” dates must use GMT (RFC 5280).

Changed in version 3.5: Interpret the input time as a time in UTC as specified by ‘GMT’
timezone in the input string. Local timezone was used
previously. Return an integer (no fractions of a second in the
input format)




ssl.get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None)¶
Given the address addr of an SSL-protected server, as a (hostname,
port-number) pair, fetches the server’s certificate, and returns it as a
PEM-encoded string.  If ssl_version is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If ca_certs is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in
SSLContext.wrap_socket().  The call will attempt to validate the
server certificate against that set of root certificates, and will fail
if the validation attempt fails.

Changed in version 3.3: This function is now IPv6-compatible.


Changed in version 3.5: The default ssl_version is changed from PROTOCOL_SSLv3 to
PROTOCOL_TLS for maximum compatibility with modern servers.




ssl.DER_cert_to_PEM_cert(DER_cert_bytes)¶
Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.



ssl.PEM_cert_to_DER_cert(PEM_cert_string)¶
Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.



ssl.get_default_verify_paths()¶
Returns a named tuple with paths to OpenSSL’s default cafile and capath.
The paths are the same as used by
SSLContext.set_default_verify_paths(). The return value is a
named tuple DefaultVerifyPaths:

cafile - resolved path to cafile or None if the file doesn’t exist,
capath - resolved path to capath or None if the directory doesn’t exist,
openssl_cafile_env - OpenSSL’s environment key that points to a cafile,
openssl_cafile - hard coded path to a cafile,
openssl_capath_env - OpenSSL’s environment key that points to a capath,
openssl_capath - hard coded path to a capath directory

Availability: LibreSSL ignores the environment vars
openssl_cafile_env and openssl_capath_env.

New in version 3.4.




ssl.enum_certificates(store_name)¶
Retrieve certificates from Windows’ system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data. Trust specifies the purpose of the certificate as a set
of OIDS or exactly True if the certificate is trustworthy for all
purposes.
Example:
>>> ssl.enum_certificates("CA")
[(b'data...', 'x509_asn', {'1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'}),
 (b'data...', 'x509_asn', True)]


Availability: Windows.

New in version 3.4.




ssl.enum_crls(store_name)¶
Retrieve CRLs from Windows’ system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data.
Availability: Windows.

New in version 3.4.




ssl.wrap_socket(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=CERT_NONE, ssl_version=PROTOCOL_TLS, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)¶
Takes an instance sock of socket.socket, and returns an instance
of ssl.SSLSocket, a subtype of socket.socket, which wraps
the underlying socket in an SSL context.  sock must be a
SOCK_STREAM socket; other socket types are unsupported.
Internally, function creates a SSLContext with protocol
ssl_version and SSLContext.options set to cert_reqs. If
parameters keyfile, certfile, ca_certs or ciphers are set, then
the values are passed to SSLContext.load_cert_chain(),
SSLContext.load_verify_locations(), and
SSLContext.set_ciphers().
The arguments server_side, do_handshake_on_connect, and
suppress_ragged_eofs have the same meaning as
SSLContext.wrap_socket().

Deprecated since version 3.7: Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() instead of wrap_socket(). The
top-level function is limited and creates an insecure client socket
without server name indication or hostname matching.


