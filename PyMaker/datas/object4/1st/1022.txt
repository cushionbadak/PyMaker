link:
library/codecs.html#codecs.Codec.decode

docs:

<dt id="codecs.Codec.decode">
<code class="descclassname">Codec.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes the object <em>input</em> and returns a tuple (output object, length
consumed).  For instance, for a <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>, decoding converts
a bytes object encoded using a particular
character set encoding to a string object.</p>
<p>For text encodings and bytes-to-bytes codecs,
<em>input</em> must be a bytes object or one which provides the read-only
buffer interface – for example, buffer objects and memory mapped files.</p>
<p>The <em>errors</em> argument defines the error handling to apply.
It defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> handling.</p>
<p>The method may not store state in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> instance. Use
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> for codecs which have to keep state in order to make
decoding efficient.</p>
<p>The decoder must be able to handle zero length input and return an empty object
of the output object type in this situation.</p>
</dd>