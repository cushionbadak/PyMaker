link:
library/doctest.html#how-are-docstring-examples-recognized

docs:

How are Docstring Examples Recognized?¶
In most cases a copy-and-paste of an interactive console session works fine,
but doctest isn’t trying to do an exact emulation of any specific Python shell.
>>> # comments are ignored
>>> x = 12
>>> x
12
>>> if x == 13:
...     print("yes")
... else:
...     print("no")
...     print("NO")
...     print("NO!!!")
...
no
NO
NO!!!
>>>


Any expected output must immediately follow the final '>>> ' or '... '
line containing the code, and the expected output (if any) extends to the next
'>>> ' or all-whitespace line.
The fine print:

Expected output cannot contain an all-whitespace line, since such a line is
taken to signal the end of expected output.  If expected output does contain a
blank line, put <BLANKLINE> in your doctest example each place a blank line
is expected.

All hard tab characters are expanded to spaces, using 8-column tab stops.
Tabs in output generated by the tested code are not modified.  Because any
hard tabs in the sample output are expanded, this means that if the code
output includes hard tabs, the only way the doctest can pass is if the
NORMALIZE_WHITESPACE option or directive
is in effect.
Alternatively, the test can be rewritten to capture the output and compare it
to an expected value as part of the test.  This handling of tabs in the
source was arrived at through trial and error, and has proven to be the least
error prone way of handling them.  It is possible to use a different
algorithm for handling tabs by writing a custom DocTestParser class.

Output to stdout is captured, but not output to stderr (exception tracebacks
are captured via a different means).

If you continue a line via backslashing in an interactive session, or for any
other reason use a backslash, you should use a raw docstring, which will
preserve your backslashes exactly as you type them:
>>> def f(x):
...     r'''Backslashes in a raw docstring: m\n'''
>>> print(f.__doc__)
Backslashes in a raw docstring: m\n


Otherwise, the backslash will be interpreted as part of the string. For example,
the \n above would be interpreted as a newline character.  Alternatively, you
can double each backslash in the doctest version (and not use a raw string):
>>> def f(x):
...     '''Backslashes in a raw docstring: m\\n'''
>>> print(f.__doc__)
Backslashes in a raw docstring: m\n



The starting column doesn’t matter:
>>> assert "Easy!"
      >>> import math
          >>> math.floor(1.9)
          1


and as many leading whitespace characters are stripped from the expected output
as appeared in the initial '>>> ' line that started the example.


