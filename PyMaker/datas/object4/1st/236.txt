link:
reference/expressions.html#primaries

docs:

6.3. Primaries¶
Primaries represent the most tightly bound operations of the language. Their
syntax is:

primary ::=  atom | attributeref | subscription | slicing | call


6.3.1. Attribute references¶
An attribute reference is a primary followed by a period and a name:

attributeref ::=  primary "." identifier

The primary must evaluate to an object of a type that supports attribute
references, which most objects do.  This object is then asked to produce the
attribute whose name is the identifier.  This production can be customized by
overriding the __getattr__() method.  If this attribute is not available,
the exception AttributeError is raised.  Otherwise, the type and value of
the object produced is determined by the object.  Multiple evaluations of the
same attribute reference may yield different objects.


6.3.2. Subscriptions¶
A subscription selects an item of a sequence (string, tuple or list) or mapping
(dictionary) object:

subscription ::=  primary "[" expression_list "]"

The primary must evaluate to an object that supports subscription (lists or
dictionaries for example).  User-defined objects can support subscription by
defining a __getitem__() method.
For built-in objects, there are two types of objects that support subscription:
If the primary is a mapping, the expression list must evaluate to an object
whose value is one of the keys of the mapping, and the subscription selects the
value in the mapping that corresponds to that key.  (The expression list is a
tuple except if it has exactly one item.)
If the primary is a sequence, the expression list must evaluate to an integer
or a slice (as discussed in the following section).
The formal syntax makes no special provision for negative indices in
sequences; however, built-in sequences all provide a __getitem__()
method that interprets negative indices by adding the length of the sequence
to the index (so that x[-1] selects the last item of x).  The
resulting value must be a nonnegative integer less than the number of items in
the sequence, and the subscription selects the item whose index is that value
(counting from zero). Since the support for negative indices and slicing
occurs in the object’s __getitem__() method, subclasses overriding
this method will need to explicitly add that support.
A string’s items are characters.  A character is not a separate data type but a
string of exactly one character.


6.3.3. Slicings¶
A slicing selects a range of items in a sequence object (e.g., a string, tuple
or list).  Slicings may be used as expressions or as targets in assignment or
del statements.  The syntax for a slicing:

slicing      ::=  primary "[" slice_list "]"
slice_list   ::=  slice_item ("," slice_item)* [","]
slice_item   ::=  expression | proper_slice
proper_slice ::=  [lower_bound] ":" [upper_bound] [ ":" [stride] ]
lower_bound  ::=  expression
upper_bound  ::=  expression
stride       ::=  expression

There is ambiguity in the formal syntax here: anything that looks like an
expression list also looks like a slice list, so any subscription can be
interpreted as a slicing.  Rather than further complicating the syntax, this is
disambiguated by defining that in this case the interpretation as a subscription
takes priority over the interpretation as a slicing (this is the case if the
slice list contains no proper slice).
The semantics for a slicing are as follows.  The primary is indexed (using the
same __getitem__() method as
normal subscription) with a key that is constructed from the slice list, as
follows.  If the slice list contains at least one comma, the key is a tuple
containing the conversion of the slice items; otherwise, the conversion of the
lone slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of a proper slice is a slice
object (see section The standard type hierarchy) whose start,
stop and step attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting None for missing expressions.


6.3.4. Calls¶
A call calls a callable object (e.g., a function) with a possibly empty
series of arguments:

call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
argument_list        ::=  positional_arguments ["," starred_and_keywords]
                            ["," keywords_arguments]
                          | starred_and_keywords ["," keywords_arguments]
                          | keywords_arguments
positional_arguments ::=  ["*"] expression ("," ["*"] expression)*
starred_and_keywords ::=  ("*" expression | keyword_item)
                          ("," "*" expression | "," keyword_item)*
keywords_arguments   ::=  (keyword_item | "**" expression)
                          ("," keyword_item | "," "**" expression)*
keyword_item         ::=  identifier "=" expression

An optional trailing comma may be present after the positional and keyword arguments
but does not affect the semantics.
The primary must evaluate to a callable object (user-defined functions, built-in
functions, methods of built-in objects, class objects, methods of class
instances, and all objects having a __call__() method are callable).  All
argument expressions are evaluated before the call is attempted.  Please refer
to section Function definitions for the syntax of formal parameter lists.
If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for the
formal parameters.  If there are N positional arguments, they are placed in the
first N slots.  Next, for each keyword argument, the identifier is used to
determine the corresponding slot (if the identifier is the same as the first
formal parameter name, the first slot is used, and so on).  If the slot is
already filled, a TypeError exception is raised. Otherwise, the value of
the argument is placed in the slot, filling it (even if the expression is
None, it fills the slot).  When all arguments have been processed, the slots
that are still unfilled are filled with the corresponding default value from the
function definition.  (Default values are calculated, once, when the function is
defined; thus, a mutable object such as a list or dictionary used as default
value will be shared by all calls that don’t specify an argument value for the
corresponding slot; this should usually be avoided.)  If there are any unfilled
slots for which no default value is specified, a TypeError exception is
raised.  Otherwise, the list of filled slots is used as the argument list for
the call.

CPython implementation detail: An implementation may provide built-in functions whose positional parameters
do not have names, even if they are ‘named’ for the purpose of documentation,
and which therefore cannot be supplied by keyword.  In CPython, this is the
case for functions implemented in C that use PyArg_ParseTuple() to
parse their arguments.

If there are more positional arguments than there are formal parameter slots, a
TypeError exception is raised, unless a formal parameter using the syntax
*identifier is present; in this case, that formal parameter receives a tuple
containing the excess positional arguments (or an empty tuple if there were no
excess positional arguments).
If any keyword argument does not correspond to a formal parameter name, a
TypeError exception is raised, unless a formal parameter using the syntax
**identifier is present; in this case, that formal parameter receives a
dictionary containing the excess keyword arguments (using the keywords as keys
and the argument values as corresponding values), or a (new) empty dictionary if
there were no excess keyword arguments.
If the syntax *expression appears in the function call, expression must
evaluate to an iterable.  Elements from these iterables are
treated as if they were additional positional arguments.  For the call
f(x1, x2, *y, x3, x4), if y evaluates to a sequence y1, …, yM,
this is equivalent to a call with M+4 positional arguments x1, x2,
y1, …, yM, x3, x4.
A consequence of this is that although the *expression syntax may appear
after explicit keyword arguments, it is processed before the
keyword arguments (and any **expression arguments – see below).  So:
>>> def f(a, b):
...     print(a, b)
...
>>> f(b=1, *(2,))
2 1
>>> f(a=1, *(2,))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() got multiple values for keyword argument 'a'
>>> f(1, *(2,))
1 2


It is unusual for both keyword arguments and the *expression syntax to be
used in the same call, so in practice this confusion does not arise.
If the syntax **expression appears in the function call, expression must
evaluate to a mapping, the contents of which are treated as
additional keyword arguments.  If a keyword is already present
(as an explicit keyword argument, or from another unpacking),
a TypeError exception is raised.
Formal parameters using the syntax *identifier or **identifier cannot be
used as positional argument slots or as keyword argument names.

Changed in version 3.5: Function calls accept any number of * and ** unpackings,
positional arguments may follow iterable unpackings (*),
and keyword arguments may follow dictionary unpackings (**).
Originally proposed by PEP 448.

A call always returns some value, possibly None, unless it raises an
exception.  How this value is computed depends on the type of the callable
object.
If it is—

a user-defined function:
The code block for the function is executed, passing it the argument list.  The
first thing the code block will do is bind the formal parameters to the
arguments; this is described in section Function definitions.  When the code block
executes a return statement, this specifies the return value of the
function call.

a built-in function or method:
The result is up to the interpreter; see Built-in Functions for the
descriptions of built-in functions and methods.

a class object:
A new instance of that class is returned.

a class instance method:
The corresponding user-defined function is called, with an argument list that is
one longer than the argument list of the call: the instance becomes the first
argument.

a class instance:
The class must define a __call__() method; the effect is then the same as
if that method was called.



