link:
library/collections.abc.html#collections.abc.Iterable

docs:

<dt id="collections.abc.Iterable">
<em class="property">class </em><code class="descclassname">collections.abc.</code><code class="descname">Iterable</code><a class="headerlink" href="#collections.abc.Iterable" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ABC for classes that provide the <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method.</p>
<p>Checking <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">Iterable)</span></code> detects classes that are registered
as <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a> or that have an <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method, but it does
not detect classes that iterate with the <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method.
The only reliable way to determine whether an object is <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a>
is to call <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code>.</p>
</dd>