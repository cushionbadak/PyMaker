link:
library/unittest.mock-examples.html#checking-multiple-calls-with-mock

docs:

Checking multiple calls with mockÂ¶
mock has a nice API for making assertions about how your mock objects are used.
>>> mock = Mock()
>>> mock.foo_bar.return_value = None
>>> mock.foo_bar('baz', spam='eggs')
>>> mock.foo_bar.assert_called_with('baz', spam='eggs')


If your mock is only being called once you can use the
assert_called_once_with() method that also asserts that the
call_count is one.
>>> mock.foo_bar.assert_called_once_with('baz', spam='eggs')
>>> mock.foo_bar()
>>> mock.foo_bar.assert_called_once_with('baz', spam='eggs')
Traceback (most recent call last):
    ...
AssertionError: Expected to be called once. Called 2 times.


Both assert_called_with and assert_called_once_with make assertions about
the most recent call. If your mock is going to be called several times, and
you want to make assertions about all those calls you can use
call_args_list:
>>> mock = Mock(return_value=None)
>>> mock(1, 2, 3)
>>> mock(4, 5, 6)
>>> mock()
>>> mock.call_args_list
[call(1, 2, 3), call(4, 5, 6), call()]


The call helper makes it easy to make assertions about these calls. You
can build up a list of expected calls and compare it to call_args_list. This
looks remarkably similar to the repr of the call_args_list:
>>> expected = [call(1, 2, 3), call(4, 5, 6), call()]
>>> mock.call_args_list == expected
True


