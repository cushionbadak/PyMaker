link:
library/stdtypes.html#additional-methods-on-integer-types

docs:

Additional Methods on Integer Types¶
The int type implements the numbers.Integral abstract base
class. In addition, it provides a few more methods:


int.bit_length()¶
Return the number of bits necessary to represent an integer in binary,
excluding the sign and leading zeros:
>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6


More precisely, if x is nonzero, then x.bit_length() is the
unique positive integer k such that 2**(k-1) <= abs(x) < 2**k.
Equivalently, when abs(x) is small enough to have a correctly
rounded logarithm, then k = 1 + int(log(abs(x), 2)).
If x is zero, then x.bit_length() returns 0.
Equivalent to:
def bit_length(self):
    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
    s = s.lstrip('-0b') # remove leading zeros and minus sign
    return len(s)       # len('100101') --> 6



New in version 3.1.




int.to_bytes(length, byteorder, *, signed=False)¶
Return an array of bytes representing an integer.
>>> (1024).to_bytes(2, byteorder='big')
b'\x04\x00'
>>> (1024).to_bytes(10, byteorder='big')
b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
>>> (-1024).to_bytes(10, byteorder='big', signed=True)
b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
>>> x = 1000
>>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')
b'\xe8\x03'


The integer is represented using length bytes.  An OverflowError
is raised if the integer is not representable with the given number of
bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is "big", the most significant byte is at the
beginning of the byte array.  If byteorder is "little", the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use sys.byteorder as the byte order
value.
The signed argument determines whether two’s complement is used to
represent the integer.  If signed is False and a negative integer is
given, an OverflowError is raised. The default value for signed
is False.

New in version 3.2.




classmethod int.from_bytes(bytes, byteorder, *, signed=False)¶
Return the integer represented by the given array of bytes.
>>> int.from_bytes(b'\x00\x10', byteorder='big')
16
>>> int.from_bytes(b'\x00\x10', byteorder='little')
4096
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
-1024
>>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
64512
>>> int.from_bytes([255, 0, 0], byteorder='big')
16711680


The argument bytes must either be a bytes-like object or an
iterable producing bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is "big", the most significant byte is at the
beginning of the byte array.  If byteorder is "little", the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use sys.byteorder as the byte order
value.
The signed argument indicates whether two’s complement is used to
represent the integer.

New in version 3.2.


