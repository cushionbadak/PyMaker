link:
library/pathlib.html#concrete-paths

docs:

Concrete paths¶
Concrete paths are subclasses of the pure path classes.  In addition to
operations provided by the latter, they also provide methods to do system
calls on path objects.  There are three ways to instantiate concrete paths:


class pathlib.Path(*pathsegments)¶
A subclass of PurePath, this class represents concrete paths of
the system’s path flavour (instantiating it creates either a
PosixPath or a WindowsPath):
>>> Path('setup.py')
PosixPath('setup.py')


pathsegments is specified similarly to PurePath.



class pathlib.PosixPath(*pathsegments)¶
A subclass of Path and PurePosixPath, this class
represents concrete non-Windows filesystem paths:
>>> PosixPath('/etc')
PosixPath('/etc')


pathsegments is specified similarly to PurePath.



class pathlib.WindowsPath(*pathsegments)¶
A subclass of Path and PureWindowsPath, this class
represents concrete Windows filesystem paths:
>>> WindowsPath('c:/Program Files/')
WindowsPath('c:/Program Files')


pathsegments is specified similarly to PurePath.

You can only instantiate the class flavour that corresponds to your system
(allowing system calls on non-compatible path flavours could lead to
bugs or failures in your application):
>>> import os
>>> os.name
'posix'
>>> Path('setup.py')
PosixPath('setup.py')
>>> PosixPath('setup.py')
PosixPath('setup.py')
>>> WindowsPath('setup.py')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "pathlib.py", line 798, in __new__
    % (cls.__name__,))
NotImplementedError: cannot instantiate 'WindowsPath' on your system



Methods¶
Concrete paths provide the following methods in addition to pure paths
methods.  Many of these methods can raise an OSError if a system
call fails (for example because the path doesn’t exist):


classmethod Path.cwd()¶
Return a new path object representing the current directory (as returned
by os.getcwd()):
>>> Path.cwd()
PosixPath('/home/antoine/pathlib')





classmethod Path.home()¶
Return a new path object representing the user’s home directory (as
returned by os.path.expanduser() with ~ construct):
>>> Path.home()
PosixPath('/home/antoine')



New in version 3.5.




Path.stat()¶
Return information about this path (similarly to os.stat()).
The result is looked up at each call to this method.
>>> p = Path('setup.py')
>>> p.stat().st_size
956
>>> p.stat().st_mtime
1327883547.852554





Path.chmod(mode)¶
Change the file mode and permissions, like os.chmod():
>>> p = Path('setup.py')
>>> p.stat().st_mode
33277
>>> p.chmod(0o444)
>>> p.stat().st_mode
33060





Path.exists()¶
Whether the path points to an existing file or directory:
>>> Path('.').exists()
True
>>> Path('setup.py').exists()
True
>>> Path('/etc').exists()
True
>>> Path('nonexistentfile').exists()
False



Note
If the path points to a symlink, exists() returns whether the
symlink points to an existing file or directory.




Path.expanduser()¶
Return a new path with expanded ~ and ~user constructs,
as returned by os.path.expanduser():
>>> p = PosixPath('~/films/Monty Python')
>>> p.expanduser()
PosixPath('/home/eric/films/Monty Python')



New in version 3.5.




Path.glob(pattern)¶
Glob the given relative pattern in the directory represented by this path,
yielding all matching files (of any kind):
>>> sorted(Path('.').glob('*.py'))
[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
>>> sorted(Path('.').glob('*/*.py'))
[PosixPath('docs/conf.py')]


The “**” pattern means “this directory and all subdirectories,
recursively”.  In other words, it enables recursive globbing:
>>> sorted(Path('.').glob('**/*.py'))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]



Note
Using the “**” pattern in large directory trees may consume
an inordinate amount of time.




Path.group()¶
Return the name of the group owning the file.  KeyError is raised
if the file’s gid isn’t found in the system database.



Path.is_dir()¶
Return True if the path points to a directory (or a symbolic link
pointing to a directory), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.is_file()¶
Return True if the path points to a regular file (or a symbolic link
pointing to a regular file), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.is_mount()¶
Return True if the path is a mount point: a point in a
file system where a different file system has been mounted.  On POSIX, the
function checks whether path’s parent, path/.., is on a different
device than path, or whether path/.. and path point to the same
i-node on the same device — this should detect mount points for all Unix
and POSIX variants.  Not implemented on Windows.

New in version 3.7.




Path.is_symlink()¶
Return True if the path points to a symbolic link, False otherwise.
False is also returned if the path doesn’t exist; other errors (such
as permission errors) are propagated.



Path.is_socket()¶
Return True if the path points to a Unix socket (or a symbolic link
pointing to a Unix socket), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.is_fifo()¶
Return True if the path points to a FIFO (or a symbolic link
pointing to a FIFO), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.is_block_device()¶
Return True if the path points to a block device (or a symbolic link
pointing to a block device), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.is_char_device()¶
Return True if the path points to a character device (or a symbolic link
pointing to a character device), False if it points to another kind of file.
False is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.



Path.iterdir()¶
When the path points to a directory, yield path objects of the directory
contents:
>>> p = Path('docs')
>>> for child in p.iterdir(): child
...
PosixPath('docs/conf.py')
PosixPath('docs/_templates')
PosixPath('docs/make.bat')
PosixPath('docs/index.rst')
PosixPath('docs/_build')
PosixPath('docs/_static')
PosixPath('docs/Makefile')





Path.lchmod(mode)¶
Like Path.chmod() but, if the path points to a symbolic link, the
symbolic link’s mode is changed rather than its target’s.



Path.lstat()¶
Like Path.stat() but, if the path points to a symbolic link, return
the symbolic link’s information rather than its target’s.



Path.mkdir(mode=0o777, parents=False, exist_ok=False)¶
Create a new directory at this given path.  If mode is given, it is
combined with the process’ umask value to determine the file mode
and access flags.  If the path already exists, FileExistsError
is raised.
If parents is true, any missing parents of this path are created
as needed; they are created with the default permissions without taking
mode into account (mimicking the POSIX mkdir -p command).
If parents is false (the default), a missing parent raises
FileNotFoundError.
If exist_ok is false (the default), FileExistsError is
raised if the target directory already exists.
If exist_ok is true, FileExistsError exceptions will be
ignored (same behavior as the POSIX mkdir -p command), but only if the
last path component is not an existing non-directory file.

Changed in version 3.5: The exist_ok parameter was added.




Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)¶
Open the file pointed to by the path, like the built-in open()
function does:
>>> p = Path('setup.py')
>>> with p.open() as f:
...     f.readline()
...
'#!/usr/bin/env python3\n'





Path.owner()¶
Return the name of the user owning the file.  KeyError is raised
if the file’s uid isn’t found in the system database.



Path.read_bytes()¶
Return the binary contents of the pointed-to file as a bytes object:
>>> p = Path('my_binary_file')
>>> p.write_bytes(b'Binary file contents')
20
>>> p.read_bytes()
b'Binary file contents'



New in version 3.5.




Path.read_text(encoding=None, errors=None)¶
Return the decoded contents of the pointed-to file as a string:
>>> p = Path('my_text_file')
>>> p.write_text('Text file contents')
18
>>> p.read_text()
'Text file contents'


The file is opened and then closed. The optional parameters have the same
meaning as in open().

New in version 3.5.




Path.rename(target)¶
Rename this file or directory to the given target.  On Unix, if
target exists and is a file, it will be replaced silently if the user
has permission.  target can be either a string or another path object:
>>> p = Path('foo')
>>> p.open('w').write('some text')
9
>>> target = Path('bar')
>>> p.rename(target)
>>> target.open().read()
'some text'





Path.replace(target)¶
Rename this file or directory to the given target.  If target points
to an existing file or directory, it will be unconditionally replaced.



Path.resolve(strict=False)¶
Make the path absolute, resolving any symlinks.  A new path object is
returned:
>>> p = Path()
>>> p
PosixPath('.')
>>> p.resolve()
PosixPath('/home/antoine/pathlib')


“..” components are also eliminated (this is the only method to do so):
>>> p = Path('docs/../setup.py')
>>> p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')


If the path doesn’t exist and strict is True, FileNotFoundError
is raised.  If strict is False, the path is resolved as far as possible
and any remainder is appended without checking whether it exists.  If an
infinite loop is encountered along the resolution path, RuntimeError
is raised.

New in version 3.6: The strict argument (pre-3.6 behavior is strict).




Path.rglob(pattern)¶
This is like calling Path.glob() with “**/” added in front of the
given relative pattern:
>>> sorted(Path().rglob("*.py"))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]





Path.rmdir()¶
Remove this directory.  The directory must be empty.



Path.samefile(other_path)¶
Return whether this path points to the same file as other_path, which
can be either a Path object, or a string.  The semantics are similar
to os.path.samefile() and os.path.samestat().
An OSError can be raised if either file cannot be accessed for some
reason.
>>> p = Path('spam')
>>> q = Path('eggs')
>>> p.samefile(q)
False
>>> p.samefile('spam')
True



New in version 3.5.




Path.symlink_to(target, target_is_directory=False)¶
Make this path a symbolic link to target.  Under Windows,
target_is_directory must be true (default False) if the link’s target
is a directory.  Under POSIX, target_is_directory’s value is ignored.
>>> p = Path('mylink')
>>> p.symlink_to('setup.py')
>>> p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')
>>> p.stat().st_size
956
>>> p.lstat().st_size
8



Note
The order of arguments (link, target) is the reverse
of os.symlink()’s.




Path.touch(mode=0o666, exist_ok=True)¶
Create a file at this given path.  If mode is given, it is combined
with the process’ umask value to determine the file mode and access
flags.  If the file already exists, the function succeeds if exist_ok
is true (and its modification time is updated to the current time),
otherwise FileExistsError is raised.



Path.unlink()¶
Remove this file or symbolic link.  If the path points to a directory,
use Path.rmdir() instead.



Path.write_bytes(data)¶
Open the file pointed to in bytes mode, write data to it, and close the
file:
>>> p = Path('my_binary_file')
>>> p.write_bytes(b'Binary file contents')
20
>>> p.read_bytes()
b'Binary file contents'


An existing file of the same name is overwritten.

New in version 3.5.




Path.write_text(data, encoding=None, errors=None)¶
Open the file pointed to in text mode, write data to it, and close the
file:
>>> p = Path('my_text_file')
>>> p.write_text('Text file contents')
18
>>> p.read_text()
'Text file contents'



New in version 3.5.



