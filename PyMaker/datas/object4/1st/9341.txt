link:
library/contextlib.html#contextlib.ContextDecorator

docs:


class contextlib.ContextDecoratorÂ¶
A base class that enables a context manager to also be used as a decorator.
Context managers inheriting from ContextDecorator have to implement
__enter__ and __exit__ as normal. __exit__ retains its optional
exception handling even when used as a decorator.
ContextDecorator is used by contextmanager(), so you get this
functionality automatically.
Example of ContextDecorator:
from contextlib import ContextDecorator

class mycontext(ContextDecorator):
    def __enter__(self):
        print('Starting')
        return self

    def __exit__(self, *exc):
        print('Finishing')
        return False

>>> @mycontext()
... def function():
...     print('The bit in the middle')
...
>>> function()
Starting
The bit in the middle
Finishing

>>> with mycontext():
...     print('The bit in the middle')
...
Starting
The bit in the middle
Finishing


This change is just syntactic sugar for any construct of the following form:
def f():
    with cm():
        # Do stuff


ContextDecorator lets you instead write:
@cm()
def f():
    # Do stuff


It makes it clear that the cm applies to the whole function, rather than
just a piece of it (and saving an indentation level is nice, too).
Existing context managers that already have a base class can be extended by
using ContextDecorator as a mixin class:
from contextlib import ContextDecorator

class mycontext(ContextBaseClass, ContextDecorator):
    def __enter__(self):
        return self

    def __exit__(self, *exc):
        return False



Note
As the decorated function must be able to be called multiple times, the
underlying context manager must support use in multiple with
statements. If this is not the case, then the original construct with the
explicit with statement inside the function should be used.


New in version 3.2.

