link:
library/io.html#i-o-base-classes

docs:

I/O Base Classes¶


class io.IOBase¶
The abstract base class for all I/O classes, acting on streams of bytes.
There is no public constructor.
This class provides empty abstract implementations for many methods
that derived classes can override selectively; the default
implementations represent a file that cannot be read, written or
seeked.
Even though IOBase does not declare read()
or write() because their signatures will vary, implementations and
clients should consider those methods part of the interface.  Also,
implementations may raise a ValueError (or UnsupportedOperation)
when operations they do not support are called.
The basic type used for binary data read from or written to a file is
bytes.  Other bytes-like objects are
accepted as method arguments too.  Text I/O classes work with str data.
Note that calling any method (even inquiries) on a closed stream is
undefined.  Implementations may raise ValueError in this case.
IOBase (and its subclasses) supports the iterator protocol, meaning
that an IOBase object can be iterated over yielding the lines in a
stream.  Lines are defined slightly differently depending on whether the
stream is a binary stream (yielding bytes), or a text stream (yielding
character strings).  See readline() below.
IOBase is also a context manager and therefore supports the
with statement.  In this example, file is closed after the
with statement’s suite is finished—even if an exception occurs:
with open('spam.txt', 'w') as file:
    file.write('Spam and eggs!')


IOBase provides these data attributes and methods:


close()¶
Flush and close this stream. This method has no effect if the file is
already closed. Once the file is closed, any operation on the file
(e.g. reading or writing) will raise a ValueError.
As a convenience, it is allowed to call this method more than once;
only the first call, however, will have an effect.



closed¶
True if the stream is closed.



fileno()¶
Return the underlying file descriptor (an integer) of the stream if it
exists.  An OSError is raised if the IO object does not use a file
descriptor.



flush()¶
Flush the write buffers of the stream if applicable.  This does nothing
for read-only and non-blocking streams.



isatty()¶
Return True if the stream is interactive (i.e., connected to
a terminal/tty device).



readable()¶
Return True if the stream can be read from.  If False, read()
will raise OSError.



readline(size=-1)¶
Read and return one line from the stream.  If size is specified, at
most size bytes will be read.
The line terminator is always b'\n' for binary files; for text files,
the newline argument to open() can be used to select the line
terminator(s) recognized.



readlines(hint=-1)¶
Read and return a list of lines from the stream.  hint can be specified
to control the number of lines read: no more lines will be read if the
total size (in bytes/characters) of all lines so far exceeds hint.
Note that it’s already possible to iterate on file objects using for
line in file: ... without calling file.readlines().



seek(offset[, whence])¶
Change the stream position to the given byte offset.  offset is
interpreted relative to the position indicated by whence.  The default
value for whence is SEEK_SET.  Values for whence are:

SEEK_SET or 0 – start of the stream (the default);
offset should be zero or positive
SEEK_CUR or 1 – current stream position; offset may
be negative
SEEK_END or 2 – end of the stream; offset is usually
negative

Return the new absolute position.

New in version 3.1: The SEEK_* constants.


New in version 3.3: Some operating systems could support additional values, like
os.SEEK_HOLE or os.SEEK_DATA. The valid values
for a file could depend on it being open in text or binary mode.




seekable()¶
Return True if the stream supports random access.  If False,
seek(), tell() and truncate() will raise OSError.



tell()¶
Return the current stream position.



truncate(size=None)¶
Resize the stream to the given size in bytes (or the current position
if size is not specified).  The current stream position isn’t changed.
This resizing can extend or reduce the current file size.  In case of
extension, the contents of the new file area depend on the platform
(on most systems, additional bytes are zero-filled).  The new file size
is returned.

Changed in version 3.5: Windows will now zero-fill files when extending.




writable()¶
Return True if the stream supports writing.  If False,
write() and truncate() will raise OSError.



writelines(lines)¶
Write a list of lines to the stream.  Line separators are not added, so it
is usual for each of the lines provided to have a line separator at the
end.



__del__()¶
Prepare for object destruction. IOBase provides a default
implementation of this method that calls the instance’s
close() method.




class io.RawIOBase¶
Base class for raw binary I/O.  It inherits IOBase.  There is no
public constructor.
Raw binary I/O typically provides low-level access to an underlying OS
device or API, and does not try to encapsulate it in high-level primitives
(this is left to Buffered I/O and Text I/O, described later in this page).
In addition to the attributes and methods from IOBase,
RawIOBase provides the following methods:


read(size=-1)¶
Read up to size bytes from the object and return them.  As a convenience,
if size is unspecified or -1, all bytes until EOF are returned.
Otherwise, only one system call is ever made.  Fewer than size bytes may
be returned if the operating system call returns fewer than size bytes.
If 0 bytes are returned, and size was not 0, this indicates end of file.
If the object is in non-blocking mode and no bytes are available,
None is returned.
The default implementation defers to readall() and
readinto().



readall()¶
Read and return all the bytes from the stream until EOF, using multiple
calls to the stream if necessary.



readinto(b)¶
Read bytes into a pre-allocated, writable
bytes-like object b, and return the
number of bytes read.  For example, b might be a bytearray.
If the object is in non-blocking mode and no bytes
are available, None is returned.



write(b)¶
Write the given bytes-like object, b, to the
underlying raw stream, and return the number of
bytes written.  This can be less than the length of b in
bytes, depending on specifics of the underlying raw
stream, and especially if it is in non-blocking mode.  None is
returned if the raw stream is set not to block and no single byte could
be readily written to it.  The caller may release or mutate b after
this method returns, so the implementation should only access b
during the method call.




class io.BufferedIOBase¶
Base class for binary streams that support some kind of buffering.
It inherits IOBase. There is no public constructor.
The main difference with RawIOBase is that methods read(),
readinto() and write() will try (respectively) to read as much
input as requested or to consume all given output, at the expense of
making perhaps more than one system call.
In addition, those methods can raise BlockingIOError if the
underlying raw stream is in non-blocking mode and cannot take or give
enough data; unlike their RawIOBase counterparts, they will
never return None.
Besides, the read() method does not have a default
implementation that defers to readinto().
A typical BufferedIOBase implementation should not inherit from a
RawIOBase implementation, but wrap one, like
BufferedWriter and BufferedReader do.
BufferedIOBase provides or overrides these methods and attribute in
addition to those from IOBase:


raw¶
The underlying raw stream (a RawIOBase instance) that
BufferedIOBase deals with.  This is not part of the
BufferedIOBase API and may not exist on some implementations.



detach()¶
Separate the underlying raw stream from the buffer and return it.
After the raw stream has been detached, the buffer is in an unusable
state.
Some buffers, like BytesIO, do not have the concept of a single
raw stream to return from this method.  They raise
UnsupportedOperation.

New in version 3.1.




read(size=-1)¶
Read and return up to size bytes.  If the argument is omitted, None,
or negative, data is read and returned until EOF is reached.  An empty
bytes object is returned if the stream is already at EOF.
If the argument is positive, and the underlying raw stream is not
interactive, multiple raw reads may be issued to satisfy the byte count
(unless EOF is reached first).  But for interactive raw streams, at most
one raw read will be issued, and a short result does not imply that EOF is
imminent.
A BlockingIOError is raised if the underlying raw stream is in
non blocking-mode, and has no data available at the moment.



read1([size])¶
Read and return up to size bytes, with at most one call to the
underlying raw stream’s read() (or
readinto()) method.  This can be useful if you are
implementing your own buffering on top of a BufferedIOBase
object.
If size is -1 (the default), an arbitrary number of bytes are
returned (more than zero unless EOF is reached).



readinto(b)¶
Read bytes into a pre-allocated, writable
bytes-like object b and return the number of bytes read.
For example, b might be a bytearray.
Like read(), multiple reads may be issued to the underlying raw
stream, unless the latter is interactive.
A BlockingIOError is raised if the underlying raw stream is in non
blocking-mode, and has no data available at the moment.



readinto1(b)¶
Read bytes into a pre-allocated, writable
bytes-like object b, using at most one call to
the underlying raw stream’s read() (or
readinto()) method. Return the number of bytes read.
A BlockingIOError is raised if the underlying raw stream is in non
blocking-mode, and has no data available at the moment.

New in version 3.5.




write(b)¶
Write the given bytes-like object, b, and return the number
of bytes written (always equal to the length of b in bytes, since if
the write fails an OSError will be raised).  Depending on the
actual implementation, these bytes may be readily written to the
underlying stream, or held in a buffer for performance and latency
reasons.
When in non-blocking mode, a BlockingIOError is raised if the
data needed to be written to the raw stream but it couldn’t accept
all the data without blocking.
The caller may release or mutate b after this method returns,
so the implementation should only access b during the method call.


