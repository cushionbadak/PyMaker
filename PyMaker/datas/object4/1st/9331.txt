link:
library/contextlib.html#utilities

docs:

Utilities¶
Functions and classes provided:


class contextlib.AbstractContextManager¶
An abstract base class for classes that implement
object.__enter__() and object.__exit__(). A default
implementation for object.__enter__() is provided which returns
self while object.__exit__() is an abstract method which by default
returns None. See also the definition of Context Manager Types.

New in version 3.6.




class contextlib.AbstractAsyncContextManager¶
An abstract base class for classes that implement
object.__aenter__() and object.__aexit__(). A default
implementation for object.__aenter__() is provided which returns
self while object.__aexit__() is an abstract method which by default
returns None. See also the definition of
Asynchronous Context Managers.

New in version 3.7.




@contextlib.contextmanager¶
This function is a decorator that can be used to define a factory
function for with statement context managers, without needing to
create a class or separate __enter__() and __exit__() methods.
While many objects natively support use in with statements, sometimes a
resource needs to be managed that isn’t a context manager in its own right,
and doesn’t implement a close() method for use with contextlib.closing
An abstract example would be the following to ensure correct resource
management:
from contextlib import contextmanager

@contextmanager
def managed_resource(*args, **kwds):
    # Code to acquire resource, e.g.:
    resource = acquire_resource(*args, **kwds)
    try:
        yield resource
    finally:
        # Code to release resource, e.g.:
        release_resource(resource)

>>> with managed_resource(timeout=3600) as resource:
...     # Resource is released at the end of this block,
...     # even if code in the block raises an exception


The function being decorated must return a generator-iterator when
called. This iterator must yield exactly one value, which will be bound to
the targets in the with statement’s as clause, if any.
At the point where the generator yields, the block nested in the with
statement is executed.  The generator is then resumed after the block is exited.
If an unhandled exception occurs in the block, it is reraised inside the
generator at the point where the yield occurred.  Thus, you can use a
try…except…finally statement to trap
the error (if any), or ensure that some cleanup takes place. If an exception is
trapped merely in order to log it or to perform some action (rather than to
suppress it entirely), the generator must reraise that exception. Otherwise the
generator context manager will indicate to the with statement that
the exception has been handled, and execution will resume with the statement
immediately following the with statement.
contextmanager() uses ContextDecorator so the context managers
it creates can be used as decorators as well as in with statements.
When used as a decorator, a new generator instance is implicitly created on
each function call (this allows the otherwise “one-shot” context managers
created by contextmanager() to meet the requirement that context
managers support multiple invocations in order to be used as decorators).

Changed in version 3.2: Use of ContextDecorator.




@contextlib.asynccontextmanager¶
Similar to contextmanager(), but creates an
asynchronous context manager.
This function is a decorator that can be used to define a factory
function for async with statement asynchronous context managers,
without needing to create a class or separate __aenter__() and
__aexit__() methods. It must be applied to an asynchronous
generator function.
A simple example:
from contextlib import asynccontextmanager

@asynccontextmanager
async def get_connection():
    conn = await acquire_db_connection()
    try:
        yield conn
    finally:
        await release_db_connection(conn)

async def get_all_users():
    async with get_connection() as conn:
        return conn.query('SELECT ...')



New in version 3.7.




contextlib.closing(thing)¶
Return a context manager that closes thing upon completion of the block.  This
is basically equivalent to:
from contextlib import contextmanager

@contextmanager
def closing(thing):
    try:
        yield thing
    finally:
        thing.close()


And lets you write code like this:
from contextlib import closing
from urllib.request import urlopen

with closing(urlopen('http://www.python.org')) as page:
    for line in page:
        print(line)


without needing to explicitly close page.  Even if an error occurs,
page.close() will be called when the with block is exited.



contextlib.nullcontext(enter_result=None)¶
Return a context manager that returns enter_result from __enter__, but
otherwise does nothing. It is intended to be used as a stand-in for an
optional context manager, for example:
def myfunction(arg, ignore_exceptions=False):
    if ignore_exceptions:
        # Use suppress to ignore all exceptions.
        cm = contextlib.suppress(Exception)
    else:
        # Do not ignore any exceptions, cm has no effect.
        cm = contextlib.nullcontext()
    with cm:
        # Do something


An example using enter_result:
def process_file(file_or_path):
    if isinstance(file_or_path, str):
        # If string, open file
        cm = open(file_or_path)
    else:
        # Caller is responsible for closing file
        cm = nullcontext(file_or_path)

    with cm as file:
        # Perform processing on the file



New in version 3.7.




contextlib.suppress(*exceptions)¶
Return a context manager that suppresses any of the specified exceptions
if they occur in the body of a with statement and then resumes execution
with the first statement following the end of the with statement.
As with any other mechanism that completely suppresses exceptions, this
context manager should be used only to cover very specific errors where
silently continuing with program execution is known to be the right
thing to do.
For example:
from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove('somefile.tmp')

with suppress(FileNotFoundError):
    os.remove('someotherfile.tmp')


This code is equivalent to:
try:
    os.remove('somefile.tmp')
except FileNotFoundError:
    pass

try:
    os.remove('someotherfile.tmp')
except FileNotFoundError:
    pass


This context manager is reentrant.

New in version 3.4.




contextlib.redirect_stdout(new_target)¶
Context manager for temporarily redirecting sys.stdout to
another file or file-like object.
This tool adds flexibility to existing functions or classes whose output
is hardwired to stdout.
For example, the output of help() normally is sent to sys.stdout.
You can capture that output in a string by redirecting the output to an
io.StringIO object:
f = io.StringIO()
with redirect_stdout(f):
    help(pow)
s = f.getvalue()


To send the output of help() to a file on disk, redirect the output
to a regular file:
with open('help.txt', 'w') as f:
    with redirect_stdout(f):
        help(pow)


To send the output of help() to sys.stderr:
with redirect_stdout(sys.stderr):
    help(pow)


Note that the global side effect on sys.stdout means that this
context manager is not suitable for use in library code and most threaded
applications. It also has no effect on the output of subprocesses.
However, it is still a useful approach for many utility scripts.
This context manager is reentrant.

New in version 3.4.




contextlib.redirect_stderr(new_target)¶
Similar to redirect_stdout() but redirecting
sys.stderr to another file or file-like object.
This context manager is reentrant.

New in version 3.5.




class contextlib.ContextDecorator¶
A base class that enables a context manager to also be used as a decorator.
Context managers inheriting from ContextDecorator have to implement
__enter__ and __exit__ as normal. __exit__ retains its optional
exception handling even when used as a decorator.
ContextDecorator is used by contextmanager(), so you get this
functionality automatically.
Example of ContextDecorator:
from contextlib import ContextDecorator

class mycontext(ContextDecorator):
    def __enter__(self):
        print('Starting')
        return self

    def __exit__(self, *exc):
        print('Finishing')
        return False

>>> @mycontext()
... def function():
...     print('The bit in the middle')
...
>>> function()
Starting
The bit in the middle
Finishing

>>> with mycontext():
...     print('The bit in the middle')
...
Starting
The bit in the middle
Finishing


This change is just syntactic sugar for any construct of the following form:
def f():
    with cm():
        # Do stuff


ContextDecorator lets you instead write:
@cm()
def f():
    # Do stuff


It makes it clear that the cm applies to the whole function, rather than
just a piece of it (and saving an indentation level is nice, too).
Existing context managers that already have a base class can be extended by
using ContextDecorator as a mixin class:
from contextlib import ContextDecorator

class mycontext(ContextBaseClass, ContextDecorator):
    def __enter__(self):
        return self

    def __exit__(self, *exc):
        return False



Note
As the decorated function must be able to be called multiple times, the
underlying context manager must support use in multiple with
statements. If this is not the case, then the original construct with the
explicit with statement inside the function should be used.


New in version 3.2.




class contextlib.ExitStack¶
A context manager that is designed to make it easy to programmatically
combine other context managers and cleanup functions, especially those
that are optional or otherwise driven by input data.
For example, a set of files may easily be handled in a single with
statement as follows:
with ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # All opened files will automatically be closed at the end of
    # the with statement, even if attempts to open files later
    # in the list raise an exception


Each instance maintains a stack of registered callbacks that are called in
reverse order when the instance is closed (either explicitly or implicitly
at the end of a with statement). Note that callbacks are not
invoked implicitly when the context stack instance is garbage collected.
This stack model is used so that context managers that acquire their
resources in their __init__ method (such as file objects) can be
handled correctly.
Since registered callbacks are invoked in the reverse order of
registration, this ends up behaving as if multiple nested with
statements had been used with the registered set of callbacks. This even
extends to exception handling - if an inner callback suppresses or replaces
an exception, then outer callbacks will be passed arguments based on that
updated state.
This is a relatively low level API that takes care of the details of
correctly unwinding the stack of exit callbacks. It provides a suitable
foundation for higher level context managers that manipulate the exit
stack in application specific ways.

New in version 3.3.



enter_context(cm)¶
Enters a new context manager and adds its __exit__() method to
the callback stack. The return value is the result of the context
manager’s own __enter__() method.
These context managers may suppress exceptions just as they normally
would if used directly as part of a with statement.



push(exit)¶
Adds a context manager’s __exit__() method to the callback stack.
As __enter__ is not invoked, this method can be used to cover
part of an __enter__() implementation with a context manager’s own
__exit__() method.
If passed an object that is not a context manager, this method assumes
it is a callback with the same signature as a context manager’s
__exit__() method and adds it directly to the callback stack.
By returning true values, these callbacks can suppress exceptions the
same way context manager __exit__() methods can.
The passed in object is returned from the function, allowing this
method to be used as a function decorator.



callback(callback, *args, **kwds)¶
Accepts an arbitrary callback function and arguments and adds it to
the callback stack.
Unlike the other methods, callbacks added this way cannot suppress
exceptions (as they are never passed the exception details).
The passed in callback is returned from the function, allowing this
method to be used as a function decorator.



pop_all()¶
Transfers the callback stack to a fresh ExitStack instance
and returns it. No callbacks are invoked by this operation - instead,
they will now be invoked when the new stack is closed (either
explicitly or implicitly at the end of a with statement).
For example, a group of files can be opened as an “all or nothing”
operation as follows:
with ExitStack() as stack:
    files = [stack.enter_context(open(fname)) for fname in filenames]
    # Hold onto the close method, but don't call it yet.
    close_files = stack.pop_all().close
    # If opening any file fails, all previously opened files will be
    # closed automatically. If all files are opened successfully,
    # they will remain open even after the with statement ends.
    # close_files() can then be invoked explicitly to close them all.





close()¶
Immediately unwinds the callback stack, invoking callbacks in the
reverse order of registration. For any context managers and exit
callbacks registered, the arguments passed in will indicate that no
exception occurred.




class contextlib.AsyncExitStack¶
An asynchronous context manager, similar
to ExitStack, that supports combining both synchronous and
asynchronous context managers, as well as having coroutines for
cleanup logic.
The close() method is not implemented, aclose() must be used
instead.


enter_async_context(cm)¶
Similar to enter_context() but expects an asynchronous context
manager.



push_async_exit(exit)¶
Similar to push() but expects either an asynchronous context manager
or a coroutine function.



push_async_callback(callback, *args, **kwds)¶
Similar to callback() but expects a coroutine function.



aclose()¶
Similar to close() but properly handles awaitables.

Continuing the example for asynccontextmanager():
async with AsyncExitStack() as stack:
    connections = [await stack.enter_async_context(get_connection())
        for i in range(5)]
    # All opened connections will automatically be released at the end of
    # the async with statement, even if attempts to open a connection
    # later in the list raise an exception.



New in version 3.7.


