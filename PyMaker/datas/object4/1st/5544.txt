link:
library/email.parser.html#email.parser.BytesParser.parsebytes

docs:

<dt id="email.parser.BytesParser.parsebytes">
<code class="descname">parsebytes</code><span class="sig-paren">(</span><em>bytes</em>, <em>headersonly=False</em><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.BytesParser.parsebytes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Similar to the <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method, except it takes a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like
object</span></a> instead of a file-like object.  Calling this method on a
<a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> is equivalent to wrapping <em>bytes</em> in a
<a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code></a> instance first and calling <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a>.</p>
<p>Optional <em>headersonly</em> is as with the <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method.</p>
</dd>