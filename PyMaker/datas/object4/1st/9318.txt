link:
library/dataclasses.html#dataclasses.replace

docs:

<dt id="dataclasses.replace">
<code class="descclassname">dataclasses.</code><code class="descname">replace</code><span class="sig-paren">(</span><em>instance</em>, <em>**changes</em><span class="sig-paren">)</span><a class="headerlink" href="#dataclasses.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new object of the same type of <code class="docutils literal notranslate"><span class="pre">instance</span></code>, replacing
fields with values from <code class="docutils literal notranslate"><span class="pre">changes</span></code>.  If <code class="docutils literal notranslate"><span class="pre">instance</span></code> is not a Data
Class, raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.  If values in <code class="docutils literal notranslate"><span class="pre">changes</span></code> do not
specify fields, raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<p>The newly returned object is created by calling the <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>
method of the dataclass.  This ensures that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>, if present, is also called.</p>
<p>Init-only variables without default values, if any exist, must be
specified on the call to <a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a> so that they can be passed to
<a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>.</p>
<p>It is an error for <code class="docutils literal notranslate"><span class="pre">changes</span></code> to contain any fields that are
defined as having <code class="docutils literal notranslate"><span class="pre">init=False</span></code>.  A <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> will be raised
in this case.</p>
<p>Be forewarned about how <code class="docutils literal notranslate"><span class="pre">init=False</span></code> fields work during a call to
<a class="reference internal" href="#dataclasses.replace" title="dataclasses.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace()</span></code></a>.  They are not copied from the source object, but
rather are initialized in <code class="xref py py-meth docutils literal notranslate"><span class="pre">__post_init__()</span></code>, if they’re
initialized at all.  It is expected that <code class="docutils literal notranslate"><span class="pre">init=False</span></code> fields will
be rarely and judiciously used.  If they are used, it might be wise
to have alternate class constructors, or perhaps a custom
<code class="docutils literal notranslate"><span class="pre">replace()</span></code> (or similarly named) method which handles instance
copying.</p>
</dd>