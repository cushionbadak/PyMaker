link:
library/concurrent.futures.html#concurrent.futures.Executor.map

docs:

<dt id="concurrent.futures.Executor.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>func</em>, <em>*iterables</em>, <em>timeout=None</em>, <em>chunksize=1</em><span class="sig-paren">)</span><a class="headerlink" href="#concurrent.futures.Executor.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map(func,</span> <span class="pre">*iterables)</span></code></a> except:</p>
<ul class="simple">
<li>the <em>iterables</em> are collected immediately rather than lazily;</li>
<li><em>func</em> is executed asynchronously and several calls to
<em>func</em> may be made concurrently.</li>
</ul>
<p>The returned iterator raises a <a class="reference internal" href="#concurrent.futures.TimeoutError" title="concurrent.futures.TimeoutError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">concurrent.futures.TimeoutError</span></code></a>
if <a class="reference internal" href="stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> is called and the result isn’t available
after <em>timeout</em> seconds from the original call to <a class="reference internal" href="#concurrent.futures.Executor.map" title="concurrent.futures.Executor.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Executor.map()</span></code></a>.
<em>timeout</em> can be an int or a float.  If <em>timeout</em> is not specified or
<code class="docutils literal notranslate"><span class="pre">None</span></code>, there is no limit to the wait time.</p>
<p>If a <em>func</em> call raises an exception, then that exception will be
raised when its value is retrieved from the iterator.</p>
<p>When using <a class="reference internal" href="#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a>, this method chops <em>iterables</em>
into a number of chunks which it submits to the pool as separate
tasks.  The (approximate) size of these chunks can be specified by
setting <em>chunksize</em> to a positive integer.  For very long iterables,
using a large value for <em>chunksize</em> can significantly improve
performance compared to the default size of 1.  With
<a class="reference internal" href="#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>, <em>chunksize</em> has no effect.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.5: </span>Added the <em>chunksize</em> argument.</p>
</div>
</dd>