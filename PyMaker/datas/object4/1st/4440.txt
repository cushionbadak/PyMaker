link:
library/subprocess.html#using-the-subprocess-module

docs:

Using the subprocess Module¶
The recommended approach to invoking subprocesses is to use the run()
function for all use cases it can handle. For more advanced use cases, the
underlying Popen interface can be used directly.
The run() function was added in Python 3.5; if you need to retain
compatibility with older versions, see the Older high-level API section.


subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None)¶
Run the command described by args.  Wait for command to complete, then
return a CompletedProcess instance.
The arguments shown above are merely the most common ones, described below
in Frequently Used Arguments (hence the use of keyword-only notation
in the abbreviated signature). The full function signature is largely the
same as that of the Popen constructor - most of the arguments to
this function are passed through to that interface. (timeout,  input,
check, and capture_output are not.)
If capture_output is true, stdout and stderr will be captured.
When used, the internal Popen object is automatically created with
stdout=PIPE and stderr=PIPE. The stdout and stderr arguments may
not be supplied at the same time as capture_output.  If you wish to capture
and combine both streams into one, use stdout=PIPE and stderr=STDOUT
instead of capture_output.
The timeout argument is passed to Popen.communicate(). If the timeout
expires, the child process will be killed and waited for.  The
TimeoutExpired exception will be re-raised after the child process
has terminated.
The input argument is passed to Popen.communicate() and thus to the
subprocess’s stdin.  If used it must be a byte sequence, or a string if
encoding or errors is specified or text is true.  When
used, the internal Popen object is automatically created with
stdin=PIPE, and the stdin argument may not be used as well.
If check is true, and the process exits with a non-zero exit code, a
CalledProcessError exception will be raised. Attributes of that
exception hold the arguments, the exit code, and stdout and stderr if they
were captured.
If encoding or errors are specified, or text is true,
file objects for stdin, stdout and stderr are opened in text mode using the
specified encoding and errors or the io.TextIOWrapper default.
The universal_newlines argument is equivalent  to text and is provided
for backwards compatibility. By default, file objects are opened in binary mode.
If env is not None, it must be a mapping that defines the environment
variables for the new process; these are used instead of the default
behavior of inheriting the current process’ environment. It is passed directly
to Popen.
Examples:
>>> subprocess.run(["ls", "-l"])  # doesn't capture output
CompletedProcess(args=['ls', '-l'], returncode=0)

>>> subprocess.run("exit 1", shell=True, check=True)
Traceback (most recent call last):
  ...
subprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1

>>> subprocess.run(["ls", "-l", "/dev/null"], capture_output=True)
CompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,
stdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n', stderr=b'')



New in version 3.5.


Changed in version 3.6: Added encoding and errors parameters


Changed in version 3.7: Added the text parameter, as a more understandable alias of universal_newlines.
Added the capture_output parameter.




class subprocess.CompletedProcess¶
The return value from run(), representing a process that has finished.


args¶
The arguments used to launch the process. This may be a list or a string.



returncode¶
Exit status of the child process. Typically, an exit status of 0 indicates
that it ran successfully.
A negative value -N indicates that the child was terminated by signal
N (POSIX only).



stdout¶
Captured stdout from the child process. A bytes sequence, or a string if
run() was called with an encoding, errors, or text=True.
None if stdout was not captured.
If you ran the process with stderr=subprocess.STDOUT, stdout and
stderr will be combined in this attribute, and stderr will be
None.



stderr¶
Captured stderr from the child process. A bytes sequence, or a string if
run() was called with an encoding, errors, or text=True.
None if stderr was not captured.



check_returncode()¶
If returncode is non-zero, raise a CalledProcessError.


New in version 3.5.




subprocess.DEVNULL¶
Special value that can be used as the stdin, stdout or stderr argument
to Popen and indicates that the special file os.devnull
will be used.

New in version 3.3.




subprocess.PIPE¶
Special value that can be used as the stdin, stdout or stderr argument
to Popen and indicates that a pipe to the standard stream should be
opened.  Most useful with Popen.communicate().



subprocess.STDOUT¶
Special value that can be used as the stderr argument to Popen and
indicates that standard error should go into the same handle as standard
output.



exception subprocess.SubprocessError¶
Base class for all other exceptions from this module.

New in version 3.3.




exception subprocess.TimeoutExpired¶
Subclass of SubprocessError, raised when a timeout expires
while waiting for a child process.


cmd¶
Command that was used to spawn the child process.



timeout¶
Timeout in seconds.



output¶
Output of the child process if it was captured by run() or
check_output().  Otherwise, None.



stdout¶
Alias for output, for symmetry with stderr.



stderr¶
Stderr output of the child process if it was captured by run().
Otherwise, None.


New in version 3.3.


Changed in version 3.5: stdout and stderr attributes added




exception subprocess.CalledProcessError¶
Subclass of SubprocessError, raised when a process run by
check_call() or check_output() returns a non-zero exit status.


returncode¶
Exit status of the child process.  If the process exited due to a
signal, this will be the negative signal number.



cmd¶
Command that was used to spawn the child process.



output¶
Output of the child process if it was captured by run() or
check_output().  Otherwise, None.



stdout¶
Alias for output, for symmetry with stderr.



stderr¶
Stderr output of the child process if it was captured by run().
Otherwise, None.


Changed in version 3.5: stdout and stderr attributes added



Frequently Used Arguments¶
To support a wide variety of use cases, the Popen constructor (and
the convenience functions) accept a large number of optional arguments. For
most typical use cases, many of these arguments can be safely left at their
default values. The arguments that are most commonly needed are:

args is required for all calls and should be a string, or a sequence of
program arguments. Providing a sequence of arguments is generally
preferred, as it allows the module to take care of any required escaping
and quoting of arguments (e.g. to permit spaces in file names). If passing
a single string, either shell must be True (see below) or else
the string must simply name the program to be executed without specifying
any arguments.
stdin, stdout and stderr specify the executed program’s standard input,
standard output and standard error file handles, respectively.  Valid values
are PIPE, DEVNULL, an existing file descriptor (a positive
integer), an existing file object, and None.  PIPE indicates
that a new pipe to the child should be created.  DEVNULL indicates
that the special file os.devnull will be used.  With the default
settings of None, no redirection will occur; the child’s file handles
will be inherited from the parent.  Additionally, stderr can be
STDOUT, which indicates that the stderr data from the child
process should be captured into the same file handle as for stdout.
If encoding or errors are specified, or text (also known as
universal_newlines) is true,
the file objects stdin, stdout and stderr will be opened in text
mode using the encoding and errors specified in the call or the
defaults for io.TextIOWrapper.
For stdin, line ending characters '\n' in the input will be converted
to the default line separator os.linesep. For stdout and stderr,
all line endings in the output will be converted to '\n'.  For more
information see the documentation of the io.TextIOWrapper class
when the newline argument to its constructor is None.
If text mode is not used, stdin, stdout and stderr will be opened as
binary streams. No encoding or line ending conversion is performed.

New in version 3.6: Added encoding and errors parameters.


New in version 3.7: Added the text parameter as an alias for universal_newlines.


Note
The newlines attribute of the file objects Popen.stdin,
Popen.stdout and Popen.stderr are not updated by
the Popen.communicate() method.

If shell is True, the specified command will be executed through
the shell.  This can be useful if you are using Python primarily for the
enhanced control flow it offers over most system shells and still want
convenient access to other shell features such as shell pipes, filename
wildcards, environment variable expansion, and expansion of ~ to a
user’s home directory.  However, note that Python itself offers
implementations of many shell-like features (in particular, glob,
fnmatch, os.walk(), os.path.expandvars(),
os.path.expanduser(), and shutil).

Changed in version 3.3: When universal_newlines is True, the class uses the encoding
locale.getpreferredencoding(False)
instead of locale.getpreferredencoding().  See the
io.TextIOWrapper class for more information on this change.


Note
Read the Security Considerations section before using shell=True.


These options, along with all of the other options, are described in more
detail in the Popen constructor documentation.


Popen Constructor¶
The underlying process creation and management in this module is handled by
the Popen class. It offers a lot of flexibility so that developers
are able to handle the less common cases not covered by the convenience
functions.


class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None, text=None)¶
Execute a child program in a new process.  On POSIX, the class uses
os.execvp()-like behavior to execute the child program.  On Windows,
the class uses the Windows CreateProcess() function.  The arguments to
Popen are as follows.
args should be a sequence of program arguments or else a single string.
By default, the program to execute is the first item in args if args is
a sequence.  If args is a string, the interpretation is
platform-dependent and described below.  See the shell and executable
arguments for additional differences from the default behavior.  Unless
otherwise stated, it is recommended to pass args as a sequence.
On POSIX, if args is a string, the string is interpreted as the name or
path of the program to execute.  However, this can only be done if not
passing arguments to the program.

Note
shlex.split() can be useful when determining the correct
tokenization for args, especially in complex cases:
>>> import shlex, subprocess
>>> command_line = input()
/bin/vikings -input eggs.txt -output "spam spam.txt" -cmd "echo '$MONEY'"
>>> args = shlex.split(command_line)
>>> print(args)
['/bin/vikings', '-input', 'eggs.txt', '-output', 'spam spam.txt', '-cmd', "echo '$MONEY'"]
>>> p = subprocess.Popen(args) # Success!


Note in particular that options (such as -input) and arguments (such
as eggs.txt) that are separated by whitespace in the shell go in separate
list elements, while arguments that need quoting or backslash escaping when
used in the shell (such as filenames containing spaces or the echo command
shown above) are single list elements.

On Windows, if args is a sequence, it will be converted to a string in a
manner described in Converting an argument sequence to a string on Windows.  This is because
the underlying CreateProcess() operates on strings.
The shell argument (which defaults to False) specifies whether to use
the shell as the program to execute.  If shell is True, it is
recommended to pass args as a string rather than as a sequence.
On POSIX with shell=True, the shell defaults to /bin/sh.  If
args is a string, the string specifies the command
to execute through the shell.  This means that the string must be
formatted exactly as it would be when typed at the shell prompt.  This
includes, for example, quoting or backslash escaping filenames with spaces in
them.  If args is a sequence, the first item specifies the command string, and
any additional items will be treated as additional arguments to the shell
itself.  That is to say, Popen does the equivalent of:
Popen(['/bin/sh', '-c', args[0], args[1], ...])


On Windows with shell=True, the COMSPEC environment variable
specifies the default shell.  The only time you need to specify
shell=True on Windows is when the command you wish to execute is built
into the shell (e.g. dir or copy).  You do not need
shell=True to run a batch file or console-based executable.

Note
Read the Security Considerations section before using shell=True.

bufsize will be supplied as the corresponding argument to the
open() function when creating the stdin/stdout/stderr pipe
file objects:

0 means unbuffered (read and write are one
system call and can return short)
1 means line buffered
(only usable if universal_newlines=True i.e., in a text mode)
any other positive value means use a buffer of approximately that
size
negative bufsize (the default) means the system default of
io.DEFAULT_BUFFER_SIZE will be used.


Changed in version 3.3.1: bufsize now defaults to -1 to enable buffering by default to match the
behavior that most code expects.  In versions prior to Python 3.2.4 and
3.3.1 it incorrectly defaulted to 0 which was unbuffered
and allowed short reads.  This was unintentional and did not match the
behavior of Python 2 as most code expected.

The executable argument specifies a replacement program to execute.   It
is very seldom needed.  When shell=False, executable replaces the
program to execute specified by args.  However, the original args is
still passed to the program.  Most programs treat the program specified
by args as the command name, which can then be different from the program
actually executed.  On POSIX, the args name
becomes the display name for the executable in utilities such as
ps.  If shell=True, on POSIX the executable argument
specifies a replacement shell for the default /bin/sh.
stdin, stdout and stderr specify the executed program’s standard input,
standard output and standard error file handles, respectively.  Valid values
are PIPE, DEVNULL, an existing file descriptor (a positive
integer), an existing file object, and None.  PIPE
indicates that a new pipe to the child should be created.  DEVNULL
indicates that the special file os.devnull will be used. With the
default settings of None, no redirection will occur; the child’s file
handles will be inherited from the parent.  Additionally, stderr can be
STDOUT, which indicates that the stderr data from the applications
should be captured into the same file handle as for stdout.
If preexec_fn is set to a callable object, this object will be called in the
child process just before the child is executed.
(POSIX only)

Warning
The preexec_fn parameter is not safe to use in the presence of threads
in your application.  The child process could deadlock before exec is
called.
If you must use it, keep it trivial!  Minimize the number of libraries
you call into.


Note
If you need to modify the environment for the child use the env
parameter rather than doing it in a preexec_fn.
The start_new_session parameter can take the place of a previously
common use of preexec_fn to call os.setsid() in the child.

If close_fds is true, all file descriptors except 0, 1 and
2 will be closed before the child process is executed.  Otherwise
when close_fds is false, file descriptors obey their inheritable flag
as described in Inheritance of File Descriptors.
On Windows, if close_fds is true then no handles will be inherited by the
child process unless explicitly passed in the handle_list element of
STARTUPINFO.lpAttributeList, or by standard handle redirection.

Changed in version 3.2: The default for close_fds was changed from False to
what is described above.


Changed in version 3.7: On Windows the default for close_fds was changed from False to
True when redirecting the standard handles. It’s now possible to
set close_fds to True when redirecting the standard handles.

pass_fds is an optional sequence of file descriptors to keep open
between the parent and child.  Providing any pass_fds forces
close_fds to be True.  (POSIX only)

New in version 3.2: The pass_fds parameter was added.

If cwd is not None, the function changes the working directory to
cwd before executing the child.  cwd can be a str and
path-like object.  In particular, the function
looks for executable (or for the first item in args) relative to cwd
if the executable path is a relative path.

Changed in version 3.6: cwd parameter accepts a path-like object.

If restore_signals is true (the default) all signals that Python has set to
SIG_IGN are restored to SIG_DFL in the child process before the exec.
Currently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals.
(POSIX only)

Changed in version 3.2: restore_signals was added.

If start_new_session is true the setsid() system call will be made in the
child process prior to the execution of the subprocess.  (POSIX only)

Changed in version 3.2: start_new_session was added.

If env is not None, it must be a mapping that defines the environment
variables for the new process; these are used instead of the default
behavior of inheriting the current process’ environment.

Note
If specified, env must provide any variables required for the program to
execute.  On Windows, in order to run a side-by-side assembly the
specified env must include a valid SystemRoot.

If encoding or errors are specified, or text is true, the file objects
stdin, stdout and stderr are opened in text mode with the specified
encoding and errors, as described above in Frequently Used Arguments.
The universal_newlines argument is equivalent  to text and is provided
for backwards compatibility. By default, file objects are opened in binary mode.

New in version 3.6: encoding and errors were added.


New in version 3.7: text was added as a more readable alias for universal_newlines.

If given, startupinfo will be a STARTUPINFO object, which is
passed to the underlying CreateProcess function.
creationflags, if given, can be one or more of the following flags:


CREATE_NEW_CONSOLE
CREATE_NEW_PROCESS_GROUP
ABOVE_NORMAL_PRIORITY_CLASS
BELOW_NORMAL_PRIORITY_CLASS
HIGH_PRIORITY_CLASS
IDLE_PRIORITY_CLASS
NORMAL_PRIORITY_CLASS
REALTIME_PRIORITY_CLASS
CREATE_NO_WINDOW
DETACHED_PROCESS
CREATE_DEFAULT_ERROR_MODE
CREATE_BREAKAWAY_FROM_JOB


Popen objects are supported as context managers via the with statement:
on exit, standard file descriptors are closed, and the process is waited for.
with Popen(["ifconfig"], stdout=PIPE) as proc:
    log.write(proc.stdout.read())



Changed in version 3.2: Added context manager support.


Changed in version 3.6: Popen destructor now emits a ResourceWarning warning if the child
process is still running.




Exceptions¶
Exceptions raised in the child process, before the new program has started to
execute, will be re-raised in the parent.
The most common exception raised is OSError.  This occurs, for example,
when trying to execute a non-existent file.  Applications should prepare for
OSError exceptions.
A ValueError will be raised if Popen is called with invalid
arguments.
check_call() and check_output() will raise
CalledProcessError if the called process returns a non-zero return
code.
All of the functions and methods that accept a timeout parameter, such as
call() and Popen.communicate() will raise TimeoutExpired if
the timeout expires before the process exits.
Exceptions defined in this module all inherit from SubprocessError.


New in version 3.3: The SubprocessError base class was added.



