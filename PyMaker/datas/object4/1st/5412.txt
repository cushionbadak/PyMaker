link:
library/asynchat.html#asynchat.async_chat

docs:

<dt id="asynchat.async_chat">
<em class="property">class </em><code class="descclassname">asynchat.</code><code class="descname">async_chat</code><a class="headerlink" href="#asynchat.async_chat" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is an abstract subclass of <a class="reference internal" href="asyncore.html#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a>. To make
practical use of the code you must subclass <a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a>, providing
meaningful <a class="reference internal" href="#asynchat.async_chat.collect_incoming_data" title="asynchat.async_chat.collect_incoming_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collect_incoming_data()</span></code></a> and <a class="reference internal" href="#asynchat.async_chat.found_terminator" title="asynchat.async_chat.found_terminator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">found_terminator()</span></code></a>
methods.
The <a class="reference internal" href="asyncore.html#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a> methods can be used, although not all make
sense in a message/response context.</p>
<p>Like <a class="reference internal" href="asyncore.html#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a>, <a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a> defines a set of
events that are generated by an analysis of socket conditions after a
<code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> call. Once the polling loop has been started the
<a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a> object’s methods are called by the event-processing
framework with no action on the part of the programmer.</p>
<p>Two class attributes can be modified, to improve performance, or possibly
even to conserve memory.</p>
<dl class="data">
<dt id="asynchat.async_chat.ac_in_buffer_size">
<code class="descname">ac_in_buffer_size</code><a class="headerlink" href="#asynchat.async_chat.ac_in_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The asynchronous input buffer size (default <code class="docutils literal notranslate"><span class="pre">4096</span></code>).</p>
</dd></dl>
<dl class="data">
<dt id="asynchat.async_chat.ac_out_buffer_size">
<code class="descname">ac_out_buffer_size</code><a class="headerlink" href="#asynchat.async_chat.ac_out_buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The asynchronous output buffer size (default <code class="docutils literal notranslate"><span class="pre">4096</span></code>).</p>
</dd></dl>
<p>Unlike <a class="reference internal" href="asyncore.html#asyncore.dispatcher" title="asyncore.dispatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncore.dispatcher</span></code></a>, <a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a> allows you to
define a <abbr title="first-in, first-out">FIFO</abbr> queue of <em>producers</em>. A producer need
have only one method, <code class="xref py py-meth docutils literal notranslate"><span class="pre">more()</span></code>, which should return data to be
transmitted on the channel.
The producer indicates exhaustion (<em>i.e.</em> that it contains no more data) by
having its <code class="xref py py-meth docutils literal notranslate"><span class="pre">more()</span></code> method return the empty bytes object. At this point
the <a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a> object removes the producer from the queue and starts
using the next producer, if any. When the producer queue is empty the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_write()</span></code> method does nothing. You use the channel object’s
<a class="reference internal" href="#asynchat.async_chat.set_terminator" title="asynchat.async_chat.set_terminator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_terminator()</span></code></a> method to describe how to recognize the end of, or
an important breakpoint in, an incoming transmission from the remote
endpoint.</p>
<p>To build a functioning <a class="reference internal" href="#asynchat.async_chat" title="asynchat.async_chat"><code class="xref py py-class docutils literal notranslate"><span class="pre">async_chat</span></code></a> subclass your  input methods
<a class="reference internal" href="#asynchat.async_chat.collect_incoming_data" title="asynchat.async_chat.collect_incoming_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collect_incoming_data()</span></code></a> and <a class="reference internal" href="#asynchat.async_chat.found_terminator" title="asynchat.async_chat.found_terminator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">found_terminator()</span></code></a> must handle the
data that the channel receives asynchronously. The methods are described
below.</p>
</dd>