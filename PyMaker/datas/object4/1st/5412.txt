link:
library/asynchat.html#asynchat.async_chat

docs:


class asynchat.async_chat¶
This class is an abstract subclass of asyncore.dispatcher. To make
practical use of the code you must subclass async_chat, providing
meaningful collect_incoming_data() and found_terminator()
methods.
The asyncore.dispatcher methods can be used, although not all make
sense in a message/response context.
Like asyncore.dispatcher, async_chat defines a set of
events that are generated by an analysis of socket conditions after a
select() call. Once the polling loop has been started the
async_chat object’s methods are called by the event-processing
framework with no action on the part of the programmer.
Two class attributes can be modified, to improve performance, or possibly
even to conserve memory.


ac_in_buffer_size¶
The asynchronous input buffer size (default 4096).



ac_out_buffer_size¶
The asynchronous output buffer size (default 4096).

Unlike asyncore.dispatcher, async_chat allows you to
define a FIFO queue of producers. A producer need
have only one method, more(), which should return data to be
transmitted on the channel.
The producer indicates exhaustion (i.e. that it contains no more data) by
having its more() method return the empty bytes object. At this point
the async_chat object removes the producer from the queue and starts
using the next producer, if any. When the producer queue is empty the
handle_write() method does nothing. You use the channel object’s
set_terminator() method to describe how to recognize the end of, or
an important breakpoint in, an incoming transmission from the remote
endpoint.
To build a functioning async_chat subclass your  input methods
collect_incoming_data() and found_terminator() must handle the
data that the channel receives asynchronously. The methods are described
below.
