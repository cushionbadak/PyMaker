link:
library/datetime.html#timedelta-objects

docs:

timedelta Objects¶
A timedelta object represents a duration, the difference between two
dates or times.


class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)¶
All arguments are optional and default to 0.  Arguments may be integers
or floats, and may be positive or negative.
Only days, seconds and microseconds are stored internally.  Arguments are
converted to those units:

A millisecond is converted to 1000 microseconds.
A minute is converted to 60 seconds.
An hour is converted to 3600 seconds.
A week is converted to 7 days.

and days, seconds and microseconds are then normalized so that the
representation is unique, with

0 <= microseconds < 1000000
0 <= seconds < 3600*24 (the number of seconds in one day)
-999999999 <= days <= 999999999

If any argument is a float and there are fractional microseconds,
the fractional microseconds left over from all arguments are
combined and their sum is rounded to the nearest microsecond using
round-half-to-even tiebreaker.  If no argument is a float, the
conversion and normalization processes are exact (no information is
lost).
If the normalized value of days lies outside the indicated range,
OverflowError is raised.
Note that normalization of negative values may be surprising at first. For
example,
>>> from datetime import timedelta
>>> d = timedelta(microseconds=-1)
>>> (d.days, d.seconds, d.microseconds)
(-1, 86399, 999999)



Class attributes are:


timedelta.min¶
The most negative timedelta object, timedelta(-999999999).



timedelta.max¶
The most positive timedelta object, timedelta(days=999999999,
hours=23, minutes=59, seconds=59, microseconds=999999).



timedelta.resolution¶
The smallest possible difference between non-equal timedelta objects,
timedelta(microseconds=1).

Note that, because of normalization, timedelta.max > -timedelta.min.
-timedelta.max is not representable as a timedelta object.
Instance attributes (read-only):






Attribute
Value



days
Between -999999999 and 999999999 inclusive

seconds
Between 0 and 86399 inclusive

microseconds
Between 0 and 999999 inclusive



Supported operations:






Operation
Result



t1 = t2 + t3
Sum of t2 and t3. Afterwards t1-t2 ==
t3 and t1-t3 == t2 are true. (1)

t1 = t2 - t3
Difference of t2 and t3. Afterwards t1
== t2 - t3 and t2 == t1 + t3 are
true. (1)(6)

t1 = t2 * i or t1 = i * t2
Delta multiplied by an integer.
Afterwards t1 // i == t2 is true,
provided i != 0.

 
In general, t1 * i == t1 * (i-1) + t1
is true. (1)

t1 = t2 * f or t1 = f * t2
Delta multiplied by a float. The result is
rounded to the nearest multiple of
timedelta.resolution using round-half-to-even.

f = t2 / t3
Division (3) of overall duration t2 by
interval unit t3. Returns a float
object.

t1 = t2 / f or t1 = t2 / i
Delta divided by a float or an int. The result
is rounded to the nearest multiple of
timedelta.resolution using round-half-to-even.

t1 = t2 // i or
t1 = t2 // t3
The floor is computed and the remainder (if
any) is thrown away.  In the second case, an
integer is returned. (3)

t1 = t2 % t3
The remainder is computed as a
timedelta object. (3)

q, r = divmod(t1, t2)
Computes the quotient and the remainder:
q = t1 // t2 (3) and r = t1 % t2.
q is an integer and r is a timedelta
object.

+t1
Returns a timedelta object with the
same value. (2)

-t1
equivalent to
timedelta(-t1.days,
-t1.seconds, -t1.microseconds),
and to t1* -1. (1)(4)

abs(t)
equivalent to +t when t.days >= 0, and
to -t when t.days < 0. (2)

str(t)
Returns a string in the form
[D day[s], ][H]H:MM:SS[.UUUUUU], where D
is negative for negative t. (5)

repr(t)
Returns a string representation of the
timedelta object as a constructor
call with canonical attribute values.



Notes:

This is exact, but may overflow.

This is exact, and cannot overflow.

Division by 0 raises ZeroDivisionError.

-timedelta.max is not representable as a timedelta object.

String representations of timedelta objects are normalized
similarly to their internal representation.  This leads to somewhat
unusual results for negative timedeltas.  For example:
>>> timedelta(hours=-5)
datetime.timedelta(days=-1, seconds=68400)
>>> print(_)
-1 day, 19:00:00



The expression t2 - t3 will always be equal to the expression t2 + (-t3) except
when t3 is equal to timedelta.max; in that case the former will produce a result
while the latter will overflow.


In addition to the operations listed above timedelta objects support
certain additions and subtractions with date and datetime
objects (see below).

Changed in version 3.2: Floor division and true division of a timedelta object by another
timedelta object are now supported, as are remainder operations and
the divmod() function.  True division and multiplication of a
timedelta object by a float object are now supported.

Comparisons of timedelta objects are supported with the
timedelta object representing the smaller duration considered to be the
smaller timedelta. In order to stop mixed-type comparisons from falling back to
the default comparison by object address, when a timedelta object is
compared to an object of a different type, TypeError is raised unless the
comparison is == or !=.  The latter cases return False or
True, respectively.
timedelta objects are hashable (usable as dictionary keys), support
efficient pickling, and in Boolean contexts, a timedelta object is
considered to be true if and only if it isn’t equal to timedelta(0).
Instance methods:


timedelta.total_seconds()¶
Return the total number of seconds contained in the duration. Equivalent to
td / timedelta(seconds=1). For interval units other than seconds, use the
division form directly (e.g. td / timedelta(microseconds=1)).
Note that for very large time intervals (greater than 270 years on
most platforms) this method will lose microsecond accuracy.

New in version 3.2.


Example usage:
>>> from datetime import timedelta
>>> year = timedelta(days=365)
>>> another_year = timedelta(weeks=40, days=84, hours=23,
...                          minutes=50, seconds=600)  # adds up to 365 days
>>> year.total_seconds()
31536000.0
>>> year == another_year
True
>>> ten_years = 10 * year
>>> ten_years, ten_years.days // 365
(datetime.timedelta(days=3650), 10)
>>> nine_years = ten_years - year
>>> nine_years, nine_years.days // 365
(datetime.timedelta(days=3285), 9)
>>> three_years = nine_years // 3
>>> three_years, three_years.days // 365
(datetime.timedelta(days=1095), 3)
>>> abs(three_years - ten_years) == 2 * three_years + year
True


