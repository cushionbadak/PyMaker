link:
library/multiprocessing.html#contexts-and-start-methods

docs:

Contexts and start methods¶
Depending on the platform, multiprocessing supports three ways
to start a process.  These start methods are


spawn
The parent process starts a fresh python interpreter process.  The
child process will only inherit those resources necessary to run
the process objects run() method.  In particular,
unnecessary file descriptors and handles from the parent process
will not be inherited.  Starting a process using this method is
rather slow compared to using fork or forkserver.
Available on Unix and Windows.  The default on Windows.

fork
The parent process uses os.fork() to fork the Python
interpreter.  The child process, when it begins, is effectively
identical to the parent process.  All resources of the parent are
inherited by the child process.  Note that safely forking a
multithreaded process is problematic.
Available on Unix only.  The default on Unix.

forkserver
When the program starts and selects the forkserver start method,
a server process is started.  From then on, whenever a new process
is needed, the parent process connects to the server and requests
that it fork a new process.  The fork server process is single
threaded so it is safe for it to use os.fork().  No
unnecessary resources are inherited.
Available on Unix platforms which support passing file descriptors
over Unix pipes.




Changed in version 3.4: spawn added on all unix platforms, and forkserver added for
some unix platforms.
Child processes no longer inherit all of the parents inheritable
handles on Windows.

On Unix using the spawn or forkserver start methods will also
start a semaphore tracker process which tracks the unlinked named
semaphores created by processes of the program.  When all processes
have exited the semaphore tracker unlinks any remaining semaphores.
Usually there should be none, but if a process was killed by a signal
there may be some “leaked” semaphores.  (Unlinking the named semaphores
is a serious matter since the system allows only a limited number, and
they will not be automatically unlinked until the next reboot.)
To select a start method you use the set_start_method() in
the if __name__ == '__main__' clause of the main module.  For
example:
import multiprocessing as mp

def foo(q):
    q.put('hello')

if __name__ == '__main__':
    mp.set_start_method('spawn')
    q = mp.Queue()
    p = mp.Process(target=foo, args=(q,))
    p.start()
    print(q.get())
    p.join()


set_start_method() should not be used more than once in the
program.
Alternatively, you can use get_context() to obtain a context
object.  Context objects have the same API as the multiprocessing
module, and allow one to use multiple start methods in the same
program.
import multiprocessing as mp

def foo(q):
    q.put('hello')

if __name__ == '__main__':
    ctx = mp.get_context('spawn')
    q = ctx.Queue()
    p = ctx.Process(target=foo, args=(q,))
    p.start()
    print(q.get())
    p.join()


Note that objects related to one context may not be compatible with
processes for a different context.  In particular, locks created using
the fork context cannot be passed to processes started using the
spawn or forkserver start methods.
A library which wants to use a particular start method should probably
use get_context() to avoid interfering with the choice of the
library user.

Warning
The 'spawn' and 'forkserver' start methods cannot currently
be used with “frozen” executables (i.e., binaries produced by
packages like PyInstaller and cx_Freeze) on Unix.
The 'fork' start method does work.

