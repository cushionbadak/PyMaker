link:
library/asyncio-subprocess.html#interacting-with-subprocesses

docs:

Interacting with Subprocesses¶
Both create_subprocess_exec() and create_subprocess_shell()
functions return instances of the Process class.  Process is a high-level
wrapper that allows communicating with subprocesses and watching for
their completion.


class asyncio.subprocess.Process¶
An object that wraps OS processes created by the
create_subprocess_exec() and create_subprocess_shell()
functions.
This class is designed to have a similar API to the
subprocess.Popen class, but there are some
notable differences:

unlike Popen, Process instances do not have an equivalent to
the poll() method;
the communicate() and
wait() methods don’t have a
timeout parameter: use the wait_for() function;
the Process.wait() method
is asynchronous, whereas subprocess.Popen.wait() method
is implemented as a blocking busy loop;
the universal_newlines parameter is not supported.

This class is not thread safe.
See also the Subprocess and Threads
section.


coroutine wait()¶
Wait for the child process to terminate.
Set and return the returncode attribute.

Note
This method can deadlock when using stdout=PIPE or
stderr=PIPE and the child process generates so much output
that it blocks waiting for the OS pipe buffer to accept
more data. Use the communicate() method when using pipes
to avoid this condition.




coroutine communicate(input=None)¶
Interact with process:

send data to stdin (if input is not None);
read data from stdout and stderr, until EOF is reached;
wait for process to terminate.

The optional input argument is the data (bytes object)
that will be sent to the child process.
Return a tuple (stdout_data, stderr_data).
If either BrokenPipeError or ConnectionResetError
exception is raised when writing input into stdin, the
exception is ignored.  This condition occurs when the process
exits before all data are written into stdin.
If it is desired to send data to the process’ stdin,
the process needs to be created with stdin=PIPE.  Similarly,
to get anything other than None in the result tuple, the
process has to be created with stdout=PIPE and/or
stderr=PIPE arguments.
Note, that the data read is buffered in memory, so do not use
this method if the data size is large or unlimited.



send_signal(signal)¶
Sends the signal signal to the child process.

Note
On Windows, SIGTERM is an alias for terminate().
CTRL_C_EVENT and CTRL_BREAK_EVENT can be sent to processes
started with a creationflags parameter which includes
CREATE_NEW_PROCESS_GROUP.




terminate()¶
Stop the child process.
On POSIX systems this method sends signal.SIGTERM to the
child process.
On Windows the Win32 API function TerminateProcess() is
called to stop the child process.



kill()¶
Kill the child.
On POSIX systems this method sends SIGKILL to the child
process.
On Windows this method is an alias for terminate().



stdin¶
Standard input stream (StreamWriter) or None
if the process was created with stdin=None.



stdout¶
Standard output stream (StreamReader) or None
if the process was created with stdout=None.



stderr¶
Standard error stream (StreamReader) or None
if the process was created with stderr=None.


Warning
Use the communicate() method rather than
process.stdin.write(),
await process.stdout.read() or
await process.stderr.read.
This avoids deadlocks due to streams pausing reading or writing
and blocking the child process.



pid¶
Process identification number (PID).
Note that for processes created by the create_subprocess_shell()
function, this attribute is the PID of the spawned shell.



returncode¶
Return code of the process when it exits.
A None value indicates that the process has not terminated yet.
A negative value -N indicates that the child was terminated
by signal N (POSIX only).



Subprocess and Threads¶
Standard asyncio event loop supports running subprocesses from
different threads, but there are limitations:

An event loop must run in the main thread.
The child watcher must be instantiated in the main thread
before executing subprocesses from other threads. Call the
get_child_watcher() function in the main thread to instantiate
the child watcher.

Note that alternative event loop implementations might not share
the above limitations; please refer to their documentation.

See also
The Concurrency and multithreading in asyncio section.



Examples¶
An example using the Process class to
control a subprocess and the StreamReader class to read from
its standard output.
The subprocess is created by the create_subprocess_exec()
function:
import asyncio
import sys

async def get_date():
    code = 'import datetime; print(datetime.datetime.now())'

    # Create the subprocess; redirect the standard output
    # into a pipe.
    proc = await asyncio.create_subprocess_exec(
        sys.executable, '-c', code,
        stdout=asyncio.subprocess.PIPE)

    # Read one line of output.
    data = await proc.stdout.readline()
    line = data.decode('ascii').rstrip()

    # Wait for the subprocess exit.
    await proc.wait()
    return line

if sys.platform == "win32":
    asyncio.set_event_loop_policy(
        asyncio.WindowsProactorEventLoopPolicy())

date = asyncio.run(get_date())
print(f"Current date: {date}")


See also the same example
written using low-level APIs.

