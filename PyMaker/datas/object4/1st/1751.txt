link:
library/decimal.html#decimal.Context.power

docs:

<dt id="decimal.Context.power">
<code class="descname">power</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>modulo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#decimal.Context.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">x</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">y</span></code>, reduced modulo <code class="docutils literal notranslate"><span class="pre">modulo</span></code> if given.</p>
<p>With two arguments, compute <code class="docutils literal notranslate"><span class="pre">x**y</span></code>.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is negative then <code class="docutils literal notranslate"><span class="pre">y</span></code>
must be integral.  The result will be inexact unless <code class="docutils literal notranslate"><span class="pre">y</span></code> is integral and
the result is finite and can be expressed exactly in ‘precision’ digits.
The rounding mode of the context is used. Results are always correctly-rounded
in the Python version.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>The C module computes <a class="reference internal" href="#decimal.Context.power" title="decimal.Context.power"><code class="xref py py-meth docutils literal notranslate"><span class="pre">power()</span></code></a> in terms of the correctly-rounded
<a class="reference internal" href="#decimal.Context.exp" title="decimal.Context.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a> and <a class="reference internal" href="#decimal.Context.ln" title="decimal.Context.ln"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ln()</span></code></a> functions. The result is well-defined but
only “almost always correctly-rounded”.</p>
</div>
<p>With three arguments, compute <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">modulo</span></code>.  For the three argument
form, the following restrictions on the arguments hold:</p>
<blockquote>
<div><ul class="simple">
<li>all three arguments must be integral</li>
<li><code class="docutils literal notranslate"><span class="pre">y</span></code> must be nonnegative</li>
<li>at least one of <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> must be nonzero</li>
<li><code class="docutils literal notranslate"><span class="pre">modulo</span></code> must be nonzero and have at most ‘precision’ digits</li>
</ul>
</div></blockquote>
<p>The value resulting from <code class="docutils literal notranslate"><span class="pre">Context.power(x,</span> <span class="pre">y,</span> <span class="pre">modulo)</span></code> is
equal to the value that would be obtained by computing <code class="docutils literal notranslate"><span class="pre">(x**y)</span>
<span class="pre">%</span> <span class="pre">modulo</span></code> with unbounded precision, but is computed more
efficiently.  The exponent of the result is zero, regardless of
the exponents of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">modulo</span></code>.  The result is
always exact.</p>
</dd>