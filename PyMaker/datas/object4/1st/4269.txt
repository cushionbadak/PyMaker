link:
library/multiprocessing.html#pipes-and-queues

docs:

Pipes and Queues¶
When using multiple processes, one generally uses message passing for
communication between processes and avoids having to use any synchronization
primitives like locks.
For passing messages one can use Pipe() (for a connection between two
processes) or a queue (which allows multiple producers and consumers).
The Queue, SimpleQueue and JoinableQueue types
are multi-producer, multi-consumer FIFO
queues modelled on the queue.Queue class in the
standard library.  They differ in that Queue lacks the
task_done() and join() methods introduced
into Python 2.5’s queue.Queue class.
If you use JoinableQueue then you must call
JoinableQueue.task_done() for each task removed from the queue or else the
semaphore used to count the number of unfinished tasks may eventually overflow,
raising an exception.
Note that one can also create a shared queue by using a manager object – see
Managers.

Note
multiprocessing uses the usual queue.Empty and
queue.Full exceptions to signal a timeout.  They are not available in
the multiprocessing namespace so you need to import them from
queue.


Note
When an object is put on a queue, the object is pickled and a
background thread later flushes the pickled data to an underlying
pipe.  This has some consequences which are a little surprising,
but should not cause any practical difficulties – if they really
bother you then you can instead use a queue created with a
manager.

After putting an object on an empty queue there may be an
infinitesimal delay before the queue’s empty()
method returns False and get_nowait() can
return without raising queue.Empty.
If multiple processes are enqueuing objects, it is possible for
the objects to be received at the other end out-of-order.
However, objects enqueued by the same process will always be in
the expected order with respect to each other.



Warning
If a process is killed using Process.terminate() or os.kill()
while it is trying to use a Queue, then the data in the queue is
likely to become corrupted.  This may cause any other process to get an
exception when it tries to use the queue later on.


Warning
As mentioned above, if a child process has put items on a queue (and it has
not used JoinableQueue.cancel_join_thread), then that process will
not terminate until all buffered items have been flushed to the pipe.
This means that if you try joining that process you may get a deadlock unless
you are sure that all items which have been put on the queue have been
consumed.  Similarly, if the child process is non-daemonic then the parent
process may hang on exit when it tries to join all its non-daemonic children.
Note that a queue created using a manager does not have this issue.  See
Programming guidelines.

For an example of the usage of queues for interprocess communication see
Examples.


multiprocessing.Pipe([duplex])¶
Returns a pair (conn1, conn2) of
Connection objects representing the
ends of a pipe.
If duplex is True (the default) then the pipe is bidirectional.  If
duplex is False then the pipe is unidirectional: conn1 can only be
used for receiving messages and conn2 can only be used for sending
messages.



class multiprocessing.Queue([maxsize])¶
Returns a process shared queue implemented using a pipe and a few
locks/semaphores.  When a process first puts an item on the queue a feeder
thread is started which transfers objects from a buffer into the pipe.
The usual queue.Empty and queue.Full exceptions from the
standard library’s queue module are raised to signal timeouts.
Queue implements all the methods of queue.Queue except for
task_done() and join().


qsize()¶
Return the approximate size of the queue.  Because of
multithreading/multiprocessing semantics, this number is not reliable.
Note that this may raise NotImplementedError on Unix platforms like
Mac OS X where sem_getvalue() is not implemented.



empty()¶
Return True if the queue is empty, False otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



full()¶
Return True if the queue is full, False otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



put(obj[, block[, timeout]])¶
Put obj into the queue.  If the optional argument block is True
(the default) and timeout is None (the default), block if necessary until
a free slot is available.  If timeout is a positive number, it blocks at
most timeout seconds and raises the queue.Full exception if no
free slot was available within that time.  Otherwise (block is
False), put an item on the queue if a free slot is immediately
available, else raise the queue.Full exception (timeout is
ignored in that case).



put_nowait(obj)¶
Equivalent to put(obj, False).



get([block[, timeout]])¶
Remove and return an item from the queue.  If optional args block is
True (the default) and timeout is None (the default), block if
necessary until an item is available.  If timeout is a positive number,
it blocks at most timeout seconds and raises the queue.Empty
exception if no item was available within that time.  Otherwise (block is
False), return an item if one is immediately available, else raise the
queue.Empty exception (timeout is ignored in that case).



get_nowait()¶
Equivalent to get(False).

multiprocessing.Queue has a few additional methods not found in
queue.Queue.  These methods are usually unnecessary for most
code:


close()¶
Indicate that no more data will be put on this queue by the current
process.  The background thread will quit once it has flushed all buffered
data to the pipe.  This is called automatically when the queue is garbage
collected.



join_thread()¶
Join the background thread.  This can only be used after close() has
been called.  It blocks until the background thread exits, ensuring that
all data in the buffer has been flushed to the pipe.
By default if a process is not the creator of the queue then on exit it
will attempt to join the queue’s background thread.  The process can call
cancel_join_thread() to make join_thread() do nothing.



cancel_join_thread()¶
Prevent join_thread() from blocking.  In particular, this prevents
the background thread from being joined automatically when the process
exits – see join_thread().
A better name for this method might be
allow_exit_without_flush().  It is likely to cause enqueued
data to lost, and you almost certainly will not need to use it.
It is really only there if you need the current process to exit
immediately without waiting to flush enqueued data to the
underlying pipe, and you don’t care about lost data.


Note
This class’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
functionality in this class will be disabled, and attempts to
instantiate a Queue will result in an ImportError. See
bpo-3770 for additional information.  The same holds true for any
of the specialized queue types listed below.




class multiprocessing.SimpleQueue¶
It is a simplified Queue type, very close to a locked Pipe.


empty()¶
Return True if the queue is empty, False otherwise.



get()¶
Remove and return an item from the queue.



put(item)¶
Put item into the queue.




class multiprocessing.JoinableQueue([maxsize])¶
JoinableQueue, a Queue subclass, is a queue which
additionally has task_done() and join() methods.


task_done()¶
Indicate that a formerly enqueued task is complete. Used by queue
consumers.  For each get() used to fetch a task, a subsequent
call to task_done() tells the queue that the processing on the task
is complete.
If a join() is currently blocking, it will resume when all
items have been processed (meaning that a task_done() call was
received for every item that had been put() into the queue).
Raises a ValueError if called more times than there were items
placed in the queue.



join()¶
Block until all items in the queue have been gotten and processed.
The count of unfinished tasks goes up whenever an item is added to the
queue.  The count goes down whenever a consumer calls
task_done() to indicate that the item was retrieved and all work on
it is complete.  When the count of unfinished tasks drops to zero,
join() unblocks.


