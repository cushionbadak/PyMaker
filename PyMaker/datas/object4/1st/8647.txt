link:
library/unittest.mock-examples.html#partial-mocking

docs:

Partial mocking¶
In some tests I wanted to mock out a call to datetime.date.today()
to return a known date, but I didn’t want to prevent the code under test from
creating new date objects. Unfortunately datetime.date is written in C, and
so I couldn’t just monkey-patch out the static date.today() method.
I found a simple way of doing this that involved effectively wrapping the date
class with a mock, but passing through calls to the constructor to the real
class (and returning real instances).
The patch decorator is used here to
mock out the date class in the module under test. The side_effect
attribute on the mock date class is then set to a lambda function that returns
a real date. When the mock date class is called a real date will be
constructed and returned by side_effect.
>>> from datetime import date
>>> with patch('mymodule.date') as mock_date:
...     mock_date.today.return_value = date(2010, 10, 8)
...     mock_date.side_effect = lambda *args, **kw: date(*args, **kw)
...
...     assert mymodule.date.today() == date(2010, 10, 8)
...     assert mymodule.date(2009, 6, 8) == date(2009, 6, 8)
...


Note that we don’t patch datetime.date globally, we patch date in the
module that uses it. See where to patch.
When date.today() is called a known date is returned, but calls to the
date(...) constructor still return normal dates. Without this you can find
yourself having to calculate an expected result using exactly the same
algorithm as the code under test, which is a classic testing anti-pattern.
Calls to the date constructor are recorded in the mock_date attributes
(call_count and friends) which may also be useful for your tests.
An alternative way of dealing with mocking dates, or other builtin classes,
is discussed in this blog entry.
