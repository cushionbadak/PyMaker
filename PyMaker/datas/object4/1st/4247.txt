link:
library/multiprocessing.html#sharing-state-between-processes

docs:

Sharing state between processesÂ¶
As mentioned above, when doing concurrent programming it is usually best to
avoid using shared state as far as possible.  This is particularly true when
using multiple processes.
However, if you really do need to use some shared data then
multiprocessing provides a couple of ways of doing so.
Shared memory

Data can be stored in a shared memory map using Value or
Array.  For example, the following code
from multiprocessing import Process, Value, Array

def f(n, a):
    n.value = 3.1415927
    for i in range(len(a)):
        a[i] = -a[i]

if __name__ == '__main__':
    num = Value('d', 0.0)
    arr = Array('i', range(10))

    p = Process(target=f, args=(num, arr))
    p.start()
    p.join()

    print(num.value)
    print(arr[:])


will print
3.1415927
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]


The 'd' and 'i' arguments used when creating num and arr are
typecodes of the kind used by the array module: 'd' indicates a
double precision float and 'i' indicates a signed integer.  These shared
objects will be process and thread-safe.
For more flexibility in using shared memory one can use the
multiprocessing.sharedctypes module which supports the creation of
arbitrary ctypes objects allocated from shared memory.

Server process

A manager object returned by Manager() controls a server process which
holds Python objects and allows other processes to manipulate them using
proxies.
A manager returned by Manager() will support types
list, dict, Namespace, Lock,
RLock, Semaphore, BoundedSemaphore,
Condition, Event, Barrier,
Queue, Value and Array.  For example,
from multiprocessing import Process, Manager

def f(d, l):
    d[1] = '1'
    d['2'] = 2
    d[0.25] = None
    l.reverse()

if __name__ == '__main__':
    with Manager() as manager:
        d = manager.dict()
        l = manager.list(range(10))

        p = Process(target=f, args=(d, l))
        p.start()
        p.join()

        print(d)
        print(l)


will print
{0.25: None, 1: '1', '2': 2}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]


Server process managers are more flexible than using shared memory objects
because they can be made to support arbitrary object types.  Also, a single
manager can be shared by processes on different computers over a network.
They are, however, slower than using shared memory.

