link:
library/urllib.request.html#legacy-interface

docs:

Legacy interface¶
The following functions and classes are ported from the Python 2 module
urllib (as opposed to urllib2).  They might become deprecated at
some point in the future.


urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)¶
Copy a network object denoted by a URL to a local file. If the URL
points to a local file, the object will not be copied unless filename is supplied.
Return a tuple (filename, headers) where filename is the
local file name under which the object can be found, and headers is whatever
the info() method of the object returned by urlopen() returned (for
a remote object). Exceptions are the same as for urlopen().
The second argument, if present, specifies the file location to copy to (if
absent, the location will be a tempfile with a generated name). The third
argument, if present, is a callable that will be called once on
establishment of the network connection and once after each block read
thereafter.  The callable will be passed three arguments; a count of blocks
transferred so far, a block size in bytes, and the total size of the file.  The
third argument may be -1 on older FTP servers which do not return a file
size in response to a retrieval request.
The following example illustrates the most common usage scenario:
>>> import urllib.request
>>> local_filename, headers = urllib.request.urlretrieve('http://python.org/')
>>> html = open(local_filename)
>>> html.close()


If the url uses the http: scheme identifier, the optional data
argument may be given to specify a POST request (normally the request
type is GET).  The data argument must be a bytes object in standard
application/x-www-form-urlencoded format; see the
urllib.parse.urlencode() function.
urlretrieve() will raise ContentTooShortError when it detects that
the amount of data available  was less than the expected amount (which is the
size reported by a  Content-Length header). This can occur, for example, when
the  download is interrupted.
The Content-Length is treated as a lower bound: if there’s more data  to read,
urlretrieve reads more data, but if less data is available,  it raises the
exception.
You can still retrieve the downloaded data in this case, it is stored  in the
content attribute of the exception instance.
If no Content-Length header was supplied, urlretrieve can not check the size
of the data it has downloaded, and just returns it.  In this case you just have
to assume that the download was successful.



urllib.request.urlcleanup()¶
Cleans up temporary files that may have been left behind by previous
calls to urlretrieve().



class urllib.request.URLopener(proxies=None, **x509)¶

Deprecated since version 3.3.

Base class for opening and reading URLs.  Unless you need to support opening
objects using schemes other than http:, ftp:, or file:,
you probably want to use FancyURLopener.
By default, the URLopener class sends a User-Agent header
of urllib/VVV, where VVV is the urllib version number.
Applications can define their own User-Agent header by subclassing
URLopener or FancyURLopener and setting the class attribute
version to an appropriate string value in the subclass definition.
The optional proxies parameter should be a dictionary mapping scheme names to
proxy URLs, where an empty dictionary turns proxies off completely.  Its default
value is None, in which case environmental proxy settings will be used if
present, as discussed in the definition of urlopen(), above.
Additional keyword parameters, collected in x509, may be used for
authentication of the client when using the https: scheme.  The keywords
key_file and cert_file are supported to provide an  SSL key and certificate;
both are needed to support client authentication.
URLopener objects will raise an OSError exception if the server
returns an error code.


open(fullurl, data=None)¶
Open fullurl using the appropriate protocol.  This method sets up cache and
proxy information, then calls the appropriate open method with its input
arguments.  If the scheme is not recognized, open_unknown() is called.
The data argument has the same meaning as the data argument of
urlopen().
This method always quotes fullurl using quote().



open_unknown(fullurl, data=None)¶
Overridable interface to open unknown URL types.



retrieve(url, filename=None, reporthook=None, data=None)¶
Retrieves the contents of url and places it in filename.  The return value
is a tuple consisting of a local filename and either an
email.message.Message object containing the response headers (for remote
URLs) or None (for local URLs).  The caller must then open and read the
contents of filename.  If filename is not given and the URL refers to a
local file, the input filename is returned.  If the URL is non-local and
filename is not given, the filename is the output of tempfile.mktemp()
with a suffix that matches the suffix of the last path component of the input
URL.  If reporthook is given, it must be a function accepting three numeric
parameters: A chunk number, the maximum size chunks are read in and the total size of the download
(-1 if unknown).  It will be called once at the start and after each chunk of data is read from the
network.  reporthook is ignored for local URLs.
If the url uses the http: scheme identifier, the optional data
argument may be given to specify a POST request (normally the request type
is GET).  The data argument must in standard
application/x-www-form-urlencoded format; see the
urllib.parse.urlencode() function.



version¶
Variable that specifies the user agent of the opener object.  To get
urllib to tell servers that it is a particular user agent, set this in a
subclass as a class variable or in the constructor before calling the base
constructor.




class urllib.request.FancyURLopener(...)¶

Deprecated since version 3.3.

FancyURLopener subclasses URLopener providing default handling
for the following HTTP response codes: 301, 302, 303, 307 and 401.  For the 30x
response codes listed above, the Location header is used to fetch
the actual URL.  For 401 response codes (authentication required), basic HTTP
authentication is performed.  For the 30x response codes, recursion is bounded
by the value of the maxtries attribute, which defaults to 10.
For all other response codes, the method http_error_default() is called
which you can override in subclasses to handle the error appropriately.

Note
According to the letter of RFC 2616, 301 and 302 responses to POST requests
must not be automatically redirected without confirmation by the user.  In
reality, browsers do allow automatic redirection of these responses, changing
the POST to a GET, and urllib reproduces this behaviour.

The parameters to the constructor are the same as those for URLopener.

Note
When performing basic authentication, a FancyURLopener instance calls
its prompt_user_passwd() method.  The default implementation asks the
users for the required information on the controlling terminal.  A subclass may
override this method to support more appropriate behavior if needed.

The FancyURLopener class offers one additional method that should be
overloaded to provide the appropriate behavior:


prompt_user_passwd(host, realm)¶
Return information needed to authenticate the user at the given host in the
specified security realm.  The return value should be a tuple, (user,
password), which can be used for basic authentication.
The implementation prompts for this information on the terminal; an application
should override this method to use an appropriate interaction model in the local
environment.


