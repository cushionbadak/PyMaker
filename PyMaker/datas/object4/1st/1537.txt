link:
library/math.html#number-theoretic-and-representation-functions

docs:

Number-theoretic and representation functions¶


math.ceil(x)¶
Return the ceiling of x, the smallest integer greater than or equal to x.
If x is not a float, delegates to x.__ceil__(), which should return an
Integral value.



math.copysign(x, y)¶
Return a float with the magnitude (absolute value) of x but the sign of
y.  On platforms that support signed zeros, copysign(1.0, -0.0)
returns -1.0.



math.fabs(x)¶
Return the absolute value of x.



math.factorial(x)¶
Return x factorial.  Raises ValueError if x is not integral or
is negative.



math.floor(x)¶
Return the floor of x, the largest integer less than or equal to x.
If x is not a float, delegates to x.__floor__(), which should return an
Integral value.



math.fmod(x, y)¶
Return fmod(x, y), as defined by the platform C library. Note that the
Python expression x % y may not return the same result.  The intent of the C
standard is that fmod(x, y) be exactly (mathematically; to infinite
precision) equal to x - n*y for some integer n such that the result has
the same sign as x and magnitude less than abs(y).  Python’s x % y
returns a result with the sign of y instead, and may not be exactly computable
for float arguments. For example, fmod(-1e-100, 1e100) is -1e-100, but
the result of Python’s -1e-100 % 1e100 is 1e100-1e-100, which cannot be
represented exactly as a float, and rounds to the surprising 1e100.  For
this reason, function fmod() is generally preferred when working with
floats, while Python’s x % y is preferred when working with integers.



math.frexp(x)¶
Return the mantissa and exponent of x as the pair (m, e).  m is a float
and e is an integer such that x == m * 2**e exactly. If x is zero,
returns (0.0, 0), otherwise 0.5 <= abs(m) < 1.  This is used to “pick
apart” the internal representation of a float in a portable way.



math.fsum(iterable)¶
Return an accurate floating point sum of values in the iterable.  Avoids
loss of precision by tracking multiple intermediate partial sums:
>>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
0.9999999999999999
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
1.0


The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the
typical case where the rounding mode is half-even.  On some non-Windows
builds, the underlying C library uses extended precision addition and may
occasionally double-round an intermediate sum causing it to be off in its
least significant bit.
For further discussion and two alternative approaches, see the ASPN cookbook
recipes for accurate floating point summation.



math.gcd(a, b)¶
Return the greatest common divisor of the integers a and b.  If either
a or b is nonzero, then the value of gcd(a, b) is the largest
positive integer that divides both a and b.  gcd(0, 0) returns
0.

New in version 3.5.




math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)¶
Return True if the values a and b are close to each other and
False otherwise.
Whether or not two values are considered close is determined according to
given absolute and relative tolerances.
rel_tol is the relative tolerance – it is the maximum allowed difference
between a and b, relative to the larger absolute value of a or b.
For example, to set a tolerance of 5%, pass rel_tol=0.05.  The default
tolerance is 1e-09, which assures that the two values are the same
within about 9 decimal digits.  rel_tol must be greater than zero.
abs_tol is the minimum absolute tolerance – useful for comparisons near
zero. abs_tol must be at least zero.
If no errors occur, the result will be:
abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol).
The IEEE 754 special values of NaN, inf, and -inf will be
handled according to IEEE rules.  Specifically, NaN is not considered
close to any other value, including NaN.  inf and -inf are only
considered close to themselves.

New in version 3.5.


See also
PEP 485 – A function for testing approximate equality




math.isfinite(x)¶
Return True if x is neither an infinity nor a NaN, and
False otherwise.  (Note that 0.0 is considered finite.)

New in version 3.2.




math.isinf(x)¶
Return True if x is a positive or negative infinity, and
False otherwise.



math.isnan(x)¶
Return True if x is a NaN (not a number), and False otherwise.



math.ldexp(x, i)¶
Return x * (2**i).  This is essentially the inverse of function
frexp().



math.modf(x)¶
Return the fractional and integer parts of x.  Both results carry the sign
of x and are floats.



math.remainder(x, y)¶
Return the IEEE 754-style remainder of x with respect to y.  For
finite x and finite nonzero y, this is the difference x - n*y,
where n is the closest integer to the exact value of the quotient x /
y.  If x / y is exactly halfway between two consecutive integers, the
nearest even integer is used for n.  The remainder r = remainder(x,
y) thus always satisfies abs(r) <= 0.5 * abs(y).
Special cases follow IEEE 754: in particular, remainder(x, math.inf) is
x for any finite x, and remainder(x, 0) and
remainder(math.inf, x) raise ValueError for any non-NaN x.
If the result of the remainder operation is zero, that zero will have
the same sign as x.
On platforms using IEEE 754 binary floating-point, the result of this
operation is always exactly representable: no rounding error is introduced.

New in version 3.7.




math.trunc(x)¶
Return the Real value x truncated to an
Integral (usually an integer). Delegates to
x.__trunc__().

Note that frexp() and modf() have a different call/return pattern
than their C equivalents: they take a single argument and return a pair of
values, rather than returning their second return value through an ‘output
parameter’ (there is no such thing in Python).
For the ceil(), floor(), and modf() functions, note that all
floating-point numbers of sufficiently large magnitude are exact integers.
Python floats typically carry no more than 53 bits of precision (the same as the
platform C double type), in which case any float x with abs(x) >= 2**52
necessarily has no fractional bits.
