link:
library/os.html#files-and-directories

docs:

Files and Directories¶
On some Unix platforms, many of these functions support one or more of these
features:

specifying a file descriptor:
For some functions, the path argument can be not only a string giving a path
name, but also a file descriptor.  The function will then operate on the file
referred to by the descriptor.  (For POSIX systems, Python will call the
f... version of the function.)
You can check whether or not path can be specified as a file descriptor on
your platform using os.supports_fd.  If it is unavailable, using it
will raise a NotImplementedError.
If the function also supports dir_fd or follow_symlinks arguments, it is
an error to specify one of those when supplying path as a file descriptor.



paths relative to directory descriptors: If dir_fd is not None, it
should be a file descriptor referring to a directory, and the path to operate
on should be relative; path will then be relative to that directory.  If the
path is absolute, dir_fd is ignored.  (For POSIX systems, Python will call
the ...at or f...at version of the function.)
You can check whether or not dir_fd is supported on your platform using
os.supports_dir_fd.  If it is unavailable, using it will raise a
NotImplementedError.



not following symlinks: If follow_symlinks is
False, and the last element of the path to operate on is a symbolic link,
the function will operate on the symbolic link itself instead of the file the
link points to.  (For POSIX systems, Python will call the l... version of
the function.)
You can check whether or not follow_symlinks is supported on your platform
using os.supports_follow_symlinks.  If it is unavailable, using it
will raise a NotImplementedError.




os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)¶
Use the real uid/gid to test for access to path.  Note that most operations
will use the effective uid/gid, therefore this routine can be used in a
suid/sgid environment to test if the invoking user has the specified access to
path.  mode should be F_OK to test the existence of path, or it
can be the inclusive OR of one or more of R_OK, W_OK, and
X_OK to test permissions.  Return True if access is allowed,
False if not. See the Unix man page access(2) for more
information.
This function can support specifying paths relative to directory
descriptors and not following symlinks.
If effective_ids is True, access() will perform its access
checks using the effective uid/gid instead of the real uid/gid.
effective_ids may not be supported on your platform; you can check whether
or not it is available using os.supports_effective_ids.  If it is
unavailable, using it will raise a NotImplementedError.

Note
Using access() to check if a user is authorized to e.g. open a file
before actually doing so using open() creates a security hole,
because the user might exploit the short time interval between checking
and opening the file to manipulate it. It’s preferable to use EAFP
techniques. For example:
if os.access("myfile", os.R_OK):
    with open("myfile") as fp:
        return fp.read()
return "some default data"


is better written as:
try:
    fp = open("myfile")
except PermissionError:
    return "some default data"
else:
    with fp:
        return fp.read()




Note
I/O operations may fail even when access() indicates that they would
succeed, particularly for operations on network filesystems which may have
permissions semantics beyond the usual POSIX permission-bit model.


Changed in version 3.3: Added the dir_fd, effective_ids, and follow_symlinks parameters.


Changed in version 3.6: Accepts a path-like object.




os.F_OK¶

os.R_OK¶

os.W_OK¶

os.X_OK¶
Values to pass as the mode parameter of access() to test the
existence, readability, writability and executability of path,
respectively.



os.chdir(path)¶
Change the current working directory to path.
This function can support specifying a file descriptor.  The
descriptor must refer to an opened directory, not an open file.

New in version 3.3: Added support for specifying path as a file descriptor
on some platforms.


Changed in version 3.6: Accepts a path-like object.




os.chflags(path, flags, *, follow_symlinks=True)¶
Set the flags of path to the numeric flags. flags may take a combination
(bitwise OR) of the following values (as defined in the stat module):

stat.UF_NODUMP
stat.UF_IMMUTABLE
stat.UF_APPEND
stat.UF_OPAQUE
stat.UF_NOUNLINK
stat.UF_COMPRESSED
stat.UF_HIDDEN
stat.SF_ARCHIVED
stat.SF_IMMUTABLE
stat.SF_APPEND
stat.SF_NOUNLINK
stat.SF_SNAPSHOT

This function can support not following symlinks.
Availability: Unix.

New in version 3.3: The follow_symlinks argument.


Changed in version 3.6: Accepts a path-like object.




os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True)¶
Change the mode of path to the numeric mode. mode may take one of the
following values (as defined in the stat module) or bitwise ORed
combinations of them:

stat.S_ISUID
stat.S_ISGID
stat.S_ENFMT
stat.S_ISVTX
stat.S_IREAD
stat.S_IWRITE
stat.S_IEXEC
stat.S_IRWXU
stat.S_IRUSR
stat.S_IWUSR
stat.S_IXUSR
stat.S_IRWXG
stat.S_IRGRP
stat.S_IWGRP
stat.S_IXGRP
stat.S_IRWXO
stat.S_IROTH
stat.S_IWOTH
stat.S_IXOTH

This function can support specifying a file descriptor,
paths relative to directory descriptors and not
following symlinks.

Note
Although Windows supports chmod(), you can only set the file’s
read-only flag with it (via the stat.S_IWRITE and stat.S_IREAD
constants or a corresponding integer value).  All other bits are ignored.


New in version 3.3: Added support for specifying path as an open file descriptor,
and the dir_fd and follow_symlinks arguments.


Changed in version 3.6: Accepts a path-like object.




os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)¶
Change the owner and group id of path to the numeric uid and gid.  To
leave one of the ids unchanged, set it to -1.
This function can support specifying a file descriptor,
paths relative to directory descriptors and not
following symlinks.
See shutil.chown() for a higher-level function that accepts names in
addition to numeric ids.
Availability: Unix.

New in version 3.3: Added support for specifying an open file descriptor for path,
and the dir_fd and follow_symlinks arguments.


Changed in version 3.6: Supports a path-like object.




os.chroot(path)¶
Change the root directory of the current process to path.
Availability: Unix.

Changed in version 3.6: Accepts a path-like object.




os.fchdir(fd)¶
Change the current working directory to the directory represented by the file
descriptor fd.  The descriptor must refer to an opened directory, not an
open file.  As of Python 3.3, this is equivalent to os.chdir(fd).
Availability: Unix.



os.getcwd()¶
Return a string representing the current working directory.



os.getcwdb()¶
Return a bytestring representing the current working directory.



os.lchflags(path, flags)¶
Set the flags of path to the numeric flags, like chflags(), but do
not follow symbolic links.  As of Python 3.3, this is equivalent to
os.chflags(path, flags, follow_symlinks=False).
Availability: Unix.

Changed in version 3.6: Accepts a path-like object.




os.lchmod(path, mode)¶
Change the mode of path to the numeric mode. If path is a symlink, this
affects the symlink rather than the target.  See the docs for chmod()
for possible values of mode.  As of Python 3.3, this is equivalent to
os.chmod(path, mode, follow_symlinks=False).
Availability: Unix.

Changed in version 3.6: Accepts a path-like object.




os.lchown(path, uid, gid)¶
Change the owner and group id of path to the numeric uid and gid.  This
function will not follow symbolic links.  As of Python 3.3, this is equivalent
to os.chown(path, uid, gid, follow_symlinks=False).
Availability: Unix.

Changed in version 3.6: Accepts a path-like object.




os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)¶
Create a hard link pointing to src named dst.
This function can support specifying src_dir_fd and/or dst_dir_fd to
supply paths relative to directory descriptors, and not
following symlinks.
Availability: Unix, Windows.

Changed in version 3.2: Added Windows support.


New in version 3.3: Added the src_dir_fd, dst_dir_fd, and follow_symlinks arguments.


Changed in version 3.6: Accepts a path-like object for src and dst.




os.listdir(path='.')¶
Return a list containing the names of the entries in the directory given by
path.  The list is in arbitrary order, and does not include the special
entries '.' and '..' even if they are present in the directory.
path may be a path-like object.  If path is of type bytes
(directly or indirectly through the PathLike interface),
the filenames returned will also be of type bytes;
in all other circumstances, they will be of type str.
This function can also support specifying a file descriptor; the file descriptor must refer to a directory.

Note
To encode str filenames to bytes, use fsencode().


See also
The scandir() function returns directory entries along with
file attribute information, giving better performance for many
common use cases.


Changed in version 3.2: The path parameter became optional.


New in version 3.3: Added support for specifying an open file descriptor for path.


Changed in version 3.6: Accepts a path-like object.




os.lstat(path, *, dir_fd=None)¶
Perform the equivalent of an lstat() system call on the given path.
Similar to stat(), but does not follow symbolic links. Return a
stat_result object.
On platforms that do not support symbolic links, this is an alias for
stat().
As of Python 3.3, this is equivalent to os.stat(path, dir_fd=dir_fd,
follow_symlinks=False).
This function can also support paths relative to directory descriptors.

See also
The stat() function.


Changed in version 3.2: Added support for Windows 6.0 (Vista) symbolic links.


Changed in version 3.3: Added the dir_fd parameter.


Changed in version 3.6: Accepts a path-like object for src and dst.




os.mkdir(path, mode=0o777, *, dir_fd=None)¶
Create a directory named path with numeric mode mode.
If the directory already exists, FileExistsError is raised.
On some systems, mode is ignored.  Where it is used, the current umask
value is first masked out.  If bits other than the last 9 (i.e. the last 3
digits of the octal representation of the mode) are set, their meaning is
platform-dependent.  On some platforms, they are ignored and you should call
chmod() explicitly to set them.
This function can also support paths relative to directory descriptors.
It is also possible to create temporary directories; see the
tempfile module’s tempfile.mkdtemp() function.

New in version 3.3: The dir_fd argument.


Changed in version 3.6: Accepts a path-like object.




os.makedirs(name, mode=0o777, exist_ok=False)¶
Recursive directory creation function.  Like mkdir(), but makes all
intermediate-level directories needed to contain the leaf directory.
The mode parameter is passed to mkdir() for creating the leaf
directory; see the mkdir() description for how it
is interpreted.  To set the file permission bits of any newly-created parent
directories you can set the umask before invoking makedirs().  The
file permission bits of existing parent directories are not changed.
If exist_ok is False (the default), an OSError is raised if the
target directory already exists.

Note
makedirs() will become confused if the path elements to create
include pardir (eg. “..” on UNIX systems).

This function handles UNC paths correctly.

New in version 3.2: The exist_ok parameter.


Changed in version 3.4.1: Before Python 3.4.1, if exist_ok was True and the directory existed,
makedirs() would still raise an error if mode did not match the
mode of the existing directory. Since this behavior was impossible to
implement safely, it was removed in Python 3.4.1. See bpo-21082.


Changed in version 3.6: Accepts a path-like object.


Changed in version 3.7: The mode argument no longer affects the file permission bits of
newly-created intermediate-level directories.




os.mkfifo(path, mode=0o666, *, dir_fd=None)¶
Create a FIFO (a named pipe) named path with numeric mode mode.
The current umask value is first masked out from the mode.
This function can also support paths relative to directory descriptors.
FIFOs are pipes that can be accessed like regular files.  FIFOs exist until they
are deleted (for example with os.unlink()). Generally, FIFOs are used as
rendezvous between “client” and “server” type processes: the server opens the
FIFO for reading, and the client opens it for writing.  Note that mkfifo()
doesn’t open the FIFO — it just creates the rendezvous point.
Availability: Unix.

New in version 3.3: The dir_fd argument.


Changed in version 3.6: Accepts a path-like object.




os.mknod(path, mode=0o600, device=0, *, dir_fd=None)¶
Create a filesystem node (file, device special file or named pipe) named
path. mode specifies both the permissions to use and the type of node
to be created, being combined (bitwise OR) with one of stat.S_IFREG,
stat.S_IFCHR, stat.S_IFBLK, and stat.S_IFIFO (those constants are
available in stat).  For stat.S_IFCHR and stat.S_IFBLK,
device defines the newly created device special file (probably using
os.makedev()), otherwise it is ignored.
This function can also support paths relative to directory descriptors.
Availability: Unix.

New in version 3.3: The dir_fd argument.


Changed in version 3.6: Accepts a path-like object.




os.major(device)¶
Extract the device major number from a raw device number (usually the
st_dev or st_rdev field from stat).



os.minor(device)¶
Extract the device minor number from a raw device number (usually the
st_dev or st_rdev field from stat).



os.makedev(major, minor)¶
Compose a raw device number from the major and minor device numbers.



os.pathconf(path, name)¶
Return system configuration information relevant to a named file. name
specifies the configuration value to retrieve; it may be a string which is the
name of a defined system value; these names are specified in a number of
standards (POSIX.1, Unix 95, Unix 98, and others).  Some platforms define
additional names as well.  The names known to the host operating system are
given in the pathconf_names dictionary.  For configuration variables not
included in that mapping, passing an integer for name is also accepted.
If name is a string and is not known, ValueError is raised.  If a
specific value for name is not supported by the host system, even if it is
included in pathconf_names, an OSError is raised with
errno.EINVAL for the error number.
This function can support specifying a file descriptor.
Availability: Unix.

Changed in version 3.6: Accepts a path-like object.




os.pathconf_names¶
Dictionary mapping names accepted by pathconf() and fpathconf() to
the integer values defined for those names by the host operating system.  This
can be used to determine the set of names known to the system.
Availability: Unix.



os.readlink(path, *, dir_fd=None)¶
Return a string representing the path to which the symbolic link points.  The
result may be either an absolute or relative pathname; if it is relative, it
may be converted to an absolute pathname using
os.path.join(os.path.dirname(path), result).
If the path is a string object (directly or indirectly through a
PathLike interface), the result will also be a string object,
and the call may raise a UnicodeDecodeError. If the path is a bytes
object (direct or indirectly), the result will be a bytes object.
This function can also support paths relative to directory descriptors.
Availability: Unix, Windows.

Changed in version 3.2: Added support for Windows 6.0 (Vista) symbolic links.


New in version 3.3: The dir_fd argument.


Changed in version 3.6: Accepts a path-like object.




os.remove(path, *, dir_fd=None)¶
Remove (delete) the file path.  If path is a directory, OSError is
raised.  Use rmdir() to remove directories.
This function can support paths relative to directory descriptors.
On Windows, attempting to remove a file that is in use causes an exception to
be raised; on Unix, the directory entry is removed but the storage allocated
to the file is not made available until the original file is no longer in use.
This function is semantically identical to unlink().

New in version 3.3: The dir_fd argument.


Changed in version 3.6: Accepts a path-like object.




os.removedirs(name)¶
Remove directories recursively.  Works like rmdir() except that, if the
leaf directory is successfully removed, removedirs()  tries to
successively remove every parent directory mentioned in  path until an error
is raised (which is ignored, because it generally means that a parent directory
is not empty). For example, os.removedirs('foo/bar/baz') will first remove
the directory 'foo/bar/baz', and then remove 'foo/bar' and 'foo' if
they are empty. Raises OSError if the leaf directory could not be
successfully removed.

Changed in version 3.6: Accepts a path-like object.




os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)¶
Rename the file or directory src to dst.  If dst is a directory,
OSError will be raised.  On Unix, if dst exists and is a file, it will
be replaced silently if the user has permission.  The operation may fail on some
Unix flavors if src and dst are on different filesystems.  If successful,
the renaming will be an atomic operation (this is a POSIX requirement).  On
Windows, if dst already exists, OSError will be raised even if it is a
file.
This function can support specifying src_dir_fd and/or dst_dir_fd to
supply paths relative to directory descriptors.
If you want cross-platform overwriting of the destination, use replace().

New in version 3.3: The src_dir_fd and dst_dir_fd arguments.


Changed in version 3.6: Accepts a path-like object for src and dst.




os.renames(old, new)¶
Recursive directory or file renaming function. Works like rename(), except
creation of any intermediate directories needed to make the new pathname good is
attempted first. After the rename, directories corresponding to rightmost path
segments of the old name will be pruned away using removedirs().

Note
This function can fail with the new directory structure made if you lack
permissions needed to remove the leaf directory or file.


Changed in version 3.6: Accepts a path-like object for old and new.




os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)¶
Rename the file or directory src to dst.  If dst is a directory,
OSError will be raised.  If dst exists and is a file, it will
be replaced silently if the user has permission.  The operation may fail
if src and dst are on different filesystems.  If successful,
the renaming will be an atomic operation (this is a POSIX requirement).
This function can support specifying src_dir_fd and/or dst_dir_fd to
supply paths relative to directory descriptors.

New in version 3.3.


Changed in version 3.6: Accepts a path-like object for src and dst.




os.rmdir(path, *, dir_fd=None)¶
Remove (delete) the directory path.  Only works when the directory is
empty, otherwise, OSError is raised.  In order to remove whole
directory trees, shutil.rmtree() can be used.
This function can support paths relative to directory descriptors.

New in version 3.3: The dir_fd parameter.


Changed in version 3.6: Accepts a path-like object.




os.scandir(path='.')¶
Return an iterator of os.DirEntry objects corresponding to the
entries in the directory given by path. The entries are yielded in
arbitrary order, and the special entries '.' and '..' are not
included.
Using scandir() instead of listdir() can significantly
increase the performance of code that also needs file type or file
attribute information, because os.DirEntry objects expose this
information if the operating system provides it when scanning a directory.
All os.DirEntry methods may perform a system call, but
is_dir() and is_file() usually only
require a system call for symbolic links; os.DirEntry.stat()
always requires a system call on Unix but only requires one for
symbolic links on Windows.
path may be a path-like object.  If path is of type bytes
(directly or indirectly through the PathLike interface),
the type of the name and path
attributes of each os.DirEntry will be bytes; in all other
circumstances, they will be of type str.
This function can also support specifying a file descriptor; the file descriptor must refer to a directory.
The scandir() iterator supports the context manager protocol
and has the following method:


scandir.close()¶
Close the iterator and free acquired resources.
This is called automatically when the iterator is exhausted or garbage
collected, or when an error happens during iterating.  However it
is advisable to call it explicitly or use the with
statement.

New in version 3.6.


The following example shows a simple use of scandir() to display all
the files (excluding directories) in the given path that don’t start with
'.'. The entry.is_file() call will generally not make an additional
system call:
with os.scandir(path) as it:
    for entry in it:
        if not entry.name.startswith('.') and entry.is_file():
            print(entry.name)



Note
On Unix-based systems, scandir() uses the system’s
opendir()
and
readdir()
functions. On Windows, it uses the Win32
FindFirstFileW
and
FindNextFileW
functions.


New in version 3.5.


New in version 3.6: Added support for the context manager protocol and the
close() method.  If a scandir() iterator is neither
exhausted nor explicitly closed a ResourceWarning will be emitted
in its destructor.
The function accepts a path-like object.


Changed in version 3.7: Added support for file descriptors on Unix.




class os.DirEntry¶
Object yielded by scandir() to expose the file path and other file
attributes of a directory entry.
scandir() will provide as much of this information as possible without
making additional system calls. When a stat() or lstat() system call
is made, the os.DirEntry object will cache the result.
os.DirEntry instances are not intended to be stored in long-lived data
structures; if you know the file metadata has changed or if a long time has
elapsed since calling scandir(), call os.stat(entry.path) to fetch
up-to-date information.
Because the os.DirEntry methods can make operating system calls, they may
also raise OSError. If you need very fine-grained
control over errors, you can catch OSError when calling one of the
os.DirEntry methods and handle as appropriate.
To be directly usable as a path-like object, os.DirEntry
implements the PathLike interface.
Attributes and methods on a os.DirEntry instance are as follows:


name¶
The entry’s base filename, relative to the scandir() path
argument.
The name attribute will be bytes if the scandir()
path argument is of type bytes and str otherwise.  Use
fsdecode() to decode byte filenames.



path¶
The entry’s full path name: equivalent to os.path.join(scandir_path,
entry.name) where scandir_path is the scandir() path
argument.  The path is only absolute if the scandir() path
argument was absolute.  If the scandir() path
argument was a file descriptor, the path
attribute is the same as the name attribute.
The path attribute will be bytes if the scandir()
path argument is of type bytes and str otherwise.  Use
fsdecode() to decode byte filenames.



inode()¶
Return the inode number of the entry.
The result is cached on the os.DirEntry object. Use
os.stat(entry.path, follow_symlinks=False).st_ino to fetch up-to-date
information.
On the first, uncached call, a system call is required on Windows but
not on Unix.



is_dir(*, follow_symlinks=True)¶
Return True if this entry is a directory or a symbolic link pointing
to a directory; return False if the entry is or points to any other
kind of file, or if it doesn’t exist anymore.
If follow_symlinks is False, return True only if this entry
is a directory (without following symlinks); return False if the
entry is any other kind of file or if it doesn’t exist anymore.
The result is cached on the os.DirEntry object, with a separate cache
for follow_symlinks True and False. Call os.stat() along
with stat.S_ISDIR() to fetch up-to-date information.
On the first, uncached call, no system call is required in most cases.
Specifically, for non-symlinks, neither Windows or Unix require a system
call, except on certain Unix file systems, such as network file systems,
that return dirent.d_type == DT_UNKNOWN. If the entry is a symlink,
a system call will be required to follow the symlink unless
follow_symlinks is False.
This method can raise OSError, such as PermissionError,
but FileNotFoundError is caught and not raised.



is_file(*, follow_symlinks=True)¶
Return True if this entry is a file or a symbolic link pointing to a
file; return False if the entry is or points to a directory or other
non-file entry, or if it doesn’t exist anymore.
If follow_symlinks is False, return True only if this entry
is a file (without following symlinks); return False if the entry is
a directory or other non-file entry, or if it doesn’t exist anymore.
The result is cached on the os.DirEntry object. Caching, system calls
made, and exceptions raised are as per is_dir().



is_symlink()¶
Return True if this entry is a symbolic link (even if broken);
return False if the entry points to a directory or any kind of file,
or if it doesn’t exist anymore.
The result is cached on the os.DirEntry object. Call
os.path.islink() to fetch up-to-date information.
On the first, uncached call, no system call is required in most cases.
Specifically, neither Windows or Unix require a system call, except on
certain Unix file systems, such as network file systems, that return
dirent.d_type == DT_UNKNOWN.
This method can raise OSError, such as PermissionError,
but FileNotFoundError is caught and not raised.



stat(*, follow_symlinks=True)¶
Return a stat_result object for this entry. This method
follows symbolic links by default; to stat a symbolic link add the
follow_symlinks=False argument.
On Unix, this method always requires a system call. On Windows, it
only requires a system call if follow_symlinks is True and the
entry is a symbolic link.
On Windows, the st_ino, st_dev and st_nlink attributes of the
stat_result are always set to zero. Call os.stat() to
get these attributes.
The result is cached on the os.DirEntry object, with a separate cache
for follow_symlinks True and False. Call os.stat() to
fetch up-to-date information.

Note that there is a nice correspondence between several attributes
and methods of os.DirEntry and of pathlib.Path.  In
particular, the name attribute has the same
meaning, as do the is_dir(), is_file(), is_symlink()
and stat() methods.

New in version 3.5.


Changed in version 3.6: Added support for the PathLike interface.  Added support
for bytes paths on Windows.




os.stat(path, *, dir_fd=None, follow_symlinks=True)¶
Get the status of a file or a file descriptor. Perform the equivalent of a
stat() system call on the given path. path may be specified as
either a string or bytes – directly or indirectly through the PathLike
interface – or as an open file descriptor. Return a stat_result
object.
This function normally follows symlinks; to stat a symlink add the argument
follow_symlinks=False, or use lstat().
This function can support specifying a file descriptor and
not following symlinks.
Example:
>>> import os
>>> statinfo = os.stat('somefile.txt')
>>> statinfo
os.stat_result(st_mode=33188, st_ino=7876932, st_dev=234881026,
st_nlink=1, st_uid=501, st_gid=501, st_size=264, st_atime=1297230295,
st_mtime=1297230027, st_ctime=1297230027)
>>> statinfo.st_size
264



See also
fstat() and lstat() functions.


New in version 3.3: Added the dir_fd and follow_symlinks arguments, specifying a file
descriptor instead of a path.


Changed in version 3.6: Accepts a path-like object.




class os.stat_result¶
Object whose attributes correspond roughly to the members of the
stat structure. It is used for the result of os.stat(),
os.fstat() and os.lstat().
Attributes:


st_mode¶
File mode: file type and file mode bits (permissions).



st_ino¶
Platform dependent, but if non-zero, uniquely identifies the
file for a given value of st_dev. Typically:

the inode number on Unix,
the file index on
Windows




st_dev¶
Identifier of the device on which this file resides.



st_nlink¶
Number of hard links.



st_uid¶
User identifier of the file owner.



st_gid¶
Group identifier of the file owner.



st_size¶
Size of the file in bytes, if it is a regular file or a symbolic link.
The size of a symbolic link is the length of the pathname it contains,
without a terminating null byte.

Timestamps:


st_atime¶
Time of most recent access expressed in seconds.



st_mtime¶
Time of most recent content modification expressed in seconds.



st_ctime¶
Platform dependent:

the time of most recent metadata change on Unix,
the time of creation on Windows, expressed in seconds.




st_atime_ns¶
Time of most recent access expressed in nanoseconds as an integer.



st_mtime_ns¶
Time of most recent content modification expressed in nanoseconds as an
integer.



st_ctime_ns¶
Platform dependent:

the time of most recent metadata change on Unix,
the time of creation on Windows, expressed in nanoseconds as an
integer.



Note
The exact meaning and resolution of the st_atime,
st_mtime, and st_ctime attributes depend on the operating
system and the file system. For example, on Windows systems using the FAT
or FAT32 file systems, st_mtime has 2-second resolution, and
st_atime has only 1-day resolution.  See your operating system
documentation for details.
Similarly, although st_atime_ns, st_mtime_ns,
and st_ctime_ns are always expressed in nanoseconds, many
systems do not provide nanosecond precision.  On systems that do
provide nanosecond precision, the floating-point object used to
store st_atime, st_mtime, and st_ctime
cannot preserve all of it, and as such will be slightly inexact.
If you need the exact timestamps you should always use
st_atime_ns, st_mtime_ns, and st_ctime_ns.

On some Unix systems (such as Linux), the following attributes may also be
available:


st_blocks¶
Number of 512-byte blocks allocated for file.
This may be smaller than st_size/512 when the file has holes.



st_blksize¶
“Preferred” blocksize for efficient file system I/O. Writing to a file in
smaller chunks may cause an inefficient read-modify-rewrite.



st_rdev¶
Type of device if an inode device.



st_flags¶
User defined flags for file.

On other Unix systems (such as FreeBSD), the following attributes may be
available (but may be only filled out if root tries to use them):


st_gen¶
File generation number.



st_birthtime¶
Time of file creation.

On Solaris and derivatives, the following attributes may also be
available:


st_fstype¶
String that uniquely identifies the type of the filesystem that
contains the file.

On Mac OS systems, the following attributes may also be available:


st_rsize¶
Real size of the file.



st_creator¶
Creator of the file.



st_type¶
File type.

On Windows systems, the following attribute is also available:


st_file_attributes¶
Windows file attributes: dwFileAttributes member of the
BY_HANDLE_FILE_INFORMATION structure returned by
GetFileInformationByHandle(). See the FILE_ATTRIBUTE_*
constants in the stat module.

The standard module stat defines functions and constants that are
useful for extracting information from a stat structure. (On
Windows, some items are filled with dummy values.)
For backward compatibility, a stat_result instance is also
accessible as a tuple of at least 10 integers giving the most important (and
portable) members of the stat structure, in the order
st_mode, st_ino, st_dev, st_nlink,
st_uid, st_gid, st_size, st_atime,
st_mtime, st_ctime. More items may be added at the end by
some implementations. For compatibility with older Python versions,
accessing stat_result as a tuple always returns integers.

New in version 3.3: Added the st_atime_ns, st_mtime_ns, and
st_ctime_ns members.


New in version 3.5: Added the st_file_attributes member on Windows.


Changed in version 3.5: Windows now returns the file index as st_ino when
available.


New in version 3.7: Added the st_fstype member to Solaris/derivatives.




os.statvfs(path)¶
Perform a statvfs() system call on the given path.  The return value is
an object whose attributes describe the filesystem on the given path, and
correspond to the members of the statvfs structure, namely:
f_bsize, f_frsize, f_blocks, f_bfree,
f_bavail, f_files, f_ffree, f_favail,
f_flag, f_namemax, f_fsid.
Two module-level constants are defined for the f_flag attribute’s
bit-flags: if ST_RDONLY is set, the filesystem is mounted
read-only, and if ST_NOSUID is set, the semantics of
setuid/setgid bits are disabled or not supported.
Additional module-level constants are defined for GNU/glibc based systems.
These are ST_NODEV (disallow access to device special files),
ST_NOEXEC (disallow program execution), ST_SYNCHRONOUS
(writes are synced at once), ST_MANDLOCK (allow mandatory locks on an FS),
ST_WRITE (write on file/directory/symlink), ST_APPEND
(append-only file), ST_IMMUTABLE (immutable file), ST_NOATIME
(do not update access times), ST_NODIRATIME (do not update directory access
times), ST_RELATIME (update atime relative to mtime/ctime).
This function can support specifying a file descriptor.
Availability: Unix.

Changed in version 3.2: The ST_RDONLY and ST_NOSUID constants were added.


New in version 3.3: Added support for specifying an open file descriptor for path.


Changed in version 3.4: The ST_NODEV, ST_NOEXEC, ST_SYNCHRONOUS,
ST_MANDLOCK, ST_WRITE, ST_APPEND,
ST_IMMUTABLE, ST_NOATIME, ST_NODIRATIME,
and ST_RELATIME constants were added.


Changed in version 3.6: Accepts a path-like object.


New in version 3.7: Added f_fsid.




os.supports_dir_fd¶
A Set object indicating which functions in the
os module permit use of their dir_fd parameter.  Different platforms
provide different functionality, and an option that might work on one might
be unsupported on another.  For consistency’s sakes, functions that support
dir_fd always allow specifying the parameter, but will raise an exception
if the functionality is not actually available.
To check whether a particular function permits use of its dir_fd
parameter, use the in operator on supports_dir_fd.  As an example,
this expression determines whether the dir_fd parameter of os.stat()
is locally available:
os.stat in os.supports_dir_fd


Currently dir_fd parameters only work on Unix platforms; none of them work
on Windows.

New in version 3.3.




os.supports_effective_ids¶
A Set object indicating which functions in the
os module permit use of the effective_ids parameter for
os.access().  If the local platform supports it, the collection will
contain os.access(), otherwise it will be empty.
To check whether you can use the effective_ids parameter for
os.access(), use the in operator on supports_effective_ids,
like so:
os.access in os.supports_effective_ids


Currently effective_ids only works on Unix platforms; it does not work on
Windows.

New in version 3.3.




os.supports_fd¶
A Set object indicating which functions in the
os module permit specifying their path parameter as an open file
descriptor.  Different platforms provide different functionality, and an
option that might work on one might be unsupported on another.  For
consistency’s sakes, functions that support fd always allow specifying
the parameter, but will raise an exception if the functionality is not
actually available.
To check whether a particular function permits specifying an open file
descriptor for its path parameter, use the in operator on
supports_fd. As an example, this expression determines whether
os.chdir() accepts open file descriptors when called on your local
platform:
os.chdir in os.supports_fd



New in version 3.3.




os.supports_follow_symlinks¶
A Set object indicating which functions in the
os module permit use of their follow_symlinks parameter.  Different
platforms provide different functionality, and an option that might work on
one might be unsupported on another.  For consistency’s sakes, functions that
support follow_symlinks always allow specifying the parameter, but will
raise an exception if the functionality is not actually available.
To check whether a particular function permits use of its follow_symlinks
parameter, use the in operator on supports_follow_symlinks.  As an
example, this expression determines whether the follow_symlinks parameter
of os.stat() is locally available:
os.stat in os.supports_follow_symlinks



New in version 3.3.




os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)¶
Create a symbolic link pointing to src named dst.
On Windows, a symlink represents either a file or a directory, and does not
morph to the target dynamically.  If the target is present, the type of the
symlink will be created to match. Otherwise, the symlink will be created
as a directory if target_is_directory is True or a file symlink (the
default) otherwise.  On non-Windows platforms, target_is_directory is ignored.
Symbolic link support was introduced in Windows 6.0 (Vista).  symlink()
will raise a NotImplementedError on Windows versions earlier than 6.0.
This function can support paths relative to directory descriptors.

Note
On Windows, the SeCreateSymbolicLinkPrivilege is required in order to
successfully create symlinks. This privilege is not typically granted to
regular users but is available to accounts which can escalate privileges
to the administrator level. Either obtaining the privilege or running your
application as an administrator are ways to successfully create symlinks.
OSError is raised when the function is called by an unprivileged
user.

Availability: Unix, Windows.

Changed in version 3.2: Added support for Windows 6.0 (Vista) symbolic links.


New in version 3.3: Added the dir_fd argument, and now allow target_is_directory
on non-Windows platforms.


Changed in version 3.6: Accepts a path-like object for src and dst.




os.sync()¶
Force write of everything to disk.
Availability: Unix.

New in version 3.3.




os.truncate(path, length)¶
Truncate the file corresponding to path, so that it is at most
length bytes in size.
This function can support specifying a file descriptor.
Availability: Unix, Windows.

New in version 3.3.


Changed in version 3.5: Added support for Windows


Changed in version 3.6: Accepts a path-like object.




os.unlink(path, *, dir_fd=None)¶
Remove (delete) the file path.  This function is semantically
identical to remove(); the unlink name is its
traditional Unix name.  Please see the documentation for
remove() for further information.

New in version 3.3: The dir_fd parameter.


Changed in version 3.6: Accepts a path-like object.




os.utime(path, times=None, *, [ns, ]dir_fd=None, follow_symlinks=True)¶
Set the access and modified times of the file specified by path.
utime() takes two optional parameters, times and ns.
These specify the times set on path and are used as follows:

If ns is specified,
it must be a 2-tuple of the form (atime_ns, mtime_ns)
where each member is an int expressing nanoseconds.
If times is not None,
it must be a 2-tuple of the form (atime, mtime)
where each member is an int or float expressing seconds.
If times is None and ns is unspecified,
this is equivalent to specifying ns=(atime_ns, mtime_ns)
where both times are the current time.

It is an error to specify tuples for both times and ns.
Whether a directory can be given for path
depends on whether the operating system implements directories as files
(for example, Windows does not).  Note that the exact times you set here may
not be returned by a subsequent stat() call, depending on the
resolution with which your operating system records access and modification
times; see stat().  The best way to preserve exact times is to
use the st_atime_ns and st_mtime_ns fields from the os.stat()
result object with the ns parameter to utime.
This function can support specifying a file descriptor,
paths relative to directory descriptors and not
following symlinks.

New in version 3.3: Added support for specifying an open file descriptor for path,
and the dir_fd, follow_symlinks, and ns parameters.


Changed in version 3.6: Accepts a path-like object.




os.walk(top, topdown=True, onerror=None, followlinks=False)¶
Generate the file names in a directory tree by walking the tree
either top-down or bottom-up. For each directory in the tree rooted at directory
top (including top itself), it yields a 3-tuple (dirpath, dirnames,
filenames).
dirpath is a string, the path to the directory.  dirnames is a list of the
names of the subdirectories in dirpath (excluding '.' and '..').
filenames is a list of the names of the non-directory files in dirpath.
Note that the names in the lists contain no path components.  To get a full path
(which begins with top) to a file or directory in dirpath, do
os.path.join(dirpath, name).
If optional argument topdown is True or not specified, the triple for a
directory is generated before the triples for any of its subdirectories
(directories are generated top-down).  If topdown is False, the triple
for a directory is generated after the triples for all of its subdirectories
(directories are generated bottom-up). No matter the value of topdown, the
list of subdirectories is retrieved before the tuples for the directory and
its subdirectories are generated.
When topdown is True, the caller can modify the dirnames list in-place
(perhaps using del or slice assignment), and walk() will only
recurse into the subdirectories whose names remain in dirnames; this can be
used to prune the search, impose a specific order of visiting, or even to inform
walk() about directories the caller creates or renames before it resumes
walk() again.  Modifying dirnames when topdown is False has
no effect on the behavior of the walk, because in bottom-up mode the directories
in dirnames are generated before dirpath itself is generated.
By default, errors from the scandir() call are ignored.  If optional
argument onerror is specified, it should be a function; it will be called with
one argument, an OSError instance.  It can report the error to continue
with the walk, or raise the exception to abort the walk.  Note that the filename
is available as the filename attribute of the exception object.
By default, walk() will not walk down into symbolic links that resolve to
directories. Set followlinks to True to visit directories pointed to by
symlinks, on systems that support them.

Note
Be aware that setting followlinks to True can lead to infinite
recursion if a link points to a parent directory of itself. walk()
does not keep track of the directories it visited already.


Note
If you pass a relative pathname, don’t change the current working directory
between resumptions of walk().  walk() never changes the current
directory, and assumes that its caller doesn’t either.

This example displays the number of bytes taken by non-directory files in each
directory under the starting directory, except that it doesn’t look under any
CVS subdirectory:
import os
from os.path import join, getsize
for root, dirs, files in os.walk('python/Lib/email'):
    print(root, "consumes", end=" ")
    print(sum(getsize(join(root, name)) for name in files), end=" ")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories


In the next example (simple implementation of shutil.rmtree()),
walking the tree bottom-up is essential, rmdir() doesn’t allow
deleting a directory before the directory is empty:
# Delete everything reachable from the directory named in "top",
# assuming there are no symbolic links.
# CAUTION:  This is dangerous!  For example, if top == '/', it
# could delete all your disk files.
import os
for root, dirs, files in os.walk(top, topdown=False):
    for name in files:
        os.remove(os.path.join(root, name))
    for name in dirs:
        os.rmdir(os.path.join(root, name))



Changed in version 3.5: This function now calls os.scandir() instead of os.listdir(),
making it faster by reducing the number of calls to os.stat().


Changed in version 3.6: Accepts a path-like object.




os.fwalk(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)¶
This behaves exactly like walk(), except that it yields a 4-tuple
(dirpath, dirnames, filenames, dirfd), and it supports dir_fd.
dirpath, dirnames and filenames are identical to walk() output,
and dirfd is a file descriptor referring to the directory dirpath.
This function always supports paths relative to directory descriptors and not following symlinks.  Note however
that, unlike other functions, the fwalk() default value for
follow_symlinks is False.

Note
Since fwalk() yields file descriptors, those are only valid until
the next iteration step, so you should duplicate them (e.g. with
dup()) if you want to keep them longer.

This example displays the number of bytes taken by non-directory files in each
directory under the starting directory, except that it doesn’t look under any
CVS subdirectory:
import os
for root, dirs, files, rootfd in os.fwalk('python/Lib/email'):
    print(root, "consumes", end="")
    print(sum([os.stat(name, dir_fd=rootfd).st_size for name in files]),
          end="")
    print("bytes in", len(files), "non-directory files")
    if 'CVS' in dirs:
        dirs.remove('CVS')  # don't visit CVS directories


In the next example, walking the tree bottom-up is essential:
rmdir() doesn’t allow deleting a directory before the directory is
empty:
# Delete everything reachable from the directory named in "top",
# assuming there are no symbolic links.
# CAUTION:  This is dangerous!  For example, if top == '/', it
# could delete all your disk files.
import os
for root, dirs, files, rootfd in os.fwalk(top, topdown=False):
    for name in files:
        os.unlink(name, dir_fd=rootfd)
    for name in dirs:
        os.rmdir(name, dir_fd=rootfd)


Availability: Unix.

New in version 3.3.


Changed in version 3.6: Accepts a path-like object.


Changed in version 3.7: Added support for bytes paths.



Linux extended attributes¶

New in version 3.3.

These functions are all available on Linux only.


os.getxattr(path, attribute, *, follow_symlinks=True)¶
Return the value of the extended filesystem attribute attribute for
path. attribute can be bytes or str (directly or indirectly through the
PathLike interface). If it is str, it is encoded with the filesystem
encoding.
This function can support specifying a file descriptor and
not following symlinks.

Changed in version 3.6: Accepts a path-like object for path and attribute.




os.listxattr(path=None, *, follow_symlinks=True)¶
Return a list of the extended filesystem attributes on path.  The
attributes in the list are represented as strings decoded with the filesystem
encoding.  If path is None, listxattr() will examine the current
directory.
This function can support specifying a file descriptor and
not following symlinks.

Changed in version 3.6: Accepts a path-like object.




os.removexattr(path, attribute, *, follow_symlinks=True)¶
Removes the extended filesystem attribute attribute from path.
attribute should be bytes or str (directly or indirectly through the
PathLike interface). If it is a string, it is encoded
with the filesystem encoding.
This function can support specifying a file descriptor and
not following symlinks.

Changed in version 3.6: Accepts a path-like object for path and attribute.




os.setxattr(path, attribute, value, flags=0, *, follow_symlinks=True)¶
Set the extended filesystem attribute attribute on path to value.
attribute must be a bytes or str with no embedded NULs (directly or
indirectly through the PathLike interface). If it is a str,
it is encoded with the filesystem encoding.  flags may be
XATTR_REPLACE or XATTR_CREATE. If XATTR_REPLACE is
given and the attribute does not exist, EEXISTS will be raised.
If XATTR_CREATE is given and the attribute already exists, the
attribute will not be created and ENODATA will be raised.
This function can support specifying a file descriptor and
not following symlinks.

Note
A bug in Linux kernel versions less than 2.6.39 caused the flags argument
to be ignored on some filesystems.


Changed in version 3.6: Accepts a path-like object for path and attribute.




os.XATTR_SIZE_MAX¶
The maximum size the value of an extended attribute can be. Currently, this
is 64 KiB on Linux.



os.XATTR_CREATE¶
This is a possible value for the flags argument in setxattr(). It
indicates the operation must create an attribute.



os.XATTR_REPLACE¶
This is a possible value for the flags argument in setxattr(). It
indicates the operation must replace an existing attribute.


