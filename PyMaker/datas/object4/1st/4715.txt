link:
library/asyncio-subprocess.html#asyncio.asyncio.subprocess.Process.wait

docs:

<dt id="asyncio.asyncio.subprocess.Process.wait">
<em class="property">coroutine </em><code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.asyncio.subprocess.Process.wait" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wait for the child process to terminate.</p>
<p>Set and return the <a class="reference internal" href="#asyncio.asyncio.subprocess.Process.returncode" title="asyncio.asyncio.subprocess.Process.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">returncode</span></code></a> attribute.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method can deadlock when using <code class="docutils literal notranslate"><span class="pre">stdout=PIPE</span></code> or
<code class="docutils literal notranslate"><span class="pre">stderr=PIPE</span></code> and the child process generates so much output
that it blocks waiting for the OS pipe buffer to accept
more data. Use the <a class="reference internal" href="#asyncio.asyncio.subprocess.Process.communicate" title="asyncio.asyncio.subprocess.Process.communicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">communicate()</span></code></a> method when using pipes
to avoid this condition.</p>
</div>
</dd>