link:
library/enum.html#allowed-members-and-attributes-of-enumerations

docs:

Allowed members and attributes of enumerations¶
The examples above use integers for enumeration values.  Using integers is
short and handy (and provided by default by the Functional API), but not
strictly enforced.  In the vast majority of use-cases, one doesn’t care what
the actual value of an enumeration is.  But if the value is important,
enumerations can have arbitrary values.
Enumerations are Python classes, and can have methods and special methods as
usual.  If we have this enumeration:
>>> class Mood(Enum):
...     FUNKY = 1
...     HAPPY = 3
...
...     def describe(self):
...         # self is the member here
...         return self.name, self.value
...
...     def __str__(self):
...         return 'my custom str! {0}'.format(self.value)
...
...     @classmethod
...     def favorite_mood(cls):
...         # cls here is the enumeration
...         return cls.HAPPY
...


Then:
>>> Mood.favorite_mood()
<Mood.HAPPY: 3>
>>> Mood.HAPPY.describe()
('HAPPY', 3)
>>> str(Mood.FUNKY)
'my custom str! 1'


The rules for what is allowed are as follows: names that start and end with
a single underscore are reserved by enum and cannot be used; all other
attributes defined within an enumeration will become members of this
enumeration, with the exception of special methods (__str__(),
__add__(), etc.), descriptors (methods are also descriptors), and
variable names listed in _ignore_.
Note:  if your enumeration defines __new__() and/or __init__() then
whatever value(s) were given to the enum member will be passed into those
methods.  See Planet for an example.
