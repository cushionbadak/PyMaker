link:
library/concurrent.futures.html#processpoolexecutor

docs:

ProcessPoolExecutor¶
The ProcessPoolExecutor class is an Executor subclass that
uses a pool of processes to execute calls asynchronously.
ProcessPoolExecutor uses the multiprocessing module, which
allows it to side-step the Global Interpreter Lock but also means that
only picklable objects can be executed and returned.
The __main__ module must be importable by worker subprocesses. This means
that ProcessPoolExecutor will not work in the interactive interpreter.
Calling Executor or Future methods from a callable submitted
to a ProcessPoolExecutor will result in deadlock.


class concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None, initializer=None, initargs=())¶
An Executor subclass that executes calls asynchronously using a pool
of at most max_workers processes.  If max_workers is None or not
given, it will default to the number of processors on the machine.
If max_workers is lower or equal to 0, then a ValueError
will be raised.
mp_context can be a multiprocessing context or None. It will be used to
launch the workers. If mp_context is None or not given, the default
multiprocessing context is used.
initializer is an optional callable that is called at the start of
each worker process; initargs is a tuple of arguments passed to the
initializer.  Should initializer raise an exception, all currently
pending jobs will raise a BrokenProcessPool,
as well any attempt to submit more jobs to the pool.

Changed in version 3.3: When one of the worker processes terminates abruptly, a
BrokenProcessPool error is now raised.  Previously, behaviour
was undefined but operations on the executor or its futures would often
freeze or deadlock.


Changed in version 3.7: The mp_context argument was added to allow users to control the
start_method for worker processes created by the pool.
Added the initializer and initargs arguments.



ProcessPoolExecutor Example¶
import concurrent.futures
import math

PRIMES = [
    112272535095293,
    112582705942171,
    112272535095293,
    115280095190773,
    115797848077099,
    1099726899285419]

def is_prime(n):
    if n % 2 == 0:
        return False

    sqrt_n = int(math.floor(math.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def main():
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
            print('%d is prime: %s' % (number, prime))

if __name__ == '__main__':
    main()



