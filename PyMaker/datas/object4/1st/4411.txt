link:
library/concurrent.futures.html#threadpoolexecutor

docs:

ThreadPoolExecutor¶
ThreadPoolExecutor is an Executor subclass that uses a pool of
threads to execute calls asynchronously.
Deadlocks can occur when the callable associated with a Future waits on
the results of another Future.  For example:
import time
def wait_on_b():
    time.sleep(5)
    print(b.result())  # b will never complete because it is waiting on a.
    return 5

def wait_on_a():
    time.sleep(5)
    print(a.result())  # a will never complete because it is waiting on b.
    return 6


executor = ThreadPoolExecutor(max_workers=2)
a = executor.submit(wait_on_b)
b = executor.submit(wait_on_a)


And:
def wait_on_future():
    f = executor.submit(pow, 5, 2)
    # This will never complete because there is only one worker thread and
    # it is executing this function.
    print(f.result())

executor = ThreadPoolExecutor(max_workers=1)
executor.submit(wait_on_future)




class concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix='', initializer=None, initargs=())¶
An Executor subclass that uses a pool of at most max_workers
threads to execute calls asynchronously.
initializer is an optional callable that is called at the start of
each worker thread; initargs is a tuple of arguments passed to the
initializer.  Should initializer raise an exception, all currently
pending jobs will raise a BrokenThreadPool,
as well as any attempt to submit more jobs to the pool.

Changed in version 3.5: If max_workers is None or
not given, it will default to the number of processors on the machine,
multiplied by 5, assuming that ThreadPoolExecutor is often
used to overlap I/O instead of CPU work and the number of workers
should be higher than the number of workers
for ProcessPoolExecutor.


New in version 3.6: The thread_name_prefix argument was added to allow users to
control the threading.Thread names for worker threads created by
the pool for easier debugging.


Changed in version 3.7: Added the initializer and initargs arguments.



ThreadPoolExecutor Example¶
import concurrent.futures
import urllib.request

URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']

# Retrieve a single page and report the URL and contents
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()

# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))



