link:
reference/datamodel.html#creating-the-class-object

docs:

3.3.3.6. Creating the class objectÂ¶
Once the class namespace has been populated by executing the class body,
the class object is created by calling
 (the additional keywords
passed here are the same as those passed to ).
This class object is the one that will be referenced by the zero-argument
form of .  is an implicit closure reference
created by the compiler if any methods in a class body refer to either
 or . This allows the zero argument form of
 to correctly identify the class being defined based on
lexical scoping, while the class or instance that was used to make the
current call is identified based on the first argument passed to the method.

CPython implementation detail: In CPython 3.6 and later, the  cell is passed to the metaclass
as a  entry in the class namespace. If present, this must
be propagated up to the  call in order for the class to be
initialised correctly.
Failing to do so will result in a  in Python 3.6,
and a  in Python 3.8.

When using the default metaclass , or any metaclass that ultimately
calls , the following additional customisation steps are
invoked after creating the class object:

first,  collects all of the descriptors in the class
namespace that define a  method;
second, all of these  methods are called with the class
being defined and the assigned name of that particular descriptor;
finally, the  hook is called on the
immediate parent of the new class in its method resolution order.

After the class object is created, it is passed to the class decorators
included in the class definition (if any) and the resulting object is bound
in the local namespace as the defined class.
When a new class is created by , the object provided as the
namespace parameter is copied to a new ordered mapping and the original
object is discarded. The new copy is wrapped in a read-only proxy, which
becomes the  attribute of the class object.

See also

PEP 3135 - New super
Describes the implicit  closure reference


