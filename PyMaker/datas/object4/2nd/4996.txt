link:
library/asyncio-dev.html#developing-with-asyncio

docs:

Developing with asyncio¶
Asynchronous programming is different from classic “sequential”
programming.
This page lists common mistakes and traps and explains how
to avoid them.

Debug Mode¶
By default asyncio runs in production mode.  In order to ease
the development asyncio has a debug mode.
There are several ways to enable asyncio debug mode:

Setting the  environment variable to .
Using the   Python command line option.
Passing  to .
Calling .

In addition to enabling the debug mode, consider also:

setting the log level of the asyncio logger to
, for example the following snippet of code
can be run at startup of the application:



configuring the  module to display
 warnings.  One way of doing that is by
using the   command line option.


When the debug mode is enabled:

asyncio checks for coroutines that were not awaited and logs them; this mitigates
the “forgotten await” pitfall.
Many non-threadsafe asyncio APIs (such as  and
 methods) raise an exception if they are called
from a wrong thread.
The execution time of the I/O selector is logged if it takes too long to
perform an I/O operation.
Callbacks taking longer than 100ms are logged.  The
 attribute can be used to set the
minimum execution duration in seconds that is considered “slow”.



Concurrency and Multithreading¶
An event loop runs in a thread (typically the main thread) and executes
all callbacks and Tasks in its thread.  While a Task is running in the
event loop, no other Tasks can run in the same thread.  When a Task
executes an  expression, the running Task gets suspended, and
the event loop executes the next Task.
To schedule a callback from a different OS thread, the
 method should be used. Example:


Almost all asyncio objects are not thread safe, which is typically
not a problem unless there is code that works with them from outside
of a Task or a callback.  If there’s a need for such code to call a
low-level asyncio API, the  method
should be used, e.g.:


To schedule a coroutine object from a different OS thread, the
 function should be used. It returns a
 to access the result:


To handle signals and to execute subprocesses, the event loop must be
run in the main thread.
The  method can be used with a
 to execute
blocking code in a different OS thread without blocking the OS thread
that the event loop runs in.


Running Blocking Code¶
Blocking (CPU-bound) code should not be called directly.  For example,
if a function performs a CPU-intensive calculation for 1 second,
all concurrent asyncio Tasks and IO operations would be delayed
by 1 second.
An executor can be used to run a task in a different thread or even in
a different process to avoid blocking block the OS thread with the
event loop.  See the  method for more
details.


Logging¶
asyncio uses the  module and all logging is performed
via the  logger.
The default log level is , which can be easily
adjusted:




Detect never-awaited coroutines¶
When a coroutine function is called, but not awaited
(e.g.  instead of )
or the coroutine is not scheduled with , asyncio
will emit a :


Output:


Output in debug mode:


The usual fix is to either await the coroutine or call the
 function:




Detect never-retrieved exceptions¶
If a  is called but the Future object is
never awaited on, the exception would never be propagated to the
user code.  In this case, asyncio would emit a log message when the
Future object is garbage collected.
Example of an unhandled exception:


Output:


Enable the debug mode to get the
traceback where the task was created:


Output in debug mode:



