link:
library/ctypes.html#structured-data-types

docs:

Structured data types¶


class (*args, **kw)¶
Abstract base class for unions in native byte order.



class (*args, **kw)¶
Abstract base class for structures in big endian byte order.



class (*args, **kw)¶
Abstract base class for structures in little endian byte order.

Structures with non-native byte order cannot contain pointer type fields, or any
other data types containing pointer type fields.


class (*args, **kw)¶
Abstract base class for structures in native byte order.
Concrete structure and union types must be created by subclassing one of these
types, and at least define a  class variable.  will
create descriptors which allow reading and writing the fields by direct
attribute accesses.  These are the


¶
A sequence defining the structure fields.  The items must be 2-tuples or
3-tuples.  The first item is the name of the field, the second item
specifies the type of the field; it can be any ctypes data type.
For integer type fields like , a third optional item can be
given.  It must be a small positive integer defining the bit width of the
field.
Field names must be unique within one structure or union.  This is not
checked, only one field can be accessed when names are repeated.
It is possible to define the  class variable after the
class statement that defines the Structure subclass, this allows creating
data types that directly or indirectly reference themselves:


The  class variable must, however, be defined before the
type is first used (an instance is created,  is called on it,
and so on).  Later assignments to the  class variable will
raise an AttributeError.
It is possible to define sub-subclasses of structure types, they inherit
the fields of the base class plus the  defined in the
sub-subclass, if any.



¶
An optional small integer that allows overriding the alignment of
structure fields in the instance.   must already be defined
when  is assigned, otherwise it will have no effect.



¶
An optional sequence that lists the names of unnamed (anonymous) fields.
 must be already defined when  is
assigned, otherwise it will have no effect.
The fields listed in this variable must be structure or union type fields.
 will create descriptors in the structure type that allows
accessing the nested fields directly, without the need to create the
structure or union field.
Here is an example type (Windows):


The  structure describes a COM data type, the  field
specifies which one of the union fields is valid.  Since the  field
is defined as anonymous field, it is now possible to access the members
directly off the TYPEDESC instance.  and 
are equivalent, but the former is faster since it does not need to create
a temporary union instance:



It is possible to define sub-subclasses of structures, they inherit the
fields of the base class.  If the subclass definition has a separate
 variable, the fields specified in this are appended to the
fields of the base class.
Structure and union constructors accept both positional and keyword
arguments.  Positional arguments are used to initialize member fields in the
same order as they are appear in .  Keyword arguments in the
constructor are interpreted as attribute assignments, so they will initialize
 with the same name, or create new attributes for names not
present in .

