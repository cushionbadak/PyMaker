link:
reference/simple_stmts.html#future-statements

docs:

7.11.1. Future statements¶
A future statement is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be available in a
specified future release of Python where the feature becomes standard.
The future statement is intended to ease migration to future versions of Python
that introduce incompatible changes to the language.  It allows use of the new
features on a per-module basis before the release in which the feature becomes
standard.

A future statement must appear near the top of the module.  The only lines that
can appear before a future statement are:

the module docstring (if any),
comments,
blank lines, and
other future statements.

The only feature in Python 3.7 that requires using the future statement is
.
All historical features enabled by the future statement are still recognized
by Python 3.  The list includes , ,
, , ,
,  and .  They are
all redundant because they are always enabled, and only kept for
backwards compatibility.
A future statement is recognized and treated specially at compile time: Changes
to the semantics of core constructs are often implemented by generating
different code.  It may even be the case that a new feature introduces new
incompatible syntax (such as a new reserved word), in which case the compiler
may need to parse the module differently.  Such decisions cannot be pushed off
until runtime.
For any given release, the compiler knows which feature names have been defined,
and raises a compile-time error if a future statement contains a feature not
known to it.
The direct runtime semantics are the same as for any import statement: there is
a standard module , described later, and it will be imported in
the usual way at the time the future statement is executed.
The interesting runtime semantics depend on the specific feature enabled by the
future statement.
Note that there is nothing special about the statement:


That is not a future statement; it’s an ordinary import statement with no
special semantics or syntax restrictions.
Code compiled by calls to the built-in functions  and 
that occur in a module  containing a future statement will, by default,
use the new syntax or semantics associated with the future statement.  This can
be controlled by optional arguments to  — see the documentation
of that function for details.
A future statement typed at an interactive interpreter prompt will take effect
for the rest of the interpreter session.  If an interpreter is started with the
 option, is passed a script name to execute, and the script includes
a future statement, it will be in effect in the interactive session started
after the script is executed.

See also

PEP 236 - Back to the __future__
The original proposal for the __future__ mechanism.


