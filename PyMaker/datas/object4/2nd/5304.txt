link:
library/ssl.html#manual-settings

docs:

Manual settings¶

Verifying certificates¶
When calling the  constructor directly,
 is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you’re talking to.
Therefore, when in client mode, it is highly recommended to use
.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the  function can be used.  This common
check is automatically performed when  is
enabled.

Changed in version 3.7: Hostname matchings is now performed by OpenSSL. Python no longer uses
.

In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you’ll also have
to specify  and similarly check the client certificate.


Protocol versions¶
SSL versions 2 and 3 are considered insecure and are therefore dangerous to
use.  If you want maximum compatibility between clients and servers, it is
recommended to use  or
 as the protocol version. SSLv2 and SSLv3 are
disabled by default.


The SSL context created above will only allow TLSv1.2 and later (if
supported by your system) connections to a server. 
implies certificate validation and hostname checks by default. You have to
load certificates into the context.


Cipher selection¶
If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
 method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL’s documentation
about the cipher list format.
If you want to check which ciphers are enabled by a given cipher list, use
 or the  command on your
system.

