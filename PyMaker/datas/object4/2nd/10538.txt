link:
library/optparse.html#reference-guide

docs:

Reference Guide¶

Creating the parser¶
The first step in using  is to create an OptionParser instance.


class (...)¶
The OptionParser constructor has no required arguments, but a number of
optional keyword arguments.  You should always pass them as keyword
arguments, i.e. do not rely on the order in which the arguments are declared.

 (default: )
The usage summary to print when your program is run incorrectly or with a
help option.  When  prints the usage string, it expands
 to  (or to  if you
passed that keyword argument).  To suppress a usage message, pass the
special value .
 (default: )
A list of Option objects to populate the parser with.  The options in
 are added after any options in  (a
class attribute that may be set by OptionParser subclasses), but before
any version or help options. Deprecated; use  after
creating the parser instead.
 (default: optparse.Option)
Class to use when adding options to the parser in .
 (default: )
A version string to print when the user supplies a version option. If you
supply a true value for ,  automatically adds a
version option with the single option string .  The
substring  is expanded the same as for .
 (default: )
Specifies what to do when options with conflicting option strings are
added to the parser; see section
Conflicts between options.
 (default: )
A paragraph of text giving a brief overview of your program.
 reformats this paragraph to fit the current terminal width
and prints it when the user requests help (after , but before the
list of options).
 (default: a new )
An instance of optparse.HelpFormatter that will be used for printing help
text.   provides two concrete classes for this purpose:
IndentedHelpFormatter and TitledHelpFormatter.
 (default: )
If true,  will add a help option (with option strings 
and ) to the parser.

The string to use when expanding  in  and 
instead of .
 (default: )
A paragraph of help text to print after the option help.




Populating the parser¶
There are several ways to populate the parser with options.  The preferred way
is by using , as shown in section
Tutorial.   can be called in one of two ways:

pass it an Option instance (as returned by )
pass it any combination of positional and keyword arguments that are
acceptable to  (i.e., to the Option constructor), and it
will create the Option instance for you

The other alternative is to pass a list of pre-constructed Option instances to
the OptionParser constructor, as in:


( is a factory function for creating Option instances;
currently it is an alias for the Option constructor.  A future version of
 may split Option into several classes, and 
will pick the right class to instantiate.  Do not instantiate Option directly.)


Defining options¶
Each Option instance represents a set of synonymous command-line option strings,
e.g.  and .  You can specify any number of short or
long option strings, but you must specify at least one overall option string.
The canonical way to create an  instance is with the
 method of .


(option)¶

(*opt_str, attr=value, ...)
To define an option with only a short option string:


And to define an option with only a long option string:


The keyword arguments define attributes of the new Option object.  The most
important option attribute is , and it largely
determines which other attributes are relevant or required.  If you pass
irrelevant option attributes, or fail to pass required ones, 
raises an  exception explaining your mistake.
An option’s action determines what  does when it encounters
this option on the command-line.  The standard option actions hard-coded into
 are:


store this option’s argument (default)

store a constant value

store a true value

store a false value

append this option’s argument to a list

append a constant value to a list

increment a counter by one

call a specified function

print a usage message including all options and the documentation for them

(If you don’t supply an action, the default is .  For this action,
you may also supply  and  option
attributes; see Standard option actions.)

As you can see, most actions involve storing or updating a value somewhere.
 always creates a special object for this, conventionally called
 (it happens to be an instance of ).  Option
arguments (and various other values) are stored as attributes of this object,
according to the  (destination) option attribute.
For example, when you call


one of the first things  does is create the  object:


If one of the options in this parser is defined with


and the command-line being parsed includes any of the following:


then , on seeing this option, will do the equivalent of


The  and  option attributes are almost
as important as , but  is the only
one that makes sense for all options.


Option attributes¶
The following option attributes may be passed as keyword arguments to
.  If you pass an option attribute that is not
relevant to a particular option, or fail to pass a required option attribute,
 raises .


¶
(default: )
Determines ’s behaviour when this option is seen on the
command line; the available options are documented here.



¶
(default: )
The argument type expected by this option (e.g.,  or );
the available option types are documented here.



¶
(default: derived from option strings)
If the option’s action implies writing or modifying a value somewhere, this
tells  where to write it:  names an
attribute of the  object that  builds as it parses
the command line.



¶
The value to use for this option’s destination if the option is not seen on
the command line.  See also .



¶
(default: 1)
How many arguments of type  should be consumed when this
option is seen.  If > 1,  will store a tuple of values to
.



¶
For actions that store a constant value, the constant value to store.



¶
For options of type , the list of strings the user may choose
from.



¶
For options with action , the callable to call when this option
is seen.  See section Option Callbacks for detail on the
arguments passed to the callable.



¶

¶
Additional positional and keyword arguments to pass to  after the
four standard callback arguments.



¶
Help text to print for this option when listing all available options after
the user supplies a  option (such as ).  If
no help text is supplied, the option will be listed without help text.  To
hide this option, use the special value .



¶
(default: derived from option strings)
Stand-in for the option argument(s) to use when printing help text.  See
section Tutorial for an example.



Standard option actions¶
The various option actions all have slightly different requirements and effects.
Most actions have several relevant option attributes which you may specify to
guide ’s behaviour; a few have required attributes, which you
must specify for any option using that action.

 [relevant: , ,
, ]
The option must be followed by an argument, which is converted to a value
according to  and stored in .  If
 > 1, multiple arguments will be consumed from the
command line; all will be converted according to  and
stored to  as a tuple.  See the
Standard option types section.
If  is supplied (a list or tuple of strings), the type
defaults to .
If  is not supplied, it defaults to .
If  is not supplied,  derives a destination
from the first long option string (e.g.,  implies
). If there are no long option strings,  derives a
destination from the first short option string (e.g.,  implies ).
Example:


As it parses the command line


 will set



 [required: ; relevant:
]
The value  is stored in .
Example:


If  is seen,  will set



 [relevant: ]
A special case of  that stores a true value to
.

 [relevant: ]
Like , but stores a false value.
Example:



 [relevant: , ,
, ]
The option must be followed by an argument, which is appended to the list in
.  If no default value for  is
supplied, an empty list is automatically created when  first
encounters this option on the command-line.  If  > 1,
multiple arguments are consumed, and a tuple of length 
is appended to .
The defaults for  and  are the same as
for the  action.
Example:


If  is seen on the command-line,  does the equivalent
of:


If, a little later on,  is seen, it does:


The  action calls the  method on the current value of the
option.  This means that any default value specified must have an 
method.  It also means that if the default value is non-empty, the default
elements will be present in the parsed value for the option, with any values
from the command line appended after those default values:



 [required: ; relevant:
]
Like , but the value  is appended to
; as with ,  defaults to
, and an empty list is automatically created the first time the option
is encountered.

 [relevant: ]
Increment the integer stored at .  If no default value is
supplied,  is set to zero before being incremented the
first time.
Example:


The first time  is seen on the command line,  does the
equivalent of:


Every subsequent occurrence of  results in



 [required: ; relevant:
, , ,
]
Call the function specified by , which is called as


See section Option Callbacks for more detail.


Prints a complete help message for all the options in the current option
parser.  The help message is constructed from the  string passed to
OptionParser’s constructor and the  string passed to every
option.
If no  string is supplied for an option, it will still be
listed in the help message.  To omit an option entirely, use the special value
.
 automatically adds a  option to all
OptionParsers, so you do not normally need to create one.
Example:


If  sees either  or  on the command line,
it will print something like the following help message to stdout (assuming
 is ):


After printing the help message,  terminates your process with
.


Prints the version number supplied to the OptionParser to stdout and exits.
The version number is actually formatted and printed by the
 method of OptionParser.  Generally only relevant if the
 argument is supplied to the OptionParser constructor.  As with
 options, you will rarely create  options,
since  automatically adds them when needed.




Standard option types¶
 has five built-in option types: , ,
,  and .  If you need to add new
option types, see section Extending optparse.
Arguments to string options are not checked or converted in any way: the text on
the command line is stored in the destination (or passed to the callback) as-is.
Integer arguments (type ) are parsed as follows:

if the number starts with , it is parsed as a hexadecimal number
if the number starts with , it is parsed as an octal number
if the number starts with , it is parsed as a binary number
otherwise, the number is parsed as a decimal number

The conversion is done by calling  with the appropriate base (2, 8,
10, or 16).  If this fails, so will , although with a more useful
error message.
 and  option arguments are converted directly with
 and , with similar error-handling.
 options are a subtype of  options.  The
 option attribute (a sequence of strings) defines the
set of allowed option arguments.   compares
user-supplied option arguments against this master list and raises
 if an invalid string is given.


Parsing arguments¶
The whole point of creating and populating an OptionParser is to call its
 method:


where the input parameters are


the list of arguments to process (default: )

an  object to store option arguments in (default: a
new instance of ) – if you give an existing object, the
option defaults will not be initialized on it

and the return values are


the same object that was passed in as , or the optparse.Values
instance created by 

the leftover positional arguments after all options have been processed

The most common usage is to supply neither keyword argument.  If you supply
, it will be modified with repeated  calls (roughly one
for every option argument stored to an option destination) and returned by
.
If  encounters any errors in the argument list, it calls the
OptionParser’s  method with an appropriate end-user error message.
This ultimately terminates your process with an exit status of 2 (the
traditional Unix exit status for command-line errors).


Querying and manipulating your option parser¶
The default behavior of the option parser can be customized slightly, and you
can also poke around your option parser and see what’s there.  OptionParser
provides several methods to help you out:


()¶
Set parsing to stop on the first non-option.  For example, if  and
 are both simple options that take no arguments, 
normally accepts this syntax:


and treats it as equivalent to


To disable this feature, call .  This
restores traditional Unix syntax, where option parsing stops with the first
non-option argument.
Use this if you have a command processor which runs another command which has
options of its own and you want to make sure these options don’t get
confused.  For example, each command might have a different set of options.



()¶
Set parsing to not stop on the first non-option, allowing interspersing
switches with command arguments.  This is the default behavior.



(opt_str)¶
Returns the Option instance with the option string opt_str, or  if
no options have that option string.



(opt_str)¶
Return true if the OptionParser has an option with option string opt_str
(e.g.,  or ).



(opt_str)¶
If the  has an option corresponding to opt_str, that
option is removed.  If that option provided any other option strings, all of
those option strings become invalid. If opt_str does not occur in any
option belonging to this , raises .



Conflicts between options¶
If you’re not careful, it’s easy to define options with conflicting option
strings:


(This is particularly true if you’ve defined your own OptionParser subclass with
some standard options.)
Every time you add an option,  checks for conflicts with existing
options.  If it finds any, it invokes the current conflict-handling mechanism.
You can set the conflict-handling mechanism either in the constructor:


or with a separate call:


The available conflict handlers are:


 (default)
assume option conflicts are a programming error and raise


resolve option conflicts intelligently (see below)


As an example, let’s define an  that resolves conflicts
intelligently and add conflicting options to it:


At this point,  detects that a previously-added option is already
using the  option string.  Since  is ,
it resolves the situation by removing  from the earlier option’s list of
option strings.  Now  is the only way for the user to activate
that option.  If the user asks for help, the help message will reflect that:


It’s possible to whittle away the option strings for a previously-added option
until there are none left, and the user has no way of invoking that option from
the command-line.  In that case,  removes that option completely,
so it doesn’t show up in help text or anywhere else. Carrying on with our
existing OptionParser:


At this point, the original / option is no longer
accessible, so  removes it, leaving this help text:




Cleanup¶
OptionParser instances have several cyclic references.  This should not be a
problem for Python’s garbage collector, but you may wish to break the cyclic
references explicitly by calling  on your
OptionParser once you are done with it.  This is particularly useful in
long-running applications where large object graphs are reachable from your
OptionParser.


Other methods¶
OptionParser supports several other public methods:


(usage)¶
Set the usage string according to the rules described above for the 
constructor keyword argument.  Passing  sets the default usage
string; use  to suppress a usage message.



(file=None)¶
Print the usage message for the current program () to file
(default stdout).  Any occurrence of the string  in 
is replaced with the name of the current program.  Does nothing if
 is empty or not defined.



()¶
Same as  but returns the usage string instead of
printing it.



(dest=value, ...)¶
Set default values for several option destinations at once.  Using
 is the preferred way to set default values for options,
since multiple options can share the same destination.  For example, if
several “mode” options all set the same destination, any one of them can set
the default, and the last one wins:


To avoid this confusion, use :




