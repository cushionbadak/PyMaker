link:
library/difflib.html#sequencematcher-objects

docs:

SequenceMatcher Objects¶
The  class has this constructor:


class (isjunk=None, a='', b='', autojunk=True)
Optional argument isjunk must be  (the default) or a one-argument
function that takes a sequence element and returns true if and only if the
element is “junk” and should be ignored. Passing  for isjunk is
equivalent to passing ; in other words, no elements are ignored.
For example, pass:


if you’re comparing lines as sequences of characters, and don’t want to synch up
on blanks or hard tabs.
The optional arguments a and b are sequences to be compared; both default to
empty strings.  The elements of both sequences must be hashable.
The optional argument autojunk can be used to disable the automatic junk
heuristic.

New in version 3.2: The autojunk parameter.

SequenceMatcher objects get three data attributes: bjunk is the
set of elements of b for which isjunk is ; bpopular is the set of
non-junk elements considered popular by the heuristic (if it is not
disabled); b2j is a dict mapping the remaining elements of b to a list
of positions where they occur. All three are reset whenever b is reset
with  or .

New in version 3.2: The bjunk and bpopular attributes.

 objects have the following methods:


(a, b)¶
Set the two sequences to be compared.

 computes and caches detailed information about the
second sequence, so if you want to compare one sequence against many
sequences, use  to set the commonly used sequence once and
call  repeatedly, once for each of the other sequences.


(a)¶
Set the first sequence to be compared.  The second sequence to be compared
is not changed.



(b)¶
Set the second sequence to be compared.  The first sequence to be compared
is not changed.



(alo, ahi, blo, bhi)¶
Find longest matching block in  and .
If isjunk was omitted or ,  returns
 such that  is equal to , where  and . For all  meeting those conditions, the additional conditions , , and if ,  are also met. In other words, of
all maximal matching blocks, return one that starts earliest in a, and
of all those maximal matching blocks that start earliest in a, return
the one that starts earliest in b.


If isjunk was provided, first the longest matching block is determined
as above, but with the additional restriction that no junk element appears
in the block.  Then that block is extended as far as possible by matching
(only) junk elements on both sides. So the resulting block never matches
on junk except as identical junk happens to be adjacent to an interesting
match.
Here’s the same example as before, but considering blanks to be junk. That
prevents  from matching the  at the tail end of the
second sequence directly.  Instead only the  can match, and
matches the leftmost  in the second sequence:


If no blocks match, this returns .
This method returns a named tuple .



()¶
Return list of triples describing non-overlapping matching subsequences.
Each triple is of the form ,
and means that .  The
triples are monotonically increasing in i and j.
The last triple is a dummy, and has the value .  It
is the only triple with .  If  and 
are adjacent triples in the list, and the second is not the last triple in
the list, then  or ; in other words, adjacent
triples always describe non-adjacent equal blocks.





()¶
Return list of 5-tuples describing how to turn a into b. Each tuple is
of the form .  The first tuple has , and remaining tuples have i1 equal to the i2 from the preceding
tuple, and, likewise, j1 equal to the previous j2.
The tag values are strings, with these meanings:






Value
Meaning




 should be replaced by
.


 should be deleted.  Note that
 in this case.


 should be inserted at
. Note that  in
this case.


 (the sub-sequences
are equal).



For example:





(n=3)¶
Return a generator of groups with up to n lines of context.
Starting with the groups returned by , this method
splits out smaller change clusters and eliminates intervening ranges which
have no changes.
The groups are returned in the same format as .



()¶
Return a measure of the sequences’ similarity as a float in the range [0,
1].
Where T is the total number of elements in both sequences, and M is the
number of matches, this is 2.0*M / T. Note that this is  if the
sequences are identical, and  if they have nothing in common.
This is expensive to compute if  or
 hasn’t already been called, in which case you may want
to try  or  first to get an
upper bound.



()¶
Return an upper bound on  relatively quickly.



()¶
Return an upper bound on  very quickly.


The three methods that return the ratio of matching to total characters can give
different results due to differing levels of approximation, although
 and  are always at least as large as
:


