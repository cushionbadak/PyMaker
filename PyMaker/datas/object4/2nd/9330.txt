link:
library/contextlib.html#module-contextlib

docs:

 — Utilities for -statement contexts¶
Source code: Lib/contextlib.py

This module provides utilities for common tasks involving the 
statement. For more information see also Context Manager Types and
With Statement Context Managers.

Utilities¶
Functions and classes provided:


class ¶
An abstract base class for classes that implement
 and . A default
implementation for  is provided which returns
 while  is an abstract method which by default
returns . See also the definition of Context Manager Types.

New in version 3.6.




class ¶
An abstract base class for classes that implement
 and . A default
implementation for  is provided which returns
 while  is an abstract method which by default
returns . See also the definition of
Asynchronous Context Managers.

New in version 3.7.




¶
This function is a decorator that can be used to define a factory
function for  statement context managers, without needing to
create a class or separate  and  methods.
While many objects natively support use in with statements, sometimes a
resource needs to be managed that isn’t a context manager in its own right,
and doesn’t implement a  method for use with 
An abstract example would be the following to ensure correct resource
management:


The function being decorated must return a generator-iterator when
called. This iterator must yield exactly one value, which will be bound to
the targets in the  statement’s  clause, if any.
At the point where the generator yields, the block nested in the 
statement is executed.  The generator is then resumed after the block is exited.
If an unhandled exception occurs in the block, it is reraised inside the
generator at the point where the yield occurred.  Thus, you can use a
…… statement to trap
the error (if any), or ensure that some cleanup takes place. If an exception is
trapped merely in order to log it or to perform some action (rather than to
suppress it entirely), the generator must reraise that exception. Otherwise the
generator context manager will indicate to the  statement that
the exception has been handled, and execution will resume with the statement
immediately following the  statement.
 uses  so the context managers
it creates can be used as decorators as well as in  statements.
When used as a decorator, a new generator instance is implicitly created on
each function call (this allows the otherwise “one-shot” context managers
created by  to meet the requirement that context
managers support multiple invocations in order to be used as decorators).

Changed in version 3.2: Use of .




¶
Similar to , but creates an
asynchronous context manager.
This function is a decorator that can be used to define a factory
function for  statement asynchronous context managers,
without needing to create a class or separate  and
 methods. It must be applied to an asynchronous
generator function.
A simple example:



New in version 3.7.




(thing)¶
Return a context manager that closes thing upon completion of the block.  This
is basically equivalent to:


And lets you write code like this:


without needing to explicitly close .  Even if an error occurs,
 will be called when the  block is exited.



(enter_result=None)¶
Return a context manager that returns enter_result from , but
otherwise does nothing. It is intended to be used as a stand-in for an
optional context manager, for example:


An example using enter_result:



New in version 3.7.




(*exceptions)¶
Return a context manager that suppresses any of the specified exceptions
if they occur in the body of a with statement and then resumes execution
with the first statement following the end of the with statement.
As with any other mechanism that completely suppresses exceptions, this
context manager should be used only to cover very specific errors where
silently continuing with program execution is known to be the right
thing to do.
For example:


This code is equivalent to:


This context manager is reentrant.

New in version 3.4.




(new_target)¶
Context manager for temporarily redirecting  to
another file or file-like object.
This tool adds flexibility to existing functions or classes whose output
is hardwired to stdout.
For example, the output of  normally is sent to sys.stdout.
You can capture that output in a string by redirecting the output to an
 object:


To send the output of  to a file on disk, redirect the output
to a regular file:


To send the output of  to sys.stderr:


Note that the global side effect on  means that this
context manager is not suitable for use in library code and most threaded
applications. It also has no effect on the output of subprocesses.
However, it is still a useful approach for many utility scripts.
This context manager is reentrant.

New in version 3.4.




(new_target)¶
Similar to  but redirecting
 to another file or file-like object.
This context manager is reentrant.

New in version 3.5.




class ¶
A base class that enables a context manager to also be used as a decorator.
Context managers inheriting from  have to implement
 and  as normal.  retains its optional
exception handling even when used as a decorator.
 is used by , so you get this
functionality automatically.
Example of :


This change is just syntactic sugar for any construct of the following form:


 lets you instead write:


It makes it clear that the  applies to the whole function, rather than
just a piece of it (and saving an indentation level is nice, too).
Existing context managers that already have a base class can be extended by
using  as a mixin class:



Note
As the decorated function must be able to be called multiple times, the
underlying context manager must support use in multiple 
statements. If this is not the case, then the original construct with the
explicit  statement inside the function should be used.


New in version 3.2.




class ¶
A context manager that is designed to make it easy to programmatically
combine other context managers and cleanup functions, especially those
that are optional or otherwise driven by input data.
For example, a set of files may easily be handled in a single with
statement as follows:


Each instance maintains a stack of registered callbacks that are called in
reverse order when the instance is closed (either explicitly or implicitly
at the end of a  statement). Note that callbacks are not
invoked implicitly when the context stack instance is garbage collected.
This stack model is used so that context managers that acquire their
resources in their  method (such as file objects) can be
handled correctly.
Since registered callbacks are invoked in the reverse order of
registration, this ends up behaving as if multiple nested 
statements had been used with the registered set of callbacks. This even
extends to exception handling - if an inner callback suppresses or replaces
an exception, then outer callbacks will be passed arguments based on that
updated state.
This is a relatively low level API that takes care of the details of
correctly unwinding the stack of exit callbacks. It provides a suitable
foundation for higher level context managers that manipulate the exit
stack in application specific ways.

New in version 3.3.



(cm)¶
Enters a new context manager and adds its  method to
the callback stack. The return value is the result of the context
manager’s own  method.
These context managers may suppress exceptions just as they normally
would if used directly as part of a  statement.



(exit)¶
Adds a context manager’s  method to the callback stack.
As  is not invoked, this method can be used to cover
part of an  implementation with a context manager’s own
 method.
If passed an object that is not a context manager, this method assumes
it is a callback with the same signature as a context manager’s
 method and adds it directly to the callback stack.
By returning true values, these callbacks can suppress exceptions the
same way context manager  methods can.
The passed in object is returned from the function, allowing this
method to be used as a function decorator.



(callback, *args, **kwds)¶
Accepts an arbitrary callback function and arguments and adds it to
the callback stack.
Unlike the other methods, callbacks added this way cannot suppress
exceptions (as they are never passed the exception details).
The passed in callback is returned from the function, allowing this
method to be used as a function decorator.



()¶
Transfers the callback stack to a fresh  instance
and returns it. No callbacks are invoked by this operation - instead,
they will now be invoked when the new stack is closed (either
explicitly or implicitly at the end of a  statement).
For example, a group of files can be opened as an “all or nothing”
operation as follows:





()¶
Immediately unwinds the callback stack, invoking callbacks in the
reverse order of registration. For any context managers and exit
callbacks registered, the arguments passed in will indicate that no
exception occurred.




class ¶
An asynchronous context manager, similar
to , that supports combining both synchronous and
asynchronous context managers, as well as having coroutines for
cleanup logic.
The  method is not implemented,  must be used
instead.


(cm)¶
Similar to  but expects an asynchronous context
manager.



(exit)¶
Similar to  but expects either an asynchronous context manager
or a coroutine function.



(callback, *args, **kwds)¶
Similar to  but expects a coroutine function.



()¶
Similar to  but properly handles awaitables.

Continuing the example for :



New in version 3.7.




Examples and Recipes¶
This section describes some examples and recipes for making effective use of
the tools provided by .

Supporting a variable number of context managers¶
The primary use case for  is the one given in the class
documentation: supporting a variable number of context managers and other
cleanup operations in a single  statement. The variability
may come from the number of context managers needed being driven by user
input (such as opening a user specified collection of files), or from
some of the context managers being optional:


As shown,  also makes it quite easy to use 
statements to manage arbitrary resources that don’t natively support the
context management protocol.


Catching exceptions from  methods¶
It is occasionally desirable to catch exceptions from an 
method implementation, without inadvertently catching exceptions from
the  statement body or the context manager’s 
method. By using  the steps in the context management
protocol can be separated slightly in order to allow this:


Actually needing to do this is likely to indicate that the underlying API
should be providing a direct resource management interface for use with
// statements, but not
all APIs are well designed in that regard. When a context manager is the
only resource management API provided, then  can make it
easier to handle various situations that can’t be handled directly in a
 statement.


Cleaning up in an  implementation¶
As noted in the documentation of , this
method can be useful in cleaning up an already allocated resource if later
steps in the  implementation fail.
Here’s an example of doing this for a context manager that accepts resource
acquisition and release functions, along with an optional validation function,
and maps them to the context management protocol:




Replacing any use of  and flag variables¶
A pattern you will sometimes see is a  statement with a flag
variable to indicate whether or not the body of the  clause should
be executed. In its simplest form (that can’t already be handled just by
using an  clause instead), it looks something like this:


As with any  statement based code, this can cause problems for
development and review, because the setup code and the cleanup code can end
up being separated by arbitrarily long sections of code.
 makes it possible to instead register a callback for
execution at the end of a  statement, and then later decide to skip
executing that callback:


This allows the intended cleanup up behaviour to be made explicit up front,
rather than requiring a separate flag variable.
If a particular application uses this pattern a lot, it can be simplified
even further by means of a small helper class:


If the resource cleanup isn’t already neatly bundled into a standalone
function, then it is still possible to use the decorator form of
 to declare the resource cleanup in
advance:


Due to the way the decorator protocol works, a callback function
declared this way cannot take any parameters. Instead, any resources to
be released must be accessed as closure variables.


Using a context manager as a function decorator¶
 makes it possible to use a context manager in
both an ordinary  statement and also as a function decorator.
For example, it is sometimes useful to wrap functions or groups of statements
with a logger that can track the time of entry and time of exit.  Rather than
writing both a function decorator and a context manager for the task,
inheriting from  provides both capabilities in a
single definition:


Instances of this class can be used as both a context manager:


And also as a function decorator:


Note that there is one additional limitation when using context managers
as function decorators: there’s no way to access the return value of
. If that value is needed, then it is still necessary to use
an explicit  statement.

See also

PEP 343 - The “with” statement
The specification, background, and examples for the Python 
statement.





Single use, reusable and reentrant context managers¶
Most context managers are written in a way that means they can only be
used effectively in a  statement once. These single use
context managers must be created afresh each time they’re used -
attempting to use them a second time will trigger an exception or
otherwise not work correctly.
This common limitation means that it is generally advisable to create
context managers directly in the header of the  statement
where they are used (as shown in all of the usage examples above).
Files are an example of effectively single use context managers, since
the first  statement will close the file, preventing any
further IO operations using that file object.
Context managers created using  are also single use
context managers, and will complain about the underlying generator failing
to yield if an attempt is made to use them a second time:



Reentrant context managers¶
More sophisticated context managers may be “reentrant”. These context
managers can not only be used in multiple  statements,
but may also be used inside a  statement that is already
using the same context manager.
 is an example of a reentrant context manager, as are
 and . Here’s a very simple example of
reentrant use:


Real world examples of reentrancy are more likely to involve multiple
functions calling each other and hence be far more complicated than this
example.
Note also that being reentrant is not the same thing as being thread safe.
, for example, is definitely not thread safe, as it
makes a global modification to the system state by binding 
to a different stream.


Reusable context managers¶
Distinct from both single use and reentrant context managers are “reusable”
context managers (or, to be completely explicit, “reusable, but not
reentrant” context managers, since reentrant context managers are also
reusable). These context managers support being used multiple times, but
will fail (or otherwise not work correctly) if the specific context manager
instance has already been used in a containing with statement.
 is an example of a reusable, but not reentrant,
context manager (for a reentrant lock, it is necessary to use
 instead).
Another example of a reusable, but not reentrant, context manager is
, as it invokes all currently registered callbacks
when leaving any with statement, regardless of where those callbacks
were added:


As the output from the example shows, reusing a single stack object across
multiple with statements works correctly, but attempting to nest them
will cause the stack to be cleared at the end of the innermost with
statement, which is unlikely to be desirable behaviour.
Using separate  instances instead of reusing a single
instance avoids that problem:




