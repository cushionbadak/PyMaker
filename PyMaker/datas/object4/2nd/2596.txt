link:
library/tarfile.html#module-tarfile

docs:

 — Read and write tar archive files¶
Source code: Lib/tarfile.py

The  module makes it possible to read and write tar
archives, including those using gzip, bz2 and lzma compression.
Use the  module to read or write  files, or the
higher-level functions in shutil.
Some facts and figures:

reads and writes ,  and  compressed archives
if the respective modules are available.
read/write support for the POSIX.1-1988 (ustar) format.
read/write support for the GNU tar format including longname and longlink
extensions, read-only support for all variants of the sparse extension
including restoration of sparse files.
read/write support for the POSIX.1-2001 (pax) format.
handles directories, regular files, hardlinks, symbolic links, fifos,
character devices and block devices and is able to acquire and restore file
information like timestamp, access permissions and owner.


Changed in version 3.3: Added support for  compression.



(name=None, mode='r', fileobj=None, bufsize=10240, **kwargs)¶
Return a  object for the pathname name. For detailed
information on  objects and the keyword arguments that are
allowed, see TarFile Objects.
mode has to be a string of the form , it defaults
to . Here is a full list of mode combinations:






mode
action




Open for reading with transparent
compression (recommended).


Open for reading exclusively without
compression.


Open for reading with gzip compression.


Open for reading with bzip2 compression.


Open for reading with lzma compression.

 or

Create a tarfile exclusively without
compression.
Raise an  exception
if it already exists.


Create a tarfile with gzip compression.
Raise an  exception
if it already exists.


Create a tarfile with bzip2 compression.
Raise an  exception
if it already exists.


Create a tarfile with lzma compression.
Raise an  exception
if it already exists.


Open for appending with no compression. The
file is created if it does not exist.


Open for uncompressed writing.


Open for gzip compressed writing.


Open for bzip2 compressed writing.


Open for lzma compressed writing.



Note that ,  or  is not possible. If mode
is not suitable to open a certain (compressed) file for reading,
 is raised. Use mode  to avoid this.  If a
compression method is not supported,  is raised.
If fileobj is specified, it is used as an alternative to a file object
opened in binary mode for name. It is supposed to be at position 0.
For modes , , , , ,
,  accepts the keyword argument
compresslevel (default ) to specify the compression level of the file.
For special purposes, there is a second format for mode:
.   will return a 
object that processes its data as a stream of blocks.  No random seeking will
be done on the file. If given, fileobj may be any object that has a
 or  method (depending on the mode). bufsize
specifies the blocksize and defaults to  bytes. Use this variant
in combination with e.g. , a socket file object or a tape
device. However, such a  object is limited in that it does
not allow random access, see Examples.  The currently
possible modes:






Mode
Action




Open a stream of tar blocks for reading
with transparent compression.


Open a stream of uncompressed tar blocks
for reading.


Open a gzip compressed stream for
reading.


Open a bzip2 compressed stream for
reading.


Open an lzma compressed stream for
reading.


Open an uncompressed stream for writing.


Open a gzip compressed stream for
writing.


Open a bzip2 compressed stream for
writing.


Open an lzma compressed stream for
writing.




Changed in version 3.5: The  (exclusive creation) mode was added.


Changed in version 3.6: The name parameter accepts a path-like object.




class ¶
Class for reading and writing tar archives. Do not use this class directly:
use  instead. See TarFile Objects.



(name)¶
Return  if name is a tar archive file, that the 
module can read.

The  module defines the following exceptions:


exception ¶
Base class for all  exceptions.



exception ¶
Is raised when a tar archive is opened, that either cannot be handled by the
 module or is somehow invalid.



exception ¶
Is raised when a compression method is not supported or when the data cannot be
decoded properly.



exception ¶
Is raised for the limitations that are typical for stream-like 
objects.



exception ¶
Is raised for non-fatal errors when using , but only if
.



exception ¶
Is raised by  if the buffer it gets is invalid.

The following constants are available at the module level:


¶
The default character encoding:  on Windows, the value returned by
 otherwise.

Each of the following constants defines a tar archive format that the
 module is able to create. See section Supported tar formats for
details.


¶
POSIX.1-1988 (ustar) format.



¶
GNU tar format.



¶
POSIX.1-2001 (pax) format.



¶
The default format for creating archives. This is currently .


See also

Module 
Documentation of the  standard module.
Archiving operations
Documentation of the higher-level archiving facilities provided by the
standard  module.
GNU tar manual, Basic Tar Format
Documentation for tar archive files, including GNU tar extensions.



TarFile Objects¶
The  object provides an interface to a tar archive. A tar
archive is a sequence of blocks. An archive member (a stored file) is made up of
a header block followed by data blocks. It is possible to store a file in a tar
archive several times. Each archive member is represented by a 
object, see TarInfo Objects for details.
A  object can be used as a context manager in a 
statement. It will automatically be closed when the block is completed. Please
note that in the event of an exception an archive opened for writing will not
be finalized; only the internally used file object will be closed. See the
Examples section for a use case.

New in version 3.2: Added support for the context management protocol.



class (name=None, mode='r', fileobj=None, format=DEFAULT_FORMAT, tarinfo=TarInfo, dereference=False, ignore_zeros=False, encoding=ENCODING, errors='surrogateescape', pax_headers=None, debug=0, errorlevel=0)
All following arguments are optional and can be accessed as instance attributes
as well.
name is the pathname of the archive. name may be a path-like object.
It can be omitted if fileobj is given.
In this case, the file object’s  attribute is used if it exists.
mode is either  to read from an existing archive,  to append
data to an existing file,  to create a new file overwriting an existing
one, or  to create a new file only if it does not already exist.
If fileobj is given, it is used for reading or writing data. If it can be
determined, mode is overridden by fileobj’s mode. fileobj will be used
from position 0.

Note
fileobj is not closed, when  is closed.

format controls the archive format. It must be one of the constants
,  or  that are
defined at module level.
The tarinfo argument can be used to replace the default  class
with a different one.
If dereference is , add symbolic and hard links to the archive. If it
is , add the content of the target files to the archive. This has no
effect on systems that do not support symbolic links.
If ignore_zeros is , treat an empty block as the end of the archive.
If it is , skip empty (and invalid) blocks and try to get as many members
as possible. This is only useful for reading concatenated or damaged archives.
debug can be set from  (no debug messages) up to  (all debug
messages). The messages are written to .
If errorlevel is , all errors are ignored when using .
Nevertheless, they appear as error messages in the debug output, when debugging
is enabled.  If , all fatal errors are raised as 
exceptions. If , all non-fatal errors are raised as 
exceptions as well.
The encoding and errors arguments define the character encoding to be
used for reading or writing the archive and how conversion errors are going
to be handled. The default settings will work for most users.
See section Unicode issues for in-depth information.
The pax_headers argument is an optional dictionary of strings which
will be added as a pax global header if format is .

Changed in version 3.2: Use  as the default for the errors argument.


Changed in version 3.5: The  (exclusive creation) mode was added.


Changed in version 3.6: The name parameter accepts a path-like object.




classmethod (...)¶
Alternative constructor. The  function is actually a
shortcut to this classmethod.



(name)¶
Return a  object for member name. If name can not be found
in the archive,  is raised.

Note
If a member occurs more than once in the archive, its last occurrence is assumed
to be the most up-to-date version.




()¶
Return the members of the archive as a list of  objects. The
list has the same order as the members in the archive.



()¶
Return the members as a list of their names. It has the same order as the list
returned by .



(verbose=True, *, members=None)¶
Print a table of contents to . If verbose is ,
only the names of the members are printed. If it is , output
similar to that of ls -l is produced. If optional members is
given, it must be a subset of the list returned by .

Changed in version 3.5: Added the members parameter.




()¶
Return the next member of the archive as a  object, when
 is opened for reading. Return  if there is no more
available.



(path=".", members=None, *, numeric_owner=False)¶
Extract all members from the archive to the current working directory or
directory path. If optional members is given, it must be a subset of the
list returned by . Directory information like owner,
modification time and permissions are set after all members have been extracted.
This is done to work around two problems: A directory’s modification time is
reset each time a file is created in it. And, if a directory’s permissions do
not allow writing, extracting files to it will fail.
If numeric_owner is , the uid and gid numbers from the tarfile
are used to set the owner/group for the extracted files. Otherwise, the named
values from the tarfile are used.

Warning
Never extract archives from untrusted sources without prior inspection.
It is possible that files are created outside of path, e.g. members
that have absolute filenames starting with  or filenames with two
dots .


Changed in version 3.5: Added the numeric_owner parameter.


Changed in version 3.6: The path parameter accepts a path-like object.




(member, path="", set_attrs=True, *, numeric_owner=False)¶
Extract a member from the archive to the current working directory, using its
full name. Its file information is extracted as accurately as possible. member
may be a filename or a  object. You can specify a different
directory using path. path may be a path-like object.
File attributes (owner, mtime, mode) are set unless set_attrs is false.
If numeric_owner is , the uid and gid numbers from the tarfile
are used to set the owner/group for the extracted files. Otherwise, the named
values from the tarfile are used.

Note
The  method does not take care of several extraction issues.
In most cases you should consider using the  method.


Warning
See the warning for .


Changed in version 3.2: Added the set_attrs parameter.


Changed in version 3.5: Added the numeric_owner parameter.


Changed in version 3.6: The path parameter accepts a path-like object.




(member)¶
Extract a member from the archive as a file object. member may be a filename
or a  object. If member is a regular file or a link, an
 object is returned. Otherwise,  is
returned.

Changed in version 3.3: Return an  object.




(name, arcname=None, recursive=True, *, filter=None)¶
Add the file name to the archive. name may be any type of file
(directory, fifo, symbolic link, etc.). If given, arcname specifies an
alternative name for the file in the archive. Directories are added
recursively by default. This can be avoided by setting recursive to
. Recursion adds entries in sorted order.
If filter is given, it
should be a function that takes a  object argument and
returns the changed  object. If it instead returns
 the  object will be excluded from the
archive. See Examples for an example.

Changed in version 3.2: Added the filter parameter.


Changed in version 3.7: Recursion adds entries in sorted order.




(tarinfo, fileobj=None)¶
Add the  object tarinfo to the archive. If fileobj is given,
it should be a binary file, and
 bytes are read from it and added to the archive.  You can
create  objects directly, or by using .



(name=None, arcname=None, fileobj=None)¶
Create a  object from the result of  or
equivalent on an existing file.  The file is either named by name, or
specified as a file object fileobj with a file descriptor.
name may be a path-like object.  If
given, arcname specifies an alternative name for the file in the
archive, otherwise, the name is taken from fileobj’s
 attribute, or the name argument.  The name
should be a text string.
You can modify
some of the ’s attributes before you add it using .
If the file object is not an ordinary file object positioned at the
beginning of the file, attributes such as  may need
modifying.  This is the case for objects such as .
The  may also be modified, in which case arcname
could be a dummy string.

Changed in version 3.6: The name parameter accepts a path-like object.




()¶
Close the . In write mode, two finishing zero blocks are
appended to the archive.



¶
A dictionary containing key-value pairs of pax global headers.



TarInfo Objects¶
A  object represents one member in a . Aside
from storing all required attributes of a file (like file type, size, time,
permissions, owner etc.), it provides some useful methods to determine its type.
It does not contain the file’s data itself.
 objects are returned by ’s methods
,  and .


class (name="")¶
Create a  object.



classmethod (buf, encoding, errors)¶
Create and return a  object from string buffer buf.
Raises  if the buffer is invalid.



classmethod (tarfile)¶
Read the next member from the  object tarfile and return it as
a  object.



(format=DEFAULT_FORMAT, encoding=ENCODING, errors='surrogateescape')¶
Create a string buffer from a  object. For information on the
arguments see the constructor of the  class.

Changed in version 3.2: Use  as the default for the errors argument.


A  object has the following public data attributes:


¶
Name of the archive member.



¶
Size in bytes.



¶
Time of last modification.



¶
Permission bits.



¶
File type.  type is usually one of these constants: ,
, , , ,
, , , ,
.  To determine the type of a  object
more conveniently, use the  methods below.



¶
Name of the target file name, which is only present in  objects
of type  and .



¶
User ID of the user who originally stored this member.



¶
Group ID of the user who originally stored this member.



¶
User name.



¶
Group name.



¶
A dictionary containing key-value pairs of an associated pax extended header.

A  object also provides some convenient query methods:


()¶
Return  if the  object is a regular file.



()¶
Same as .



()¶
Return  if it is a directory.



()¶
Return  if it is a symbolic link.



()¶
Return  if it is a hard link.



()¶
Return  if it is a character device.



()¶
Return  if it is a block device.



()¶
Return  if it is a FIFO.



()¶
Return  if it is one of character device, block device or FIFO.



Command-Line Interface¶

New in version 3.4.

The  module provides a simple command-line interface to interact
with tar archives.
If you want to create a new tar archive, specify its name after the 
option and then list the filename(s) that should be included:


Passing a directory is also acceptable:


If you want to extract a tar archive into the current directory, use
the  option:


You can also extract a tar archive into a different directory by passing the
directory’s name:


For a list of the files in a tar archive, use the  option:



Command-line options¶


¶

¶
List files in a tarfile.



¶

¶
Create tarfile from source files.



¶

¶
Extract tarfile into the current directory if output_dir is not specified.



¶

¶
Test whether the tarfile is valid or not.



¶
Verbose output.




Examples¶
How to extract an entire tar archive to the current working directory:


How to extract a subset of a tar archive with  using
a generator function instead of a list:


How to create an uncompressed tar archive from a list of filenames:


The same example using the  statement:


How to read a gzip compressed tar archive and display some member information:


How to create an archive and reset the user information using the filter
parameter in :




Supported tar formats¶
There are three tar formats that can be created with the  module:

The POSIX.1-1988 ustar format (). It supports filenames
up to a length of at best 256 characters and linknames up to 100 characters. The
maximum file size is 8 GiB. This is an old and limited but widely
supported format.

The GNU tar format (). It supports long filenames and
linknames, files bigger than 8 GiB and sparse files. It is the de facto
standard on GNU/Linux systems.  fully supports the GNU tar
extensions for long names, sparse file support is read-only.

The POSIX.1-2001 pax format (). It is the most flexible
format with virtually no limits. It supports long filenames and linknames, large
files and stores pathnames in a portable way. However, not all tar
implementations today are able to handle pax archives properly.
The pax format is an extension to the existing ustar format. It uses extra
headers for information that cannot be stored otherwise. There are two flavours
of pax headers: Extended headers only affect the subsequent file header, global
headers are valid for the complete archive and affect all following files. All
the data in a pax header is encoded in UTF-8 for portability reasons.


There are some more variants of the tar format which can be read, but not
created:

The ancient V7 format. This is the first tar format from Unix Seventh Edition,
storing only regular files and directories. Names must not be longer than 100
characters, there is no user/group name information. Some archives have
miscalculated header checksums in case of fields with non-ASCII characters.
The SunOS tar extended format. This format is a variant of the POSIX.1-2001
pax format, but is not compatible.



Unicode issues¶
The tar format was originally conceived to make backups on tape drives with the
main focus on preserving file system information. Nowadays tar archives are
commonly used for file distribution and exchanging archives over networks. One
problem of the original format (which is the basis of all other formats) is
that there is no concept of supporting different character encodings. For
example, an ordinary tar archive created on a UTF-8 system cannot be read
correctly on a Latin-1 system if it contains non-ASCII characters. Textual
metadata (like filenames, linknames, user/group names) will appear damaged.
Unfortunately, there is no way to autodetect the encoding of an archive. The
pax format was designed to solve this problem. It stores non-ASCII metadata
using the universal character encoding UTF-8.
The details of character conversion in  are controlled by the
encoding and errors keyword arguments of the  class.
encoding defines the character encoding to use for the metadata in the
archive. The default value is  or 
as a fallback. Depending on whether the archive is read or written, the
metadata must be either decoded or encoded. If encoding is not set
appropriately, this conversion may fail.
The errors argument defines how characters are treated that cannot be
converted. Possible values are listed in section Error Handlers.
The default scheme is  which Python also uses for its
file system calls, see File Names, Command Line Arguments, and Environment Variables.
In case of  archives, encoding is generally not needed
because all the metadata is stored using UTF-8. encoding is only used in
the rare cases when binary pax headers are decoded or when strings with
surrogate characters are stored.

