link:
library/test.html#writing-unit-tests-for-the-test-package

docs:

Writing Unit Tests for the  package¶
It is preferred that tests that use the  module follow a few
guidelines. One is to name the test module by starting it with  and end
it with the name of the module being tested. The test methods in the test module
should start with  and end with a description of what the method is
testing. This is needed so that the methods are recognized by the test driver as
test methods. Also, no documentation string for the method should be included. A
comment (such as ) should be used
to provide documentation for test methods. This is done because documentation
strings get printed out if they exist and thus what test is being run is not
stated.
A basic boilerplate is often used:


This code pattern allows the testing suite to be run by ,
on its own as a script that supports the  CLI, or via the
 CLI.
The goal for regression testing is to try to break code. This leads to a few
guidelines to be followed:

The testing suite should exercise all classes, functions, and constants. This
includes not just the external API that is to be presented to the outside
world but also “private” code.

Whitebox testing (examining the code being tested when the tests are being
written) is preferred. Blackbox testing (testing only the published user
interface) is not complete enough to make sure all boundary and edge cases
are tested.

Make sure all possible values are tested including invalid ones. This makes
sure that not only all valid values are acceptable but also that improper
values are handled correctly.

Exhaust as many code paths as possible. Test where branching occurs and thus
tailor input to make sure as many different paths through the code are taken.

Add an explicit test for any bugs discovered for the tested code. This will
make sure that the error does not crop up again if the code is changed in the
future.

Make sure to clean up after your tests (such as close and remove all temporary
files).

If a test is dependent on a specific condition of the operating system then
verify the condition already exists before attempting the test.

Import as few modules as possible and do it as soon as possible. This
minimizes external dependencies of tests and also minimizes possible anomalous
behavior from side-effects of importing a module.

Try to maximize code reuse. On occasion, tests will vary by something as small
as what type of input is used. Minimize code duplication by subclassing a
basic test class with a class that specifies the input:


When using this pattern, remember that all classes that inherit from
 are run as tests.  The  class in the example above
does not have any data and so can’t be run by itself, thus it does not
inherit from .



See also

Test Driven Development
A book by Kent Beck on writing tests before code.


