link:
library/xml.etree.elementtree.html

docs:


 — The ElementTree XML API¶
Source code: Lib/xml/etree/ElementTree.py

The  module implements a simple and efficient API
for parsing and creating XML data.

Changed in version 3.3: This module will use a fast implementation whenever available.
The  module is deprecated.


Warning
The  module is not secure against
maliciously constructed data.  If you need to parse untrusted or
unauthenticated data see XML vulnerabilities.


Tutorial¶
This is a short tutorial for using  ( in
short).  The goal is to demonstrate some of the building blocks and basic
concepts of the module.

XML tree and elements¶
XML is an inherently hierarchical data format, and the most natural way to
represent it is with a tree.   has two classes for this purpose -
 represents the whole XML document as a tree, and
 represents a single node in this tree.  Interactions with
the whole document (reading and writing to/from files) are usually done
on the  level.  Interactions with a single XML element
and its sub-elements are done on the  level.


Parsing XML¶
We’ll be using the following XML document as the sample data for this section:


We can import this data by reading from a file:


Or directly from a string:


 parses XML from a string directly into an ,
which is the root element of the parsed tree.  Other parsing functions may
create an .  Check the documentation to be sure.
As an ,  has a tag and a dictionary of attributes:


It also has children nodes over which we can iterate:


Children are nested, and we can access specific child nodes by index:



Note
Not all elements of the XML input will end up as elements of the
parsed tree. Currently, this module skips over any XML comments,
processing instructions, and document type declarations in the
input. Nevertheless, trees built using this module’s API rather
than parsing from XML text can have comments and processing
instructions in them; they will be included when generating XML
output. A document type declaration may be accessed by passing a
custom  instance to the 
constructor.



Pull API for non-blocking parsing¶
Most parsing functions provided by this module require the whole document
to be read at once before returning any result.  It is possible to use an
 and feed data into it incrementally, but it is a push API that
calls methods on a callback target, which is too low-level and inconvenient for
most needs.  Sometimes what the user really wants is to be able to parse XML
incrementally, without blocking operations, while enjoying the convenience of
fully constructed  objects.
The most powerful tool for doing this is .  It does not
require a blocking read to obtain the XML data, and is instead fed with data
incrementally with  calls.  To get the parsed XML
elements, call .  Here is an example:


The obvious use case is applications that operate in a non-blocking fashion
where the XML data is being received from a socket or read incrementally from
some storage device.  In such cases, blocking reads are unacceptable.
Because it’s so flexible,  can be inconvenient to use for
simpler use-cases.  If you don’t mind your application blocking on reading XML
data but would still like to have incremental parsing capabilities, take a look
at .  It can be useful when you’re reading a large XML document
and don’t want to hold it wholly in memory.


Finding interesting elements¶
 has some useful methods that help iterate recursively over all
the sub-tree below it (its children, their children, and so on).  For example,
:


 finds only elements with a tag which are direct
children of the current element.   finds the first child
with a particular tag, and  accesses the element’s text
content.   accesses the element’s attributes:


More sophisticated specification of which elements to look for is possible by
using XPath.


Modifying an XML File¶
 provides a simple way to build XML documents and write them to files.
The  method serves this purpose.
Once created, an  object may be manipulated by directly changing
its fields (such as ), adding and modifying attributes
( method), as well as adding new children (for example
with ).
Let’s say we want to add one to each country’s rank, and add an 
attribute to the rank element:


Our XML now looks like this:


We can remove elements using .  Let’s say we want to
remove all countries with a rank higher than 50:


Our XML now looks like this:




Building XML documents¶
The  function also provides a convenient way to create new
sub-elements for a given element:




Parsing XML with Namespaces¶
If the XML input has namespaces, tags and attributes
with prefixes in the form  get expanded to
 where the prefix is replaced by the full URI.
Also, if there is a default namespace,
that full URI gets prepended to all of the non-prefixed tags.
Here is an XML example that incorporates two namespaces, one with the
prefix “fictional” and the other serving as the default namespace:


One way to search and explore this XML example is to manually add the
URI to every tag or attribute in the xpath of a
 or :


A better way to search the namespaced XML example is to create a
dictionary with your own prefixes and use those in the search functions:


These two approaches both output:




Additional resources¶
See http://effbot.org/zone/element-index.htm for tutorials and links to other
docs.



XPath support¶
This module provides limited support for
XPath expressions for locating elements in a
tree.  The goal is to support a small subset of the abbreviated syntax; a full
XPath engine is outside the scope of the module.

Example¶
Here’s an example that demonstrates some of the XPath capabilities of the
module.  We’ll be using the  XML document from the
Parsing XML section:




Supported XPath syntax¶






Syntax
Meaning




Selects all child elements with the given tag.
For example,  selects all child elements
named , and  selects all
grandchildren named  in all children named
.


Selects all child elements.  For example, 
selects all grandchildren named .


Selects the current node.  This is mostly useful
at the beginning of the path, to indicate that it’s
a relative path.


Selects all subelements, on all levels beneath the
current  element.  For example,  selects
all  elements in the entire tree.


Selects the parent element.  Returns  if the
path attempts to reach the ancestors of the start
element (the element  was called on).


Selects all elements that have the given attribute.


Selects all elements for which the given attribute
has the given value.  The value cannot contain
quotes.


Selects all elements that have a child named
.  Only immediate children are supported.


Selects all elements whose complete text content,
including descendants, equals the given .

New in version 3.7.




Selects all elements that have a child named
 whose complete text content, including
descendants, equals the given .


Selects all elements that are located at the given
position.  The position can be either an integer
(1 is the first position), the expression 
(for the last position), or a position relative to
the last position (e.g. ).



Predicates (expressions within square brackets) must be preceded by a tag
name, an asterisk, or another predicate.   predicates must be
preceded by a tag name.



Reference¶

Functions¶


(text=None)¶
Comment element factory.  This factory function creates a special element
that will be serialized as an XML comment by the standard serializer.  The
comment string can be either a bytestring or a Unicode string.  text is a
string containing the comment string.  Returns an element instance
representing a comment.
Note that  skips over comments in the input
instead of creating comment objects for them. An  will
only contain comment nodes if they have been inserted into to
the tree using one of the  methods.



(elem)¶
Writes an element tree or element structure to sys.stdout.  This function
should be used for debugging only.
The exact output format is implementation dependent.  In this version, it’s
written as an ordinary XML file.
elem is an element tree or an individual element.



(text, parser=None)¶
Parses an XML section from a string constant.  Same as .  text
is a string containing XML data.  parser is an optional parser instance.
If not given, the standard  parser is used.
Returns an  instance.



(sequence, parser=None)¶
Parses an XML document from a sequence of string fragments.  sequence is a
list or other sequence containing XML data fragments.  parser is an
optional parser instance.  If not given, the standard 
parser is used.  Returns an  instance.

New in version 3.2.




(element)¶
Checks if an object appears to be a valid element object.  element is an
element instance.  Returns a true value if this is an element object.



(source, events=None, parser=None)¶
Parses an XML section into an element tree incrementally, and reports what’s
going on to the user.  source is a filename or file object
containing XML data.  events is a sequence of events to report back.  The
supported events are the strings , ,  and
 (the “ns” events are used to get detailed namespace
information).  If events is omitted, only  events are reported.
parser is an optional parser instance.  If not given, the standard
 parser is used.  parser must be a subclass of
 and can only use the default  as a
target.  Returns an iterator providing  pairs.
Note that while  builds the tree incrementally, it issues
blocking reads on source (or the file it names).  As such, it’s unsuitable
for applications where blocking reads can’t be made.  For fully non-blocking
parsing, see .

Note
 only guarantees that it has seen the “>” character of a
starting tag when it emits a “start” event, so the attributes are defined,
but the contents of the text and tail attributes are undefined at that
point.  The same applies to the element children; they may or may not be
present.
If you need a fully populated element, look for “end” events instead.


Deprecated since version 3.4: The parser argument.




(source, parser=None)¶
Parses an XML section into an element tree.  source is a filename or file
object containing XML data.  parser is an optional parser instance.  If
not given, the standard  parser is used.  Returns an
 instance.



(target, text=None)¶
PI element factory.  This factory function creates a special element that
will be serialized as an XML processing instruction.  target is a string
containing the PI target.  text is a string containing the PI contents, if
given.  Returns an element instance, representing a processing instruction.
Note that  skips over processing instructions
in the input instead of creating comment objects for them. An
 will only contain processing instruction nodes if
they have been inserted into to the tree using one of the
 methods.



(prefix, uri)¶
Registers a namespace prefix.  The registry is global, and any existing
mapping for either the given prefix or the namespace URI will be removed.
prefix is a namespace prefix.  uri is a namespace uri.  Tags and
attributes in this namespace will be serialized with the given prefix, if at
all possible.

New in version 3.2.




(parent, tag, attrib={}, **extra)¶
Subelement factory.  This function creates an element instance, and appends
it to an existing element.
The element name, attribute names, and attribute values can be either
bytestrings or Unicode strings.  parent is the parent element.  tag is
the subelement name.  attrib is an optional dictionary, containing element
attributes.  extra contains additional attributes, given as keyword
arguments.  Returns an element instance.



(element, encoding="us-ascii", method="xml", *, short_empty_elements=True)¶
Generates a string representation of an XML element, including all
subelements.  element is an  instance.  encoding [1] is
the output encoding (default is US-ASCII).  Use  to
generate a Unicode string (otherwise, a bytestring is generated).  method
is either ,  or  (default is ).
short_empty_elements has the same meaning as in .
Returns an (optionally) encoded string containing the XML data.

New in version 3.4: The short_empty_elements parameter.




(element, encoding="us-ascii", method="xml", *, short_empty_elements=True)¶
Generates a string representation of an XML element, including all
subelements.  element is an  instance.  encoding [1] is
the output encoding (default is US-ASCII).  Use  to
generate a Unicode string (otherwise, a bytestring is generated).  method
is either ,  or  (default is ).
short_empty_elements has the same meaning as in .
Returns a list of (optionally) encoded strings containing the XML data.
It does not guarantee any specific sequence, except that
.

New in version 3.2.


New in version 3.4: The short_empty_elements parameter.




(text, parser=None)¶
Parses an XML section from a string constant.  This function can be used to
embed “XML literals” in Python code.  text is a string containing XML
data.  parser is an optional parser instance.  If not given, the standard
 parser is used.  Returns an  instance.



(text, parser=None)¶
Parses an XML section from a string constant, and also returns a dictionary
which maps from element id:s to elements.  text is a string containing XML
data.  parser is an optional parser instance.  If not given, the standard
 parser is used.  Returns a tuple containing an
 instance and a dictionary.



Element Objects¶


class (tag, attrib={}, **extra)¶
Element class.  This class defines the Element interface, and provides a
reference implementation of this interface.
The element name, attribute names, and attribute values can be either
bytestrings or Unicode strings.  tag is the element name.  attrib is
an optional dictionary, containing element attributes.  extra contains
additional attributes, given as keyword arguments.


¶
A string identifying what kind of data this element represents (the
element type, in other words).



¶

¶
These attributes can be used to hold additional data associated with
the element.  Their values are usually strings but may be any
application-specific object.  If the element is created from
an XML file, the text attribute holds either the text between
the element’s start tag and its first child or end tag, or , and
the tail attribute holds either the text between the element’s
end tag and the next tag, or .  For the XML data


the a element has  for both text and tail attributes,
the b element has text  and tail ,
the c element has text  and tail ,
and the d element has text  and tail .
To collect the inner text of an element, see , for
example .
Applications may store arbitrary objects in these attributes.



¶
A dictionary containing the element’s attributes.  Note that while the
attrib value is always a real mutable Python dictionary, an ElementTree
implementation may choose to use another internal representation, and
create the dictionary only if someone asks for it.  To take advantage of
such implementations, use the dictionary methods below whenever possible.

The following dictionary-like methods work on the element attributes.


()¶
Resets an element.  This function removes all subelements, clears all
attributes, and sets the text and tail attributes to .



(key, default=None)¶
Gets the element attribute named key.
Returns the attribute value, or default if the attribute was not found.



()¶
Returns the element attributes as a sequence of (name, value) pairs.  The
attributes are returned in an arbitrary order.



()¶
Returns the elements attribute names as a list.  The names are returned
in an arbitrary order.



(key, value)¶
Set the attribute key on the element to value.

The following methods work on the element’s children (subelements).


(subelement)¶
Adds the element subelement to the end of this element’s internal list
of subelements.  Raises  if subelement is not an
.



(subelements)¶
Appends subelements from a sequence object with zero or more elements.
Raises  if a subelement is not an .

New in version 3.2.




(match, namespaces=None)¶
Finds the first subelement matching match.  match may be a tag name
or a path.  Returns an element instance
or .  namespaces is an optional mapping from namespace prefix
to full name.



(match, namespaces=None)¶
Finds all matching subelements, by tag name or
path.  Returns a list containing all matching
elements in document order.  namespaces is an optional mapping from
namespace prefix to full name.



(match, default=None, namespaces=None)¶
Finds text for the first subelement matching match.  match may be
a tag name or a path.  Returns the text content
of the first matching element, or default if no element was found.
Note that if the matching element has no text content an empty string
is returned. namespaces is an optional mapping from namespace prefix
to full name.



()¶

Deprecated since version 3.2: Use  or iteration.




(tag=None)¶

Deprecated since version 3.2: Use method  instead.




(index, subelement)¶
Inserts subelement at the given position in this element.  Raises
 if subelement is not an .



(tag=None)¶
Creates a tree iterator with the current element as the root.
The iterator iterates over this element and all elements below it, in
document (depth first) order.  If tag is not  or , only
elements whose tag equals tag are returned from the iterator.  If the
tree structure is modified during iteration, the result is undefined.

New in version 3.2.




(match, namespaces=None)¶
Finds all matching subelements, by tag name or
path.  Returns an iterable yielding all
matching elements in document order. namespaces is an optional mapping
from namespace prefix to full name.

New in version 3.2.




()¶
Creates a text iterator.  The iterator loops over this element and all
subelements, in document order, and returns all inner text.

New in version 3.2.




(tag, attrib)¶
Creates a new element object of the same type as this element.  Do not
call this method, use the  factory function instead.



(subelement)¶
Removes subelement from the element.  Unlike the find* methods this
method compares elements based on the instance identity, not on tag value
or contents.

 objects also support the following sequence type methods
for working with subelements: ,
, ,
.
Caution: Elements with no subelements will test as .  This behavior
will change in future versions.  Use specific  or  test instead.





ElementTree Objects¶


class (element=None, file=None)¶
ElementTree wrapper class.  This class represents an entire element
hierarchy, and adds some extra support for serialization to and from
standard XML.
element is the root element.  The tree is initialized with the contents
of the XML file if given.


(element)¶
Replaces the root element for this tree.  This discards the current
contents of the tree, and replaces it with the given element.  Use with
care.  element is an element instance.



(match, namespaces=None)¶
Same as , starting at the root of the tree.



(match, namespaces=None)¶
Same as , starting at the root of the tree.



(match, default=None, namespaces=None)¶
Same as , starting at the root of the tree.



(tag=None)¶

Deprecated since version 3.2: Use method  instead.




()¶
Returns the root element for this tree.



(tag=None)¶
Creates and returns a tree iterator for the root element.  The iterator
loops over all elements in this tree, in section order.  tag is the tag
to look for (default is to return all elements).



(match, namespaces=None)¶
Same as , starting at the root of the tree.

New in version 3.2.




(source, parser=None)¶
Loads an external XML section into this element tree.  source is a file
name or file object.  parser is an optional parser instance.
If not given, the standard  parser is used.  Returns the
section root element.



(file, encoding="us-ascii", xml_declaration=None, default_namespace=None, method="xml", *, short_empty_elements=True)¶
Writes the element tree to a file, as XML.  file is a file name, or a
file object opened for writing.  encoding [1] is the output
encoding (default is US-ASCII).
xml_declaration controls if an XML declaration should be added to the
file.  Use  for never,  for always, 
for only if not US-ASCII or UTF-8 or Unicode (default is ).
default_namespace sets the default XML namespace (for “xmlns”).
method is either ,  or  (default is
).
The keyword-only short_empty_elements parameter controls the formatting
of elements that contain no content.  If  (the default), they are
emitted as a single self-closed tag, otherwise they are emitted as a pair
of start/end tags.
The output is either a string () or binary ().
This is controlled by the encoding argument.  If encoding is
, the output is a string; otherwise, it’s binary.  Note that
this may conflict with the type of file if it’s an open
file object; make sure you do not try to write a string to a
binary stream and vice versa.

New in version 3.4: The short_empty_elements parameter.



This is the XML file that is going to be manipulated:


Example of changing the attribute “target” of every link in first paragraph:




QName Objects¶


class (text_or_uri, tag=None)¶
QName wrapper.  This can be used to wrap a QName attribute value, in order
to get proper namespace handling on output.  text_or_uri is a string
containing the QName value, in the form {uri}local, or, if the tag argument
is given, the URI part of a QName.  If tag is given, the first argument is
interpreted as a URI, and this argument is interpreted as a local name.
 instances are opaque.



TreeBuilder Objects¶


class (element_factory=None)¶
Generic element structure builder.  This builder converts a sequence of
start, data, and end method calls to a well-formed element structure.  You
can use this class to build an element structure using a custom XML parser,
or a parser for some other XML-like format.  element_factory, when given,
must be a callable accepting two positional arguments: a tag and
a dict of attributes.  It is expected to return a new element instance.


()¶
Flushes the builder buffers, and returns the toplevel document
element.  Returns an  instance.



(data)¶
Adds text to the current element.  data is a string.  This should be
either a bytestring, or a Unicode string.



(tag)¶
Closes the current element.  tag is the element name.  Returns the
closed element.



(tag, attrs)¶
Opens a new element.  tag is the element name.  attrs is a dictionary
containing element attributes.  Returns the opened element.

In addition, a custom  object can provide the
following method:


(name, pubid, system)¶
Handles a doctype declaration.  name is the doctype name.  pubid is
the public identifier.  system is the system identifier.  This method
does not exist on the default  class.

New in version 3.2.





XMLParser Objects¶


class (html=0, target=None, encoding=None)¶
This class is the low-level building block of the module.  It uses
 for efficient, event-based parsing of XML.  It can
be fed XML data incrementally with the  method, and parsing
events are translated to a push API - by invoking callbacks on the target
object.  If target is omitted, the standard  is used.
The html argument was historically used for backwards compatibility and is
now deprecated.  If encoding [1] is given, the value overrides the
encoding specified in the XML file.

Deprecated since version 3.4: The html argument.  The remaining arguments should be passed via
keyword to prepare for the removal of the html argument.



()¶
Finishes feeding data to the parser.  Returns the result of calling the
 method of the target passed during construction; by default,
this is the toplevel document element.



(name, pubid, system)¶

Deprecated since version 3.2: Define the  method on a custom TreeBuilder
target.




(data)¶
Feeds data to the parser.  data is encoded data.

 calls target’s  method
for each opening tag, its  method for each closing tag, and data
is processed by method .   calls
target’s method .  can be used not only for
building a tree structure. This is an example of counting the maximum depth
of an XML file:





XMLPullParser Objects¶


class (events=None)¶
A pull parser suitable for non-blocking applications.  Its input-side API is
similar to that of , but instead of pushing calls to a
callback target,  collects an internal list of parsing
events and lets the user read from it. events is a sequence of events to
report back.  The supported events are the strings , ,
 and  (the “ns” events are used to get detailed
namespace information).  If events is omitted, only  events are
reported.


(data)¶
Feed the given bytes data to the parser.



()¶
Signal the parser that the data stream is terminated. Unlike
, this method always returns .
Any events not yet retrieved when the parser is closed can still be
read with .



()¶
Return an iterator over the events which have been encountered in the
data fed to the
parser.  The iterator yields  pairs, where event is a
string representing the type of event (e.g. ) and elem is the
encountered  object.
Events provided in a previous call to  will not be
yielded again.  Events are consumed from the internal queue only when
they are retrieved from the iterator, so multiple readers iterating in
parallel over iterators obtained from  will have
unpredictable results.


Note
 only guarantees that it has seen the “>”
character of a starting tag when it emits a “start” event, so the
attributes are defined, but the contents of the text and tail attributes
are undefined at that point.  The same applies to the element children;
they may or may not be present.
If you need a fully populated element, look for “end” events instead.


New in version 3.4.




Exceptions¶


class ¶
XML parse error, raised by the various parsing methods in this module when
parsing fails.  The string representation of an instance of this exception
will contain a user-friendly error message.  In addition, it will have
the following attributes available:


¶
A numeric error code from the expat parser. See the documentation of
 for the list of error codes and their meanings.



¶
A tuple of line, column numbers, specifying where the error occurred.


Footnotes



[1](1, 2, 3, 4) The encoding string included in XML output should conform to the
appropriate standards.  For example, “UTF-8” is valid, but “UTF8” is
not.  See https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl
and https://www.iana.org/assignments/character-sets/character-sets.xhtml.





