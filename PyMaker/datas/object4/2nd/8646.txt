link:
library/unittest.mock-examples.html#mocking-chained-calls

docs:

Mocking chained calls¶
Mocking chained calls is actually straightforward with mock once you
understand the  attribute. When a mock is called for
the first time, or you fetch its  before it has been called, a
new  is created.
This means that you can see how the object returned from a call to a mocked
object has been used by interrogating the  mock:


From here it is a simple step to configure and then make assertions about
chained calls. Of course another alternative is writing your code in a more
testable way in the first place…
So, suppose we have some code that looks a little bit like this:


Assuming that  is already well tested, how do we test
? Specifically, we want to test that the code section  uses the response object in the correct way.
As this chain of calls is made from an instance attribute we can monkey patch
the  attribute on a  instance. In this particular case
we are only interested in the return value from the final call to
 so we don’t have much configuration to do. Let’s assume the
object it returns is ‘file-like’, so we’ll ensure that our response object
uses the builtin  as its .
To do this we create a mock instance as our mock backend and create a mock
response object for it. To set the response as the return value for that final
 we could do this:


We can do that in a slightly nicer way using the 
method to directly set the return value for us:


With these we monkey patch the “mock backend” in place and can make the real
call:


Using  we can check the chained call with a single
assert. A chained call is several calls in one line of code, so there will be
several entries in . We can use  to create
this list of calls for us:


