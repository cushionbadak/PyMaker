link:
library/tokenize.html#tokenizing-input

docs:

Tokenizing Input¶
The primary entry point is a generator:


(readline)¶
The  generator requires one argument, readline, which
must be a callable object which provides the same interface as the
 method of file objects.  Each call to the
function should return one line of input as bytes.
The generator produces 5-tuples with these members: the token type; the
token string; a 2-tuple  of ints specifying the row and
column where the token begins in the source; a 2-tuple  of
ints specifying the row and column where the token ends in the source; and
the line on which the token was found. The line passed (the last tuple item)
is the logical line; continuation lines are included.  The 5 tuple is
returned as a named tuple with the field names:
.
The returned named tuple has an additional property named
 that contains the exact operator type for
 tokens.  For all other token types 
equals the named tuple  field.

Changed in version 3.1: Added support for named tuples.


Changed in version 3.3: Added support for .

 determines the source encoding of the file by looking for a
UTF-8 BOM or encoding cookie, according to PEP 263.

All constants from the  module are also exported from
.
Another function is provided to reverse the tokenization process. This is
useful for creating tools that tokenize a script, modify the token stream, and
write back the modified script.


(iterable)¶
Converts tokens back into Python source code.  The iterable must return
sequences with at least two elements, the token type and the token string.
Any additional sequence elements are ignored.
The reconstructed script is returned as a single string.  The result is
guaranteed to tokenize back to match the input so that the conversion is
lossless and round-trips are assured.  The guarantee applies only to the
token type and token string as the spacing between tokens (column
positions) may change.
It returns bytes, encoded using the  token, which
is the first token sequence output by .

 needs to detect the encoding of source files it tokenizes. The
function it uses to do this is available:


(readline)¶
The  function is used to detect the encoding that
should be used to decode a Python source file. It requires one argument,
readline, in the same way as the  generator.
It will call readline a maximum of twice, and return the encoding used
(as a string) and a list of any lines (not decoded from bytes) it has read
in.
It detects the encoding from the presence of a UTF-8 BOM or an encoding
cookie as specified in PEP 263. If both a BOM and a cookie are present,
but disagree, a  will be raised. Note that if the BOM is found,
 will be returned as an encoding.
If no encoding is specified, then the default of  will be
returned.
Use  to open Python source files: it uses
 to detect the file encoding.



(filename)¶
Open a file in read only mode using the encoding detected by
.

New in version 3.2.




exception ¶
Raised when either a docstring or expression that may be split over several
lines is not completed anywhere in the file, for example:


or:



Note that unclosed single-quoted strings do not cause an error to be
raised. They are tokenized as , followed by the
tokenization of their contents.
