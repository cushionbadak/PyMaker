link:
library/codecs.html#codec-base-classes

docs:

Codec Base Classes¶
The  module defines a set of base classes which define the
interfaces for working with codec objects, and can also be used as the basis
for custom codec implementations.
Each codec has to define four interfaces to make it usable as codec in Python:
stateless encoder, stateless decoder, stream reader and stream writer. The
stream reader and writers typically reuse the stateless encoder/decoder to
implement the file protocols. Codec authors also need to define how the
codec will handle encoding and decoding errors.

Error Handlers¶
To simplify and standardize error handling,
codecs may implement different error handling schemes by
accepting the errors string argument.  The following string values are
defined and implemented by all standard Python codecs:






Value
Meaning




Raise  (or a subclass);
this is the default.  Implemented in
.


Ignore the malformed data and continue
without further notice.  Implemented in
.



The following error handlers are only applicable to
text encodings:






Value
Meaning




Replace with a suitable replacement
marker; Python will use the official
 REPLACEMENT CHARACTER for the
built-in codecs on decoding, and ‘?’ on
encoding.  Implemented in
.


Replace with the appropriate XML character
reference (only for encoding).  Implemented
in .


Replace with backslashed escape sequences.
Implemented in
.


Replace with  escape sequences
(only for encoding).  Implemented in
.


On decoding, replace byte with individual
surrogate code ranging from  to
.  This code will then be turned
back into the same byte when the
 error handler is used
when encoding the data.  (See PEP 383 for
more.)



In addition, the following error handler is specific to the given codecs:







Value
Codecs
Meaning




utf-8, utf-16, utf-32,
utf-16-be, utf-16-le,
utf-32-be, utf-32-le
Allow encoding and decoding of surrogate
codes.  These codecs normally treat the
presence of surrogates as an error.




New in version 3.1: The  and  error handlers.


Changed in version 3.4: The  error handlers now works with utf-16* and utf-32* codecs.


New in version 3.5: The  error handler.


Changed in version 3.5: The  error handlers now works with decoding and
translating.

The set of allowed values can be extended by registering a new named error
handler:


(name, error_handler)¶
Register the error handling function error_handler under the name name.
The error_handler argument will be called during encoding and decoding
in case of an error, when name is specified as the errors parameter.
For encoding, error_handler will be called with a 
instance, which contains information about the location of the error. The
error handler must either raise this or a different exception, or return a
tuple with a replacement for the unencodable part of the input and a position
where encoding should continue. The replacement may be either  or
.  If the replacement is bytes, the encoder will simply copy
them into the output buffer. If the replacement is a string, the encoder will
encode the replacement.  Encoding continues on original input at the
specified position. Negative position values will be treated as being
relative to the end of the input string. If the resulting position is out of
bound an  will be raised.
Decoding and translating works similarly, except  or
 will be passed to the handler and that the
replacement from the error handler will be put into the output directly.

Previously registered error handlers (including the standard error handlers)
can be looked up by name:


(name)¶
Return the error handler previously registered under the name name.
Raises a  in case the handler cannot be found.

The following standard error handlers are also made available as module level
functions:


(exception)¶
Implements the  error handling: each encoding or
decoding error raises a .



(exception)¶
Implements the  error handling (for text encodings only): substitutes  for encoding errors
(to be encoded by the codec), and  (the Unicode replacement
character) for decoding errors.



(exception)¶
Implements the  error handling: malformed data is ignored and
encoding or decoding is continued without further notice.



(exception)¶
Implements the  error handling (for encoding with
text encodings only): the
unencodable character is replaced by an appropriate XML character reference.



(exception)¶
Implements the  error handling (for
text encodings only): malformed data is
replaced by a backslashed escape sequence.



(exception)¶
Implements the  error handling (for encoding with
text encodings only): the
unencodable character is replaced by a  escape sequence.

New in version 3.5.




Stateless Encoding and Decoding¶
The base  class defines these methods which also define the
function interfaces of the stateless encoder and decoder:


(input[, errors])¶
Encodes the object input and returns a tuple (output object, length consumed).
For instance, text encoding converts
a string object to a bytes object using a particular
character set encoding (e.g.,  or ).
The errors argument defines the error handling to apply.
It defaults to  handling.
The method may not store state in the  instance. Use
 for codecs which have to keep state in order to make
encoding efficient.
The encoder must be able to handle zero length input and return an empty object
of the output object type in this situation.



(input[, errors])¶
Decodes the object input and returns a tuple (output object, length
consumed).  For instance, for a text encoding, decoding converts
a bytes object encoded using a particular
character set encoding to a string object.
For text encodings and bytes-to-bytes codecs,
input must be a bytes object or one which provides the read-only
buffer interface – for example, buffer objects and memory mapped files.
The errors argument defines the error handling to apply.
It defaults to  handling.
The method may not store state in the  instance. Use
 for codecs which have to keep state in order to make
decoding efficient.
The decoder must be able to handle zero length input and return an empty object
of the output object type in this situation.



Incremental Encoding and Decoding¶
The  and  classes provide
the basic interface for incremental encoding and decoding. Encoding/decoding the
input isn’t done with one call to the stateless encoder/decoder function, but
with multiple calls to the
/ method of
the incremental encoder/decoder. The incremental encoder/decoder keeps track of
the encoding/decoding process during method calls.
The joined output of calls to the
/ method is
the same as if all the single inputs were joined into one, and this input was
encoded/decoded with the stateless encoder/decoder.

IncrementalEncoder Objects¶
The  class is used for encoding an input in multiple
steps. It defines the following methods which every incremental encoder must
define in order to be compatible with the Python codec registry.


class (errors='strict')¶
Constructor for an  instance.
All incremental encoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.
The  may implement different error handling schemes
by providing the errors keyword argument. See Error Handlers for
possible values.
The errors argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the 
object.


(object[, final])¶
Encodes object (taking the current state of the encoder into account)
and returns the resulting encoded object. If this is the last call to
 final must be true (the default is false).



()¶
Reset the encoder to the initial state. The output is discarded: call
, passing an empty byte or text string
if necessary, to reset the encoder and to get the output.



()¶
Return the current state of the encoder which must be an integer. The
implementation should make sure that  is the most common
state. (States that are more complicated than integers can be converted
into an integer by marshaling/pickling the state and encoding the bytes
of the resulting string into an integer).



(state)¶
Set the state of the encoder to state. state must be an encoder state
returned by .




IncrementalDecoder Objects¶
The  class is used for decoding an input in multiple
steps. It defines the following methods which every incremental decoder must
define in order to be compatible with the Python codec registry.


class (errors='strict')¶
Constructor for an  instance.
All incremental decoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.
The  may implement different error handling schemes
by providing the errors keyword argument. See Error Handlers for
possible values.
The errors argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the 
object.


(object[, final])¶
Decodes object (taking the current state of the decoder into account)
and returns the resulting decoded object. If this is the last call to
 final must be true (the default is false). If final is
true the decoder must decode the input completely and must flush all
buffers. If this isn’t possible (e.g. because of incomplete byte sequences
at the end of the input) it must initiate error handling just like in the
stateless case (which might raise an exception).



()¶
Reset the decoder to the initial state.



()¶
Return the current state of the decoder. This must be a tuple with two
items, the first must be the buffer containing the still undecoded
input. The second must be an integer and can be additional state
info. (The implementation should make sure that  is the most common
additional state info.) If this additional state info is  it must be
possible to set the decoder to the state which has no input buffered and
 as the additional state info, so that feeding the previously
buffered input to the decoder returns it to the previous state without
producing any output. (Additional state info that is more complicated than
integers can be converted into an integer by marshaling/pickling the info
and encoding the bytes of the resulting string into an integer.)



(state)¶
Set the state of the decoder to state. state must be a decoder state
returned by .





Stream Encoding and Decoding¶
The  and  classes provide generic
working interfaces which can be used to implement new encoding submodules very
easily. See  for an example of how this is done.

StreamWriter Objects¶
The  class is a subclass of  and defines the
following methods which every stream writer must define in order to be
compatible with the Python codec registry.


class (stream, errors='strict')¶
Constructor for a  instance.
All stream writers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.
The stream argument must be a file-like object open for writing
text or binary data, as appropriate for the specific codec.
The  may implement different error handling schemes by
providing the errors keyword argument. See Error Handlers for
the standard error handlers the underlying stream codec may support.
The errors argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the  object.


(object)¶
Writes the object’s contents encoded to the stream.



(list)¶
Writes the concatenated list of strings to the stream (possibly by reusing
the  method). The standard bytes-to-bytes codecs
do not support this method.



()¶
Flushes and resets the codec buffers used for keeping state.
Calling this method should ensure that the data on the output is put into
a clean state that allows appending of new fresh data without having to
rescan the whole stream to recover state.


In addition to the above methods, the  must also inherit
all other methods and attributes from the underlying stream.


StreamReader Objects¶
The  class is a subclass of  and defines the
following methods which every stream reader must define in order to be
compatible with the Python codec registry.


class (stream, errors='strict')¶
Constructor for a  instance.
All stream readers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.
The stream argument must be a file-like object open for reading
text or binary data, as appropriate for the specific codec.
The  may implement different error handling schemes by
providing the errors keyword argument. See Error Handlers for
the standard error handlers the underlying stream codec may support.
The errors argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the  object.
The set of allowed values for the errors argument can be extended with
.


([size[, chars[, firstline]]])¶
Decodes data from the stream and returns the resulting object.
The chars argument indicates the number of decoded
code points or bytes to return. The  method will
never return more data than requested, but it might return less,
if there is not enough available.
The size argument indicates the approximate maximum
number of encoded bytes or code points to read
for decoding. The decoder can modify this setting as
appropriate. The default value -1 indicates to read and decode as much as
possible.  This parameter is intended to
prevent having to decode huge files in one step.
The firstline flag indicates that
it would be sufficient to only return the first
line, if there are decoding errors on later lines.
The method should use a greedy read strategy meaning that it should read
as much data as is allowed within the definition of the encoding and the
given size, e.g.  if optional encoding endings or state markers are
available on the stream, these should be read too.



([size[, keepends]])¶
Read one line from the input stream and return the decoded data.
size, if given, is passed as size argument to the stream’s
 method.
If keepends is false line-endings will be stripped from the lines
returned.



([sizehint[, keepends]])¶
Read all lines available on the input stream and return them as a list of
lines.
Line-endings are implemented using the codec’s decoder method and are
included in the list entries if keepends is true.
sizehint, if given, is passed as the size argument to the stream’s
 method.



()¶
Resets the codec buffers used for keeping state.
Note that no stream repositioning should take place.  This method is
primarily intended to be able to recover from decoding errors.


In addition to the above methods, the  must also inherit
all other methods and attributes from the underlying stream.


StreamReaderWriter Objects¶
The  is a convenience class that allows wrapping
streams which work in both read and write modes.
The design is such that one can use the factory functions returned by the
 function to construct the instance.


class (stream, Reader, Writer, errors='strict')¶
Creates a  instance. stream must be a file-like
object. Reader and Writer must be factory functions or classes providing the
 and  interface resp. Error handling
is done in the same way as defined for the stream readers and writers.

 instances define the combined interfaces of
 and  classes. They inherit all other
methods and attributes from the underlying stream.


StreamRecoder Objects¶
The  translates data from one encoding to another,
which is sometimes useful when dealing with different encoding environments.
The design is such that one can use the factory functions returned by the
 function to construct the instance.


class (stream, encode, decode, Reader, Writer, errors='strict')¶
Creates a  instance which implements a two-way conversion:
encode and decode work on the frontend — the data visible to
code calling  and , while Reader and Writer
work on the backend — the data in stream.
You can use these objects to do transparent transcodings from e.g. Latin-1
to UTF-8 and back.
The stream argument must be a file-like object.
The encode and decode arguments must
adhere to the  interface. Reader and
Writer must be factory functions or classes providing objects of the
 and  interface respectively.
Error handling is done in the same way as defined for the stream readers and
writers.

 instances define the combined interfaces of
 and  classes. They inherit all other
methods and attributes from the underlying stream.


