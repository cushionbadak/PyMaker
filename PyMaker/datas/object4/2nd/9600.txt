link:
library/pkgutil.html#module-pkgutil

docs:

 — Package extension utility¶
Source code: Lib/pkgutil.py

This module provides utilities for the import system, in particular package
support.


class (module_finder, name, ispkg)¶
A namedtuple that holds a brief summary of a module’s info.

New in version 3.6.




(path, name)¶
Extend the search path for the modules which comprise a package.  Intended
use is to place the following code in a package’s :


This will add to the package’s  all subdirectories of directories
on  named after the package.  This is useful if one wants to
distribute different parts of a single logical package as multiple
directories.
It also looks for  files beginning where  matches the
name argument.  This feature is similar to  files (see the
 module for more information), except that it doesn’t special-case
lines starting with .  A  file is trusted at face
value: apart from checking for duplicates, all entries found in a
 file are added to the path, regardless of whether they exist
on the filesystem.  (This is a feature.)
If the input path is not a list (as is the case for frozen packages) it is
returned unchanged.  The input path is not modified; an extended copy is
returned.  Items are only appended to the copy at the end.
It is assumed that  is a sequence.  Items of 
that are not strings referring to existing directories are ignored. Unicode
items on  that cause errors when used as filenames may cause
this function to raise an exception (in line with 
behavior).



class (dirname=None)¶
PEP 302 Finder that wraps Python’s “classic” import algorithm.
If dirname is a string, a PEP 302 finder is created that searches that
directory.  If dirname is , a PEP 302 finder is created that
searches the current , plus any modules that are frozen or
built-in.
Note that  does not currently support being used by
placement on .

Deprecated since version 3.3: This emulation is no longer needed, as the standard import mechanism
is now fully PEP 302 compliant and available in .




class (fullname, file, filename, etc)¶
Loader that wraps Python’s “classic” import algorithm.

Deprecated since version 3.3: This emulation is no longer needed, as the standard import mechanism
is now fully PEP 302 compliant and available in .




(fullname)¶
Retrieve a module loader for the given fullname.
This is a backwards compatibility wrapper around
 that converts most failures to
 and only returns the loader rather than the full
.

Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.


Changed in version 3.4: Updated to be based on PEP 451




(path_item)¶
Retrieve a finder for the given path_item.
The returned finder is cached in  if it was
newly created by a path hook.
The cache (or part of it) can be cleared manually if a rescan of
 is necessary.

Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.




(module_or_name)¶
Get a loader object for module_or_name.
If the module or package is accessible via the normal import mechanism, a
wrapper around the relevant part of that machinery is returned.  Returns
 if the module cannot be found or imported.  If the named module is
not already imported, its containing package (if any) is imported, in order
to establish the package .

Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.


Changed in version 3.4: Updated to be based on PEP 451




(fullname='')¶
Yield finder objects for the given module name.
If fullname contains a ‘.’, the finders will be for the package
containing fullname, otherwise they will be all registered top level
finders (i.e. those on both sys.meta_path and sys.path_hooks).
If the named module is in a package, that package is imported as a side
effect of invoking this function.
If no module name is specified, all top level finders are produced.

Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.




(path=None, prefix='')¶
Yields  for all submodules on path, or, if
path is , all top-level modules on .
path should be either  or a list of paths to look for modules in.
prefix is a string to output on the front of every module name on output.

Note
Only works for a finder which defines an 
method. This interface is non-standard, so the module also provides
implementations for  and
.


Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.




(path=None, prefix='', onerror=None)¶
Yields  for all modules recursively on
path, or, if path is , all accessible modules.
path should be either  or a list of paths to look for modules in.
prefix is a string to output on the front of every module name on output.
Note that this function must import all packages (not all modules!) on
the given path, in order to access the  attribute to find
submodules.
onerror is a function which gets called with one argument (the name of the
package which was being imported) if any exception occurs while trying to
import a package.  If no onerror function is supplied, s
are caught and ignored, while all other exceptions are propagated,
terminating the search.
Examples:



Note
Only works for a finder which defines an 
method. This interface is non-standard, so the module also provides
implementations for  and
.


Changed in version 3.3: Updated to be based directly on  rather than relying
on the package internal PEP 302 import emulation.




(package, resource)¶
Get a resource from a package.
This is a wrapper for the loader
 API.  The
package argument should be the name of a package, in standard module format
().  The resource argument should be in the form of a relative
filename, using  as the path separator.  The parent directory name
 is not allowed, and nor is a rooted name (starting with a ).
The function returns a binary string that is the contents of the specified
resource.
For packages located in the filesystem, which have already been imported,
this is the rough equivalent of:


If the package cannot be located or loaded, or it uses a loader
which does not support ,
then  is returned.  In particular, the loader for
namespace packages does not support
.

