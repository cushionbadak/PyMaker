link:
library/asyncio-policy.html#process-watchers

docs:

Process Watchers¶
A process watcher allows customization of how an event loop monitors
child processes on Unix. Specifically, the event loop needs to know
when a child process has exited.
In asyncio, child processes are created with
 and 
functions.
asyncio defines the  abstract base class,
which child watchers should implement, and has two different
implementations:  (configured to be used
by default) and .
See also the Subprocess and Threads
section.
The following two functions can be used to customize the child process watcher
implementation used by the asyncio event loop:


()¶
Return the current child watcher for the current policy.



(watcher)¶
Set the current child watcher to watcher for the current
policy.  watcher must implement methods defined in the
 base class.


Note
Third-party event loops implementations might not support
custom child watchers.  For such event loops, using
 might be prohibited or have no effect.



class ¶


(pid, callback, *args)¶
Register a new child handler.
Arrange for  to be called
when a process with PID equal to pid terminates.  Specifying
another callback for the same process replaces the previous
handler.
The callback callable must be thread-safe.



(pid)¶
Removes the handler for process with PID equal to pid.
The function returns  if the handler was successfully
removed,  if there was nothing to remove.



(loop)¶
Attach the watcher to an event loop.
If the watcher was previously attached to an event loop, then
it is first detached before attaching to the new loop.
Note: loop may be .



()¶
Close the watcher.
This method has to be called to ensure that underlying
resources are cleaned-up.




class ¶
This implementation avoids disrupting other code spawning processes
by polling every process explicitly on a  signal.
This is a safe solution but it has a significant overhead when
handling a big number of processes (O(n) each time a
 is received).
asyncio uses this safe implementation by default.



class ¶
This implementation reaps every terminated processes by calling
 directly, possibly breaking other code spawning
processes and waiting for their termination.
There is no noticeable overhead when handling a big number of
children (O(1) each time a child terminates).

