link:
library/contextlib.html#single-use-reusable-and-reentrant-context-managers

docs:

Single use, reusable and reentrant context managers¶
Most context managers are written in a way that means they can only be
used effectively in a  statement once. These single use
context managers must be created afresh each time they’re used -
attempting to use them a second time will trigger an exception or
otherwise not work correctly.
This common limitation means that it is generally advisable to create
context managers directly in the header of the  statement
where they are used (as shown in all of the usage examples above).
Files are an example of effectively single use context managers, since
the first  statement will close the file, preventing any
further IO operations using that file object.
Context managers created using  are also single use
context managers, and will complain about the underlying generator failing
to yield if an attempt is made to use them a second time:



Reentrant context managers¶
More sophisticated context managers may be “reentrant”. These context
managers can not only be used in multiple  statements,
but may also be used inside a  statement that is already
using the same context manager.
 is an example of a reentrant context manager, as are
 and . Here’s a very simple example of
reentrant use:


Real world examples of reentrancy are more likely to involve multiple
functions calling each other and hence be far more complicated than this
example.
Note also that being reentrant is not the same thing as being thread safe.
, for example, is definitely not thread safe, as it
makes a global modification to the system state by binding 
to a different stream.


Reusable context managers¶
Distinct from both single use and reentrant context managers are “reusable”
context managers (or, to be completely explicit, “reusable, but not
reentrant” context managers, since reentrant context managers are also
reusable). These context managers support being used multiple times, but
will fail (or otherwise not work correctly) if the specific context manager
instance has already been used in a containing with statement.
 is an example of a reusable, but not reentrant,
context manager (for a reentrant lock, it is necessary to use
 instead).
Another example of a reusable, but not reentrant, context manager is
, as it invokes all currently registered callbacks
when leaving any with statement, regardless of where those callbacks
were added:


As the output from the example shows, reusing a single stack object across
multiple with statements works correctly, but attempting to nest them
will cause the stack to be cleared at the end of the innermost with
statement, which is unlikely to be desirable behaviour.
Using separate  instances instead of reusing a single
instance avoids that problem:



