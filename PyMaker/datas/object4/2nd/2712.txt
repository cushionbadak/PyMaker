link:
library/configparser.html#module-configparser

docs:

 — Configuration file parser¶
Source code: Lib/configparser.py

This module provides the  class which implements a basic
configuration language which provides a structure similar to what’s found in
Microsoft Windows INI files.  You can use this to write Python programs which
can be customized by end users easily.

Note
This library does not interpret or write the value-type prefixes used in
the Windows Registry extended version of INI syntax.


See also

Module 
Support for creating Unix shell-like mini-languages which can be used as
an alternate format for application configuration files.
Module 
The json module implements a subset of JavaScript syntax which can also
be used for this purpose.



Quick Start¶
Let’s take a very basic configuration file that looks like this:


The structure of INI files is described in the following section.  Essentially, the file
consists of sections, each of which contains keys with values.
 classes can read and write such files.  Let’s start by
creating the above configuration file programmatically.


As you can see, we can treat a config parser much like a dictionary.
There are differences, outlined later, but
the behavior is very close to what you would expect from a dictionary.
Now that we have created and saved a configuration file, let’s read it
back and explore the data it holds.


As we can see above, the API is pretty straightforward.  The only bit of magic
involves the  section which provides default values for all other
sections [1].  Note also that keys in sections are
case-insensitive and stored in lowercase [1].


Supported Datatypes¶
Config parsers do not guess datatypes of values in configuration files, always
storing them internally as strings.  This means that if you need other
datatypes, you should convert on your own:


Since this task is so common, config parsers provide a range of handy getter
methods to handle integers, floats and booleans.  The last one is the most
interesting because simply passing the value to  would do no good
since  is still .  This is why config parsers also
provide .  This method is case-insensitive and
recognizes Boolean values from /, /,
/ and / [1].  For example:


Apart from , config parsers also
provide equivalent  and
 methods.  You can register your own
converters and customize the provided ones. [1]


Fallback Values¶
As with a dictionary, you can use a section’s  method to
provide fallback values:


Please note that default values have precedence over fallback values.
For instance, in our example the  key was
specified only in the  section.  If we try to get it from
the section , we will always get the default,
even if we specify a fallback:


One more thing to be aware of is that the parser-level  method
provides a custom, more complex interface, maintained for backwards
compatibility.  When using this method, a fallback value can be provided via
the  keyword-only argument:


The same  argument can be used with the
,  and
 methods, for example:




Supported INI File Structure¶
A configuration file consists of sections, each led by a  header,
followed by key/value entries separated by a specific string ( or  by
default [1]).  By default, section names are case sensitive but keys are not
[1].  Leading and trailing whitespace is removed from keys and values.
Values can be omitted, in which case the key/value delimiter may also be left
out.  Values can also span multiple lines, as long as they are indented deeper
than the first line of the value.  Depending on the parser’s mode, blank lines
may be treated as parts of multiline values or ignored.
Configuration files may include comments, prefixed by specific
characters ( and  by default [1]).  Comments may appear on
their own on an otherwise empty line, possibly indented. [1]
For example:




Interpolation of values¶
On top of the core functionality,  supports
interpolation.  This means values can be preprocessed before returning them
from  calls.


class ¶
The default implementation used by .  It enables
values to contain format strings which refer to other values in the same
section, or values in the special default section [1].  Additional default
values can be provided on initialization.
For example:


In the example above,  with interpolation set to
 would resolve  to the value of
 ( in this case).   in effect would
resolve to .  All interpolations are done on demand so
keys used in the chain of references do not have to be specified in any
specific order in the configuration file.
With  set to , the parser would simply return
 as the value of  and
 as the value of .



class ¶
An alternative handler for interpolation which implements a more advanced
syntax, used for instance in .  Extended interpolation is
using  to denote a value from a foreign section.
Interpolation can span multiple levels.  For convenience, if the
 part is omitted, interpolation defaults to the current section
(and possibly the default values from the special section).
For example, the configuration specified above with basic interpolation,
would look like this with extended interpolation:


Values from other sections can be fetched as well:





Mapping Protocol Access¶

New in version 3.2.

Mapping protocol access is a generic name for functionality that enables using
custom objects as if they were dictionaries.  In case of ,
the mapping interface implementation is using the
 notation.
 in particular returns a proxy for the section’s data in
the parser.  This means that the values are not copied but they are taken from
the original parser on demand.  What’s even more important is that when values
are changed on a section proxy, they are actually mutated in the original
parser.
 objects behave as close to actual dictionaries as possible.
The mapping interface is complete and adheres to the
 ABC.
However, there are a few differences that should be taken into account:

By default, all keys in sections are accessible in a case-insensitive manner
[1].  E.g.  yields only ’ed
option key names.  This means lowercased keys by default.  At the same time,
for a section that holds the key , both expressions return :



All sections include  values as well which means that
 on a section may not leave the section visibly empty.  This is
because default values cannot be deleted from the section (because technically
they are not there).  If they are overridden in the section, deleting causes
the default value to be visible again.  Trying to delete a default value
causes a .

 cannot be removed from the parser:

trying to delete it raises ,
 leaves it intact,
 never returns it.


 - the second argument is not
a fallback value.  Note however that the section-level  methods are
compatible both with the mapping protocol and the classic configparser API.

 is compatible with the mapping protocol (returns a list of
section_name, section_proxy pairs including the DEFAULTSECT).  However,
this method can also be invoked with arguments: .  The latter call returns a list of option, value pairs for
a specified , with all interpolations expanded (unless
 is provided).


The mapping protocol is implemented on top of the existing legacy API so that
subclasses overriding the original interface still should have mappings working
as expected.


Customizing Parser Behaviour¶
There are nearly as many INI format variants as there are applications using it.
 goes a long way to provide support for the largest sensible
set of INI styles available.  The default functionality is mainly dictated by
historical background and it’s very likely that you will want to customize some
of the features.
The most common way to change the way a specific config parser works is to use
the  options:

defaults, default value: 
This option accepts a dictionary of key-value pairs which will be initially
put in the  section.  This makes for an elegant way to support
concise configuration files that don’t specify values which are the same as
the documented default.
Hint: if you want to specify default values for a specific section, use
 before you read the actual file.

dict_type, default value: 
This option has a major impact on how the mapping protocol will behave and how
the written configuration files look.  With the default ordered
dictionary, every section is stored in the order they were added to the
parser.  Same goes for options within sections.
An alternative dictionary type can be used for example to sort sections and
options on write-back.  You can also use a regular dictionary for performance
reasons.
Please note: there are ways to add a set of key-value pairs in a single
operation.  When you use a regular dictionary in those operations, the order
of the keys will be ordered because dict preserves order from Python 3.7.
For example:



allow_no_value, default value: 
Some configuration files are known to include settings without values, but
which otherwise conform to the syntax supported by .  The
allow_no_value parameter to the constructor can be used to
indicate that such values should be accepted:



delimiters, default value: 
Delimiters are substrings that delimit keys from values within a section.
The first occurrence of a delimiting substring on a line is considered
a delimiter.  This means values (but not keys) can contain the delimiters.
See also the space_around_delimiters argument to
.

comment_prefixes, default value: 

inline_comment_prefixes, default value: 
Comment prefixes are strings that indicate the start of a valid comment within
a config file. comment_prefixes are used only on otherwise empty lines
(optionally indented) whereas inline_comment_prefixes can be used after
every valid value (e.g. section names, options and empty lines as well).  By
default inline comments are disabled and  and  are used as
prefixes for whole line comments.

Changed in version 3.2: In previous versions of  behaviour matched
 and .

Please note that config parsers don’t support escaping of comment prefixes so
using inline_comment_prefixes may prevent users from specifying option
values with characters used as comment prefixes.  When in doubt, avoid
setting inline_comment_prefixes.  In any circumstances, the only way of
storing comment prefix characters at the beginning of a line in multiline
values is to interpolate the prefix, for example:



strict, default value: 
When set to , the parser will not allow for any section or option
duplicates while reading from a single source (using ,
 or ).  It is recommended to use strict
parsers in new applications.

Changed in version 3.2: In previous versions of  behaviour matched
.


empty_lines_in_values, default value: 
In config parsers, values can span multiple lines as long as they are
indented more than the key that holds them.  By default parsers also let
empty lines to be parts of values.  At the same time, keys can be arbitrarily
indented themselves to improve readability.  In consequence, when
configuration files get big and complex, it is easy for the user to lose
track of the file structure.  Take for instance:


This can be especially problematic for the user to see if she’s using a
proportional font to edit the file.  That is why when your application does
not need values with empty lines, you should consider disallowing them.  This
will make empty lines split keys every time.  In the example above, it would
produce two keys,  and .

default_section, default value:  (that is:
)
The convention of allowing a special section of default values for other
sections or interpolation purposes is a powerful concept of this library,
letting users create complex declarative configurations.  This section is
normally called  but this can be customized to point to any
other valid section name.  Some typical values include:  or
.  The name provided is used for recognizing default sections
when reading from any source and is used when writing configuration back to
a file.  Its current value can be retrieved using the
 attribute and may be modified at runtime
(i.e. to convert files from one format to another).

interpolation, default value: 
Interpolation behaviour may be customized by providing a custom handler
through the interpolation argument.  can be used to turn off
interpolation completely,  provides a more
advanced variant inspired by .  More on the subject in the
dedicated documentation section.
 has a default value of .

converters, default value: not set
Config parsers provide option value getters that perform type conversion.  By
default , , and
 are implemented.  Should other getters be
desirable, users may define them in a subclass or pass a dictionary where each
key is a name of the converter and each value is a callable implementing said
conversion.  For instance, passing  would add
 on both the parser object and all section proxies.  In
other words, it will be possible to write both
 and
.
If the converter needs to access the state of the parser, it can be
implemented as a method on a config parser subclass.  If the name of this
method starts with , it will be available on all section proxies, in
the dict-compatible form (see the  example above).


More advanced customization may be achieved by overriding default values of
these parser attributes.  The defaults are defined on the classes, so they may
be overridden by subclasses or by attribute assignment.


¶
By default when using , config parsers
consider the following values : , , ,
 and the following values : , , ,
.  You can override this by specifying a custom dictionary of strings
and their Boolean outcomes. For example:


Other typical Boolean pairs include / or
/.



(option)¶
This method transforms option names on every read, get, or set
operation.  The default converts the name to lowercase.  This also
means that when a configuration file gets written, all keys will be
lowercase.  Override this method if that’s unsuitable.
For example:



Note
The optionxform function transforms option names to a canonical form.
This should be an idempotent function: if the name is already in
canonical form, it should be returned unchanged.




¶
A compiled regular expression used to parse section headers.  The default
matches  to the name .  Whitespace is considered
part of the section name, thus  will be read as a section of
name .  Override this attribute if that’s unsuitable.  For
example:



Note
While ConfigParser objects also use an  attribute for recognizing
option lines, it’s not recommended to override it because that would
interfere with constructor options allow_no_value and delimiters.




Legacy API Examples¶
Mainly because of backwards compatibility concerns, 
provides also a legacy API with explicit / methods.  While there
are valid use cases for the methods outlined below, mapping protocol access is
preferred for new projects.  The legacy API is at times more advanced,
low-level and downright counterintuitive.
An example of writing to a configuration file:


An example of reading the configuration file again:


To get interpolation, use :


Default values are available in both types of ConfigParsers.  They are used in
interpolation if an option used is not defined elsewhere.




ConfigParser Objects¶


class (defaults=None, dict_type=collections.OrderedDict, allow_no_value=False, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT, interpolation=BasicInterpolation(), converters={})¶
The main configuration parser.  When defaults is given, it is initialized
into the dictionary of intrinsic defaults.  When dict_type is given, it
will be used to create the dictionary objects for the list of sections, for
the options within a section, and for the default values.
When delimiters is given, it is used as the set of substrings that
divide keys from values.  When comment_prefixes is given, it will be used
as the set of substrings that prefix comments in otherwise empty lines.
Comments can be indented.  When inline_comment_prefixes is given, it will
be used as the set of substrings that prefix comments in non-empty lines.
When strict is  (the default), the parser won’t allow for
any section or option duplicates while reading from a single source (file,
string or dictionary), raising  or
.  When empty_lines_in_values is 
(default: ), each empty line marks the end of an option.  Otherwise,
internal empty lines of a multiline option are kept as part of the value.
When allow_no_value is  (default: ), options without
values are accepted; the value held for these is  and they are
serialized without the trailing delimiter.
When default_section is given, it specifies the name for the special
section holding default values for other sections and interpolation purposes
(normally named ).  This value can be retrieved and changed on
runtime using the  instance attribute.
Interpolation behaviour may be customized by providing a custom handler
through the interpolation argument.  can be used to turn off
interpolation completely,  provides a more
advanced variant inspired by .  More on the subject in the
dedicated documentation section.
All option names used in interpolation will be passed through the
 method just like any other option name reference.  For
example, using the default implementation of  (which
converts option names to lower case), the values  and  are equivalent.
When converters is given, it should be a dictionary where each key
represents the name of a type converter and each value is a callable
implementing the conversion from string to the desired datatype.  Every
converter gets its own corresponding  method on the parser
object and section proxies.

Changed in version 3.1: The default dict_type is .


Changed in version 3.2: allow_no_value, delimiters, comment_prefixes, strict,
empty_lines_in_values, default_section and interpolation were
added.


Changed in version 3.5: The converters argument was added.


Changed in version 3.7: The defaults argument is read with ,
providing consistent behavior across the parser: non-string
keys and values are implicitly converted to strings.



()¶
Return a dictionary containing the instance-wide defaults.



()¶
Return a list of the sections available; the default section is not
included in the list.



(section)¶
Add a section named section to the instance.  If a section by the given
name already exists,  is raised.  If the
default section name is passed,  is raised.  The name
of the section must be a string; if not,  is raised.

Changed in version 3.2: Non-string section names raise .




(section)¶
Indicates whether the named section is present in the configuration.
The default section is not acknowledged.



(section)¶
Return a list of options available in the specified section.



(section, option)¶
If the given section exists, and contains the given option, return
; otherwise return .  If the specified
section is  or an empty string, DEFAULT is assumed.



(filenames, encoding=None)¶
Attempt to read and parse an iterable of filenames, returning a list of
filenames which were successfully parsed.
If filenames is a string, a  object or a
path-like object, it is treated as
a single filename.  If a file named in filenames cannot be opened, that
file will be ignored.  This is designed so that you can specify an
iterable of potential configuration file locations (for example, the
current directory, the user’s home directory, and some system-wide
directory), and all existing configuration files in the iterable will be
read.
If none of the named files exist, the 
instance will contain an empty dataset.  An application which requires
initial values to be loaded from a file should load the required file or
files using  before calling  for any
optional files:



New in version 3.2: The encoding parameter.  Previously, all files were read using the
default encoding for .


New in version 3.6.1: The filenames parameter accepts a path-like object.


New in version 3.7: The filenames parameter accepts a  object.




(f, source=None)¶
Read and parse configuration data from f which must be an iterable
yielding Unicode strings (for example files opened in text mode).
Optional argument source specifies the name of the file being read.  If
not given and f has a  attribute, that is used for
source; the default is .

New in version 3.2: Replaces .




(string, source='<string>')¶
Parse configuration data from a string.
Optional argument source specifies a context-specific name of the
string passed.  If not given,  is used.  This should
commonly be a filesystem path or a URL.

New in version 3.2.




(dictionary, source='<dict>')¶
Load configuration from any object that provides a dict-like 
method.  Keys are section names, values are dictionaries with keys and
values that should be present in the section.  If the used dictionary
type preserves order, sections and their keys will be added in order.
Values are automatically converted to strings.
Optional argument source specifies a context-specific name of the
dictionary passed.  If not given,  is used.
This method can be used to copy state between parsers.

New in version 3.2.




(section, option, *, raw=False, vars=None[, fallback])¶
Get an option value for the named section.  If vars is provided, it
must be a dictionary.  The option is looked up in vars (if provided),
section, and in DEFAULTSECT in that order.  If the key is not found
and fallback is provided, it is used as a fallback value.   can
be provided as a fallback value.
All the  interpolations are expanded in the return values, unless
the raw argument is true.  Values for interpolation keys are looked up
in the same manner as the option.

Changed in version 3.2: Arguments raw, vars and fallback are keyword only to protect
users from trying to use the third argument as the fallback fallback
(especially when using the mapping protocol).




(section, option, *, raw=False, vars=None[, fallback])¶
A convenience method which coerces the option in the specified section
to an integer.  See  for explanation of raw, vars and
fallback.



(section, option, *, raw=False, vars=None[, fallback])¶
A convenience method which coerces the option in the specified section
to a floating point number.  See  for explanation of raw,
vars and fallback.



(section, option, *, raw=False, vars=None[, fallback])¶
A convenience method which coerces the option in the specified section
to a Boolean value.  Note that the accepted values for the option are
, , , and , which cause this method to
return , and , , , and , which
cause it to return .  These string values are checked in a
case-insensitive manner.  Any other value will cause it to raise
.  See  for explanation of raw, vars and
fallback.



(raw=False, vars=None)¶

(section, raw=False, vars=None)
When section is not given, return a list of section_name,
section_proxy pairs, including DEFAULTSECT.
Otherwise, return a list of name, value pairs for the options in the
given section.  Optional arguments have the same meaning as for the
 method.



(section, option, value)¶
If the given section exists, set the given option to the specified value;
otherwise raise .  option and value must be
strings; if not,  is raised.



(fileobject, space_around_delimiters=True)¶
Write a representation of the configuration to the specified file
object, which must be opened in text mode (accepting strings).  This
representation can be parsed by a future  call.  If
space_around_delimiters is true, delimiters between
keys and values are surrounded by spaces.



(section, option)¶
Remove the specified option from the specified section.  If the
section does not exist, raise .  If the option
existed to be removed, return ; otherwise return
.



(section)¶
Remove the specified section from the configuration.  If the section in
fact existed, return .  Otherwise return .



(option)
Transforms the option name option as found in an input file or as passed
in by client code to the form that should be used in the internal
structures.  The default implementation returns a lower-case version of
option; subclasses may override this or client code can set an attribute
of this name on instances to affect this behavior.
You don’t need to subclass the parser to use this method, you can also
set it on an instance, to a function that takes a string argument and
returns a string.  Setting it to , for example, would make option
names case sensitive:


Note that when reading configuration files, whitespace around the option
names is stripped before  is called.



(fp, filename=None)¶

Deprecated since version 3.2: Use  instead.


Changed in version 3.2:  now iterates on fp instead of calling .

For existing code calling  with arguments which don’t
support iteration, the following generator may be used as a wrapper
around the file-like object:


Instead of  use
.




¶
The maximum depth for recursive interpolation for  when the raw
parameter is false.  This is relevant only when the default interpolation
is used.



RawConfigParser Objects¶


class (defaults=None, dict_type=collections.OrderedDict, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT[, interpolation])¶
Legacy variant of the .  It has interpolation
disabled by default and allows for non-string section names, option
names, and values via its unsafe  and  methods,
as well as the legacy  keyword argument handling.

Note
Consider using  instead which checks types of
the values to be stored internally.  If you don’t want interpolation, you
can use .



(section)¶
Add a section named section to the instance.  If a section by the given
name already exists,  is raised.  If the
default section name is passed,  is raised.
Type of section is not checked which lets users create non-string named
sections.  This behaviour is unsupported and may cause internal errors.



(section, option, value)¶
If the given section exists, set the given option to the specified value;
otherwise raise .  While it is possible to use
 (or  with raw parameters
set to true) for internal storage of non-string values, full
functionality (including interpolation and output to files) can only be
achieved using string values.
This method lets users assign non-string values to keys internally.  This
behaviour is unsupported and will cause errors when attempting to write
to a file or get it in non-raw mode.  Use the mapping protocol API
which does not allow such assignments to take place.




Exceptions¶


exception ¶
Base class for all other  exceptions.



exception ¶
Exception raised when a specified section is not found.



exception ¶
Exception raised if  is called with the name of a section
that is already present or in strict parsers when a section if found more
than once in a single input file, string or dictionary.

New in version 3.2: Optional  and  attributes and arguments to
 were added.




exception ¶
Exception raised by strict parsers if a single option appears twice during
reading from a single file, string or dictionary. This catches misspellings
and case sensitivity-related errors, e.g. a dictionary may have two keys
representing the same case-insensitive configuration key.



exception ¶
Exception raised when a specified option is not found in the specified
section.



exception ¶
Base class for exceptions raised when problems occur performing string
interpolation.



exception ¶
Exception raised when string interpolation cannot be completed because the
number of iterations exceeds .  Subclass of
.



exception ¶
Exception raised when an option referenced from a value does not exist.
Subclass of .



exception ¶
Exception raised when the source text into which substitutions are made does
not conform to the required syntax.  Subclass of .



exception ¶
Exception raised when attempting to parse a file which has no section
headers.



exception ¶
Exception raised when errors occur attempting to parse a file.

Changed in version 3.2: The  attribute and  argument were renamed to
 for consistency.


Footnotes



[1](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) Config parsers allow for heavy customization.  If you are interested in
changing the behaviour outlined by the footnote reference, consult the
Customizing Parser Behaviour section.



