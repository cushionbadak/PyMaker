link:
library/types.html#dynamic-type-creation

docs:

Dynamic Type Creation¶


(name, bases=(), kwds=None, exec_body=None)¶
Creates a class object dynamically using the appropriate metaclass.
The first three arguments are the components that make up a class
definition header: the class name, the base classes (in order), the
keyword arguments (such as ).
The exec_body argument is a callback that is used to populate the
freshly created class namespace. It should accept the class namespace
as its sole argument and update the namespace directly with the class
contents. If no callback is provided, it has the same effect as passing
in .

New in version 3.3.




(name, bases=(), kwds=None)¶
Calculates the appropriate metaclass and creates the class namespace.
The arguments are the components that make up a class definition header:
the class name, the base classes (in order) and the keyword arguments
(such as ).
The return value is a 3-tuple: 
metaclass is the appropriate metaclass, namespace is the
prepared class namespace and kwds is an updated copy of the passed
in kwds argument with any  entry removed. If no kwds
argument is passed in, this will be an empty dict.

New in version 3.3.


Changed in version 3.6: The default value for the  element of the returned
tuple has changed.  Now an insertion-order-preserving mapping is
used when the metaclass does not have a  method.



See also

Metaclasses
Full details of the class creation process supported by these functions
PEP 3115 - Metaclasses in Python 3000
Introduced the  namespace hook




(bases)¶
Resolve MRO entries dynamically as specified by PEP 560.
This function looks for items in bases that are not instances of
, and returns a tuple where each such object that has
an  method is replaced with an unpacked result of
calling this method.  If a bases item is an instance of ,
or it doesn’t have an  method, then it is included in
the return tuple unchanged.

New in version 3.7.



See also
PEP 560 - Core support for typing module and generic types

