link:
library/multiprocessing.html#managers

docs:

Managers¶
Managers provide a way to create data which can be shared between different
processes, including sharing over a network between processes running on
different machines. A manager object controls a server process which manages
shared objects.  Other processes can access the shared objects by using
proxies.


()¶
Returns a started  object which
can be used for sharing objects between processes.  The returned manager
object corresponds to a spawned child process and has methods which will
create shared objects and return corresponding proxies.

Manager processes will be shutdown as soon as they are garbage collected or
their parent process exits.  The manager classes are defined in the
 module:


class ([address[, authkey]])¶
Create a BaseManager object.
Once created one should call  or  to ensure
that the manager object refers to a started manager process.
address is the address on which the manager process listens for new
connections.  If address is  then an arbitrary one is chosen.
authkey is the authentication key which will be used to check the
validity of incoming connections to the server process.  If
authkey is  then  is used.
Otherwise authkey is used and it must be a byte string.


([initializer[, initargs]])¶
Start a subprocess to start the manager.  If initializer is not 
then the subprocess will call  when it starts.



()¶
Returns a  object which represents the actual server under
the control of the Manager. The  object supports the
 method:


 additionally has an  attribute.



()¶
Connect a local manager object to a remote manager process:





()¶
Stop the process used by the manager.  This is only available if
 has been used to start the server process.
This can be called multiple times.



(typeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])¶
A classmethod which can be used for registering a type or callable with
the manager class.
typeid is a “type identifier” which is used to identify a particular
type of shared object.  This must be a string.
callable is a callable used for creating objects for this type
identifier.  If a manager instance will be connected to the
server using the  method, or if the
create_method argument is  then this can be left as
.
proxytype is a subclass of  which is used to create
proxies for shared objects with this typeid.  If  then a proxy
class is created automatically.
exposed is used to specify a sequence of method names which proxies for
this typeid should be allowed to access using
.  (If exposed is  then
 is used instead if it exists.)  In the case
where no exposed list is specified, all “public methods” of the shared
object will be accessible.  (Here a “public method” means any attribute
which has a  method and whose name does not begin
with .)
method_to_typeid is a mapping used to specify the return type of those
exposed methods which should return a proxy.  It maps method names to
typeid strings.  (If method_to_typeid is  then
 is used instead if it exists.)  If a
method’s name is not a key of this mapping or if the mapping is 
then the object returned by the method will be copied by value.
create_method determines whether a method should be created with name
typeid which can be used to tell the server process to create a new
shared object and return a proxy for it.  By default it is .

 instances also have one read-only property:


¶
The address used by the manager.


Changed in version 3.3: Manager objects support the context management protocol – see
Context Manager Types.   starts the
server process (if it has not already started) and then returns the
manager object.   calls .
In previous versions  did not start the
manager’s server process if it was not already started.




class ¶
A subclass of  which can be used for the synchronization
of processes.  Objects of this type are returned by
.
Its methods create and return Proxy Objects for a
number of commonly used data types to be synchronized across processes.
This notably includes shared lists and dictionaries.


(parties[, action[, timeout]])¶
Create a shared  object and return a
proxy for it.

New in version 3.3.




([value])¶
Create a shared  object and return a
proxy for it.



([lock])¶
Create a shared  object and return a proxy for
it.
If lock is supplied then it should be a proxy for a
 or  object.

Changed in version 3.3: The  method was added.




()¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



([maxsize])¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



([value])¶
Create a shared  object and return a proxy for
it.



(typecode, sequence)¶
Create an array and return a proxy for it.



(typecode, value)¶
Create an object with a writable  attribute and return a proxy
for it.



()¶

(mapping)

(sequence)
Create a shared  object and return a proxy for it.



()¶

(sequence)
Create a shared  object and return a proxy for it.


Changed in version 3.6: Shared objects are capable of being nested.  For example, a shared
container object such as a shared list can contain other shared objects
which will all be managed and synchronized by the .




class ¶
A type that can register with .
A namespace object has no public methods, but does have writable attributes.
Its representation shows the values of its attributes.
However, when using a proxy for a namespace object, an attribute beginning
with  will be an attribute of the proxy and not an attribute of the
referent:




Customized managers¶
To create one’s own manager, one creates a subclass of  and
uses the  classmethod to register new types or
callables with the manager class.  For example:




Using a remote manager¶
It is possible to run a manager server on one machine and have clients use it
from other machines (assuming that the firewalls involved allow it).
Running the following commands creates a server for a single shared queue which
remote clients can access:


One client can access the server as follows:


Another client can also use it:


Local processes can also access that queue, using the code from above on the
client to access it remotely:



