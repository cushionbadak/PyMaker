link:
library/numbers.html#module-numbers

docs:

 — Numeric abstract base classes¶
Source code: Lib/numbers.py

The  module (PEP 3141) defines a hierarchy of numeric
abstract base classes which progressively define
more operations.  None of the types defined in this module can be instantiated.


class ¶
The root of the numeric hierarchy. If you just want to check if an argument
x is a number, without caring what kind, use .


The numeric tower¶


class ¶
Subclasses of this type describe complex numbers and include the operations
that work on the built-in  type. These are: conversions to
 and , , , ,
, , , , , , and . All
except  and  are abstract.


¶
Abstract. Retrieves the real component of this number.



¶
Abstract. Retrieves the imaginary component of this number.



abstractmethod ()¶
Abstract. Returns the complex conjugate. For example, .




class ¶
To ,  adds the operations that work on real
numbers.
In short, those are: a conversion to , ,
, , , , ,
, , , , and .
Real also provides defaults for , ,
, and .



class ¶
Subtypes  and adds
 and  properties, which
should be in lowest terms. With these, it provides a default for
.


¶
Abstract.



¶
Abstract.




class ¶
Subtypes  and adds a conversion to .  Provides
defaults for , , and
.  Adds abstract methods for  and
bit-string operations: , , , , , .



Notes for type implementors¶
Implementors should be careful to make equal numbers equal and hash
them to the same values. This may be subtle if there are two different
extensions of the real numbers. For example, 
implements  as follows:



Adding More Numeric ABCs¶
There are, of course, more possible ABCs for numbers, and this would
be a poor hierarchy if it precluded the possibility of adding
those. You can add  between  and
 with:




Implementing the arithmetic operations¶
We want to implement the arithmetic operations so that mixed-mode
operations either call an implementation whose author knew about the
types of both arguments, or convert both to the nearest built in type
and do the operation there. For subtypes of , this
means that  and  should be defined as:


There are 5 different cases for a mixed-type operation on subclasses
of . I’ll refer to all of the above code that doesn’t
refer to  and  as
“boilerplate”.  will be an instance of , which is a subtype
of  (), and . I’ll consider :


If  defines an  which accepts , all is
well.
If  falls back to the boilerplate code, and it were to
return a value from , we’d miss the possibility
that  defines a more intelligent , so the
boilerplate should return  from
. (Or  may not implement  at
all.)
Then ’s  gets a chance. If it accepts
, all is well.
If it falls back to the boilerplate, there are no more possible
methods to try, so this is where the default implementation
should live.
If , Python tries  before
. This is ok, because it was implemented with
knowledge of , so it can handle those instances before
delegating to .


If  and  without sharing any other knowledge,
then the appropriate shared operation is the one involving the built
in , and both  s land there, so .
Because most of the operations on any given type will be very similar,
it can be useful to define a helper function which generates the
forward and reverse instances of any given operator. For example,
 uses:




