link:
library/logging.html#module-logging

docs:

 — Logging facility for Python¶
Source code: Lib/logging/__init__.py

Important
This page contains the API reference information. For tutorial
information and discussion of more advanced topics, see

Basic Tutorial
Advanced Tutorial
Logging Cookbook



This module defines functions and classes which implement a flexible event
logging system for applications and libraries.
The key benefit of having the logging API provided by a standard library module
is that all Python modules can participate in logging, so your application log
can include your own messages integrated with messages from third-party
modules.
The module provides a lot of functionality and flexibility.  If you are
unfamiliar with logging, the best way to get to grips with it is to see the
tutorials (see the links on the right).
The basic classes defined by the module, together with their functions, are
listed below.

Loggers expose the interface that application code directly uses.
Handlers send the log records (created by loggers) to the appropriate
destination.
Filters provide a finer grained facility for determining which log records
to output.
Formatters specify the layout of log records in the final output.


Logger Objects¶
Loggers have the following attributes and methods.  Note that Loggers are never
instantiated directly, but always through the module-level function
.  Multiple calls to  with the same
name will always return a reference to the same Logger object.
The  is potentially a period-separated hierarchical value, like
 (though it could also be just plain , for example).
Loggers that are further down in the hierarchical list are children of loggers
higher up in the list.  For example, given a logger with a name of ,
loggers with names of , , and  are all
descendants of .  The logger name hierarchy is analogous to the Python
package hierarchy, and identical to it if you organise your loggers on a
per-module basis using the recommended construction
.  That’s because in a module, 
is the module’s name in the Python package namespace.


class ¶


¶
If this attribute evaluates to true, events logged to this logger will be
passed to the handlers of higher level (ancestor) loggers, in addition to
any handlers attached to this logger. Messages are passed directly to the
ancestor loggers’ handlers - neither the level nor filters of the ancestor
loggers in question are considered.
If this evaluates to false, logging messages are not passed to the handlers
of ancestor loggers.
The constructor sets this attribute to .

Note
If you attach a handler to a logger and one or more of its
ancestors, it may emit the same record multiple times. In general, you
should not need to attach a handler to more than one logger - if you just
attach it to the appropriate logger which is highest in the logger
hierarchy, then it will see all events logged by all descendant loggers,
provided that their propagate setting is left set to . A common
scenario is to attach handlers only to the root logger, and to let
propagation take care of the rest.




(level)¶
Sets the threshold for this logger to level. Logging messages which are less
severe than level will be ignored; logging messages which have severity level
or higher will be emitted by whichever handler or handlers service this logger,
unless a handler’s level has been set to a higher severity level than level.
When a logger is created, the level is set to  (which causes
all messages to be processed when the logger is the root logger, or delegation
to the parent when the logger is a non-root logger). Note that the root logger
is created with level .
The term ‘delegation to the parent’ means that if a logger has a level of
NOTSET, its chain of ancestor loggers is traversed until either an ancestor with
a level other than NOTSET is found, or the root is reached.
If an ancestor is found with a level other than NOTSET, then that ancestor’s
level is treated as the effective level of the logger where the ancestor search
began, and is used to determine how a logging event is handled.
If the root is reached, and it has a level of NOTSET, then all messages will be
processed. Otherwise, the root’s level will be used as the effective level.
See Logging Levels for a list of levels.

Changed in version 3.2: The level parameter now accepts a string representation of the
level such as ‘INFO’ as an alternative to the integer constants
such as . Note, however, that levels are internally stored
as integers, and methods such as e.g.  and
 will return/expect to be passed integers.




(lvl)¶
Indicates if a message of severity lvl would be processed by this logger.
This method checks first the module-level level set by
 and then the logger’s effective level as determined
by .



()¶
Indicates the effective level for this logger. If a value other than
 has been set using , it is returned. Otherwise,
the hierarchy is traversed towards the root until a value other than
 is found, and that value is returned. The value returned is
an integer, typically one of , 
etc.



(suffix)¶
Returns a logger which is a descendant to this logger, as determined by the suffix.
Thus,  would return the same
logger as would be returned by . This is a
convenience method, useful when the parent logger is named using e.g. 
rather than a literal string.

New in version 3.2.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The msg is the
message format string, and the args are the arguments which are merged into
msg using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
There are three keyword arguments in kwargs which are inspected:
exc_info, stack_info, and extra.
If exc_info does not evaluate as false, it causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
) or an exception instance is provided, it is used;
otherwise,  is called to get the exception information.
The second optional keyword argument is stack_info, which defaults to
. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying exc_info: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.
You can specify stack_info independently of exc_info, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:


This mimics the  which is used when
displaying exception frames.
The third keyword argument is extra which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:


would print something like


The keys in the dictionary passed in extra should not clash with the keys used
by the logging system. (See the  documentation for more
information on which keys are used by the logging system.)
If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the  has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the extra dictionary with these keys.
While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
s would be used with particular s.

New in version 3.2: The stack_info parameter was added.


Changed in version 3.5: The exc_info parameter can now accept exception instances.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .

Note
There is an obsolete method  which is functionally
identical to . As  is deprecated, please do not use
it - use  instead.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(lvl, msg, *args, **kwargs)¶
Logs a message with integer level lvl on this logger. The other arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for . Exception info is added to the logging
message. This method should only be called from an exception handler.



(filter)¶
Adds the specified filter filter to this logger.



(filter)¶
Removes the specified filter filter from this logger.



(record)¶
Applies this logger’s filters to the record and returns a true value if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be processed (passed to handlers). If one returns a false value, no
further processing of the record occurs.



(hdlr)¶
Adds the specified handler hdlr to this logger.



(hdlr)¶
Removes the specified handler hdlr from this logger.



(stack_info=False)¶
Finds the caller’s source filename and line number. Returns the filename, line
number, function name and stack information as a 4-element tuple. The stack
information is returned as  unless stack_info is .



(record)¶
Handles a record by passing it to all handlers associated with this logger and
its ancestors (until a false value of propagate is found). This method is used
for unpickled records received from a socket, as well as those created locally.
Logger-level filtering is applied using .



(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)¶
This is a factory method which can be overridden in subclasses to create
specialized  instances.



()¶
Checks to see if this logger has any handlers configured. This is done by
looking for handlers in this logger and its parents in the logger hierarchy.
Returns  if a handler was found, else . The method stops searching
up the hierarchy whenever a logger with the ‘propagate’ attribute set to
false is found - that will be the last logger which is checked for the
existence of handlers.

New in version 3.2.



Changed in version 3.7: Loggers can now be pickled and unpickled.




Logging Levels¶
The numeric values of logging levels are given in the following table. These are
primarily of interest if you want to define your own levels, and need them to
have specific values relative to the predefined levels. If you define a level
with the same numeric value, it overwrites the predefined value; the predefined
name is lost.






Level
Numeric value




50


40


30


20


10


0





Handler Objects¶
Handlers have the following attributes and methods. Note that 
is never instantiated directly; this class acts as a base for more useful
subclasses. However, the  method in subclasses needs to call
.


class ¶


(level=NOTSET)¶
Initializes the  instance by setting its level, setting the list
of filters to the empty list and creating a lock (using ) for
serializing access to an I/O mechanism.



()¶
Initializes a thread lock which can be used to serialize access to underlying
I/O functionality which may not be threadsafe.



()¶
Acquires the thread lock created with .



()¶
Releases the thread lock acquired with .



(level)¶
Sets the threshold for this handler to level. Logging messages which are
less severe than level will be ignored. When a handler is created, the
level is set to  (which causes all messages to be
processed).
See Logging Levels for a list of levels.

Changed in version 3.2: The level parameter now accepts a string representation of the
level such as ‘INFO’ as an alternative to the integer constants
such as .




(fmt)¶
Sets the  for this handler to fmt.



(filter)¶
Adds the specified filter filter to this handler.



(filter)¶
Removes the specified filter filter from this handler.



(record)¶
Applies this handler’s filters to the record and returns a true value if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be emitted. If one returns a false value, the handler will not emit the
record.



()¶
Ensure all logging output has been flushed. This version does nothing and is
intended to be implemented by subclasses.



()¶
Tidy up any resources used by the handler. This version does no output but
removes the handler from an internal list of handlers which is closed when
 is called. Subclasses should ensure that this gets called
from overridden  methods.



(record)¶
Conditionally emits the specified logging record, depending on filters which may
have been added to the handler. Wraps the actual emission of the record with
acquisition/release of the I/O thread lock.



(record)¶
This method should be called from handlers when an exception is encountered
during an  call. If the module-level attribute
 is , exceptions get silently ignored. This is
what is mostly wanted for a logging system - most users will not care about
errors in the logging system, they are more interested in application
errors. You could, however, replace this with a custom handler if you wish.
The specified record is the one which was being processed when the exception
occurred. (The default value of  is , as that is
more useful during development).



(record)¶
Do formatting for a record - if a formatter is set, use it. Otherwise, use the
default formatter for the module.



(record)¶
Do whatever it takes to actually log the specified logging record. This version
is intended to be implemented by subclasses and so raises a
.


For a list of handlers included as standard, see .


Formatter Objects¶
 objects have the following attributes and methods. They are
responsible for converting a  to (usually) a string which can
be interpreted by either a human or an external system. The base
 allows a formatting string to be specified. If none is
supplied, the default value of  is used, which just includes
the message in the logging call. To have additional items of information in the
formatted output (such as a timestamp), keep reading.
A Formatter can be initialized with a format string which makes use of knowledge
of the  attributes - such as the default value mentioned above
making use of the fact that the user’s message and arguments are pre-formatted
into a ’s message attribute.  This format string contains
standard Python %-style mapping keys. See section printf-style String Formatting
for more information on string formatting.
The useful mapping keys in a  are given in the section on
LogRecord attributes.


class (fmt=None, datefmt=None, style='%')¶
Returns a new instance of the  class.  The instance is
initialized with a format string for the message as a whole, as well as a
format string for the date/time portion of a message.  If no fmt is
specified,  is used.  If no datefmt is specified, a format
is used which is described in the  documentation.
The style parameter can be one of ‘%’, ‘{‘ or ‘$’ and determines how
the format string will be merged with its data: using one of %-formatting,
 or . See Using particular formatting styles throughout your application
for more information on using {- and $-formatting for log messages.

Changed in version 3.2: The style parameter was added.



(record)¶
The record’s attribute dictionary is used as the operand to a string
formatting operation. Returns the resulting string. Before formatting the
dictionary, a couple of preparatory steps are carried out. The message
attribute of the record is computed using msg % args. If the
formatting string contains ,  is called
to format the event time. If there is exception information, it is
formatted using  and appended to the message. Note
that the formatted exception information is cached in attribute
exc_text. This is useful because the exception information can be
pickled and sent across the wire, but you should be careful if you have
more than one  subclass which customizes the formatting
of exception information. In this case, you will have to clear the cached
value after a formatter has done its formatting, so that the next
formatter to handle the event doesn’t use the cached value but
recalculates it afresh.
If stack information is available, it’s appended after the exception
information, using  to transform it if necessary.



(record, datefmt=None)¶
This method should be called from  by a formatter which
wants to make use of a formatted time. This method can be overridden in
formatters to provide for any specific requirement, but the basic behavior
is as follows: if datefmt (a string) is specified, it is used with
 to format the creation time of the
record. Otherwise, the format ‘%Y-%m-%d %H:%M:%S,uuu’ is used, where the
uuu part is a millisecond value and the other letters are as per the
 documentation.  An example time in this format is
.  The resulting string is returned.
This function uses a user-configurable function to convert the creation
time to a tuple. By default,  is used; to change
this for a particular formatter instance, set the  attribute
to a function with the same signature as  or
. To change it for all formatters, for example if you
want all logging times to be shown in GMT, set the 
attribute in the  class.

Changed in version 3.3: Previously, the default format was hard-coded as in this example:
 where the part before the comma is
handled by a strptime format string (), and the
part after the comma is a millisecond value. Because strptime does not
have a format placeholder for milliseconds, the millisecond value is
appended using another format string,  — and both of these
format strings have been hardcoded into this method. With the change,
these strings are defined as class-level attributes which can be
overridden at the instance level when desired. The names of the
attributes are  (for the strptime format string)
and  (for appending the millisecond value).




(exc_info)¶
Formats the specified exception information (a standard exception tuple as
returned by ) as a string. This default implementation
just uses . The resulting string is
returned.



(stack_info)¶
Formats the specified stack information (a string as returned by
, but with the last newline removed) as a
string. This default implementation just returns the input value.




Filter Objects¶
 can be used by  and  for more sophisticated
filtering than is provided by levels. The base filter class only allows events
which are below a certain point in the logger hierarchy. For example, a filter
initialized with ‘A.B’ will allow events logged by loggers ‘A.B’, ‘A.B.C’,
‘A.B.C.D’, ‘A.B.D’ etc. but not ‘A.BB’, ‘B.A.B’ etc. If initialized with the
empty string, all events are passed.


class (name='')¶
Returns an instance of the  class. If name is specified, it
names a logger which, together with its children, will have its events allowed
through the filter. If name is the empty string, allows every event.


(record)¶
Is the specified record to be logged? Returns zero for no, nonzero for
yes. If deemed appropriate, the record may be modified in-place by this
method.


Note that filters attached to handlers are consulted before an event is
emitted by the handler, whereas filters attached to loggers are consulted
whenever an event is logged (using , ,
etc.), before sending an event to handlers. This means that events which have
been generated by descendant loggers will not be filtered by a logger’s filter
setting, unless the filter has also been applied to those descendant loggers.
You don’t actually need to subclass : you can pass any instance
which has a  method with the same semantics.

Changed in version 3.2: You don’t need to create specialized  classes, or use other
classes with a  method: you can use a function (or other
callable) as a filter. The filtering logic will check to see if the filter
object has a  attribute: if it does, it’s assumed to be a
 and its  method is called. Otherwise, it’s
assumed to be a callable and called with the record as the single
parameter. The returned value should conform to that returned by
.

Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which is
processed by the handler or logger they’re attached to: this can be useful if
you want to do things like counting how many records were processed by a
particular logger or handler, or adding, changing or removing attributes in
the LogRecord being processed. Obviously changing the LogRecord needs to be
done with some care, but it does allow the injection of contextual information
into logs (see Using Filters to impart contextual information).


LogRecord Objects¶
 instances are created automatically by the 
every time something is logged, and can be created manually via
 (for example, from a pickled event received over the
wire).


class (name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None)¶
Contains all the information pertinent to the event being logged.
The primary information is passed in  and , which
are combined using  to create the  field of the
record.




Parameters:
name – The name of the logger used to log the event represented by
this LogRecord. Note that this name will always have this
value, even though it may be emitted by a handler attached to
a different (ancestor) logger.
level – The numeric level of the logging event (one of DEBUG, INFO etc.)
Note that this is converted to two attributes of the LogRecord:
 for the numeric value and  for the
corresponding level name.
pathname – The full pathname of the source file where the logging call
was made.
lineno – The line number in the source file where the logging call was
made.
msg – The event description message, possibly a format string with
placeholders for variable data.
args – Variable data to merge into the msg argument to obtain the
event description.
exc_info – An exception tuple with the current exception information,
or  if no exception information is available.
func – The name of the function or method from which the logging call
was invoked.
sinfo – A text string representing stack information from the base of
the stack in the current thread, up to the logging call.







()¶
Returns the message for this  instance after merging any
user-supplied arguments with the message. If the user-supplied message
argument to the logging call is not a string,  is called on it to
convert it to a string. This allows use of user-defined classes as
messages, whose  method can return the actual format string to
be used.


Changed in version 3.2: The creation of a  has been made more configurable by
providing a factory which is used to create the record. The factory can be
set using  and 
(see this for the factory’s signature).

This functionality can be used to inject your own values into a
LogRecord at creation time. You can use the following pattern:


With this pattern, multiple factories could be chained, and as long
as they don’t overwrite each other’s attributes or unintentionally
overwrite the standard attributes listed above, there should be no
surprises.



LogRecord attributes¶
The LogRecord has a number of attributes, most of which are derived from the
parameters to the constructor. (Note that the names do not always correspond
exactly between the LogRecord constructor parameters and the LogRecord
attributes.) These attributes can be used to merge data from the record into
the format string. The following table lists (in alphabetical order) the
attribute names, their meanings and the corresponding placeholder in a %-style
format string.
If you are using {}-formatting (), you can use
 as the placeholder in the format string. If you are using
$-formatting (), use the form . In
both cases, of course, replace  with the actual attribute name
you want to use.
In the case of {}-formatting, you can specify formatting flags by placing them
after the attribute name, separated from it with a colon. For example: a
placeholder of  would format a millisecond value of  as
. Refer to the  documentation for full details on
the options available to you.







Attribute name
Format
Description



args
You shouldn’t need to
format this yourself.
The tuple of arguments merged into  to
produce , or a dict whose values
are used for the merge (when there is only one
argument, and it is a dictionary).

asctime

Human-readable time when the
 was created.  By default
this is of the form ‘2003-07-08 16:49:45,896’
(the numbers after the comma are millisecond
portion of the time).

created

Time when the  was created
(as returned by ).

exc_info
You shouldn’t need to
format this yourself.
Exception tuple (à la ) or,
if no exception has occurred, .

filename

Filename portion of .

funcName

Name of function containing the logging call.

levelname

Text logging level for the message
(, , ,
, ).

levelno

Numeric logging level for the message
(, ,
, ,
).

lineno

Source line number where the logging call was
issued (if available).

message

The logged message, computed as . This is set when
 is invoked.

module

Module (name portion of ).

msecs

Millisecond portion of the time when the
 was created.

msg
You shouldn’t need to
format this yourself.
The format string passed in the original
logging call. Merged with  to
produce , or an arbitrary object
(see Using arbitrary objects as messages).

name

Name of the logger used to log the call.

pathname

Full pathname of the source file where the
logging call was issued (if available).

process

Process ID (if available).

processName

Process name (if available).

relativeCreated

Time in milliseconds when the LogRecord was
created, relative to the time the logging
module was loaded.

stack_info
You shouldn’t need to
format this yourself.
Stack frame information (where available)
from the bottom of the stack in the current
thread, up to and including the stack frame
of the logging call which resulted in the
creation of this record.

thread

Thread ID (if available).

threadName

Thread name (if available).




Changed in version 3.1: processName was added.



LoggerAdapter Objects¶
 instances are used to conveniently pass contextual
information into logging calls. For a usage example, see the section on
adding contextual information to your logging output.


class (logger, extra)¶
Returns an instance of  initialized with an
underlying  instance and a dict-like object.


(msg, kwargs)¶
Modifies the message and/or keyword arguments passed to a logging call in
order to insert contextual information. This implementation takes the object
passed as extra to the constructor and adds it to kwargs using key
‘extra’. The return value is a (msg, kwargs) tuple which has the
(possibly modified) versions of the arguments passed in.


In addition to the above,  supports the following
methods of : , ,
, , ,
, , ,
,  and
. These methods have the same signatures as their
counterparts in , so you can use the two types of instances
interchangeably.

Changed in version 3.2: The , ,
 and  methods were added
to .  These methods delegate to the underlying logger.



Thread Safety¶
The logging module is intended to be thread-safe without any special work
needing to be done by its clients. It achieves this though using threading
locks; there is one lock to serialize access to the module’s shared data, and
each handler also creates a lock to serialize access to its underlying I/O.
If you are implementing asynchronous signal handlers using the 
module, you may not be able to use logging from within such handlers. This is
because lock implementations in the  module are not always
re-entrant, and so cannot be invoked from such signal handlers.


Module-Level Functions¶
In addition to the classes described above, there are a number of module-level
functions.


(name=None)¶
Return a logger with the specified name or, if name is , return a
logger which is the root logger of the hierarchy. If specified, the name is
typically a dot-separated hierarchical name like ‘a’, ‘a.b’ or ‘a.b.c.d’.
Choice of these names is entirely up to the developer who is using logging.
All calls to this function with a given name return the same logger instance.
This means that logger instances never need to be passed between different parts
of an application.



()¶
Return either the standard  class, or the last class passed to
. This function may be called from within a new class
definition, to ensure that installing a customized  class will
not undo customizations already applied by other code. For example:





()¶
Return a callable which is used to create a .

New in version 3.2: This function has been provided, along with ,
to allow developers more control over how the 
representing a logging event is constructed.

See  for more information about the how the
factory is called.



(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The msg is the
message format string, and the args are the arguments which are merged into
msg using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
There are three keyword arguments in kwargs which are inspected: exc_info
which, if it does not evaluate as false, causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
) or an exception instance is provided, it is used;
otherwise,  is called to get the exception information.
The second optional keyword argument is stack_info, which defaults to
. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying exc_info: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.
You can specify stack_info independently of exc_info, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:


This mimics the  which is used when
displaying exception frames.
The third optional keyword argument is extra which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:


would print something like:


The keys in the dictionary passed in extra should not clash with the keys used
by the logging system. (See the  documentation for more
information on which keys are used by the logging system.)
If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the  has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the extra dictionary with these keys.
While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
s would be used with particular s.

New in version 3.2: The stack_info parameter was added.




(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The arguments
are interpreted as for .

Note
There is an obsolete function  which is functionally
identical to . As  is deprecated, please do not use
it - use  instead.




(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The arguments
are interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on the root logger. The arguments are
interpreted as for . Exception info is added to the logging
message. This function should only be called from an exception handler.



(level, msg, *args, **kwargs)¶
Logs a message with level level on the root logger. The other arguments are
interpreted as for .

Note
The above module-level convenience functions, which delegate to the
root logger, call  to ensure that at least one handler
is available. Because of this, they should not be used in threads,
in versions of Python earlier than 2.7.1 and 3.2, unless at least one
handler has been added to the root logger before the threads are
started. In earlier versions of Python, due to a thread safety shortcoming
in , this can (under rare circumstances) lead to
handlers being added multiple times to the root logger, which can in turn
lead to multiple messages for the same event.




(lvl=CRITICAL)¶
Provides an overriding level lvl for all loggers which takes precedence over
the logger’s own level. When the need arises to temporarily throttle logging
output down across the whole application, this function can be useful. Its
effect is to disable all logging calls of severity lvl and below, so that
if you call it with a value of INFO, then all INFO and DEBUG events would be
discarded, whereas those of severity WARNING and above would be processed
according to the logger’s effective level. If
 is called, it effectively removes this
overriding level, so that logging output again depends on the effective
levels of individual loggers.
Note that if you have defined any custom logging level higher than
 (this is not recommended), you won’t be able to rely on the
default value for the lvl parameter, but will have to explicitly supply a
suitable value.

Changed in version 3.7: The lvl parameter was defaulted to level . See Issue
#28524 for more information about this change.




(lvl, levelName)¶
Associates level lvl with text levelName in an internal dictionary, which is
used to map numeric levels to a textual representation, for example when a
 formats a message. This function can also be used to define
your own levels. The only constraints are that all levels used must be
registered using this function, levels should be positive integers and they
should increase in increasing order of severity.

Note
If you are thinking of defining your own levels, please see the
section on Custom Levels.




(lvl)¶
Returns the textual representation of logging level lvl. If the level is one
of the predefined levels , , ,
 or  then you get the corresponding string. If you
have associated levels with names using  then the name you
have associated with lvl is returned. If a numeric value corresponding to one
of the defined levels is passed in, the corresponding string representation is
returned. Otherwise, the string ‘Level %s’ % lvl is returned.

Note
Levels are internally integers (as they need to be compared in the
logging logic). This function is used to convert between an integer level
and the level name displayed in the formatted log output by means of the
 format specifier (see LogRecord attributes).


Changed in version 3.4: In Python versions earlier than 3.4, this function could also be passed a
text level, and would return the corresponding numeric value of the level.
This undocumented behaviour was considered a mistake, and was removed in
Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility.




(attrdict)¶
Creates and returns a new  instance whose attributes are
defined by attrdict. This function is useful for taking a pickled
 attribute dictionary, sent over a socket, and reconstituting
it as a  instance at the receiving end.



(**kwargs)¶
Does basic configuration for the logging system by creating a
 with a default  and adding it to the
root logger. The functions , , ,
 and  will call  automatically
if no handlers are defined for the root logger.
This function does nothing if the root logger already has handlers
configured for it.

Note
This function should be called from the main thread
before other threads are started. In versions of Python prior to
2.7.1 and 3.2, if this function is called from multiple threads,
it is possible (in rare circumstances) that a handler will be added
to the root logger more than once, leading to unexpected results
such as messages being duplicated in the log.

The following keyword arguments are supported.






Format
Description



filename
Specifies that a FileHandler be created,
using the specified filename, rather than a
StreamHandler.

filemode
If filename is specified, open the file
in this mode. Defaults
to .

format
Use the specified format string for the
handler.

datefmt
Use the specified date/time format, as
accepted by .

style
If format is specified, use this style
for the format string. One of ,
 or  for printf-style,
 or
 respectively.
Defaults to .

level
Set the root logger level to the specified
level.

stream
Use the specified stream to initialize the
StreamHandler. Note that this argument is
incompatible with filename - if both
are present, a  is raised.

handlers
If specified, this should be an iterable of
already created handlers to add to the root
logger. Any handlers which don’t already
have a formatter set will be assigned the
default formatter created in this function.
Note that this argument is incompatible
with filename or stream - if both
are present, a  is raised.




Changed in version 3.2: The style argument was added.


Changed in version 3.3: The handlers argument was added. Additional checks were added to
catch situations where incompatible arguments are specified (e.g.
handlers together with stream or filename, or stream
together with filename).




()¶
Informs the logging system to perform an orderly shutdown by flushing and
closing all handlers. This should be called at application exit and no
further use of the logging system should be made after this call.



(klass)¶
Tells the logging system to use the class klass when instantiating a logger.
The class should define  such that only a name argument is
required, and the  should call . This
function is typically called before any loggers are instantiated by applications
which need to use custom logger behavior.



(factory)¶
Set a callable which is used to create a .




Parameters:factory – The factory callable to be used to instantiate a log record.




New in version 3.2: This function has been provided, along with , to
allow developers more control over how the  representing
a logging event is constructed.

The factory has the following signature:






name:The logger name.

level:The logging level (numeric).

fn:The full pathname of the file where the logging call was made.

lno:The line number in the file where the logging call was made.

msg:The logging message.

args:The arguments for the logging message.

exc_info:An exception tuple, or .

func:The name of the function or method which invoked the logging
call.

sinfo:A stack traceback such as is provided by
, showing the call hierarchy.

kwargs:Additional keyword arguments.







Module-Level Attributes¶


¶
A “handler of last resort” is available through this attribute. This
is a  writing to  with a level of
, and is used to handle logging events in the absence of any
logging configuration. The end result is to just print the message to
. This replaces the earlier error message saying that
“no handlers could be found for logger XYZ”. If you need the earlier
behaviour for some reason,  can be set to .

New in version 3.2.




Integration with the warnings module¶
The  function can be used to integrate 
with the  module.


(capture)¶
This function is used to turn the capture of warnings by logging on and
off.
If capture is , warnings issued by the  module will
be redirected to the logging system. Specifically, a warning will be
formatted using  and the resulting string
logged to a logger named  with a severity of .
If capture is , the redirection of warnings to the logging system
will stop, and warnings will be redirected to their original destinations
(i.e. those in effect before  was called).


See also

Module 
Configuration API for the logging module.
Module 
Useful handlers included with the logging module.
PEP 282 - A Logging System
The proposal which described this feature for inclusion in the Python standard
library.
Original Python logging package
This is the original source for the  package.  The version of the
package available from this site is suitable for use with Python 1.5.2, 2.1.x
and 2.2.x, which do not include the  package in the standard
library.



