link:
library/stdtypes.html#hashing-of-numeric-types

docs:

Hashing of numeric types¶
For numbers  and , possibly of different types, it’s a requirement
that  whenever  (see the 
method documentation for more details).  For ease of implementation and
efficiency across a variety of numeric types (including ,
,  and )
Python’s hash for numeric types is based on a single mathematical function
that’s defined for any rational number, and hence applies to all instances of
 and , and all finite instances of
 and .  Essentially, this function is
given by reduction modulo  for a fixed prime .  The value of  is
made available to Python as the  attribute of
.

CPython implementation detail: Currently, the prime used is  on machines with 32-bit C
longs and  on machines with 64-bit C longs.

Here are the rules in detail:

If  is a nonnegative rational number and  is not divisible
by , define  as , where  gives the inverse of  modulo .
If  is a nonnegative rational number and  is
divisible by  (but  is not) then  has no inverse
modulo  and the rule above doesn’t apply; in this case define
 to be the constant value .
If  is a negative rational number define 
as .  If the resulting hash is , replace it with
.
The particular values , 
and  are used as hash values for positive
infinity, negative infinity, or nans (respectively).  (All hashable
nans have the same hash value.)
For a  number , the hash values of the real
and imaginary parts are combined by computing , reduced modulo
 so that it lies in
.  Again, if the result is , it’s replaced with .

To clarify the above rules, here’s some example Python code,
equivalent to the built-in hash, for computing the hash of a rational
number, , or :


