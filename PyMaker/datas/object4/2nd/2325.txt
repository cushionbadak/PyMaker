link:
library/pickle.html#pickling-class-instances

docs:

Pickling Class Instances¶
In this section, we describe the general mechanisms available to you to define,
customize, and control how class instances are pickled and unpickled.
In most cases, no additional code is needed to make instances picklable.  By
default, pickle will retrieve the class and the attributes of an instance via
introspection. When a class instance is unpickled, its  method
is usually not invoked.  The default behaviour first creates an uninitialized
instance and then restores the saved attributes.  The following code shows an
implementation of this behaviour:


Classes can alter the default behaviour by providing one or several special
methods:


()¶
In protocols 2 and newer, classes that implements the
 method can dictate the values passed to the
 method upon unpickling.  The method must return a pair
 where args is a tuple of positional arguments
and kwargs a dictionary of named arguments for constructing the
object.  Those will be passed to the  method upon
unpickling.
You should implement this method if the  method of your
class requires keyword-only arguments.  Otherwise, it is recommended for
compatibility to implement .

Changed in version 3.6:  is now used in protocols 2 and 3.




()¶
This method serves a similar purpose as , but
supports only positional arguments.  It must return a tuple of arguments
 which will be passed to the  method upon unpickling.
 will not be called if  is
defined.

Changed in version 3.6: Before Python 3.6,  was called instead of
 in protocols 2 and 3.




()¶
Classes can further influence how their instances are pickled; if the class
defines the method , it is called and the returned object
is pickled as the contents for the instance, instead of the contents of the
instance’s dictionary.  If the  method is absent, the
instance’s  is pickled as usual.



(state)¶
Upon unpickling, if the class defines , it is called with
the unpickled state.  In that case, there is no requirement for the state
object to be a dictionary.  Otherwise, the pickled state must be a dictionary
and its items are assigned to the new instance’s dictionary.

Note
If  returns a false value, the 
method will not be called upon unpickling.


Refer to the section Handling Stateful Objects for more information about how to use
the methods  and .

Note
At unpickling time, some methods like ,
, or  may be called upon the
instance.  In case those methods rely on some internal invariant being
true, the type should implement  or
 to establish such an invariant; otherwise,
neither  nor  will be called.

As we shall see, pickle does not use directly the methods described above.  In
fact, these methods are part of the copy protocol which implements the
 special method.  The copy protocol provides a unified
interface for retrieving the data necessary for pickling and copying
objects. [4]
Although powerful, implementing  directly in your classes is
error prone.  For this reason, class designers should use the high-level
interface (i.e., ,  and
) whenever possible.  We will show, however, cases where
using  is the only option or leads to more efficient pickling
or both.


()¶
The interface is currently defined as follows.  The  method
takes no argument and shall return either a string or preferably a tuple (the
returned object is often referred to as the “reduce value”).
If a string is returned, the string should be interpreted as the name of a
global variable.  It should be the object’s local name relative to its
module; the pickle module searches the module namespace to determine the
object’s module.  This behaviour is typically useful for singletons.
When a tuple is returned, it must be between two and five items long.
Optional items can either be omitted, or  can be provided as their
value.  The semantics of each item are in order:

A callable object that will be called to create the initial version of the
object.
A tuple of arguments for the callable object.  An empty tuple must be given
if the callable does not accept any argument.
Optionally, the object’s state, which will be passed to the object’s
 method as previously described.  If the object has no
such method then, the value must be a dictionary and it will be added to
the object’s  attribute.
Optionally, an iterator (and not a sequence) yielding successive items.
These items will be appended to the object either using
 or, in batch, using .
This is primarily used for list subclasses, but may be used by other
classes as long as they have  and  methods with
the appropriate signature.  (Whether  or  is
used depends on which pickle protocol version is used as well as the number
of items to append, so both must be supported.)
Optionally, an iterator (not a sequence) yielding successive key-value
pairs.  These items will be stored to the object using .  This is primarily used for dictionary subclasses, but may be used
by other classes as long as they implement .




(protocol)¶
Alternatively, a  method may be defined.  The only
difference is this method should take a single integer argument, the protocol
version.  When defined, pickle will prefer it over the 
method.  In addition,  automatically becomes a synonym for
the extended version.  The main use for this method is to provide
backwards-compatible reduce values for older Python releases.


Persistence of External Objects¶
For the benefit of object persistence, the  module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a persistent ID, which should be either a string of
alphanumeric characters (for protocol 0) [5] or just an arbitrary object (for
any newer protocol).
The resolution of such persistent IDs is not defined by the 
module; it will delegate this resolution to the user defined methods on the
pickler and unpickler,  and
 respectively.
To pickle objects that have an external persistent id, the pickler must have a
custom  method that takes an object as an
argument and returns either  or the persistent id for that object.
When  is returned, the pickler simply pickles the object as normal.
When a persistent ID string is returned, the pickler will pickle that object,
along with a marker so that the unpickler will recognize it as a persistent ID.
To unpickle external objects, the unpickler must have a custom
 method that takes a persistent ID object and
returns the referenced object.
Here is a comprehensive example presenting how persistent ID can be used to
pickle external objects by reference.




Dispatch Tables¶
If one wants to customize pickling of some classes without disturbing
any other code which depends on pickling, then one can create a
pickler with a private dispatch table.
The global dispatch table managed by the  module is
available as .  Therefore, one may
choose to use a modified copy of  as a
private dispatch table.
For example


creates an instance of  with a private dispatch
table which handles the  class specially.  Alternatively,
the code


does the same, but all instances of  will by default
share the same dispatch table.  The equivalent code using the
 module is




Handling Stateful Objects¶
Here’s an example that shows how to modify pickling behavior for a class.
The  class opens a text file, and returns the line number and
line contents each time its  method is called. If a
 instance is pickled, all attributes except the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The  and
 methods are used to implement this behavior.


A sample usage might be something like this:



