link:
reference/datamodel.html#the-standard-type-hierarchy

docs:

3.2. The standard type hierarchy¶
Below is a list of the types that are built into Python.  Extension modules
(written in C, Java, or other languages, depending on the implementation) can
define additional types.  Future versions of Python may add types to the type
hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.),
although such additions will often be provided via the standard library instead.
Some of the type descriptions below contain a paragraph listing ‘special
attributes.’  These are attributes that provide access to the implementation and
are not intended for general use.  Their definition may change in the future.

None
This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name . It is used to signify the
absence of a value in many situations, e.g., it is returned from functions that
don’t explicitly return anything. Its truth value is false.

NotImplemented
This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name . Numeric methods
and rich comparison methods should return this value if they do not implement the
operation for the operands provided.  (The interpreter will then try the
reflected operation, or some other fallback, depending on the operator.)  Its
truth value is true.
See
Implementing the arithmetic operations
for more details.

Ellipsis
This type has a single value.  There is a single object with this value. This
object is accessed through the literal  or the built-in name
.  Its truth value is true.


These are created by numeric literals and returned as results by arithmetic
operators and arithmetic built-in functions.  Numeric objects are immutable;
once created their value never changes.  Python numbers are of course strongly
related to mathematical numbers, but subject to the limitations of numerical
representation in computers.
Python distinguishes between integers, floating point numbers, and complex
numbers:


These represent elements from the mathematical set of integers (positive and
negative).
There are two types of integers:
Integers ()

These represent numbers in an unlimited range, subject to available (virtual)
memory only.  For the purpose of shift and mask operations, a binary
representation is assumed, and negative numbers are represented in a variant of
2’s complement which gives the illusion of an infinite string of sign bits
extending to the left.

Booleans ()
These represent the truth values False and True.  The two objects representing
the values  and  are the only Boolean objects. The Boolean type is a
subtype of the integer type, and Boolean values behave like the values 0 and 1,
respectively, in almost all contexts, the exception being that when converted to
a string, the strings  or  are returned, respectively.


The rules for integer representation are intended to give the most meaningful
interpretation of shift and mask operations involving negative integers.

 ()
These represent machine-level double precision floating point numbers. You are
at the mercy of the underlying machine architecture (and C or Java
implementation) for the accepted range and handling of overflow. Python does not
support single-precision floating point numbers; the savings in processor and
memory usage that are usually the reason for using these are dwarfed by the
overhead of using objects in Python, so there is no reason to complicate the
language with two kinds of floating point numbers.

 ()
These represent complex numbers as a pair of machine-level double precision
floating point numbers.  The same caveats apply as for floating point numbers.
The real and imaginary parts of a complex number  can be retrieved through
the read-only attributes  and .



Sequences
These represent finite ordered sets indexed by non-negative numbers. The
built-in function  returns the number of items of a sequence. When
the length of a sequence is n, the index set contains the numbers 0, 1,
…, n-1.  Item i of sequence a is selected by .
Sequences also support slicing:  selects all items with index k such
that i  k  j.  When used as an expression, a slice is a
sequence of the same type.  This implies that the index set is renumbered so
that it starts at 0.
Some sequences also support “extended slicing” with a third “step” parameter:
 selects all items of a with index x where , n
  and i  x  j.
Sequences are distinguished according to their mutability:

Immutable sequences
An object of an immutable sequence type cannot change once it is created.  (If
the object contains references to other objects, these other objects may be
mutable and may be changed; however, the collection of objects directly
referenced by an immutable object cannot change.)
The following types are immutable sequences:

Strings
A string is a sequence of values that represent Unicode code points.
All the code points in the range  can be
represented in a string.  Python doesn’t have a  type;
instead, every code point in the string is represented as a string
object with length .  The built-in function 
converts a code point from its string form to an integer in the
range ;  converts an integer in the range
 to the corresponding length  string object.
 can be used to convert a  to
 using the given text encoding, and
 can be used to achieve the opposite.

Tuples
The items of a tuple are arbitrary Python objects. Tuples of two or
more items are formed by comma-separated lists of expressions.  A tuple
of one item (a ‘singleton’) can be formed by affixing a comma to an
expression (an expression by itself does not create a tuple, since
parentheses must be usable for grouping of expressions).  An empty
tuple can be formed by an empty pair of parentheses.

Bytes
A bytes object is an immutable array.  The items are 8-bit bytes,
represented by integers in the range 0 <= x < 256.  Bytes literals
(like ) and the built-in  constructor
can be used to create bytes objects.  Also, bytes objects can be
decoded to strings via the  method.



Mutable sequences
Mutable sequences can be changed after they are created.  The subscription and
slicing notations can be used as the target of assignment and 
(delete) statements.
There are currently two intrinsic mutable sequence types:

Lists
The items of a list are arbitrary Python objects.  Lists are formed by
placing a comma-separated list of expressions in square brackets. (Note
that there are no special cases needed to form lists of length 0 or 1.)

Byte Arrays
A bytearray object is a mutable array. They are created by the built-in
 constructor.  Aside from being mutable
(and hence unhashable), byte arrays otherwise provide the same interface
and functionality as immutable  objects.


The extension module  provides an additional example of a
mutable sequence type, as does the  module.



Set types
These represent unordered, finite sets of unique, immutable objects. As such,
they cannot be indexed by any subscript. However, they can be iterated over, and
the built-in function  returns the number of items in a set. Common
uses for sets are fast membership testing, removing duplicates from a sequence,
and computing mathematical operations such as intersection, union, difference,
and symmetric difference.
For set elements, the same immutability rules apply as for dictionary keys. Note
that numeric types obey the normal rules for numeric comparison: if two numbers
compare equal (e.g.,  and ), only one of them can be contained in a
set.
There are currently two intrinsic set types:

Sets
These represent a mutable set. They are created by the built-in 
constructor and can be modified afterwards by several methods, such as
.

Frozen sets
These represent an immutable set.  They are created by the built-in
 constructor.  As a frozenset is immutable and
hashable, it can be used again as an element of another set, or as
a dictionary key.



Mappings
These represent finite sets of objects indexed by arbitrary index sets. The
subscript notation  selects the item indexed by  from the mapping
; this can be used in expressions and as the target of assignments or
 statements. The built-in function  returns the number
of items in a mapping.
There is currently a single intrinsic mapping type:

Dictionaries
These represent finite sets of objects indexed by nearly arbitrary values.  The
only types of values not acceptable as keys are values containing lists or
dictionaries or other mutable types that are compared by value rather than by
object identity, the reason being that the efficient implementation of
dictionaries requires a key’s hash value to remain constant. Numeric types used
for keys obey the normal rules for numeric comparison: if two numbers compare
equal (e.g.,  and ) then they can be used interchangeably to index
the same dictionary entry.
Dictionaries are mutable; they can be created by the  notation (see
section Dictionary displays).
The extension modules  and  provide
additional examples of mapping types, as does the 
module.



Callable types
These are the types to which the function call operation (see section
Calls) can be applied:

User-defined functions
A user-defined function object is created by a function definition (see
section Function definitions).  It should be called with an argument list
containing the same number of items as the function’s formal parameter
list.
Special attributes:







Attribute
Meaning
 




The function’s documentation
string, or  if
unavailable; not inherited by
subclasses.
Writable


The function’s name.
Writable


The function’s
qualified name.

New in version 3.3.


Writable


The name of the module the
function was defined in, or
 if unavailable.
Writable


A tuple containing default
argument values for those
arguments that have defaults,
or  if no arguments
have a default value.
Writable


The code object representing
the compiled function body.
Writable


A reference to the dictionary
that holds the function’s
global variables — the
global namespace of the
module in which the function
was defined.
Read-only


The namespace supporting
arbitrary function
attributes.
Writable


 or a tuple of cells
that contain bindings for the
function’s free variables.
See below for information on
the 
attribute.
Read-only


A dict containing annotations
of parameters.  The keys of
the dict are the parameter
names, and  for
the return annotation, if
provided.
Writable


A dict containing defaults
for keyword-only parameters.
Writable



Most of the attributes labelled “Writable” check the type of the assigned value.
Function objects also support getting and setting arbitrary attributes, which
can be used, for example, to attach metadata to functions.  Regular attribute
dot-notation is used to get and set such attributes. Note that the current
implementation only supports function attributes on user-defined functions.
Function attributes on built-in functions may be supported in the future.
A cell object has the attribute . This can be used to get
the value of the cell, as well as set the value.
Additional information about a function’s definition can be retrieved from its
code object; see the description of internal types below.

Instance methods
An instance method object combines a class, a class instance and any
callable object (normally a user-defined function).
Special read-only attributes:  is the class instance object,
 is the function object;  is the method’s
documentation (same as );  is the
method name (same as );  is the
name of the module the method was defined in, or  if unavailable.
Methods also support accessing (but not setting) the arbitrary function
attributes on the underlying function object.
User-defined method objects may be created when getting an attribute of a
class (perhaps via an instance of that class), if that attribute is a
user-defined function object or a class method object.
When an instance method object is created by retrieving a user-defined
function object from a class via one of its instances, its
 attribute is the instance, and the method object is said
to be bound.  The new method’s  attribute is the original
function object.
When a user-defined method object is created by retrieving another method
object from a class or instance, the behaviour is the same as for a
function object, except that the  attribute of the new
instance is not the original method object but its 
attribute.
When an instance method object is created by retrieving a class method
object from a class or instance, its  attribute is the
class itself, and its  attribute is the function object
underlying the class method.
When an instance method object is called, the underlying function
() is called, inserting the class instance
() in front of the argument list.  For instance, when
 is a class which contains a definition for a function
, and  is an instance of , calling  is
equivalent to calling .
When an instance method object is derived from a class method object, the
“class instance” stored in  will actually be the class
itself, so that calling either  or  is equivalent to
calling  where  is the underlying function.
Note that the transformation from function object to instance method
object happens each time the attribute is retrieved from the instance.  In
some cases, a fruitful optimization is to assign the attribute to a local
variable and call that local variable. Also notice that this
transformation only happens for user-defined functions; other callable
objects (and all non-callable objects) are retrieved without
transformation.  It is also important to note that user-defined functions
which are attributes of a class instance are not converted to bound
methods; this only happens when the function is an attribute of the
class.

Generator functions
A function or method which uses the  statement (see section
The yield statement) is called a generator function.  Such a function, when
called, always returns an iterator object which can be used to execute the
body of the function:  calling the iterator’s 
method will cause the function to execute until it provides a value
using the  statement.  When the function executes a
 statement or falls off the end, a 
exception is raised and the iterator will have reached the end of the set of
values to be returned.

Coroutine functions
A function or method which is defined using  is called
a coroutine function.  Such a function, when called, returns a
coroutine object.  It may contain  expressions,
as well as  and  statements. See
also the Coroutine Objects section.

Asynchronous generator functions
A function or method which is defined using  and
which uses the  statement is called a
asynchronous generator function.  Such a function, when called,
returns an asynchronous iterator object which can be used in an
 statement to execute the body of the function.
Calling the asynchronous iterator’s  method
will return an awaitable which when awaited
will execute until it provides a value using the 
expression.  When the function executes an empty 
statement or falls off the end, a  exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.

Built-in functions
A built-in function object is a wrapper around a C function.  Examples of
built-in functions are  and  ( is a
standard built-in module). The number and type of the arguments are
determined by the C function. Special read-only attributes:
 is the function’s documentation string, or  if
unavailable;  is the function’s name;  is
set to  (but see the next item);  is the name of
the module the function was defined in or  if unavailable.

Built-in methods
This is really a different disguise of a built-in function, this time containing
an object passed to the C function as an implicit extra argument.  An example of
a built-in method is , assuming alist is a list object. In
this case, the special read-only attribute  is set to the object
denoted by alist.

Classes
Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override .  The arguments of the call are passed to
 and, in the typical case, to  to
initialize the new instance.
Class Instances
Instances of arbitrary classes can be made callable by defining a
 method in their class.


Modules
Modules are a basic organizational unit of Python code, and are created by
the import system as invoked either by the
 statement, or by calling
functions such as  and built-in
.  A module object has a namespace implemented by a
dictionary object (this is the dictionary referenced by the 
attribute of functions defined in the module).  Attribute references are
translated to lookups in this dictionary, e.g.,  is equivalent to
. A module object does not contain the code object used
to initialize the module (since it isn’t needed once the initialization is
done).
Attribute assignment updates the module’s namespace dictionary, e.g.,
 is equivalent to .
Predefined (writable) attributes:  is the module’s name;
 is the module’s documentation string, or  if
unavailable;  (optional) is a dictionary containing
variable annotations collected during module
body execution;  is the pathname of the file from which the
module was loaded, if it was loaded from a file. The 
attribute may be missing for certain types of modules, such as C modules
that are statically linked into the interpreter; for extension modules
loaded dynamically from a shared library, it is the pathname of the shared
library file.
Special read-only attribute:  is the module’s
namespace as a dictionary object.

CPython implementation detail: Because of the way CPython clears module dictionaries, the module
dictionary will be cleared when the module falls out of scope even if the
dictionary still has live references.  To avoid this, copy the dictionary
or keep the module around while using its dictionary directly.


Custom classes
Custom class types are typically created by class definitions (see section
Class definitions).  A class has a namespace implemented by a dictionary object.
Class attribute references are translated to lookups in this dictionary, e.g.,
 is translated to  (although there are a number of
hooks which allow for other means of locating attributes). When the attribute
name is not found there, the attribute search continues in the base classes.
This search of the base classes uses the C3 method resolution order which
behaves correctly even in the presence of ‘diamond’ inheritance structures
where there are multiple inheritance paths leading back to a common ancestor.
Additional details on the C3 MRO used by Python can be found in the
documentation accompanying the 2.3 release at
https://www.python.org/download/releases/2.3/mro/.
When a class attribute reference (for class , say) would yield a
class method object, it is transformed into an instance method object whose
 attribute is .  When it would yield a static
method object, it is transformed into the object wrapped by the static method
object. See section Implementing Descriptors for another way in which attributes
retrieved from a class may differ from those actually contained in its
.
Class attribute assignments update the class’s dictionary, never the dictionary
of a base class.
A class object can be called (see above) to yield a class instance (see below).
Special attributes:  is the class name;  is
the module name in which the class was defined;  is the
dictionary containing the class’s namespace;  is a
tuple containing the base classes, in the order of their occurrence in the
base class list;  is the class’s documentation string,
or  if undefined;  (optional) is a dictionary
containing variable annotations collected during
class body execution.

Class instances
A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose  attribute is the instance.  Static method and
class method objects are also transformed; see above under “Classes”.  See
section Implementing Descriptors for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s .  If no class attribute is found, and the
object’s class has a  method, that is called to satisfy
the lookup.
Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a  or
 method, this is called instead of updating the instance
dictionary directly.
Class instances can pretend to be numbers, sequences, or mappings if they have
methods with certain special names.  See section Special method names.
Special attributes:  is the attribute dictionary;
 is the instance’s class.

I/O objects (also known as file objects)
A file object represents an open file.  Various shortcuts are
available to create file objects: the  built-in function, and
also , , and the
 method of socket objects (and perhaps by
other functions or methods provided by extension modules).
The objects ,  and  are
initialized to file objects corresponding to the interpreter’s standard
input, output and error streams; they are all open in text mode and
therefore follow the interface defined by the 
abstract class.

Internal types
A few types used internally by the interpreter are exposed to the user. Their
definitions may change with future versions of the interpreter, but they are
mentioned here for completeness.

Code objects
Code objects represent byte-compiled executable Python code, or bytecode.
The difference between a code object and a function object is that the function
object contains an explicit reference to the function’s globals (the module in
which it was defined), while a code object contains no context; also the default
argument values are stored in the function object, not in the code object
(because they represent values calculated at run-time).  Unlike function
objects, code objects are immutable and contain no references (directly or
indirectly) to mutable objects.
Special read-only attributes:  gives the function name;
 is the number of positional arguments (including arguments
with default values);  is the number of local variables used
by the function (including arguments);  is a tuple containing
the names of the local variables (starting with the argument names);
 is a tuple containing the names of local variables that are
referenced by nested functions;  is a tuple containing the
names of free variables;  is a string representing the sequence
of bytecode instructions;  is a tuple containing the literals
used by the bytecode;  is a tuple containing the names used by
the bytecode;  is the filename from which the code was
compiled;  is the first line number of the function;
 is a string encoding the mapping from bytecode offsets to
line numbers (for details see the source code of the interpreter);
 is the required stack size (including local variables);
 is an integer encoding a number of flags for the interpreter.
The following flag bits are defined for : bit  is set if
the function uses the  syntax to accept an arbitrary number of
positional arguments; bit  is set if the function uses the
 syntax to accept arbitrary keyword arguments; bit  is set
if the function is a generator.
Future feature declarations () also use bits
in  to indicate whether a code object was compiled with a
particular feature enabled: bit  is set if the function was compiled
with future division enabled; bits  and  were used in earlier
versions of Python.
Other bits in  are reserved for internal use.
If a code object represents a function, the first item in  is
the documentation string of the function, or  if undefined.



Frame objects
Frame objects represent execution frames.  They may occur in traceback objects
(see below), and are also passed to registered trace functions.
Special read-only attributes:  is to the previous stack frame
(towards the caller), or  if this is the bottom stack frame;
 is the code object being executed in this frame; 
is the dictionary used to look up local variables;  is used for
global variables;  is used for built-in (intrinsic) names;
 gives the precise instruction (this is an index into the
bytecode string of the code object).
Special writable attributes: , if not , is a function
called for various events during code execution (this is used by the debugger).
Normally an event is triggered for each new source line - this can be
disabled by setting  to .
Implementations may allow per-opcode events to be requested by setting
 to . Note that this may lead to
undefined interpreter behaviour if exceptions raised by the trace
function escape to the function being traced.
 is the current line number of the frame — writing to this
from within a trace function jumps to the given line (only for the bottom-most
frame).  A debugger can implement a Jump command (aka Set Next Statement)
by writing to f_lineno.
Frame objects support one method:


()¶
This method clears all references to local variables held by the
frame.  Also, if the frame belonged to a generator, the generator
is finalized.  This helps break reference cycles involving frame
objects (for example when catching an exception and storing its
traceback for later use).
 is raised if the frame is currently executing.

New in version 3.4.





Traceback objects
Traceback objects represent a stack trace of an exception.  A traceback object
is implicitly created when an exception occurs, and may also be explicitly
created by calling .
For implicitly created tracebacks, when the search for an exception handler
unwinds the execution stack, at each unwound level a traceback object is
inserted in front of the current traceback.  When an exception handler is
entered, the stack trace is made available to the program. (See section
The try statement.) It is accessible as the third item of the
tuple returned by , and as the  attribute
of the caught exception.
When the program contains no suitable
handler, the stack trace is written (nicely formatted) to the standard error
stream; if the interpreter is interactive, it is also made available to the user
as .
For explicitly created tracebacks, it is up to the creator of the traceback
to determine how the  attributes should be linked to form a
full stack trace.
Special read-only attributes:
 points to the execution frame of the current level;
 gives the line number where the exception occurred;
 indicates the precise instruction.
The line number and last instruction in the traceback may differ from the
line number of its frame object if the exception occurred in a
 statement with no matching except clause or with a
finally clause.
Special writable attribute:  is the next level in the stack
trace (towards the frame where the exception occurred), or  if
there is no next level.

Changed in version 3.7: Traceback objects can now be explicitly instantiated from Python code,
and the  attribute of existing instances can be updated.


Slice objects
Slice objects are used to represent slices for 
methods.  They are also created by the built-in  function.
Special read-only attributes:  is the lower bound;
 is the upper bound;  is the step
value; each is  if omitted.  These attributes can have any type.
Slice objects support one method:


(self, length)¶
This method takes a single integer argument length and computes
information about the slice that the slice object would describe if
applied to a sequence of length items.  It returns a tuple of three
integers; respectively these are the start and stop indices and the
step or stride length of the slice. Missing or out-of-bounds indices
are handled in a manner consistent with regular slices.


Static method objects
Static method objects provide a way of defeating the transformation of function
objects to method objects described above. A static method object is a wrapper
around any other object, usually a user-defined method object. When a static
method object is retrieved from a class or a class instance, the object actually
returned is the wrapped object, which is not subject to any further
transformation. Static method objects are not themselves callable, although the
objects they wrap usually are. Static method objects are created by the built-in
 constructor.
Class method objects
A class method object, like a static method object, is a wrapper around another
object that alters the way in which that object is retrieved from classes and
class instances. The behaviour of class method objects upon such retrieval is
described above, under “User-defined methods”. Class method objects are created
by the built-in  constructor.



