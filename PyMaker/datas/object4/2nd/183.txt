link:
reference/import.html#searching

docs:

5.3. Searching¶
To begin the search, Python needs the fully qualified
name of the module (or package, but for the purposes of this discussion, the
difference is immaterial) being imported.  This name may come from various
arguments to the  statement, or from the parameters to the
 or  functions.
This name will be used in various phases of the import search, and it may be
the dotted path to a submodule, e.g. .  In this case, Python
first tries to import , then , and finally .
If any of the intermediate imports fail, a  is raised.

5.3.1. The module cache¶
The first place checked during import search is .  This
mapping serves as a cache of all modules that have been previously imported,
including the intermediate paths.  So if  was previously
imported,  will contain entries for , ,
and .  Each key will have as its value the corresponding module
object.
During import, the module name is looked up in  and if
present, the associated value is the module satisfying the import, and the
process completes.  However, if the value is , then a
 is raised.  If the module name is missing, Python will
continue searching for the module.
 is writable.  Deleting a key may not destroy the
associated module (as other modules may hold references to it),
but it will invalidate the cache entry for the named module, causing
Python to search anew for the named module upon its next
import. The key can also be assigned to , forcing the next import
of the module to result in a .
Beware though, as if you keep a reference to the module object,
invalidate its cache entry in , and then re-import the
named module, the two module objects will not be the same. By contrast,
 will reuse the same module object, and simply
reinitialise the module contents by rerunning the module’s code.


5.3.2. Finders and loaders¶
If the named module is not found in , then Python’s import
protocol is invoked to find and load the module.  This protocol consists of
two conceptual objects, finders and loaders.
A finder’s job is to determine whether it can find the named module using
whatever strategy it knows about. Objects that implement both of these
interfaces are referred to as importers - they return
themselves when they find that they can load the requested module.
Python includes a number of default finders and importers.  The first one
knows how to locate built-in modules, and the second knows how to locate
frozen modules.  A third default finder searches an import path
for modules.  The import path is a list of locations that may
name file system paths or zip files.  It can also be extended to search
for any locatable resource, such as those identified by URLs.
The import machinery is extensible, so new finders can be added to extend the
range and scope of module searching.
Finders do not actually load modules.  If they can find the named module, they
return a module spec, an encapsulation of the module’s import-related
information, which the import machinery then uses when loading the module.
The following sections describe the protocol for finders and loaders in more
detail, including how you can create and register new ones to extend the
import machinery.

Changed in version 3.4: In previous versions of Python, finders returned loaders
directly, whereas now they return module specs which contain loaders.
Loaders are still used during import but have fewer responsibilities.



5.3.3. Import hooks¶
The import machinery is designed to be extensible; the primary mechanism for
this are the import hooks.  There are two types of import hooks: meta
hooks and import path hooks.
Meta hooks are called at the start of import processing, before any other
import processing has occurred, other than  cache look up.
This allows meta hooks to override  processing, frozen
modules, or even built-in modules.  Meta hooks are registered by adding new
finder objects to , as described below.
Import path hooks are called as part of  (or
) processing, at the point where their associated path
item is encountered.  Import path hooks are registered by adding new callables
to  as described below.


5.3.4. The meta path¶
When the named module is not found in , Python next
searches , which contains a list of meta path finder
objects.  These finders are queried in order to see if they know how to handle
the named module.  Meta path finders must implement a method called
 which takes three arguments:
a name, an import path, and (optionally) a target module.  The meta path
finder can use any strategy it wants to determine whether it can handle
the named module or not.
If the meta path finder knows how to handle the named module, it returns a
spec object.  If it cannot handle the named module, it returns .  If
 processing reaches the end of its list without returning
a spec, then a  is raised.  Any other exceptions
raised are simply propagated up, aborting the import process.
The  method of meta path
finders is called with two or three arguments.  The first is the fully
qualified name of the module being imported, for example .
The second argument is the path entries to use for the module search.  For
top-level modules, the second argument is , but for submodules or
subpackages, the second argument is the value of the parent package’s
 attribute. If the appropriate  attribute cannot
be accessed, a  is raised.  The third argument
is an existing module object that will be the target of loading later.
The import system passes in a target module only during reload.
The meta path may be traversed multiple times for a single import request.
For example, assuming none of the modules involved has already been cached,
importing  will first perform a top level import, calling
 on each meta path finder (). After
 has been imported,  will be imported by traversing the
meta path a second time, calling
. Once  has been
imported, the final traversal will call
.
Some meta path finders only support top level imports. These importers will
always return  when anything other than  is passed as the
second argument.
Python’s default  has three meta path finders, one that
knows how to import built-in modules, one that knows how to import frozen
modules, and one that knows how to import modules from an import path
(i.e. the path based finder).

Changed in version 3.4: The  method of meta path
finders replaced , which
is now deprecated.  While it will continue to work without change, the
import machinery will try it only if the finder does not implement
.


