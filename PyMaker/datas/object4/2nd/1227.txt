link:
library/collections.html

docs:


 — Container datatypes¶
Source code: Lib/collections/__init__.py

This module implements specialized container datatypes providing alternatives to
Python’s general purpose built-in containers, , ,
, and .







factory function for creating tuple subclasses with named fields


list-like container with fast appends and pops on either end


dict-like class for creating a single view of multiple mappings


dict subclass for counting hashable objects


dict subclass that remembers the order entries were added


dict subclass that calls a factory function to supply missing values


wrapper around dictionary objects for easier dict subclassing


wrapper around list objects for easier list subclassing


wrapper around string objects for easier string subclassing




Changed in version 3.3: Moved Collections Abstract Base Classes to the  module.
For backwards compatibility, they continue to be visible in this module through
Python 3.7.  Subsequently, they will be removed entirely.


 objects¶

New in version 3.3.

A  class is provided for quickly linking a number of mappings
so they can be treated as a single unit.  It is often much faster than creating
a new dictionary and running multiple  calls.
The class can be used to simulate nested scopes and is useful in templating.


class (*maps)¶
A  groups multiple dicts or other mappings together to
create a single, updateable view.  If no maps are specified, a single empty
dictionary is provided so that a new chain always has at least one mapping.
The underlying mappings are stored in a list.  That list is public and can
be accessed or updated using the maps attribute.  There is no other state.
Lookups search the underlying mappings successively until a key is found.  In
contrast, writes, updates, and deletions only operate on the first mapping.
A  incorporates the underlying mappings by reference.  So, if
one of the underlying mappings gets updated, those changes will be reflected
in .
All of the usual dictionary methods are supported.  In addition, there is a
maps attribute, a method for creating new subcontexts, and a property for
accessing all but the first mapping:


¶
A user updateable list of mappings.  The list is ordered from
first-searched to last-searched.  It is the only stored state and can
be modified to change which mappings are searched.  The list should
always contain at least one mapping.



(m=None)¶
Returns a new  containing a new map followed by
all of the maps in the current instance.  If  is specified,
it becomes the new map at the front of the list of mappings; if not
specified, an empty dict is used, so that a call to 
is equivalent to: .  This method is used for
creating subcontexts that can be updated without altering values in any
of the parent mappings.

Changed in version 3.4: The optional  parameter was added.




¶
Property returning a new  containing all of the maps in
the current instance except the first one.  This is useful for skipping
the first map in the search.  Use cases are similar to those for the
 keyword used in nested scopes.  The use cases also parallel those for the built-in
 function.  A reference to  is equivalent to:
.

Note, the iteration order of a  is determined by
scanning the mappings last to first:


This gives the same ordering as a series of  calls
starting with the last mapping:




See also

The MultiContext class
in the Enthought CodeTools package has options to support
writing to any mapping in the chain.
Django’s Context class
for templating is a read-only chain of mappings.  It also features
pushing and popping of contexts similar to the
 method and the
 property.
The Nested Contexts recipe has options to control
whether writes and other mutations apply only to the first mapping or to
any mapping in the chain.
A greatly simplified read-only version of Chainmap.



 Examples and Recipes¶
This section shows various approaches to working with chained maps.
Example of simulating Python’s internal lookup chain:


Example of letting user specified command-line arguments take precedence over
environment variables which in turn take precedence over default values:


Example patterns for using the  class to simulate nested
contexts:


The  class only makes updates (writes and deletions) to the
first mapping in the chain while lookups will search the full chain.  However,
if deep writes and deletions are desired, it is easy to make a subclass that
updates keys found deeper in the chain:





 objects¶
A counter tool is provided to support convenient and rapid tallies.
For example:




class ([iterable-or-mapping])¶
A  is a  subclass for counting hashable objects.
It is a collection where elements are stored as dictionary keys
and their counts are stored as dictionary values.  Counts are allowed to be
any integer value including zero or negative counts.  The 
class is similar to bags or multisets in other languages.
Elements are counted from an iterable or initialized from another
mapping (or counter):


Counter objects have a dictionary interface except that they return a zero
count for missing items instead of raising a :


Setting a count to zero does not remove an element from a counter.
Use  to remove it entirely:



New in version 3.1.

Counter objects support three methods beyond those available for all
dictionaries:


()¶
Return an iterator over elements repeating each as many times as its
count.  Elements are returned in arbitrary order.  If an element’s count
is less than one,  will ignore it.





([n])¶
Return a list of the n most common elements and their counts from the
most common to the least.  If n is omitted or ,
 returns all elements in the counter.
Elements with equal counts are ordered arbitrarily:





([iterable-or-mapping])¶
Elements are subtracted from an iterable or from another mapping
(or counter).  Like  but subtracts counts instead
of replacing them.  Both inputs and outputs may be zero or negative.



New in version 3.2.


The usual dictionary methods are available for  objects
except for two which work differently for counters.


(iterable)¶
This class method is not implemented for  objects.



([iterable-or-mapping])¶
Elements are counted from an iterable or added-in from another
mapping (or counter).  Like  but adds counts
instead of replacing them.  Also, the iterable is expected to be a
sequence of elements, not a sequence of  pairs.


Common patterns for working with  objects:


Several mathematical operations are provided for combining 
objects to produce multisets (counters that have counts greater than zero).
Addition and subtraction combine counters by adding or subtracting the counts
of corresponding elements.  Intersection and union return the minimum and
maximum of corresponding counts.  Each operation can accept inputs with signed
counts, but the output will exclude results with counts of zero or less.


Unary addition and subtraction are shortcuts for adding an empty counter
or subtracting from an empty counter.



New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations.


Note
Counters were primarily designed to work with positive integers to represent
running counts; however, care was taken to not unnecessarily preclude use
cases needing other types or negative values.  To help with those use cases,
this section documents the minimum range and type restrictions.

The  class itself is a dictionary subclass with no
restrictions on its keys and values.  The values are intended to be numbers
representing counts, but you could store anything in the value field.
The  method requires only that the values be orderable.
For in-place operations such as , the value type need only
support addition and subtraction.  So fractions, floats, and decimals would
work and negative values are supported.  The same is also true for
 and  which allow negative and zero values
for both inputs and outputs.
The multiset methods are designed only for use cases with positive values.
The inputs may be negative or zero, but only outputs with positive values
are created.  There are no type restrictions, but the value type needs to
support addition, subtraction, and comparison.
The  method requires integer counts.  It ignores zero and
negative counts.



See also

Bag class
in Smalltalk.

Wikipedia entry for Multisets.

C++ multisets
tutorial with examples.

For mathematical operations on multisets and their use cases, see
Knuth, Donald. The Art of Computer Programming Volume II,
Section 4.6.3, Exercise 19.

To enumerate all distinct multisets of a given size over a given set of
elements, see :







 objects¶


class ([iterable[, maxlen]])¶
Returns a new deque object initialized left-to-right (using ) with
data from iterable.  If iterable is not specified, the new deque is empty.
Deques are a generalization of stacks and queues (the name is pronounced “deck”
and is short for “double-ended queue”).  Deques support thread-safe, memory
efficient appends and pops from either side of the deque with approximately the
same O(1) performance in either direction.
Though  objects support similar operations, they are optimized for
fast fixed-length operations and incur O(n) memory movement costs for
 and  operations which change both the size and
position of the underlying data representation.
If maxlen is not specified or is , deques may grow to an
arbitrary length.  Otherwise, the deque is bounded to the specified maximum
length.  Once a bounded length deque is full, when new items are added, a
corresponding number of items are discarded from the opposite end.  Bounded
length deques provide functionality similar to the  filter in
Unix. They are also useful for tracking transactions and other pools of data
where only the most recent activity is of interest.
Deque objects support the following methods:


(x)¶
Add x to the right side of the deque.



(x)¶
Add x to the left side of the deque.



()¶
Remove all elements from the deque leaving it with length 0.



()¶
Create a shallow copy of the deque.

New in version 3.5.




(x)¶
Count the number of deque elements equal to x.

New in version 3.2.




(iterable)¶
Extend the right side of the deque by appending elements from the iterable
argument.



(iterable)¶
Extend the left side of the deque by appending elements from iterable.
Note, the series of left appends results in reversing the order of
elements in the iterable argument.



(x[, start[, stop]])¶
Return the position of x in the deque (at or after index start
and before index stop).  Returns the first match or raises
 if not found.

New in version 3.5.




(i, x)¶
Insert x into the deque at position i.
If the insertion would cause a bounded deque to grow beyond maxlen,
an  is raised.

New in version 3.5.




()¶
Remove and return an element from the right side of the deque. If no
elements are present, raises an .



()¶
Remove and return an element from the left side of the deque. If no
elements are present, raises an .



(value)¶
Remove the first occurrence of value.  If not found, raises a
.



()¶
Reverse the elements of the deque in-place and then return .

New in version 3.2.




(n=1)¶
Rotate the deque n steps to the right.  If n is negative, rotate
to the left.
When the deque is not empty, rotating one step to the right is equivalent
to , and rotating one step to the left is
equivalent to .

Deque objects also provide one read-only attribute:


¶
Maximum size of a deque or  if unbounded.

New in version 3.1.



In addition to the above, deques support iteration, pickling, ,
, , , membership testing with
the  operator, and subscript references such as .  Indexed
access is O(1) at both ends but slows to O(n) in the middle.  For fast random
access, use lists instead.
Starting in version 3.5, deques support , ,
and .
Example:



 Recipes¶
This section shows various approaches to working with deques.
Bounded length deques provide functionality similar to the  filter
in Unix:


Another approach to using deques is to maintain a sequence of recently
added elements by appending to the right and popping to the left:


A round-robin scheduler can be implemented with
input iterators stored in a .  Values are yielded from the active
iterator in position zero.  If that iterator is exhausted, it can be removed
with ; otherwise, it can be cycled back to the end with
the  method:


The  method provides a way to implement  slicing and
deletion.  For example, a pure Python implementation of  relies on
the  method to position elements to be popped:


To implement  slicing, use a similar approach applying
 to bring a target element to the left side of the deque. Remove
old entries with , add new entries with , and then
reverse the rotation.
With minor variations on that approach, it is easy to implement Forth style
stack manipulations such as , , , , ,
, and .



 objects¶


class ([default_factory[, ...]])¶
Returns a new dictionary-like object.   is a subclass of the
built-in  class.  It overrides one method and adds one writable
instance variable.  The remaining functionality is the same as for the
 class and is not documented here.
The first argument provides the initial value for the 
attribute; it defaults to . All remaining arguments are treated the same
as if they were passed to the  constructor, including keyword
arguments.
 objects support the following method in addition to the
standard  operations:


(key)¶
If the  attribute is , this raises a
 exception with the key as argument.
If  is not , it is called without arguments
to provide a default value for the given key, this value is inserted in
the dictionary for the key, and returned.
If calling  raises an exception this exception is
propagated unchanged.
This method is called by the  method of the
 class when the requested key is not found; whatever it
returns or raises is then returned or raised by .
Note that  is not called for any operations besides
. This means that  will, like normal
dictionaries, return  as a default rather than using
.

 objects support the following instance variable:


¶
This attribute is used by the  method; it is
initialized from the first argument to the constructor, if present, or to
, if absent.



 Examples¶
Using  as the , it is easy to group a
sequence of key-value pairs into a dictionary of lists:


When each key is encountered for the first time, it is not already in the
mapping; so an entry is automatically created using the 
function which returns an empty .  The 
operation then attaches the value to the new list.  When keys are encountered
again, the look-up proceeds normally (returning the list for that key) and the
 operation adds another value to the list. This technique is
simpler and faster than an equivalent technique using :


Setting the  to  makes the
 useful for counting (like a bag or multiset in other
languages):


When a letter is first encountered, it is missing from the mapping, so the
 function calls  to supply a default count of
zero.  The increment operation then builds up the count for each letter.
The function  which always returns zero is just a special case of
constant functions.  A faster and more flexible way to create constant functions
is to use a lambda function which can supply any constant value (not just
zero):


Setting the  to  makes the
 useful for building a dictionary of sets:





 Factory Function for Tuples with Named Fields¶
Named tuples assign meaning to each position in a tuple and allow for more readable,
self-documenting code.  They can be used wherever regular tuples are used, and
they add the ability to access fields by name instead of position index.


(typename, field_names, *, rename=False, defaults=None, module=None)¶
Returns a new tuple subclass named typename.  The new subclass is used to
create tuple-like objects that have fields accessible by attribute lookup as
well as being indexable and iterable.  Instances of the subclass also have a
helpful docstring (with typename and field_names) and a helpful 
method which lists the tuple contents in a  format.
The field_names are a sequence of strings such as .
Alternatively, field_names can be a single string with each fieldname
separated by whitespace and/or commas, for example  or .
Any valid Python identifier may be used for a fieldname except for names
starting with an underscore.  Valid identifiers consist of letters, digits,
and underscores but do not start with a digit or underscore and cannot be
a  such as class, for, return, global, pass,
or raise.
If rename is true, invalid fieldnames are automatically replaced
with positional names.  For example,  is
converted to , eliminating the keyword
 and the duplicate fieldname .
defaults can be  or an iterable of default values.
Since fields with a default value must come after any fields without a
default, the defaults are applied to the rightmost parameters.  For
example, if the fieldnames are  and the defaults are
, then  will be a required argument,  will default to
, and  will default to .
If module is defined, the  attribute of the named tuple is
set to that value.
Named tuple instances do not have per-instance dictionaries, so they are
lightweight and require no more memory than regular tuples.

Changed in version 3.1: Added support for rename.


Changed in version 3.6: The verbose and rename parameters became
keyword-only arguments.


Changed in version 3.6: Added the module parameter.


Changed in version 3.7: Remove the verbose parameter and the  attribute.


Changed in version 3.7: Added the defaults parameter and the 
attribute.




Named tuples are especially useful for assigning field names to result tuples returned
by the  or  modules:


In addition to the methods inherited from tuples, named tuples support
three additional methods and two attributes.  To prevent conflicts with
field names, the method and attribute names start with an underscore.


classmethod (iterable)¶
Class method that makes a new instance from an existing sequence or iterable.





()¶
Return a new  which maps field names to their corresponding
values:



Changed in version 3.1: Returns an  instead of a regular .




(**kwargs)¶
Return a new instance of the named tuple replacing specified fields with new
values:





¶
Tuple of strings listing the field names.  Useful for introspection
and for creating new named tuple types from existing named tuples.





¶
Dictionary mapping field names to default values.



To retrieve a field whose name is stored in a string, use the 
function:


To convert a dictionary to a named tuple, use the  operator
(as described in Unpacking Argument Lists):


Since a named tuple is a regular Python class, it is easy to add or change
functionality with a subclass.  Here is how to add a calculated field and
a fixed-width print format:


The subclass shown above sets  to an empty tuple.  This helps
keep memory requirements low by preventing the creation of instance dictionaries.
Subclassing is not useful for adding new, stored fields.  Instead, simply
create a new named tuple type from the  attribute:


Docstrings can be customized by making direct assignments to the 
fields:



Changed in version 3.5: Property docstrings became writeable.

Default values can be implemented by using  to
customize a prototype instance:



See also

See  for a way to add type hints for named
tuples.  It also provides an elegant notation using the 
keyword:



See  for a mutable namespace based on an
underlying dictionary instead of a tuple.

The  module provides a decorator and functions for
automatically adding generated special methods to user-defined classes.





 objects¶
Ordered dictionaries are just like regular dictionaries but have some extra
capabilities relating to ordering operations.  They have become less
important now that the built-in  class gained the ability
to remember insertion order (this new behavior became guaranteed in
Python 3.7).
Some differences from  still remain:

The regular  was designed to be very good at mapping
operations.  Tracking insertion order was secondary.
The  was designed to be good at reordering operations.
Space efficiency, iteration speed, and the performance of update
operations were secondary.
Algorithmically,  can handle frequent reordering
operations better than .  This makes it suitable for tracking
recent accesses (for example in an LRU cache).
The equality operation for  checks for matching order.
The  method of  has a different
signature.  It accepts an optional argument to specify which item is popped.
 has a  method to
efficiently reposition an element to an endpoint.
Until Python 3.8,  lacked a  method.



class ([items])¶
Return an instance of a  subclass that has methods
specialized for rearranging dictionary order.

New in version 3.1.



(last=True)¶
The  method for ordered dictionaries returns and removes a
(key, value) pair.  The pairs are returned in
LIFO order if last is true
or FIFO order if false.



(key, last=True)¶
Move an existing key to either end of an ordered dictionary.  The item
is moved to the right end if last is true (the default) or to the
beginning if last is false.  Raises  if the key does
not exist:



New in version 3.2.



In addition to the usual mapping methods, ordered dictionaries also support
reverse iteration using .
Equality tests between  objects are order-sensitive
and are implemented as .
Equality tests between  objects and other
 objects are order-insensitive like regular
dictionaries.  This allows  objects to be substituted
anywhere a regular dictionary is used.

Changed in version 3.5: The items, keys, and values views
of  now support reverse iteration using .


Changed in version 3.6: With the acceptance of PEP 468, order is retained for keyword arguments
passed to the  constructor and its 
method.


 Examples and Recipes¶
It is straightforward to create an ordered dictionary variant
that remembers the order the keys were last inserted.
If a new entry overwrites an existing entry, the
original insertion position is changed and moved to the end:


An  would also be useful for implementing
variants of :





 objects¶
The class,  acts as a wrapper around dictionary objects.
The need for this class has been partially supplanted by the ability to
subclass directly from ; however, this class can be easier
to work with because the underlying dictionary is accessible as an
attribute.


class ([initialdata])¶
Class that simulates a dictionary.  The instance’s contents are kept in a
regular dictionary, which is accessible via the  attribute of
 instances.  If initialdata is provided,  is
initialized with its contents; note that a reference to initialdata will not
be kept, allowing it be used for other purposes.
In addition to supporting the methods and operations of mappings,
 instances provide the following attribute:


¶
A real dictionary used to store the contents of the 
class.




 objects¶
This class acts as a wrapper around list objects.  It is a useful base class
for your own list-like classes which can inherit from them and override
existing methods or add new ones.  In this way, one can add new behaviors to
lists.
The need for this class has been partially supplanted by the ability to
subclass directly from ; however, this class can be easier
to work with because the underlying list is accessible as an attribute.


class ([list])¶
Class that simulates a list.  The instance’s contents are kept in a regular
list, which is accessible via the  attribute of 
instances.  The instance’s contents are initially set to a copy of list,
defaulting to the empty list .  list can be any iterable, for
example a real Python list or a  object.
In addition to supporting the methods and operations of mutable sequences,
 instances provide the following attribute:


¶
A real  object used to store the contents of the
 class.


Subclassing requirements: Subclasses of  are expected to
offer a constructor which can be called with either no arguments or one
argument.  List operations which return a new sequence attempt to create an
instance of the actual implementation class.  To do so, it assumes that the
constructor can be called with a single parameter, which is a sequence object
used as a data source.
If a derived class does not wish to comply with this requirement, all of the
special methods supported by this class will need to be overridden; please
consult the sources for information about the methods which need to be provided
in that case.


 objects¶
The class,  acts as a wrapper around string objects.
The need for this class has been partially supplanted by the ability to
subclass directly from ; however, this class can be easier
to work with because the underlying string is accessible as an
attribute.


class (seq)¶
Class that simulates a string object.  The instance’s
content is kept in a regular string object, which is accessible via the
 attribute of  instances.  The instance’s
contents are initially set to a copy of seq.  The seq argument can
be any object which can be converted into a string using the built-in
 function.
In addition to supporting the methods and operations of strings,
 instances provide the following attribute:


¶
A real  object used to store the contents of the
 class.


Changed in version 3.5: New methods , , ,
, , and .




