link:
library/secrets.html#module-secrets

docs:

 — Generate secure random numbers for managing secrets¶

New in version 3.6.

Source code: Lib/secrets.py

The  module is used for generating cryptographically strong
random numbers suitable for managing data such as passwords, account
authentication, security tokens, and related secrets.
In particularly,  should be used in preference to the
default pseudo-random number generator in the  module, which
is designed for modelling and simulation, not security or cryptography.

See also
PEP 506


Random numbers¶
The  module provides access to the most secure source of
randomness that your operating system provides.


class ¶
A class for generating random numbers using the highest-quality
sources provided by the operating system.  See
 for additional details.



(sequence)¶
Return a randomly-chosen element from a non-empty sequence.



(n)¶
Return a random int in the range [0, n).



(k)¶
Return an int with k random bits.



Generating tokens¶
The  module provides functions for generating secure
tokens, suitable for applications such as password resets,
hard-to-guess URLs, and similar.


([nbytes=None])¶
Return a random byte string containing nbytes number of bytes.
If nbytes is  or not supplied, a reasonable default is
used.





([nbytes=None])¶
Return a random text string, in hexadecimal.  The string has nbytes
random bytes, each byte converted to two hex digits.  If nbytes is
 or not supplied, a reasonable default is used.





([nbytes=None])¶
Return a random URL-safe text string, containing nbytes random
bytes.  The text is Base64 encoded, so on average each byte results
in approximately 1.3 characters.  If nbytes is  or not
supplied, a reasonable default is used.




How many bytes should tokens use?¶
To be secure against
brute-force attacks,
tokens need to have sufficient randomness.  Unfortunately, what is
considered sufficient will necessarily increase as computers get more
powerful and able to make more guesses in a shorter period.  As of 2015,
it is believed that 32 bytes (256 bits) of randomness is sufficient for
the typical use-case expected for the  module.
For those who want to manage their own token length, you can explicitly
specify how much randomness is used for tokens by giving an 
argument to the various  functions.  That argument is taken
as the number of bytes of randomness to use.
Otherwise, if no argument is provided, or if the argument is ,
the  functions will use a reasonable default instead.

Note
That default is subject to change at any time, including during
maintenance releases.




Other functions¶


(a, b)¶
Return  if strings a and b are equal, otherwise ,
in such a way as to reduce the risk of
timing attacks.
See  for additional details.



Recipes and best practices¶
This section shows recipes and best practices for using 
to manage a basic level of security.
Generate an eight-character alphanumeric password:



Note
Applications should not
store passwords in a recoverable format,
whether plain text or encrypted.  They should be salted and hashed
using a cryptographically-strong one-way (irreversible) hash function.

Generate a ten-character alphanumeric password with at least one
lowercase character, at least one uppercase character, and at least
three digits:


Generate an XKCD-style passphrase:


Generate a hard-to-guess temporary URL containing a security token
suitable for password recovery applications:



