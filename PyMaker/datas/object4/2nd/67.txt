link:
reference/datamodel.html#invoking-descriptors

docs:

3.3.2.3. Invoking Descriptors¶
In general, a descriptor is an object attribute with “binding behavior”, one
whose attribute access has been overridden by methods in the descriptor
protocol:  , , and . If any of
those methods are defined for an object, it is said to be a descriptor.
The default behavior for attribute access is to get, set, or delete the
attribute from an object’s dictionary. For instance,  has a lookup chain
starting with , then , and
continuing through the base classes of  excluding metaclasses.
However, if the looked-up value is an object defining one of the descriptor
methods, then Python may override the default behavior and invoke the descriptor
method instead.  Where this occurs in the precedence chain depends on which
descriptor methods were defined and how they were called.
The starting point for descriptor invocation is a binding, . How the
arguments are assembled depends on :

Direct Call
The simplest and least common call is when user code directly invokes a
descriptor method:    .
Instance Binding
If binding to an object instance,  is transformed into the call:
.
Class Binding
If binding to a class,  is transformed into the call:
.
Super Binding
If  is an instance of , then the binding 
searches  for the base class 
immediately preceding  and then invokes the descriptor with the call:
.

For instance bindings, the precedence of descriptor invocation depends on the
which descriptor methods are defined.  A descriptor can define any combination
of ,  and .  If it does not
define , then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines  and/or , it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both  and , while non-data
descriptors have just the  method.  Data descriptors with
 and  defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.
Python methods (including  and ) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.
The  function is implemented as a data descriptor. Accordingly,
instances cannot override the behavior of a property.
