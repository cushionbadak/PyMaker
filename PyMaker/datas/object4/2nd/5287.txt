link:
library/ssl.html#memory-bio-support

docs:

Memory BIO Support¶

New in version 3.5.

Ever since the SSL module was introduced in Python 2.6, the 
class has provided two related but distinct areas of functionality:

SSL protocol handling
Network IO

The network IO API is identical to that provided by ,
from which  also inherits. This allows an SSL socket to be
used as a drop-in replacement for a regular socket, making it very easy to add
SSL support to an existing application.
Combining SSL protocol handling and network IO usually works well, but there
are some cases where it doesn’t. An example is async IO frameworks that want to
use a different IO multiplexing model than the “select/poll on a file
descriptor” (readiness based) model that is assumed by 
and by the internal OpenSSL socket IO routines. This is mostly relevant for
platforms like Windows where this model is not efficient. For this purpose, a
reduced scope variant of  called  is
provided.


class ¶
A reduced-scope variant of  representing an SSL protocol
instance that does not contain any network IO methods. This class is
typically used by framework authors that want to implement asynchronous IO
for SSL through memory buffers.
This class implements an interface on top of a low-level SSL object as
implemented by OpenSSL. This object captures the state of an SSL connection
but does not provide any network IO itself. IO needs to be performed through
separate “BIO” objects which are OpenSSL’s IO abstraction layer.
This class has no public constructor.  An  instance
must be created using the  method. This
method will create the  instance and bind it to a
pair of BIOs. The incoming BIO is used to pass data from Python to the
SSL protocol instance, while the outgoing BIO is used to pass data the
other way around.
The following methods are available:


















When compared to , this object lacks the following
features:

Any form of network IO;  and  read and write only to
the underlying  buffers.
There is no do_handshake_on_connect machinery. You must always manually
call  to start the handshake.
There is no handling of suppress_ragged_eofs. All end-of-file conditions
that are in violation of the protocol are reported via the
 exception.
The method  call does not return anything,
unlike for an SSL socket where it returns the underlying socket.
The server_name_callback callback passed to
 will get an 
instance instead of a  instance as its first parameter.

Some notes related to the use of :

All IO on an  is non-blocking.
This means that for example  will raise an
 if it needs more data than the incoming BIO has
available.
There is no module-level  call like there is for
. An  is always created
via an .


Changed in version 3.7:  instances must to created with
. In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.


An SSLObject communicates with the outside world using memory buffers. The
class  provides a memory buffer that can be used for this
purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:


class ¶
A memory buffer that can be used to pass data between Python and an SSL
protocol instance.


¶
Return the number of bytes currently in the memory buffer.



¶
A boolean indicating whether the memory BIO is current at the end-of-file
position.



(n=-1)¶
Read up to n bytes from the memory buffer. If n is not specified or
negative, all bytes are returned.



(buf)¶
Write the bytes from buf to the memory BIO. The buf argument must be an
object supporting the buffer protocol.
The return value is the number of bytes written, which is always equal to
the length of buf.



()¶
Write an EOF marker to the memory BIO. After this method has been called, it
is illegal to call . The attribute  will
become true after all data currently in the buffer has been read.


