link:
library/xml.etree.elementtree.html#tutorial

docs:

Tutorial¶
This is a short tutorial for using  ( in
short).  The goal is to demonstrate some of the building blocks and basic
concepts of the module.

XML tree and elements¶
XML is an inherently hierarchical data format, and the most natural way to
represent it is with a tree.   has two classes for this purpose -
 represents the whole XML document as a tree, and
 represents a single node in this tree.  Interactions with
the whole document (reading and writing to/from files) are usually done
on the  level.  Interactions with a single XML element
and its sub-elements are done on the  level.


Parsing XML¶
We’ll be using the following XML document as the sample data for this section:


We can import this data by reading from a file:


Or directly from a string:


 parses XML from a string directly into an ,
which is the root element of the parsed tree.  Other parsing functions may
create an .  Check the documentation to be sure.
As an ,  has a tag and a dictionary of attributes:


It also has children nodes over which we can iterate:


Children are nested, and we can access specific child nodes by index:



Note
Not all elements of the XML input will end up as elements of the
parsed tree. Currently, this module skips over any XML comments,
processing instructions, and document type declarations in the
input. Nevertheless, trees built using this module’s API rather
than parsing from XML text can have comments and processing
instructions in them; they will be included when generating XML
output. A document type declaration may be accessed by passing a
custom  instance to the 
constructor.



Pull API for non-blocking parsing¶
Most parsing functions provided by this module require the whole document
to be read at once before returning any result.  It is possible to use an
 and feed data into it incrementally, but it is a push API that
calls methods on a callback target, which is too low-level and inconvenient for
most needs.  Sometimes what the user really wants is to be able to parse XML
incrementally, without blocking operations, while enjoying the convenience of
fully constructed  objects.
The most powerful tool for doing this is .  It does not
require a blocking read to obtain the XML data, and is instead fed with data
incrementally with  calls.  To get the parsed XML
elements, call .  Here is an example:


The obvious use case is applications that operate in a non-blocking fashion
where the XML data is being received from a socket or read incrementally from
some storage device.  In such cases, blocking reads are unacceptable.
Because it’s so flexible,  can be inconvenient to use for
simpler use-cases.  If you don’t mind your application blocking on reading XML
data but would still like to have incremental parsing capabilities, take a look
at .  It can be useful when you’re reading a large XML document
and don’t want to hold it wholly in memory.


Finding interesting elements¶
 has some useful methods that help iterate recursively over all
the sub-tree below it (its children, their children, and so on).  For example,
:


 finds only elements with a tag which are direct
children of the current element.   finds the first child
with a particular tag, and  accesses the element’s text
content.   accesses the element’s attributes:


More sophisticated specification of which elements to look for is possible by
using XPath.


Modifying an XML File¶
 provides a simple way to build XML documents and write them to files.
The  method serves this purpose.
Once created, an  object may be manipulated by directly changing
its fields (such as ), adding and modifying attributes
( method), as well as adding new children (for example
with ).
Let’s say we want to add one to each country’s rank, and add an 
attribute to the rank element:


Our XML now looks like this:


We can remove elements using .  Let’s say we want to
remove all countries with a rank higher than 50:


Our XML now looks like this:




Building XML documents¶
The  function also provides a convenient way to create new
sub-elements for a given element:




Parsing XML with Namespaces¶
If the XML input has namespaces, tags and attributes
with prefixes in the form  get expanded to
 where the prefix is replaced by the full URI.
Also, if there is a default namespace,
that full URI gets prepended to all of the non-prefixed tags.
Here is an XML example that incorporates two namespaces, one with the
prefix “fictional” and the other serving as the default namespace:


One way to search and explore this XML example is to manually add the
URI to every tag or attribute in the xpath of a
 or :


A better way to search the namespaced XML example is to create a
dictionary with your own prefixes and use those in the search functions:


These two approaches both output:




Additional resources¶
See http://effbot.org/zone/element-index.htm for tutorials and links to other
docs.

