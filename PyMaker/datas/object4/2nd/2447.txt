link:
library/sqlite3.html#sqlite-and-python-types

docs:

SQLite and Python types¶

Introduction¶
SQLite natively supports the following types: , ,
, , .
The following Python types can thus be sent to SQLite without any problem:






Python type
SQLite type




















This is how SQLite types are converted to Python types by default:






SQLite type
Python type













depends on ,
 by default






The type system of the  module is extensible in two ways: you can
store additional Python types in a SQLite database via object adaptation, and
you can let the  module convert SQLite types to different Python
types via converters.


Using adapters to store additional Python types in SQLite databases¶
As described before, SQLite supports only a limited set of types natively. To
use other Python types with SQLite, you must adapt them to one of the
sqlite3 module’s supported types for SQLite: one of NoneType, int, float,
str, bytes.
There are two ways to enable the  module to adapt a custom Python
type to one of the supported ones.

Letting your object adapt itself¶
This is a good approach if you write the class yourself. Let’s suppose you have
a class like this:


Now you want to store the point in a single SQLite column.  First you’ll have to
choose one of the supported types first to be used for representing the point.
Let’s just use str and separate the coordinates using a semicolon. Then you need
to give your class a method  which must return
the converted value. The parameter protocol will be .




Registering an adapter callable¶
The other possibility is to create a function that converts the type to the
string representation and register the function with .


The  module has two default adapters for Python’s built-in
 and  types.  Now let’s suppose
we want to store  objects not in ISO representation,
but as a Unix timestamp.





Converting SQLite values to custom Python types¶
Writing an adapter lets you send custom Python types to SQLite. But to make it
really useful we need to make the Python to SQLite to Python roundtrip work.
Enter converters.
Let’s go back to the  class. We stored the x and y coordinates
separated via semicolons as strings in SQLite.
First, we’ll define a converter function that accepts the string as a parameter
and constructs a  object from it.

Note
Converter functions always get called with a  object, no
matter under which data type you sent the value to SQLite.



Now you need to make the  module know that what you select from
the database is actually a point. There are two ways of doing this:

Implicitly via the declared type
Explicitly via the column name

Both ways are described in section Module functions and constants, in the entries
for the constants  and .
The following example illustrates both approaches.




Default adapters and converters¶
There are default adapters for the date and datetime types in the datetime
module. They will be sent as ISO dates/ISO timestamps to SQLite.
The default converters are registered under the name “date” for
 and under the name “timestamp” for
.
This way, you can use date/timestamps from Python without any additional
fiddling in most cases. The format of the adapters is also compatible with the
experimental SQLite date/time functions.
The following example demonstrates this.


If a timestamp stored in SQLite has a fractional part longer than 6
numbers, its value will be truncated to microsecond precision by the
timestamp converter.

