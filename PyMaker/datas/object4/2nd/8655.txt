link:
library/unittest.mock-examples.html#mock-subclasses-and-their-attributes

docs:

Mock subclasses and their attributes¶
There are various reasons why you might want to subclass . One
reason might be to add helper methods. Here’s a silly example:


The standard behaviour for  instances is that attributes and the return
value mocks are of the same type as the mock they are accessed on. This ensures
that  attributes are  and  attributes are 
[2]. So if you’re subclassing to add helper methods then they’ll also be
available on the attributes and return value mock of instances of your
subclass.


Sometimes this is inconvenient. For example, one user is subclassing mock to
created a Twisted adaptor.
Having this applied to attributes too actually causes errors.
 (in all its flavours) uses a method called  to create
these “sub-mocks” for attributes and return values. You can prevent your
subclass being used for attributes by overriding this method. The signature is
that it takes arbitrary keyword arguments () which are then passed
onto the mock constructor:





[2]An exception to this rule are the non-callable mocks. Attributes use the
callable variant because otherwise non-callable mocks couldn’t have callable
methods.


