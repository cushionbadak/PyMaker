link:
library/contextlib.html#examples-and-recipes

docs:

Examples and Recipes¶
This section describes some examples and recipes for making effective use of
the tools provided by .

Supporting a variable number of context managers¶
The primary use case for  is the one given in the class
documentation: supporting a variable number of context managers and other
cleanup operations in a single  statement. The variability
may come from the number of context managers needed being driven by user
input (such as opening a user specified collection of files), or from
some of the context managers being optional:


As shown,  also makes it quite easy to use 
statements to manage arbitrary resources that don’t natively support the
context management protocol.


Catching exceptions from  methods¶
It is occasionally desirable to catch exceptions from an 
method implementation, without inadvertently catching exceptions from
the  statement body or the context manager’s 
method. By using  the steps in the context management
protocol can be separated slightly in order to allow this:


Actually needing to do this is likely to indicate that the underlying API
should be providing a direct resource management interface for use with
// statements, but not
all APIs are well designed in that regard. When a context manager is the
only resource management API provided, then  can make it
easier to handle various situations that can’t be handled directly in a
 statement.


Cleaning up in an  implementation¶
As noted in the documentation of , this
method can be useful in cleaning up an already allocated resource if later
steps in the  implementation fail.
Here’s an example of doing this for a context manager that accepts resource
acquisition and release functions, along with an optional validation function,
and maps them to the context management protocol:




Replacing any use of  and flag variables¶
A pattern you will sometimes see is a  statement with a flag
variable to indicate whether or not the body of the  clause should
be executed. In its simplest form (that can’t already be handled just by
using an  clause instead), it looks something like this:


As with any  statement based code, this can cause problems for
development and review, because the setup code and the cleanup code can end
up being separated by arbitrarily long sections of code.
 makes it possible to instead register a callback for
execution at the end of a  statement, and then later decide to skip
executing that callback:


This allows the intended cleanup up behaviour to be made explicit up front,
rather than requiring a separate flag variable.
If a particular application uses this pattern a lot, it can be simplified
even further by means of a small helper class:


If the resource cleanup isn’t already neatly bundled into a standalone
function, then it is still possible to use the decorator form of
 to declare the resource cleanup in
advance:


Due to the way the decorator protocol works, a callback function
declared this way cannot take any parameters. Instead, any resources to
be released must be accessed as closure variables.


Using a context manager as a function decorator¶
 makes it possible to use a context manager in
both an ordinary  statement and also as a function decorator.
For example, it is sometimes useful to wrap functions or groups of statements
with a logger that can track the time of entry and time of exit.  Rather than
writing both a function decorator and a context manager for the task,
inheriting from  provides both capabilities in a
single definition:


Instances of this class can be used as both a context manager:


And also as a function decorator:


Note that there is one additional limitation when using context managers
as function decorators: there’s no way to access the return value of
. If that value is needed, then it is still necessary to use
an explicit  statement.

See also

PEP 343 - The “with” statement
The specification, background, and examples for the Python 
statement.



