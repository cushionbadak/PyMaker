link:
library/unittest.mock.html#magicmock-and-magic-method-support

docs:

MagicMock and magic method support¶

Mocking Magic Methods¶
 supports mocking the Python protocol methods, also known as
“magic methods”. This allows mock objects to replace containers or other
objects that implement Python protocols.
Because magic methods are looked up differently from normal methods [2], this
support has been specially implemented. This means that only specific magic
methods are supported. The supported list includes almost all of them. If
there are any missing that you need please let us know.
You mock magic methods by setting the method you are interested in to a function
or a mock instance. If you are using a function then it must take  as
the first argument [3].






One use case for this is for mocking objects used as context managers in a
 statement:


Calls to magic methods do not appear in , but they
are recorded in .

Note
If you use the spec keyword argument to create a mock then attempting to
set a magic method that isn’t in the spec will raise an .

The full list of supported magic methods is:

, ,  and 
,  and 
,  and 
Comparisons: , , , ,
 and 
Container methods: , , ,
, , , 
and 
Context manager:  and 
Unary numeric methods: ,  and 
The numeric methods (including right hand and in-place variants):
, , , , , ,
, , , ,
, , , , and 
Numeric conversion methods: , , 
and 
Descriptor methods: ,  and 
Pickling: , , ,
,  and 

The following methods exist but are not supported as they are either in use
by mock, can’t be set dynamically, or can cause problems:

, ,  and 
, , , 



Magic Mock¶
There are two  variants:  and .


class (*args, **kw)¶
 is a subclass of  with default implementations
of most of the magic methods. You can use  without having to
configure the magic methods yourself.
The constructor parameters have the same meaning as for .
If you use the spec or spec_set arguments then only magic methods
that exist in the spec will be created.



class (*args, **kw)¶
A non-callable version of .
The constructor parameters have the same meaning as for
, with the exception of return_value and
side_effect which have no meaning on a non-callable mock.

The magic methods are setup with  objects, so you can configure them
and use them in the usual way:


By default many of the protocol methods are required to return objects of a
specific type. These methods are preconfigured with a default return value, so
that they can be used without you having to do anything if you aren’t interested
in the return value. You can still set the return value manually if you want
to change the default.
Methods and their defaults:

: NotImplemented
: NotImplemented
: NotImplemented
: NotImplemented
: 1
: False
: 0
: iter([])
: False
: 1j
: 1.0
: True
: 1
: default hash for the mock
: default str for the mock
: default sizeof for the mock

For example:


The two equality methods,  and , are special.
They do the default equality comparison on identity, using the
 attribute, unless you change their return value to
return something else:


The return value of  can be any iterable object and isn’t
required to be an iterator:


If the return value is an iterator, then iterating over it once will consume
it and subsequent iterations will result in an empty list:


 has all of the supported magic methods configured except for some
of the obscure and obsolete ones. You can still set these up if you want.
Magic methods that are supported but not setup by default in  are:




,  and 
 and 
, , , ,
 and 
 and 




[2]Magic methods should be looked up on the class rather than the
instance. Different versions of Python are inconsistent about applying this
rule. The supported protocol methods should work with all supported versions
of Python.





[3]The function is basically hooked up to the class, but each 
instance is kept isolated from the others.



