link:
library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields

docs:

 Factory Function for Tuples with Named Fields¶
Named tuples assign meaning to each position in a tuple and allow for more readable,
self-documenting code.  They can be used wherever regular tuples are used, and
they add the ability to access fields by name instead of position index.


(typename, field_names, *, rename=False, defaults=None, module=None)¶
Returns a new tuple subclass named typename.  The new subclass is used to
create tuple-like objects that have fields accessible by attribute lookup as
well as being indexable and iterable.  Instances of the subclass also have a
helpful docstring (with typename and field_names) and a helpful 
method which lists the tuple contents in a  format.
The field_names are a sequence of strings such as .
Alternatively, field_names can be a single string with each fieldname
separated by whitespace and/or commas, for example  or .
Any valid Python identifier may be used for a fieldname except for names
starting with an underscore.  Valid identifiers consist of letters, digits,
and underscores but do not start with a digit or underscore and cannot be
a  such as class, for, return, global, pass,
or raise.
If rename is true, invalid fieldnames are automatically replaced
with positional names.  For example,  is
converted to , eliminating the keyword
 and the duplicate fieldname .
defaults can be  or an iterable of default values.
Since fields with a default value must come after any fields without a
default, the defaults are applied to the rightmost parameters.  For
example, if the fieldnames are  and the defaults are
, then  will be a required argument,  will default to
, and  will default to .
If module is defined, the  attribute of the named tuple is
set to that value.
Named tuple instances do not have per-instance dictionaries, so they are
lightweight and require no more memory than regular tuples.

Changed in version 3.1: Added support for rename.


Changed in version 3.6: The verbose and rename parameters became
keyword-only arguments.


Changed in version 3.6: Added the module parameter.


Changed in version 3.7: Remove the verbose parameter and the  attribute.


Changed in version 3.7: Added the defaults parameter and the 
attribute.




Named tuples are especially useful for assigning field names to result tuples returned
by the  or  modules:


In addition to the methods inherited from tuples, named tuples support
three additional methods and two attributes.  To prevent conflicts with
field names, the method and attribute names start with an underscore.


classmethod (iterable)¶
Class method that makes a new instance from an existing sequence or iterable.





()¶
Return a new  which maps field names to their corresponding
values:



Changed in version 3.1: Returns an  instead of a regular .




(**kwargs)¶
Return a new instance of the named tuple replacing specified fields with new
values:





¶
Tuple of strings listing the field names.  Useful for introspection
and for creating new named tuple types from existing named tuples.





¶
Dictionary mapping field names to default values.



To retrieve a field whose name is stored in a string, use the 
function:


To convert a dictionary to a named tuple, use the  operator
(as described in Unpacking Argument Lists):


Since a named tuple is a regular Python class, it is easy to add or change
functionality with a subclass.  Here is how to add a calculated field and
a fixed-width print format:


The subclass shown above sets  to an empty tuple.  This helps
keep memory requirements low by preventing the creation of instance dictionaries.
Subclassing is not useful for adding new, stored fields.  Instead, simply
create a new named tuple type from the  attribute:


Docstrings can be customized by making direct assignments to the 
fields:



Changed in version 3.5: Property docstrings became writeable.

Default values can be implemented by using  to
customize a prototype instance:



See also

See  for a way to add type hints for named
tuples.  It also provides an elegant notation using the 
keyword:



See  for a mutable namespace based on an
underlying dictionary instead of a tuple.

The  module provides a decorator and functions for
automatically adding generated special methods to user-defined classes.



