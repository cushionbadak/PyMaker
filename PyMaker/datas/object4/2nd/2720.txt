link:
library/configparser.html#mapping-protocol-access

docs:

Mapping Protocol Access¶

New in version 3.2.

Mapping protocol access is a generic name for functionality that enables using
custom objects as if they were dictionaries.  In case of ,
the mapping interface implementation is using the
 notation.
 in particular returns a proxy for the section’s data in
the parser.  This means that the values are not copied but they are taken from
the original parser on demand.  What’s even more important is that when values
are changed on a section proxy, they are actually mutated in the original
parser.
 objects behave as close to actual dictionaries as possible.
The mapping interface is complete and adheres to the
 ABC.
However, there are a few differences that should be taken into account:

By default, all keys in sections are accessible in a case-insensitive manner
[1].  E.g.  yields only ’ed
option key names.  This means lowercased keys by default.  At the same time,
for a section that holds the key , both expressions return :



All sections include  values as well which means that
 on a section may not leave the section visibly empty.  This is
because default values cannot be deleted from the section (because technically
they are not there).  If they are overridden in the section, deleting causes
the default value to be visible again.  Trying to delete a default value
causes a .

 cannot be removed from the parser:

trying to delete it raises ,
 leaves it intact,
 never returns it.


 - the second argument is not
a fallback value.  Note however that the section-level  methods are
compatible both with the mapping protocol and the classic configparser API.

 is compatible with the mapping protocol (returns a list of
section_name, section_proxy pairs including the DEFAULTSECT).  However,
this method can also be invoked with arguments: .  The latter call returns a list of option, value pairs for
a specified , with all interpolations expanded (unless
 is provided).


The mapping protocol is implemented on top of the existing legacy API so that
subclasses overriding the original interface still should have mappings working
as expected.
