link:
library/optparse.html#tutorial

docs:

Tutorial¶
While  is quite flexible and powerful, it’s also straightforward
to use in most cases.  This section covers the code patterns that are common to
any -based program.
First, you need to import the OptionParser class; then, early in the main
program, create an OptionParser instance:


Then you can start defining options.  The basic syntax is:


Each option has one or more option strings, such as  or ,
and several option attributes that tell  what to expect and what
to do when it encounters that option on the command line.
Typically, each option will have one short option string and one long option
string, e.g.:


You’re free to define as many short option strings and as many long option
strings as you like (including zero), as long as there is at least one option
string overall.
The option strings passed to  are effectively
labels for the
option defined by that call.  For brevity, we will frequently refer to
encountering an option on the command line; in reality, 
encounters option strings and looks up options from them.
Once all of your options are defined, instruct  to parse your
program’s command line:


(If you like, you can pass a custom argument list to , but
that’s rarely necessary: by default it uses .)
 returns two values:

, an object containing values for all of your options—e.g. if
 takes a single string argument, then  will be the
filename supplied by the user, or  if the user did not supply that
option
, the list of positional arguments leftover after parsing options

This tutorial section only covers the four most important option attributes:
, , 
(destination), and . Of these,  is the
most fundamental.

Understanding option actions¶
Actions tell  what to do when it encounters an option on the
command line.  There is a fixed set of actions hard-coded into ;
adding new actions is an advanced topic covered in section
Extending optparse.  Most actions tell  to store
a value in some variable—for example, take a string from the command line and
store it in an attribute of .
If you don’t specify an option action,  defaults to .


The store action¶
The most common option action is , which tells  to take
the next argument (or the remainder of the current argument), ensure that it is
of the correct type, and store it to your chosen destination.
For example:


Now let’s make up a fake command line and ask  to parse it:


When  sees the option string , it consumes the next
argument, , and stores it in .  So, after this
call to ,  is .
Some other option types supported by  are  and .
Here’s an option that expects an integer argument:


Note that this option has no long option string, which is perfectly acceptable.
Also, there’s no explicit action, since the default is .
Let’s parse another fake command-line.  This time, we’ll jam the option argument
right up against the option: since  (one argument) is equivalent to
 (two arguments), the code


will print .
If you don’t specify a type,  assumes .  Combined with
the fact that the default action is , that means our first example can
be a lot shorter:


If you don’t supply a destination,  figures out a sensible
default from the option strings: if the first long option string is
, then the default destination is .  If there are no
long option strings,  looks at the first short option string: the
default destination for  is .
 also includes the built-in  type.  Adding
types is covered in section Extending optparse.


Handling boolean (flag) options¶
Flag options—set a variable to true or false when a particular option is
seen—are quite common.   supports them with two separate actions,
 and .  For example, you might have a 
flag that is turned on with  and off with :


Here we have two different options with the same destination, which is perfectly
OK.  (It just means you have to be a bit careful when setting default
values—see below.)
When  encounters  on the command line, it sets
 to ; when it encounters ,
 is set to .


Other actions¶
Some other actions supported by  are:


store a constant value

append this option’s argument to a list

increment a counter by one

call a specified function

These are covered in section Reference Guide, Reference Guide
and section Option Callbacks.


Default values¶
All of the above examples involve setting some variable (the “destination”) when
certain command-line options are seen.  What happens if those options are never
seen?  Since we didn’t supply any defaults, they are all set to .  This
is usually fine, but sometimes you want more control.   lets you
supply a default value for each destination, which is assigned before the
command line is parsed.
First, consider the verbose/quiet example.  If we want  to set
 to  unless  is seen, then we can do this:


Since default values apply to the destination rather than to any particular
option, and these two options happen to have the same destination, this is
exactly equivalent:


Consider this:


Again, the default value for  will be : the last default
value supplied for any particular destination is the one that counts.
A clearer way to specify default values is the  method of
OptionParser, which you can call at any time before calling :


As before, the last value specified for a given option destination is the one
that counts.  For clarity, try to use one method or the other of setting default
values, not both.


Generating help¶
’s ability to generate help and usage text automatically is
useful for creating user-friendly command-line interfaces.  All you have to do
is supply a  value for each option, and optionally a short
usage message for your whole program.  Here’s an OptionParser populated with
user-friendly (documented) options:


If  encounters either  or  on the
command-line, or if you just call , it prints the
following to standard output:


(If the help output is triggered by a help option,  exits after
printing the help text.)
There’s a lot going on here to help  generate the best possible
help message:

the script defines its own usage message:


 expands  in the usage string to the name of the
current program, i.e. .  The expanded string
is then printed before the detailed option help.
If you don’t supply a usage string,  uses a bland but sensible
default: , which is fine if your script doesn’t
take any positional arguments.

every option defines a help string, and doesn’t worry about
line-wrapping— takes care of wrapping lines and making
the help output look good.

options that take a value indicate this fact in their automatically-generated
help message, e.g. for the “mode” option:


Here, “MODE” is called the meta-variable: it stands for the argument that the
user is expected to supply to /.  By default,
 converts the destination variable name to uppercase and uses
that for the meta-variable.  Sometimes, that’s not what you want—for
example, the  option explicitly sets ,
resulting in this automatically-generated option description:


This is important for more than just saving space, though: the manually
written help text uses the meta-variable  to clue the user in that
there’s a connection between the semi-formal syntax  and the informal
semantic description “write output to FILE”. This is a simple but effective
way to make your help text a lot clearer and more useful for end users.

options that have a default value can include  in the help
string— will replace it with  of the option’s
default value.  If an option has no default value (or the default value is
),  expands to .



Grouping Options¶
When dealing with many options, it is convenient to group these options for
better help output.  An  can contain several option groups,
each of which can contain several options.
An option group is obtained using the class :


class (parser, title, description=None)¶
where

parser is the  instance the group will be inserted in
to
title is the group title
description, optional, is a long description of the group


 inherits from  (like
) and so the  method can be used to add
an option to the group.
Once all the options are declared, using the  method
 the group is added to the previously defined parser.
Continuing with the parser defined in the previous section, adding an
 to a parser is easy:


This would result in the following help output:


A bit more complete example might involve using more than one group: still
extending the previous example:


that results in the following output:


Another interesting method, in particular when working programmatically with
option groups is:


(opt_str)¶
Return the  to which the short or long option
string opt_str (e.g.  or ) belongs. If
there’s no such , return .




Printing a version string¶
Similar to the brief usage string,  can also print a version
string for your program.  You have to supply the string as the 
argument to OptionParser:


 is expanded just like it is in .  Apart from that,
 can contain anything you like.  When you supply it, 
automatically adds a  option to your parser. If it encounters
this option on the command line, it expands your  string (by
replacing ), prints it to stdout, and exits.
For example, if your script is called :


The following two methods can be used to print and get the  string:


(file=None)¶
Print the version message for the current program () to
file (default stdout).  As with , any occurrence
of  in  is replaced with the name of the current
program.  Does nothing if  is empty or undefined.



()¶
Same as  but returns the version string instead of
printing it.



How  handles errors¶
There are two broad classes of errors that  has to worry about:
programmer errors and user errors.  Programmer errors are usually erroneous
calls to , e.g. invalid option strings, unknown
option attributes, missing option attributes, etc.  These are dealt with in the
usual way: raise an exception (either  or
) and let the program crash.
Handling user errors is much more important, since they are guaranteed to happen
no matter how stable your code is.   can automatically detect
some user errors, such as bad option arguments (passing  where
 takes an integer argument), missing arguments ( at the end
of the command line, where  takes an argument of any type).  Also,
you can call  to signal an application-defined error
condition:


In either case,  handles the error the same way: it prints the
program’s usage message and an error message to standard error and exits with
error status 2.
Consider the first example above, where the user passes  to an option
that takes an integer:


Or, where the user fails to pass a value at all:


-generated error messages take care always to mention the
option involved in the error; be sure to do the same when calling
 from your application code.
If ’s default error-handling behaviour does not suit your needs,
you’ll need to subclass OptionParser and override its 
and/or  methods.


Putting it all together¶
Here’s what -based scripts usually look like:



