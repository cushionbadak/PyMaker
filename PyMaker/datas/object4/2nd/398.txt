link:
library/stdtypes.html#sequence-types-list-tuple-range

docs:

Sequence Types — , , ¶
There are three basic sequence types: lists, tuples, and range objects.
Additional sequence types tailored for processing of
binary data and text strings are
described in dedicated sections.

Common Sequence Operations¶
The operations in the following table are supported by most sequence types,
both mutable and immutable. The  ABC is
provided to make it easier to correctly implement these operations on
custom sequence types.
This table lists the sequence operations sorted in ascending priority.  In the
table, s and t are sequences of the same type, n, i, j and k are
integers and x is an arbitrary object that meets any type and value
restrictions imposed by s.
The  and  operations have the same priorities as the
comparison operations. The  (concatenation) and  (repetition)
operations have the same priority as the corresponding numeric operations. [3]







Operation
Result
Notes




 if an item of s is
equal to x, else 
(1)


 if an item of s is
equal to x, else 
(1)


the concatenation of s and
t
(6)(7)

 or

equivalent to adding s to
itself n times
(2)(7)


ith item of s, origin 0
(3)


slice of s from i to j
(3)(4)


slice of s from i to j
with step k
(3)(5)


length of s
 


smallest item of s
 


largest item of s
 


index of the first occurrence
of x in s (at or after
index i and before index j)
(8)


total number of occurrences of
x in s
 



Sequences of the same type also support comparisons.  In particular, tuples
and lists are compared lexicographically by comparing corresponding elements.
This means that to compare equal, every element must compare equal and the
two sequences must be of the same type and have the same length.  (For full
details see Comparisons in the language reference.)
Notes:

While the  and  operations are used only for simple
containment testing in the general case, some specialised sequences
(such as ,  and ) also use
them for subsequence testing:



Values of n less than  are treated as  (which yields an empty
sequence of the same type as s).  Note that items in the sequence s
are not copied; they are referenced multiple times.  This often haunts
new Python programmers; consider:


What has happened is that  is a one-element list containing an empty
list, so all three elements of  are references to this single empty
list.  Modifying any of the elements of  modifies this single list.
You can create a list of different lists this way:


Further explanation is available in the FAQ entry
How do I create a multidimensional list?.

If i or j is negative, the index is relative to the end of sequence s:
 or  is substituted.  But note that  is
still .

The slice of s from i to j is defined as the sequence of items with index
k such that .  If i or j is greater than , use
.  If i is omitted or , use .  If j is omitted or
, use .  If i is greater than or equal to j, the slice is
empty.

The slice of s from i to j with step k is defined as the sequence of
items with index   such that .  In other words,
the indices are , , ,  and so on, stopping when
j is reached (but never including j).  When k is positive,
i and j are reduced to  if they are greater.
When k is negative, i and j are reduced to  if
they are greater.  If i or j are omitted or , they become
“end” values (which end depends on the sign of k).  Note, k cannot be zero.
If k is , it is treated like .

Concatenating immutable sequences always results in a new object.  This
means that building up a sequence by repeated concatenation will have a
quadratic runtime cost in the total sequence length.  To get a linear
runtime cost, you must switch to one of the alternatives below:

if concatenating  objects, you can build a list and use
 at the end or else write to an 
instance and retrieve its value when complete
if concatenating  objects, you can similarly use
 or , or you can do in-place
concatenation with a  object.  
objects are mutable and have an efficient overallocation mechanism
if concatenating  objects, extend a  instead
for other types, investigate the relevant class documentation


Some sequence types (such as ) only support item sequences
that follow specific patterns, and hence don’t support sequence
concatenation or repetition.

 raises  when x is not found in s.
Not all implementations support passing the additional arguments i and j.
These arguments allow efficient searching of subsections of the sequence. Passing
the extra arguments is roughly equivalent to using , only
without copying any data and with the returned index being relative to
the start of the sequence rather than the start of the slice.




Immutable Sequence Types¶
The only operation that immutable sequence types generally implement that is
not also implemented by mutable sequence types is support for the 
built-in.
This support allows immutable sequences, such as  instances, to
be used as  keys and stored in  and 
instances.
Attempting to hash an immutable sequence that contains unhashable values will
result in .


Mutable Sequence Types¶
The operations in the following table are defined on mutable sequence types.
The  ABC is provided to make it
easier to correctly implement these operations on custom sequence types.
In the table s is an instance of a mutable sequence type, t is any
iterable object and x is an arbitrary object that meets any type
and value restrictions imposed by s (for example,  only
accepts integers that meet the value restriction ).







Operation
Result
Notes




item i of s is replaced by
x
 


slice of s from i to j
is replaced by the contents of
the iterable t
 


same as 
 


the elements of 
are replaced by those of t
(1)


removes the elements of
 from the list
 


appends x to the end of the
sequence (same as
)
 


removes all items from s
(same as )
(5)


creates a shallow copy of s
(same as )
(5)

 or

extends s with the
contents of t (for the
most part the same as
)
 


updates s with its contents
repeated n times
(6)


inserts x into s at the
index given by i
(same as )
 


retrieves the item at i and
also removes it from s
(2)


remove the first item from s
where  is equal to x
(3)


reverses the items of s in
place
(4)



Notes:

t must have the same length as the slice it is replacing.

The optional argument i defaults to , so that by default the last
item is removed and returned.

 raises  when x is not found in s.

The  method modifies the sequence in place for economy of
space when reversing a large sequence.  To remind users that it operates by
side effect, it does not return the reversed sequence.

 and  are included for consistency with the
interfaces of mutable containers that don’t support slicing operations
(such as  and )

New in version 3.3:  and  methods.


The value n is an integer, or an object implementing
.  Zero and negative values of n clear
the sequence.  Items in the sequence are not copied; they are referenced
multiple times, as explained for  under Common Sequence Operations.




Lists¶
Lists are mutable sequences, typically used to store collections of
homogeneous items (where the precise degree of similarity will vary by
application).


class ([iterable])¶
Lists may be constructed in several ways:

Using a pair of square brackets to denote the empty list: 
Using square brackets, separating items with commas: , 
Using a list comprehension: 
Using the type constructor:  or 

The constructor builds a list whose items are the same and in the same
order as iterable’s items.  iterable may be either a sequence, a
container that supports iteration, or an iterator object.  If iterable
is already a list, a copy is made and returned, similar to .
For example,  returns  and
 returns .
If no argument is given, the constructor creates a new empty list, .
Many other operations also produce lists, including the 
built-in.
Lists implement all of the common and
mutable sequence operations. Lists also provide the
following additional method:


(*, key=None, reverse=False)¶
This method sorts the list in place, using only  comparisons
between items. Exceptions are not suppressed - if any comparison operations
fail, the entire sort operation will fail (and the list will likely be left
in a partially modified state).
 accepts two arguments that can only be passed by keyword
(keyword-only arguments):
key specifies a function of one argument that is used to extract a
comparison key from each list element (for example, ).
The key corresponding to each item in the list is calculated once and
then used for the entire sorting process. The default value of 
means that list items are sorted directly without calculating a separate
key value.
The  utility is available to convert a 2.x
style cmp function to a key function.
reverse is a boolean value.  If set to , then the list elements
are sorted as if each comparison were reversed.
This method modifies the sequence in place for economy of space when
sorting a large sequence.  To remind users that it operates by side
effect, it does not return the sorted sequence (use  to
explicitly request a new sorted list instance).
The  method is guaranteed to be stable.  A sort is stable if it
guarantees not to change the relative order of elements that compare equal
— this is helpful for sorting in multiple passes (for example, sort by
department, then by salary grade).

CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even
inspect, the list is undefined.  The C implementation of Python makes the
list appear empty for the duration, and raises  if it can
detect that the list has been mutated during a sort.





Tuples¶
Tuples are immutable sequences, typically used to store collections of
heterogeneous data (such as the 2-tuples produced by the 
built-in). Tuples are also used for cases where an immutable sequence of
homogeneous data is needed (such as allowing storage in a  or
 instance).


class ([iterable])¶
Tuples may be constructed in a number of ways:

Using a pair of parentheses to denote the empty tuple: 
Using a trailing comma for a singleton tuple:  or 
Separating items with commas:  or 
Using the  built-in:  or 

The constructor builds a tuple whose items are the same and in the same
order as iterable’s items.  iterable may be either a sequence, a
container that supports iteration, or an iterator object.  If iterable
is already a tuple, it is returned unchanged. For example,
 returns  and
 returns .
If no argument is given, the constructor creates a new empty tuple, .
Note that it is actually the comma which makes a tuple, not the parentheses.
The parentheses are optional, except in the empty tuple case, or
when they are needed to avoid syntactic ambiguity. For example,
 is a function call with three arguments, while
 is a function call with a 3-tuple as the sole argument.
Tuples implement all of the common sequence
operations.

For heterogeneous collections of data where access by name is clearer than
access by index,  may be a more appropriate
choice than a simple tuple object.


Ranges¶
The  type represents an immutable sequence of numbers and is
commonly used for looping a specific number of times in 
loops.


class (stop)¶

class (start, stop[, step])
The arguments to the range constructor must be integers (either built-in
 or any object that implements the  special
method).  If the step argument is omitted, it defaults to .
If the start argument is omitted, it defaults to .
If step is zero,  is raised.
For a positive step, the contents of a range  are determined by the
formula  where  and
.
For a negative step, the contents of the range are still determined by
the formula , but the constraints are 
and .
A range object will be empty if  does not meet the value
constraint. Ranges do support negative indices, but these are interpreted
as indexing from the end of the sequence determined by the positive
indices.
Ranges containing absolute values larger than  are
permitted but some features (such as ) may raise
.
Range examples:


Ranges implement all of the common sequence operations
except concatenation and repetition (due to the fact that range objects can
only represent sequences that follow a strict pattern and repetition and
concatenation will usually violate that pattern).


¶
The value of the start parameter (or  if the parameter was
not supplied)



¶
The value of the stop parameter



¶
The value of the step parameter (or  if the parameter was
not supplied)


The advantage of the  type over a regular  or
 is that a  object will always take the same
(small) amount of memory, no matter the size of the range it represents (as it
only stores the ,  and  values, calculating individual
items and subranges as needed).
Range objects implement the  ABC, and provide
features such as containment tests, element index lookup, slicing and
support for negative indices (see Sequence Types — list, tuple, range):


Testing range objects for equality with  and  compares
them as sequences.  That is, two range objects are considered equal if
they represent the same sequence of values.  (Note that two range
objects that compare equal might have different ,
 and  attributes, for example
 or .)

Changed in version 3.2: Implement the Sequence ABC.
Support slicing and negative indices.
Test  objects for membership in constant time instead of
iterating through all items.


Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the
sequence of values they define (instead of comparing based on
object identity).


New in version 3.3: The ,  and 
attributes.


See also

The linspace recipe
shows how to implement a lazy version of range suitable for floating
point applications.



