link:
library/stdtypes.html#common-sequence-operations

docs:

Common Sequence Operations¶
The operations in the following table are supported by most sequence types,
both mutable and immutable. The  ABC is
provided to make it easier to correctly implement these operations on
custom sequence types.
This table lists the sequence operations sorted in ascending priority.  In the
table, s and t are sequences of the same type, n, i, j and k are
integers and x is an arbitrary object that meets any type and value
restrictions imposed by s.
The  and  operations have the same priorities as the
comparison operations. The  (concatenation) and  (repetition)
operations have the same priority as the corresponding numeric operations. [3]







Operation
Result
Notes




 if an item of s is
equal to x, else 
(1)


 if an item of s is
equal to x, else 
(1)


the concatenation of s and
t
(6)(7)

 or

equivalent to adding s to
itself n times
(2)(7)


ith item of s, origin 0
(3)


slice of s from i to j
(3)(4)


slice of s from i to j
with step k
(3)(5)


length of s
 


smallest item of s
 


largest item of s
 


index of the first occurrence
of x in s (at or after
index i and before index j)
(8)


total number of occurrences of
x in s
 



Sequences of the same type also support comparisons.  In particular, tuples
and lists are compared lexicographically by comparing corresponding elements.
This means that to compare equal, every element must compare equal and the
two sequences must be of the same type and have the same length.  (For full
details see Comparisons in the language reference.)
Notes:

While the  and  operations are used only for simple
containment testing in the general case, some specialised sequences
(such as ,  and ) also use
them for subsequence testing:



Values of n less than  are treated as  (which yields an empty
sequence of the same type as s).  Note that items in the sequence s
are not copied; they are referenced multiple times.  This often haunts
new Python programmers; consider:


What has happened is that  is a one-element list containing an empty
list, so all three elements of  are references to this single empty
list.  Modifying any of the elements of  modifies this single list.
You can create a list of different lists this way:


Further explanation is available in the FAQ entry
How do I create a multidimensional list?.

If i or j is negative, the index is relative to the end of sequence s:
 or  is substituted.  But note that  is
still .

The slice of s from i to j is defined as the sequence of items with index
k such that .  If i or j is greater than , use
.  If i is omitted or , use .  If j is omitted or
, use .  If i is greater than or equal to j, the slice is
empty.

The slice of s from i to j with step k is defined as the sequence of
items with index   such that .  In other words,
the indices are , , ,  and so on, stopping when
j is reached (but never including j).  When k is positive,
i and j are reduced to  if they are greater.
When k is negative, i and j are reduced to  if
they are greater.  If i or j are omitted or , they become
“end” values (which end depends on the sign of k).  Note, k cannot be zero.
If k is , it is treated like .

Concatenating immutable sequences always results in a new object.  This
means that building up a sequence by repeated concatenation will have a
quadratic runtime cost in the total sequence length.  To get a linear
runtime cost, you must switch to one of the alternatives below:

if concatenating  objects, you can build a list and use
 at the end or else write to an 
instance and retrieve its value when complete
if concatenating  objects, you can similarly use
 or , or you can do in-place
concatenation with a  object.  
objects are mutable and have an efficient overallocation mechanism
if concatenating  objects, extend a  instead
for other types, investigate the relevant class documentation


Some sequence types (such as ) only support item sequences
that follow specific patterns, and hence don’t support sequence
concatenation or repetition.

 raises  when x is not found in s.
Not all implementations support passing the additional arguments i and j.
These arguments allow efficient searching of subsections of the sequence. Passing
the extra arguments is roughly equivalent to using , only
without copying any data and with the returned index being relative to
the start of the sequence rather than the start of the slice.


