link:
library/optparse.html#module-optparse

docs:

 — Parser for command line options¶
Source code: Lib/optparse.py

Deprecated since version 3.2: The  module is deprecated and will not be developed further;
development will continue with the  module.


 is a more convenient, flexible, and powerful library for parsing
command-line options than the old  module.   uses a
more declarative style of command-line parsing: you create an instance of
, populate it with options, and parse the command
line.  allows users to specify options in the conventional
GNU/POSIX syntax, and additionally generates usage and help messages for you.
Here’s an example of using  in a simple script:


With these few lines of code, users of your script can now do the “usual thing”
on the command-line, for example:


As it parses the command line,  sets attributes of the
 object returned by  based on user-supplied
command-line values.  When  returns from parsing this command
line,  will be  and  will be
.   supports both long and short options, allows short
options to be merged together, and allows options to be associated with their
arguments in a variety of ways.  Thus, the following command lines are all
equivalent to the above example:


Additionally, users can run one of


and  will print out a brief summary of your script’s options:


where the value of yourscript is determined at runtime (normally from
).

Background¶
 was explicitly designed to encourage the creation of programs
with straightforward, conventional command-line interfaces.  To that end, it
supports only the most common command-line syntax and semantics conventionally
used under Unix.  If you are unfamiliar with these conventions, read this
section to acquaint yourself with them.

Terminology¶

argument
a string entered on the command-line, and passed by the shell to 
or .  In Python, arguments are elements of 
( is the name of the program being executed).  Unix shells
also use the term “word”.
It is occasionally desirable to substitute an argument list other than
, so you should read “argument” as “an element of
, or of some other list provided as a substitute for
”.

option
an argument used to supply extra information to guide or customize the
execution of a program.  There are many different syntaxes for options; the
traditional Unix syntax is a hyphen (“-“) followed by a single letter,
e.g.  or .  Also, traditional Unix syntax allows multiple
options to be merged into a single argument, e.g.  is equivalent
to .  The GNU project introduced  followed by a series of
hyphen-separated words, e.g.  or .  These are the
only two option syntaxes provided by .
Some other option syntaxes that the world has seen include:

a hyphen followed by a few letters, e.g.  (this is not the same
as multiple options merged into a single argument)
a hyphen followed by a whole word, e.g.  (this is technically
equivalent to the previous syntax, but they aren’t usually seen in the same
program)
a plus sign followed by a single letter, or a few letters, or a word, e.g.
, 
a slash followed by a letter, or a few letters, or a word, e.g. ,


These option syntaxes are not supported by , and they never
will be.  This is deliberate: the first three are non-standard on any
environment, and the last only makes sense if you’re exclusively targeting
VMS, MS-DOS, and/or Windows.

option argument
an argument that follows an option, is closely associated with that option,
and is consumed from the argument list when that option is. With
, option arguments may either be in a separate argument from
their option:


or included in the same argument:


Typically, a given option either takes an argument or it doesn’t. Lots of
people want an “optional option arguments” feature, meaning that some options
will take an argument if they see it, and won’t if they don’t.  This is
somewhat controversial, because it makes parsing ambiguous: if  takes
an optional argument and  is another option entirely, how do we
interpret ?  Because of this ambiguity,  does not
support this feature.

positional argument
something leftover in the argument list after options have been parsed, i.e.
after options and their arguments have been parsed and removed from the
argument list.
required option
an option that must be supplied on the command-line; note that the phrase
“required option” is self-contradictory in English.   doesn’t
prevent you from implementing required options, but doesn’t give you much
help at it either.

For example, consider this hypothetical command-line:


 and  are both options.  Assuming that 
takes one argument,  is an option argument.   and
 are positional arguments.


What are options for?¶
Options are used to provide extra information to tune or customize the execution
of a program.  In case it wasn’t clear, options are usually optional.  A
program should be able to run just fine with no options whatsoever.  (Pick a
random program from the Unix or GNU toolsets.  Can it run without any options at
all and still make sense?  The main exceptions are , , and
—all of which are mutant oddballs that have been rightly criticized
for their non-standard syntax and confusing interfaces.)
Lots of people want their programs to have “required options”.  Think about it.
If it’s required, then it’s not optional!  If there is a piece of information
that your program absolutely requires in order to run successfully, that’s what
positional arguments are for.
As an example of good command-line interface design, consider the humble 
utility, for copying files.  It doesn’t make much sense to try to copy files
without supplying a destination and at least one source. Hence,  fails if
you run it with no arguments.  However, it has a flexible, useful syntax that
does not require any options at all:


You can get pretty far with just that.  Most  implementations provide a
bunch of options to tweak exactly how the files are copied: you can preserve
mode and modification time, avoid following symlinks, ask before clobbering
existing files, etc.  But none of this distracts from the core mission of
, which is to copy either one file to another, or several files to another
directory.


What are positional arguments for?¶
Positional arguments are for those pieces of information that your program
absolutely, positively requires to run.
A good user interface should have as few absolute requirements as possible.  If
your program requires 17 distinct pieces of information in order to run
successfully, it doesn’t much matter how you get that information from the
user—most people will give up and walk away before they successfully run the
program.  This applies whether the user interface is a command-line, a
configuration file, or a GUI: if you make that many demands on your users, most
of them will simply give up.
In short, try to minimize the amount of information that users are absolutely
required to supply—use sensible defaults whenever possible.  Of course, you
also want to make your programs reasonably flexible.  That’s what options are
for.  Again, it doesn’t matter if they are entries in a config file, widgets in
the “Preferences” dialog of a GUI, or command-line options—the more options
you implement, the more flexible your program is, and the more complicated its
implementation becomes.  Too much flexibility has drawbacks as well, of course;
too many options can overwhelm users and make your code much harder to maintain.



Tutorial¶
While  is quite flexible and powerful, it’s also straightforward
to use in most cases.  This section covers the code patterns that are common to
any -based program.
First, you need to import the OptionParser class; then, early in the main
program, create an OptionParser instance:


Then you can start defining options.  The basic syntax is:


Each option has one or more option strings, such as  or ,
and several option attributes that tell  what to expect and what
to do when it encounters that option on the command line.
Typically, each option will have one short option string and one long option
string, e.g.:


You’re free to define as many short option strings and as many long option
strings as you like (including zero), as long as there is at least one option
string overall.
The option strings passed to  are effectively
labels for the
option defined by that call.  For brevity, we will frequently refer to
encountering an option on the command line; in reality, 
encounters option strings and looks up options from them.
Once all of your options are defined, instruct  to parse your
program’s command line:


(If you like, you can pass a custom argument list to , but
that’s rarely necessary: by default it uses .)
 returns two values:

, an object containing values for all of your options—e.g. if
 takes a single string argument, then  will be the
filename supplied by the user, or  if the user did not supply that
option
, the list of positional arguments leftover after parsing options

This tutorial section only covers the four most important option attributes:
, , 
(destination), and . Of these,  is the
most fundamental.

Understanding option actions¶
Actions tell  what to do when it encounters an option on the
command line.  There is a fixed set of actions hard-coded into ;
adding new actions is an advanced topic covered in section
Extending optparse.  Most actions tell  to store
a value in some variable—for example, take a string from the command line and
store it in an attribute of .
If you don’t specify an option action,  defaults to .


The store action¶
The most common option action is , which tells  to take
the next argument (or the remainder of the current argument), ensure that it is
of the correct type, and store it to your chosen destination.
For example:


Now let’s make up a fake command line and ask  to parse it:


When  sees the option string , it consumes the next
argument, , and stores it in .  So, after this
call to ,  is .
Some other option types supported by  are  and .
Here’s an option that expects an integer argument:


Note that this option has no long option string, which is perfectly acceptable.
Also, there’s no explicit action, since the default is .
Let’s parse another fake command-line.  This time, we’ll jam the option argument
right up against the option: since  (one argument) is equivalent to
 (two arguments), the code


will print .
If you don’t specify a type,  assumes .  Combined with
the fact that the default action is , that means our first example can
be a lot shorter:


If you don’t supply a destination,  figures out a sensible
default from the option strings: if the first long option string is
, then the default destination is .  If there are no
long option strings,  looks at the first short option string: the
default destination for  is .
 also includes the built-in  type.  Adding
types is covered in section Extending optparse.


Handling boolean (flag) options¶
Flag options—set a variable to true or false when a particular option is
seen—are quite common.   supports them with two separate actions,
 and .  For example, you might have a 
flag that is turned on with  and off with :


Here we have two different options with the same destination, which is perfectly
OK.  (It just means you have to be a bit careful when setting default
values—see below.)
When  encounters  on the command line, it sets
 to ; when it encounters ,
 is set to .


Other actions¶
Some other actions supported by  are:


store a constant value

append this option’s argument to a list

increment a counter by one

call a specified function

These are covered in section Reference Guide, Reference Guide
and section Option Callbacks.


Default values¶
All of the above examples involve setting some variable (the “destination”) when
certain command-line options are seen.  What happens if those options are never
seen?  Since we didn’t supply any defaults, they are all set to .  This
is usually fine, but sometimes you want more control.   lets you
supply a default value for each destination, which is assigned before the
command line is parsed.
First, consider the verbose/quiet example.  If we want  to set
 to  unless  is seen, then we can do this:


Since default values apply to the destination rather than to any particular
option, and these two options happen to have the same destination, this is
exactly equivalent:


Consider this:


Again, the default value for  will be : the last default
value supplied for any particular destination is the one that counts.
A clearer way to specify default values is the  method of
OptionParser, which you can call at any time before calling :


As before, the last value specified for a given option destination is the one
that counts.  For clarity, try to use one method or the other of setting default
values, not both.


Generating help¶
’s ability to generate help and usage text automatically is
useful for creating user-friendly command-line interfaces.  All you have to do
is supply a  value for each option, and optionally a short
usage message for your whole program.  Here’s an OptionParser populated with
user-friendly (documented) options:


If  encounters either  or  on the
command-line, or if you just call , it prints the
following to standard output:


(If the help output is triggered by a help option,  exits after
printing the help text.)
There’s a lot going on here to help  generate the best possible
help message:

the script defines its own usage message:


 expands  in the usage string to the name of the
current program, i.e. .  The expanded string
is then printed before the detailed option help.
If you don’t supply a usage string,  uses a bland but sensible
default: , which is fine if your script doesn’t
take any positional arguments.

every option defines a help string, and doesn’t worry about
line-wrapping— takes care of wrapping lines and making
the help output look good.

options that take a value indicate this fact in their automatically-generated
help message, e.g. for the “mode” option:


Here, “MODE” is called the meta-variable: it stands for the argument that the
user is expected to supply to /.  By default,
 converts the destination variable name to uppercase and uses
that for the meta-variable.  Sometimes, that’s not what you want—for
example, the  option explicitly sets ,
resulting in this automatically-generated option description:


This is important for more than just saving space, though: the manually
written help text uses the meta-variable  to clue the user in that
there’s a connection between the semi-formal syntax  and the informal
semantic description “write output to FILE”. This is a simple but effective
way to make your help text a lot clearer and more useful for end users.

options that have a default value can include  in the help
string— will replace it with  of the option’s
default value.  If an option has no default value (or the default value is
),  expands to .



Grouping Options¶
When dealing with many options, it is convenient to group these options for
better help output.  An  can contain several option groups,
each of which can contain several options.
An option group is obtained using the class :


class (parser, title, description=None)¶
where

parser is the  instance the group will be inserted in
to
title is the group title
description, optional, is a long description of the group


 inherits from  (like
) and so the  method can be used to add
an option to the group.
Once all the options are declared, using the  method
 the group is added to the previously defined parser.
Continuing with the parser defined in the previous section, adding an
 to a parser is easy:


This would result in the following help output:


A bit more complete example might involve using more than one group: still
extending the previous example:


that results in the following output:


Another interesting method, in particular when working programmatically with
option groups is:


(opt_str)¶
Return the  to which the short or long option
string opt_str (e.g.  or ) belongs. If
there’s no such , return .




Printing a version string¶
Similar to the brief usage string,  can also print a version
string for your program.  You have to supply the string as the 
argument to OptionParser:


 is expanded just like it is in .  Apart from that,
 can contain anything you like.  When you supply it, 
automatically adds a  option to your parser. If it encounters
this option on the command line, it expands your  string (by
replacing ), prints it to stdout, and exits.
For example, if your script is called :


The following two methods can be used to print and get the  string:


(file=None)¶
Print the version message for the current program () to
file (default stdout).  As with , any occurrence
of  in  is replaced with the name of the current
program.  Does nothing if  is empty or undefined.



()¶
Same as  but returns the version string instead of
printing it.



How  handles errors¶
There are two broad classes of errors that  has to worry about:
programmer errors and user errors.  Programmer errors are usually erroneous
calls to , e.g. invalid option strings, unknown
option attributes, missing option attributes, etc.  These are dealt with in the
usual way: raise an exception (either  or
) and let the program crash.
Handling user errors is much more important, since they are guaranteed to happen
no matter how stable your code is.   can automatically detect
some user errors, such as bad option arguments (passing  where
 takes an integer argument), missing arguments ( at the end
of the command line, where  takes an argument of any type).  Also,
you can call  to signal an application-defined error
condition:


In either case,  handles the error the same way: it prints the
program’s usage message and an error message to standard error and exits with
error status 2.
Consider the first example above, where the user passes  to an option
that takes an integer:


Or, where the user fails to pass a value at all:


-generated error messages take care always to mention the
option involved in the error; be sure to do the same when calling
 from your application code.
If ’s default error-handling behaviour does not suit your needs,
you’ll need to subclass OptionParser and override its 
and/or  methods.


Putting it all together¶
Here’s what -based scripts usually look like:





Reference Guide¶

Creating the parser¶
The first step in using  is to create an OptionParser instance.


class (...)¶
The OptionParser constructor has no required arguments, but a number of
optional keyword arguments.  You should always pass them as keyword
arguments, i.e. do not rely on the order in which the arguments are declared.

 (default: )
The usage summary to print when your program is run incorrectly or with a
help option.  When  prints the usage string, it expands
 to  (or to  if you
passed that keyword argument).  To suppress a usage message, pass the
special value .
 (default: )
A list of Option objects to populate the parser with.  The options in
 are added after any options in  (a
class attribute that may be set by OptionParser subclasses), but before
any version or help options. Deprecated; use  after
creating the parser instead.
 (default: optparse.Option)
Class to use when adding options to the parser in .
 (default: )
A version string to print when the user supplies a version option. If you
supply a true value for ,  automatically adds a
version option with the single option string .  The
substring  is expanded the same as for .
 (default: )
Specifies what to do when options with conflicting option strings are
added to the parser; see section
Conflicts between options.
 (default: )
A paragraph of text giving a brief overview of your program.
 reformats this paragraph to fit the current terminal width
and prints it when the user requests help (after , but before the
list of options).
 (default: a new )
An instance of optparse.HelpFormatter that will be used for printing help
text.   provides two concrete classes for this purpose:
IndentedHelpFormatter and TitledHelpFormatter.
 (default: )
If true,  will add a help option (with option strings 
and ) to the parser.

The string to use when expanding  in  and 
instead of .
 (default: )
A paragraph of help text to print after the option help.




Populating the parser¶
There are several ways to populate the parser with options.  The preferred way
is by using , as shown in section
Tutorial.   can be called in one of two ways:

pass it an Option instance (as returned by )
pass it any combination of positional and keyword arguments that are
acceptable to  (i.e., to the Option constructor), and it
will create the Option instance for you

The other alternative is to pass a list of pre-constructed Option instances to
the OptionParser constructor, as in:


( is a factory function for creating Option instances;
currently it is an alias for the Option constructor.  A future version of
 may split Option into several classes, and 
will pick the right class to instantiate.  Do not instantiate Option directly.)


Defining options¶
Each Option instance represents a set of synonymous command-line option strings,
e.g.  and .  You can specify any number of short or
long option strings, but you must specify at least one overall option string.
The canonical way to create an  instance is with the
 method of .


(option)¶

(*opt_str, attr=value, ...)
To define an option with only a short option string:


And to define an option with only a long option string:


The keyword arguments define attributes of the new Option object.  The most
important option attribute is , and it largely
determines which other attributes are relevant or required.  If you pass
irrelevant option attributes, or fail to pass required ones, 
raises an  exception explaining your mistake.
An option’s action determines what  does when it encounters
this option on the command-line.  The standard option actions hard-coded into
 are:


store this option’s argument (default)

store a constant value

store a true value

store a false value

append this option’s argument to a list

append a constant value to a list

increment a counter by one

call a specified function

print a usage message including all options and the documentation for them

(If you don’t supply an action, the default is .  For this action,
you may also supply  and  option
attributes; see Standard option actions.)

As you can see, most actions involve storing or updating a value somewhere.
 always creates a special object for this, conventionally called
 (it happens to be an instance of ).  Option
arguments (and various other values) are stored as attributes of this object,
according to the  (destination) option attribute.
For example, when you call


one of the first things  does is create the  object:


If one of the options in this parser is defined with


and the command-line being parsed includes any of the following:


then , on seeing this option, will do the equivalent of


The  and  option attributes are almost
as important as , but  is the only
one that makes sense for all options.


Option attributes¶
The following option attributes may be passed as keyword arguments to
.  If you pass an option attribute that is not
relevant to a particular option, or fail to pass a required option attribute,
 raises .


¶
(default: )
Determines ’s behaviour when this option is seen on the
command line; the available options are documented here.



¶
(default: )
The argument type expected by this option (e.g.,  or );
the available option types are documented here.



¶
(default: derived from option strings)
If the option’s action implies writing or modifying a value somewhere, this
tells  where to write it:  names an
attribute of the  object that  builds as it parses
the command line.



¶
The value to use for this option’s destination if the option is not seen on
the command line.  See also .



¶
(default: 1)
How many arguments of type  should be consumed when this
option is seen.  If > 1,  will store a tuple of values to
.



¶
For actions that store a constant value, the constant value to store.



¶
For options of type , the list of strings the user may choose
from.



¶
For options with action , the callable to call when this option
is seen.  See section Option Callbacks for detail on the
arguments passed to the callable.



¶

¶
Additional positional and keyword arguments to pass to  after the
four standard callback arguments.



¶
Help text to print for this option when listing all available options after
the user supplies a  option (such as ).  If
no help text is supplied, the option will be listed without help text.  To
hide this option, use the special value .



¶
(default: derived from option strings)
Stand-in for the option argument(s) to use when printing help text.  See
section Tutorial for an example.



Standard option actions¶
The various option actions all have slightly different requirements and effects.
Most actions have several relevant option attributes which you may specify to
guide ’s behaviour; a few have required attributes, which you
must specify for any option using that action.

 [relevant: , ,
, ]
The option must be followed by an argument, which is converted to a value
according to  and stored in .  If
 > 1, multiple arguments will be consumed from the
command line; all will be converted according to  and
stored to  as a tuple.  See the
Standard option types section.
If  is supplied (a list or tuple of strings), the type
defaults to .
If  is not supplied, it defaults to .
If  is not supplied,  derives a destination
from the first long option string (e.g.,  implies
). If there are no long option strings,  derives a
destination from the first short option string (e.g.,  implies ).
Example:


As it parses the command line


 will set



 [required: ; relevant:
]
The value  is stored in .
Example:


If  is seen,  will set



 [relevant: ]
A special case of  that stores a true value to
.

 [relevant: ]
Like , but stores a false value.
Example:



 [relevant: , ,
, ]
The option must be followed by an argument, which is appended to the list in
.  If no default value for  is
supplied, an empty list is automatically created when  first
encounters this option on the command-line.  If  > 1,
multiple arguments are consumed, and a tuple of length 
is appended to .
The defaults for  and  are the same as
for the  action.
Example:


If  is seen on the command-line,  does the equivalent
of:


If, a little later on,  is seen, it does:


The  action calls the  method on the current value of the
option.  This means that any default value specified must have an 
method.  It also means that if the default value is non-empty, the default
elements will be present in the parsed value for the option, with any values
from the command line appended after those default values:



 [required: ; relevant:
]
Like , but the value  is appended to
; as with ,  defaults to
, and an empty list is automatically created the first time the option
is encountered.

 [relevant: ]
Increment the integer stored at .  If no default value is
supplied,  is set to zero before being incremented the
first time.
Example:


The first time  is seen on the command line,  does the
equivalent of:


Every subsequent occurrence of  results in



 [required: ; relevant:
, , ,
]
Call the function specified by , which is called as


See section Option Callbacks for more detail.


Prints a complete help message for all the options in the current option
parser.  The help message is constructed from the  string passed to
OptionParser’s constructor and the  string passed to every
option.
If no  string is supplied for an option, it will still be
listed in the help message.  To omit an option entirely, use the special value
.
 automatically adds a  option to all
OptionParsers, so you do not normally need to create one.
Example:


If  sees either  or  on the command line,
it will print something like the following help message to stdout (assuming
 is ):


After printing the help message,  terminates your process with
.


Prints the version number supplied to the OptionParser to stdout and exits.
The version number is actually formatted and printed by the
 method of OptionParser.  Generally only relevant if the
 argument is supplied to the OptionParser constructor.  As with
 options, you will rarely create  options,
since  automatically adds them when needed.




Standard option types¶
 has five built-in option types: , ,
,  and .  If you need to add new
option types, see section Extending optparse.
Arguments to string options are not checked or converted in any way: the text on
the command line is stored in the destination (or passed to the callback) as-is.
Integer arguments (type ) are parsed as follows:

if the number starts with , it is parsed as a hexadecimal number
if the number starts with , it is parsed as an octal number
if the number starts with , it is parsed as a binary number
otherwise, the number is parsed as a decimal number

The conversion is done by calling  with the appropriate base (2, 8,
10, or 16).  If this fails, so will , although with a more useful
error message.
 and  option arguments are converted directly with
 and , with similar error-handling.
 options are a subtype of  options.  The
 option attribute (a sequence of strings) defines the
set of allowed option arguments.   compares
user-supplied option arguments against this master list and raises
 if an invalid string is given.


Parsing arguments¶
The whole point of creating and populating an OptionParser is to call its
 method:


where the input parameters are


the list of arguments to process (default: )

an  object to store option arguments in (default: a
new instance of ) – if you give an existing object, the
option defaults will not be initialized on it

and the return values are


the same object that was passed in as , or the optparse.Values
instance created by 

the leftover positional arguments after all options have been processed

The most common usage is to supply neither keyword argument.  If you supply
, it will be modified with repeated  calls (roughly one
for every option argument stored to an option destination) and returned by
.
If  encounters any errors in the argument list, it calls the
OptionParser’s  method with an appropriate end-user error message.
This ultimately terminates your process with an exit status of 2 (the
traditional Unix exit status for command-line errors).


Querying and manipulating your option parser¶
The default behavior of the option parser can be customized slightly, and you
can also poke around your option parser and see what’s there.  OptionParser
provides several methods to help you out:


()¶
Set parsing to stop on the first non-option.  For example, if  and
 are both simple options that take no arguments, 
normally accepts this syntax:


and treats it as equivalent to


To disable this feature, call .  This
restores traditional Unix syntax, where option parsing stops with the first
non-option argument.
Use this if you have a command processor which runs another command which has
options of its own and you want to make sure these options don’t get
confused.  For example, each command might have a different set of options.



()¶
Set parsing to not stop on the first non-option, allowing interspersing
switches with command arguments.  This is the default behavior.



(opt_str)¶
Returns the Option instance with the option string opt_str, or  if
no options have that option string.



(opt_str)¶
Return true if the OptionParser has an option with option string opt_str
(e.g.,  or ).



(opt_str)¶
If the  has an option corresponding to opt_str, that
option is removed.  If that option provided any other option strings, all of
those option strings become invalid. If opt_str does not occur in any
option belonging to this , raises .



Conflicts between options¶
If you’re not careful, it’s easy to define options with conflicting option
strings:


(This is particularly true if you’ve defined your own OptionParser subclass with
some standard options.)
Every time you add an option,  checks for conflicts with existing
options.  If it finds any, it invokes the current conflict-handling mechanism.
You can set the conflict-handling mechanism either in the constructor:


or with a separate call:


The available conflict handlers are:


 (default)
assume option conflicts are a programming error and raise


resolve option conflicts intelligently (see below)


As an example, let’s define an  that resolves conflicts
intelligently and add conflicting options to it:


At this point,  detects that a previously-added option is already
using the  option string.  Since  is ,
it resolves the situation by removing  from the earlier option’s list of
option strings.  Now  is the only way for the user to activate
that option.  If the user asks for help, the help message will reflect that:


It’s possible to whittle away the option strings for a previously-added option
until there are none left, and the user has no way of invoking that option from
the command-line.  In that case,  removes that option completely,
so it doesn’t show up in help text or anywhere else. Carrying on with our
existing OptionParser:


At this point, the original / option is no longer
accessible, so  removes it, leaving this help text:




Cleanup¶
OptionParser instances have several cyclic references.  This should not be a
problem for Python’s garbage collector, but you may wish to break the cyclic
references explicitly by calling  on your
OptionParser once you are done with it.  This is particularly useful in
long-running applications where large object graphs are reachable from your
OptionParser.


Other methods¶
OptionParser supports several other public methods:


(usage)¶
Set the usage string according to the rules described above for the 
constructor keyword argument.  Passing  sets the default usage
string; use  to suppress a usage message.



(file=None)¶
Print the usage message for the current program () to file
(default stdout).  Any occurrence of the string  in 
is replaced with the name of the current program.  Does nothing if
 is empty or not defined.



()¶
Same as  but returns the usage string instead of
printing it.



(dest=value, ...)¶
Set default values for several option destinations at once.  Using
 is the preferred way to set default values for options,
since multiple options can share the same destination.  For example, if
several “mode” options all set the same destination, any one of them can set
the default, and the last one wins:


To avoid this confusion, use :






Option Callbacks¶
When ’s built-in actions and types aren’t quite enough for your
needs, you have two choices: extend  or define a callback option.
Extending  is more general, but overkill for a lot of simple
cases.  Quite often a simple callback is all you need.
There are two steps to defining a callback option:

define the option itself using the  action
write the callback; this is a function (or method) that takes at least four
arguments, as described below


Defining a callback option¶
As always, the easiest way to define a callback option is by using the
 method.  Apart from , the
only option attribute you must specify is , the function to call:


 is a function (or other callable object), so you must have already
defined  when you create this callback option. In this simple
case,  doesn’t even know if  takes any arguments,
which usually means that the option takes no arguments—the mere presence of
 on the command-line is all it needs to know.  In some
circumstances, though, you might want your callback to consume an arbitrary
number of command-line arguments.  This is where writing callbacks gets tricky;
it’s covered later in this section.
 always passes four particular arguments to your callback, and it
will only pass additional arguments if you specify them via
 and .  Thus, the
minimal callback function signature is:


The four arguments to a callback are described below.
There are several other option attributes that you can supply when you define a
callback option:


has its usual meaning: as with the  or  actions, it
instructs  to consume one argument and convert it to
.  Rather than storing the converted value(s) anywhere,
though,  passes it to your callback function.

also has its usual meaning: if it is supplied and > 1,  will
consume  arguments, each of which must be convertible to
.  It then passes a tuple of converted values to your
callback.

a tuple of extra positional arguments to pass to the callback

a dictionary of extra keyword arguments to pass to the callback



How callbacks are called¶
All callbacks are called as follows:


where


is the Option instance that’s calling the callback

is the option string seen on the command-line that’s triggering the callback.
(If an abbreviated long option was used,  will be the full,
canonical option string—e.g. if the user puts  on the
command-line as an abbreviation for , then  will be
.)

is the argument to this option seen on the command-line.   will
only expect an argument if  is set; the type of  will be
the type implied by the option’s type.  If  for this option is
 (no argument expected), then  will be .  If 
> 1,  will be a tuple of values of the appropriate type.

is the OptionParser instance driving the whole thing, mainly useful because
you can access some other interesting data through its instance attributes:


the current list of leftover arguments, ie. arguments that have been
consumed but are neither options nor option arguments. Feel free to modify
, e.g. by adding more arguments to it.  (This list will
become , the second return value of .)

the current list of remaining arguments, ie. with  and
 (if applicable) removed, and only the arguments following them
still there.  Feel free to modify , e.g. by consuming more
arguments.

the object where option values are by default stored (an instance of
optparse.OptionValues).  This lets callbacks use the same mechanism as the
rest of  for storing option values; you don’t need to mess
around with globals or closures.  You can also access or modify the
value(s) of any options already encountered on the command-line.



is a tuple of arbitrary positional arguments supplied via the
 option attribute.

is a dictionary of arbitrary keyword arguments supplied via
.



Raising errors in a callback¶
The callback function should raise  if there are any
problems with the option or its argument(s).   catches this and
terminates the program, printing the error message you supply to stderr.  Your
message should be clear, concise, accurate, and mention the option at fault.
Otherwise, the user will have a hard time figuring out what they did wrong.


Callback example 1: trivial callback¶
Here’s an example of a callback option that takes no arguments, and simply
records that the option was seen:


Of course, you could do that with the  action.


Callback example 2: check option order¶
Here’s a slightly more interesting example: record the fact that  is
seen, but blow up if it comes after  in the command-line.




Callback example 3: check option order (generalized)¶
If you want to re-use this callback for several similar options (set a flag, but
blow up if  has already been seen), it needs a bit of work: the error
message and the flag that it sets must be generalized.




Callback example 4: check arbitrary condition¶
Of course, you could put any condition in there—you’re not limited to checking
the values of already-defined options.  For example, if you have options that
should not be called when the moon is full, all you have to do is this:


(The definition of  is left as an exercise for the reader.)


Callback example 5: fixed arguments¶
Things get slightly more interesting when you define callback options that take
a fixed number of arguments.  Specifying that a callback option takes arguments
is similar to defining a  or  option: if you define
, then the option takes one argument that must be
convertible to that type; if you further define , then the
option takes  arguments.
Here’s an example that just emulates the standard  action:


Note that  takes care of consuming 3 arguments and converting
them to integers for you; all you have to do is store them.  (Or whatever;
obviously you don’t need a callback for this example.)


Callback example 6: variable arguments¶
Things get hairy when you want an option to take a variable number of arguments.
For this case, you must write a callback, as  doesn’t provide any
built-in capabilities for it.  And you have to deal with certain intricacies of
conventional Unix command-line parsing that  normally handles for
you.  In particular, callbacks should implement the conventional rules for bare
 and  arguments:

either  or  can be option arguments
bare  (if not the argument to some option): halt command-line
processing and discard the 
bare  (if not the argument to some option): halt command-line
processing but keep the  (append it to )

If you want an option that takes a variable number of arguments, there are
several subtle, tricky issues to worry about.  The exact implementation you
choose will be based on which trade-offs you’re willing to make for your
application (which is why  doesn’t support this sort of thing
directly).
Nevertheless, here’s a stab at a callback for an option with variable
arguments:





Extending ¶
Since the two major controlling factors in how  interprets
command-line options are the action and type of each option, the most likely
direction of extension is to add new actions and new types.

Adding new types¶
To add new types, you need to define your own subclass of ’s
 class.  This class has a couple of attributes that define
’s types:  and .


¶
A tuple of type names; in your subclass, simply define a new tuple
 that builds on the standard one.



¶
A dictionary mapping type names to type-checking functions.  A type-checking
function has the following signature:


where  is an  instance,  is an option string
(e.g., ), and  is the string from the command line that must
be checked and converted to your desired type.   should
return an object of the hypothetical type .  The value returned by
a type-checking function will wind up in the OptionValues instance returned
by , or be passed to a callback as the
 parameter.
Your type-checking function should raise  if it
encounters any problems.   takes a single string
argument, which is passed as-is to ’s 
method, which in turn prepends the program name and the string 
and prints everything to stderr before terminating the process.

Here’s a silly example that demonstrates adding a  option type to
parse Python-style complex numbers on the command line.  (This is even sillier
than it used to be, because  1.3 added built-in support for
complex numbers, but never mind.)
First, the necessary imports:


You need to define your type-checker first, since it’s referred to later (in the
 class attribute of your Option subclass):


Finally, the Option subclass:


(If we didn’t make a  of , we would end
up modifying the  attribute of ’s
Option class.  This being Python, nothing stops you from doing that except good
manners and common sense.)
That’s it!  Now you can write a script that uses the new option type just like
any other -based script, except you have to instruct your
OptionParser to use MyOption instead of Option:


Alternately, you can build your own option list and pass it to OptionParser; if
you don’t use  in the above way, you don’t need to tell
OptionParser which option class to use:




Adding new actions¶
Adding new actions is a bit trickier, because you have to understand that
 has a couple of classifications for actions:

“store” actions
actions that result in  storing a value to an attribute of the
current OptionValues instance; these options require a 
attribute to be supplied to the Option constructor.
“typed” actions
actions that take a value from the command line and expect it to be of a
certain type; or rather, a string that can be converted to a certain type.
These options require a  attribute to the Option
constructor.

These are overlapping sets: some default “store” actions are ,
, , and , while the default “typed”
actions are , , and .
When you add an action, you need to categorize it by listing it in at least one
of the following class attributes of Option (all are lists of strings):


¶
All actions must be listed in ACTIONS.



¶
“store” actions are additionally listed here.



¶
“typed” actions are additionally listed here.



¶
Actions that always take a type (i.e. whose options always take a value) are
additionally listed here.  The only effect of this is that 
assigns the default type, , to options with no explicit type
whose action is listed in .

In order to actually implement your new action, you must override Option’s
 method and add a case that recognizes your action.
For example, let’s add an  action.  This is similar to the standard
 action, but instead of taking a single value from the command-line
and appending it to an existing list,  will take multiple values in
a single comma-delimited string, and extend an existing list with them.  That
is, if  is an  option of type , the command
line


would result in a list


Again we define a subclass of Option:


Features of note:

 both expects a value on the command-line and stores that value
somewhere, so it goes in both  and
.

to ensure that  assigns the default type of  to
 actions, we put the  action in
 as well.

 implements just this one new action, and passes
control back to  for the standard 
actions.

 is an instance of the optparse_parser.Values class, which provides
the very useful  method.  is
essentially  with a safety valve; it is called as


If the  attribute of  doesn’t exist or is , then
ensure_value() first sets it to , and then returns ‘value. This is
very handy for actions like , , and , all
of which accumulate data in a variable and expect that variable to be of a
certain type (a list for the first two, an integer for the latter).  Using
 means that scripts using your action don’t have to worry
about setting a default value for the option destinations in question; they
can just leave the default as  and  will take care of
getting it right when it’s needed.




