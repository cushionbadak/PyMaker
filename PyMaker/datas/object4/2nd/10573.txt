link:
library/optparse.html#option-callbacks

docs:

Option Callbacks¶
When ’s built-in actions and types aren’t quite enough for your
needs, you have two choices: extend  or define a callback option.
Extending  is more general, but overkill for a lot of simple
cases.  Quite often a simple callback is all you need.
There are two steps to defining a callback option:

define the option itself using the  action
write the callback; this is a function (or method) that takes at least four
arguments, as described below


Defining a callback option¶
As always, the easiest way to define a callback option is by using the
 method.  Apart from , the
only option attribute you must specify is , the function to call:


 is a function (or other callable object), so you must have already
defined  when you create this callback option. In this simple
case,  doesn’t even know if  takes any arguments,
which usually means that the option takes no arguments—the mere presence of
 on the command-line is all it needs to know.  In some
circumstances, though, you might want your callback to consume an arbitrary
number of command-line arguments.  This is where writing callbacks gets tricky;
it’s covered later in this section.
 always passes four particular arguments to your callback, and it
will only pass additional arguments if you specify them via
 and .  Thus, the
minimal callback function signature is:


The four arguments to a callback are described below.
There are several other option attributes that you can supply when you define a
callback option:


has its usual meaning: as with the  or  actions, it
instructs  to consume one argument and convert it to
.  Rather than storing the converted value(s) anywhere,
though,  passes it to your callback function.

also has its usual meaning: if it is supplied and > 1,  will
consume  arguments, each of which must be convertible to
.  It then passes a tuple of converted values to your
callback.

a tuple of extra positional arguments to pass to the callback

a dictionary of extra keyword arguments to pass to the callback



How callbacks are called¶
All callbacks are called as follows:


where


is the Option instance that’s calling the callback

is the option string seen on the command-line that’s triggering the callback.
(If an abbreviated long option was used,  will be the full,
canonical option string—e.g. if the user puts  on the
command-line as an abbreviation for , then  will be
.)

is the argument to this option seen on the command-line.   will
only expect an argument if  is set; the type of  will be
the type implied by the option’s type.  If  for this option is
 (no argument expected), then  will be .  If 
> 1,  will be a tuple of values of the appropriate type.

is the OptionParser instance driving the whole thing, mainly useful because
you can access some other interesting data through its instance attributes:


the current list of leftover arguments, ie. arguments that have been
consumed but are neither options nor option arguments. Feel free to modify
, e.g. by adding more arguments to it.  (This list will
become , the second return value of .)

the current list of remaining arguments, ie. with  and
 (if applicable) removed, and only the arguments following them
still there.  Feel free to modify , e.g. by consuming more
arguments.

the object where option values are by default stored (an instance of
optparse.OptionValues).  This lets callbacks use the same mechanism as the
rest of  for storing option values; you don’t need to mess
around with globals or closures.  You can also access or modify the
value(s) of any options already encountered on the command-line.



is a tuple of arbitrary positional arguments supplied via the
 option attribute.

is a dictionary of arbitrary keyword arguments supplied via
.



Raising errors in a callback¶
The callback function should raise  if there are any
problems with the option or its argument(s).   catches this and
terminates the program, printing the error message you supply to stderr.  Your
message should be clear, concise, accurate, and mention the option at fault.
Otherwise, the user will have a hard time figuring out what they did wrong.


Callback example 1: trivial callback¶
Here’s an example of a callback option that takes no arguments, and simply
records that the option was seen:


Of course, you could do that with the  action.


Callback example 2: check option order¶
Here’s a slightly more interesting example: record the fact that  is
seen, but blow up if it comes after  in the command-line.




Callback example 3: check option order (generalized)¶
If you want to re-use this callback for several similar options (set a flag, but
blow up if  has already been seen), it needs a bit of work: the error
message and the flag that it sets must be generalized.




Callback example 4: check arbitrary condition¶
Of course, you could put any condition in there—you’re not limited to checking
the values of already-defined options.  For example, if you have options that
should not be called when the moon is full, all you have to do is this:


(The definition of  is left as an exercise for the reader.)


Callback example 5: fixed arguments¶
Things get slightly more interesting when you define callback options that take
a fixed number of arguments.  Specifying that a callback option takes arguments
is similar to defining a  or  option: if you define
, then the option takes one argument that must be
convertible to that type; if you further define , then the
option takes  arguments.
Here’s an example that just emulates the standard  action:


Note that  takes care of consuming 3 arguments and converting
them to integers for you; all you have to do is store them.  (Or whatever;
obviously you don’t need a callback for this example.)


Callback example 6: variable arguments¶
Things get hairy when you want an option to take a variable number of arguments.
For this case, you must write a callback, as  doesn’t provide any
built-in capabilities for it.  And you have to deal with certain intricacies of
conventional Unix command-line parsing that  normally handles for
you.  In particular, callbacks should implement the conventional rules for bare
 and  arguments:

either  or  can be option arguments
bare  (if not the argument to some option): halt command-line
processing and discard the 
bare  (if not the argument to some option): halt command-line
processing but keep the  (append it to )

If you want an option that takes a variable number of arguments, there are
several subtle, tricky issues to worry about.  The exact implementation you
choose will be based on which trade-offs you’re willing to make for your
application (which is why  doesn’t support this sort of thing
directly).
Nevertheless, here’s a stab at a callback for an option with variable
arguments:



