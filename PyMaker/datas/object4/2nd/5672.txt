link:
library/email.compat32-message.html#email.message.Message

docs:


class (policy=compat32)¶
If policy is specified (it must be an instance of a 
class) use the rules it specifies to update and serialize the representation
of the message.  If policy is not set, use the  policy, which maintains backward compatibility with
the Python 3.2 version of the email package.  For more information see the
 documentation.

Changed in version 3.3: The policy keyword argument was added.



(unixfrom=False, maxheaderlen=0, policy=None)¶
Return the entire message flattened as a string.  When optional unixfrom
is true, the envelope header is included in the returned string.
unixfrom defaults to .  For backward compatibility reasons,
maxheaderlen defaults to , so if you want a different value you
must override it explicitly (the value specified for max_line_length in
the policy will be ignored by this method).  The policy argument may be
used to override the default policy obtained from the message instance.
This can be used to control some of the formatting produced by the
method, since the specified policy will be passed to the .
Flattening the message may trigger changes to the  if
defaults need to be filled in to complete the transformation to a string
(for example, MIME boundaries may be generated or modified).
Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with  that is
required by the unix mbox format.  For more flexibility, instantiate a
 instance and use its
 method directly.  For example:


If the message object contains binary data that is not encoded according
to RFC standards, the non-compliant data will be replaced by unicode
“unknown character” code points.  (See also  and
.)

Changed in version 3.4: the policy keyword argument was added.




()¶
Equivalent to .  Allows  to produce a
string containing the formatted message.



(unixfrom=False, policy=None)¶
Return the entire message flattened as a bytes object.  When optional
unixfrom is true, the envelope header is included in the returned
string.  unixfrom defaults to .  The policy argument may be
used to override the default policy obtained from the message instance.
This can be used to control some of the formatting produced by the
method, since the specified policy will be passed to the
.
Flattening the message may trigger changes to the  if
defaults need to be filled in to complete the transformation to a string
(for example, MIME boundaries may be generated or modified).
Note that this method is provided as a convenience and may not always
format the message the way you want.  For example, by default it does
not do the mangling of lines that begin with  that is
required by the unix mbox format.  For more flexibility, instantiate a
 instance and use its
 method directly.
For example:



New in version 3.4.




()¶
Equivalent to .  Allows  to produce a
bytes object containing the formatted message.

New in version 3.4.




()¶
Return  if the message’s payload is a list of
sub- objects, otherwise return .  When
 returns , the payload should be a string
object (which might be a CTE encoded binary payload).  (Note that
 returning  does not necessarily mean that
“msg.get_content_maintype() == ‘multipart’” will return the .
For example,  will return  when the
 is of type .)



(unixfrom)¶
Set the message’s envelope header to unixfrom, which should be a string.



()¶
Return the message’s envelope header.  Defaults to  if the
envelope header was never set.



(payload)¶
Add the given payload to the current payload, which must be  or
a list of  objects before the call. After the call, the
payload will always be a list of  objects.  If you want to
set the payload to a scalar object (e.g. a string), use
 instead.
This is a legacy method.  On the
 class its functionality is
replaced by  and the
related  and  methods.



(i=None, decode=False)¶
Return the current payload, which will be a list of
 objects when  is , or a
string when  is .  If the payload is a list
and you mutate the list object, you modify the message’s payload in place.
With optional argument i,  will return the i-th
element of the payload, counting from zero, if  is
.  An  will be raised if i is less than 0 or
greater than or equal to the number of items in the payload.  If the
payload is a string (i.e.   is ) and i is
given, a  is raised.
Optional decode is a flag indicating whether the payload should be
decoded or not, according to the Content-Transfer-Encoding
header. When  and the message is not a multipart, the payload will
be decoded if this header’s value is  or .
If some other encoding is used, or Content-Transfer-Encoding
header is missing, the payload is
returned as-is (undecoded).  In all cases the returned value is binary
data.  If the message is a multipart and the decode flag is ,
then  is returned.  If the payload is base64 and it was not
perfectly formed (missing padding, characters outside the base64
alphabet), then an appropriate defect will be added to the message’s
defect property ( or
, respectively).
When decode is  (the default) the body is returned as a string
without decoding the Content-Transfer-Encoding.  However,
for a Content-Transfer-Encoding of 8bit, an attempt is made
to decode the original bytes using the  specified by the
Content-Type header, using the  error handler.
If no  is specified, or if the  given is not
recognized by the email package, the body is decoded using the default
ASCII charset.
This is a legacy method.  On the
 class its functionality is
replaced by  and
.



(payload, charset=None)¶
Set the entire message object’s payload to payload.  It is the client’s
responsibility to ensure the payload invariants.  Optional charset sets
the message’s default character set; see  for details.
This is a legacy method.  On the
 class its functionality is
replaced by .



(charset)¶
Set the character set of the payload to charset, which can either be a
 instance (see ), a
string naming a character set, or .  If it is a string, it will
be converted to a  instance.  If charset
is , the  parameter will be removed from the
Content-Type header (the message will not be otherwise
modified).  Anything else will generate a .
If there is no existing MIME-Version header one will be
added.  If there is no existing Content-Type header, one
will be added with a value of text/plain.  Whether the
Content-Type header already exists or not, its 
parameter will be set to charset.output_charset.   If
charset.input_charset and charset.output_charset differ, the payload
will be re-encoded to the output_charset.  If there is no existing
Content-Transfer-Encoding header, then the payload will be
transfer-encoded, if needed, using the specified
, and a header with the appropriate value
will be added.  If a Content-Transfer-Encoding header
already exists, the payload is assumed to already be correctly encoded
using that Content-Transfer-Encoding and is not modified.
This is a legacy method.  On the
 class its functionality is
replaced by the charset parameter of the
 method.



()¶
Return the  instance associated with the
message’s payload.
This is a legacy method.  On the
 class it always returns
.

The following methods implement a mapping-like interface for accessing the
message’s RFC 2822 headers.  Note that there are some semantic differences
between these methods and a normal mapping (i.e. dictionary) interface.  For
example, in a dictionary there are no duplicate keys, but here there may be
duplicate message headers.  Also, in dictionaries there is no guaranteed
order to the keys returned by , but in a  object,
headers are always returned in the order they appeared in the original
message, or were added to the message later.  Any header deleted and then
re-added are always appended to the end of the header list.
These semantic differences are intentional and are biased toward maximal
convenience.
Note that in all cases, any envelope header present in the message is not
included in the mapping interface.
In a model generated from bytes, any header values that (in contravention of
the RFCs) contain non-ASCII bytes will, when retrieved through this
interface, be represented as  objects with
a charset of unknown-8bit.


()¶
Return the total number of headers, including duplicates.



(name)¶
Return true if the message object has a field named name. Matching is
done case-insensitively and name should not include the trailing colon.
Used for the  operator, e.g.:





(name)¶
Return the value of the named header field.  name should not include the
colon field separator.  If the header is missing,  is returned; a
 is never raised.
Note that if the named field appears more than once in the message’s
headers, exactly which of those field values will be returned is
undefined.  Use the  method to get the values of all the
extant named headers.



(name, val)¶
Add a header to the message with field name name and value val.  The
field is appended to the end of the message’s existing fields.
Note that this does not overwrite or delete any existing header with the same
name.  If you want to ensure that the new header is the only one present in the
message with field name name, delete the field first, e.g.:





(name)¶
Delete all occurrences of the field with name name from the message’s
headers.  No exception is raised if the named field isn’t present in the
headers.



()¶
Return a list of all the message’s header field names.



()¶
Return a list of all the message’s field values.



()¶
Return a list of 2-tuples containing all the message’s field headers and
values.



(name, failobj=None)¶
Return the value of the named header field.  This is identical to
 except that optional failobj is returned if the
named header is missing (defaults to ).

Here are some additional useful methods:


(name, failobj=None)¶
Return a list of all the values for the field named name. If there are
no such named headers in the message, failobj is returned (defaults to
).



(_name, _value, **_params)¶
Extended header setting.  This method is similar to 
except that additional header parameters can be provided as keyword
arguments.  _name is the header field to add and _value is the
primary value for the header.
For each item in the keyword argument dictionary _params, the key is
taken as the parameter name, with underscores converted to dashes (since
dashes are illegal in Python identifiers).  Normally, the parameter will
be added as  unless the value is , in which case
only the key will be added.  If the value contains non-ASCII characters,
it can be specified as a three tuple in the format
, where  is a string naming the
charset to be used to encode the value,  can usually be set
to  or the empty string (see RFC 2231 for other possibilities),
and  is the string value containing non-ASCII code points.  If
a three tuple is not passed and the value contains non-ASCII characters,
it is automatically encoded in RFC 2231 format using a 
of  and a  of .
Here’s an example:


This will add a header that looks like


An example with non-ASCII characters:


Which produces





(_name, _value)¶
Replace a header.  Replace the first header found in the message that
matches _name, retaining header order and field name case.  If no
matching header was found, a  is raised.



()¶
Return the message’s content type.  The returned string is coerced to
lower case of the form maintype/subtype.  If there was no
Content-Type header in the message the default type as given
by  will be returned.  Since according to
RFC 2045, messages always have a default type, 
will always return a value.
RFC 2045 defines a message’s default type to be text/plain
unless it appears inside a multipart/digest container, in
which case it would be message/rfc822.  If the
Content-Type header has an invalid type specification,
RFC 2045 mandates that the default type be text/plain.



()¶
Return the message’s main content type.  This is the maintype
part of the string returned by .



()¶
Return the message’s sub-content type.  This is the subtype
part of the string returned by .



()¶
Return the default content type.  Most messages have a default content
type of text/plain, except for messages that are subparts of
multipart/digest containers.  Such subparts have a default
content type of message/rfc822.



(ctype)¶
Set the default content type.  ctype should either be
text/plain or message/rfc822, although this is not
enforced.  The default content type is not stored in the
Content-Type header.



(failobj=None, header='content-type', unquote=True)¶
Return the message’s Content-Type parameters, as a list.
The elements of the returned list are 2-tuples of key/value pairs, as
split on the  sign.  The left hand side of the  is the key,
while the right hand side is the value.  If there is no  sign in
the parameter the value is the empty string, otherwise the value is as
described in  and is unquoted if optional unquote is
 (the default).
Optional failobj is the object to return if there is no
Content-Type header.  Optional header is the header to
search instead of Content-Type.
This is a legacy method.  On the
 class its functionality is
replaced by the params property of the individual header objects
returned by the header access methods.



(param, failobj=None, header='content-type', unquote=True)¶
Return the value of the Content-Type header’s parameter
param as a string.  If the message has no Content-Type
header or if there is no such parameter, then failobj is returned
(defaults to ).
Optional header if given, specifies the message header to use instead of
Content-Type.
Parameter keys are always compared case insensitively.  The return value
can either be a string, or a 3-tuple if the parameter was RFC 2231
encoded.  When it’s a 3-tuple, the elements of the value are of the form
.  Note that both  and
 can be , in which case you should consider 
to be encoded in the  charset.  You can usually ignore
.
If your application doesn’t care whether the parameter was encoded as in
RFC 2231, you can collapse the parameter value by calling
, passing in the return value
from .  This will return a suitably decoded Unicode
string when the value is a tuple, or the original string unquoted if it
isn’t.  For example:


In any case, the parameter value (either the returned string, or the
 item in the 3-tuple) is always unquoted, unless unquote is set
to .
This is a legacy method.  On the
 class its functionality is
replaced by the params property of the individual header objects
returned by the header access methods.



(param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)¶
Set a parameter in the Content-Type header.  If the
parameter already exists in the header, its value will be replaced with
value.  If the Content-Type header as not yet been defined
for this message, it will be set to text/plain and the new
parameter value will be appended as per RFC 2045.
Optional header specifies an alternative header to
Content-Type, and all parameters will be quoted as necessary
unless optional requote is  (the default is ).
If optional charset is specified, the parameter will be encoded
according to RFC 2231. Optional language specifies the RFC 2231
language, defaulting to the empty string.  Both charset and language
should be strings.
If replace is  (the default) the header is moved to the
end of the list of headers.  If replace is , the header
will be updated in place.

Changed in version 3.4:  keyword was added.




(param, header='content-type', requote=True)¶
Remove the given parameter completely from the Content-Type
header.  The header will be re-written in place without the parameter or
its value.  All values will be quoted as necessary unless requote is
 (the default is ).  Optional header specifies an
alternative to Content-Type.



(type, header='Content-Type', requote=True)¶
Set the main type and subtype for the Content-Type
header. type must be a string in the form maintype/subtype,
otherwise a  is raised.
This method replaces the Content-Type header, keeping all
the parameters in place.  If requote is , this leaves the
existing header’s quoting as is, otherwise the parameters will be quoted
(the default).
An alternative header can be specified in the header argument. When the
Content-Type header is set a MIME-Version
header is also added.
This is a legacy method.  On the
 class its functionality is
replaced by the  and  methods.



(failobj=None)¶
Return the value of the  parameter of the
Content-Disposition header of the message.  If the header
does not have a  parameter, this method falls back to looking
for the  parameter on the Content-Type header.  If
neither is found, or the header is missing, then failobj is returned.
The returned string will always be unquoted as per
.



(failobj=None)¶
Return the value of the  parameter of the
Content-Type header of the message, or failobj if either
the header is missing, or has no  parameter.  The returned
string will always be unquoted as per .



(boundary)¶
Set the  parameter of the Content-Type header to
boundary.   will always quote boundary if
necessary.  A  is raised if the
message object has no Content-Type header.
Note that using this method is subtly different than deleting the old
Content-Type header and adding a new one with the new
boundary via , because  preserves
the order of the Content-Type header in the list of
headers. However, it does not preserve any continuation lines which may
have been present in the original Content-Type header.



(failobj=None)¶
Return the  parameter of the Content-Type header,
coerced to lower case.  If there is no Content-Type header, or if
that header has no  parameter, failobj is returned.
Note that this method differs from  which returns the
 instance for the default encoding of the message body.



(failobj=None)¶
Return a list containing the character set names in the message.  If the
message is a multipart, then the list will contain one element
for each subpart in the payload, otherwise, it will be a list of length 1.
Each item in the list will be a string which is the value of the
 parameter in the Content-Type header for the
represented subpart.  However, if the subpart has no
Content-Type header, no  parameter, or is not of
the text main MIME type, then that item in the returned list
will be failobj.



()¶
Return the lowercased value (without parameters) of the message’s
Content-Disposition header if it has one, or .  The
possible values for this method are inline, attachment or 
if the message follows RFC 2183.

New in version 3.5.




()¶
The  method is an all-purpose generator which can be used to
iterate over all the parts and subparts of a message object tree, in
depth-first traversal order.  You will typically use  as the
iterator in a  loop; each iteration returns the next subpart.
Here’s an example that prints the MIME type of every part of a multipart
message structure:


 iterates over the subparts of any part where
 returns , even though
 may return .  We
can see this in our example by making use of the  debug
helper function:


Here the  parts are not , but they do contain
subparts.  returns  and  descends
into the subparts.

 objects can also optionally contain two instance attributes,
which can be used when generating the plain text of a MIME message.


¶
The format of a MIME document allows for some text between the blank line
following the headers, and the first multipart boundary string. Normally,
this text is never visible in a MIME-aware mail reader because it falls
outside the standard MIME armor.  However, when viewing the raw text of
the message, or when viewing the message in a non-MIME aware reader, this
text can become visible.
The preamble attribute contains this leading extra-armor text for MIME
documents.  When the  discovers some text
after the headers but before the first boundary string, it assigns this
text to the message’s preamble attribute.  When the
 is writing out the plain text
representation of a MIME message, and it finds the
message has a preamble attribute, it will write this text in the area
between the headers and the first boundary.  See  and
 for details.
Note that if the message object has no preamble, the preamble attribute
will be .



¶
The epilogue attribute acts the same way as the preamble attribute,
except that it contains text that appears between the last boundary and
the end of the message.
You do not need to set the epilogue to the empty string in order for the
 to print a newline at the end of the
file.



¶
The defects attribute contains a list of all the problems found when
parsing this message.  See  for a detailed description
of the possible parsing defects.

