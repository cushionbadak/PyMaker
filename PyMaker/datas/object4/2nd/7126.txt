link:
library/socketserver.html#server-creation-notes

docs:

Server Creation Notes¶
There are five classes in an inheritance diagram, four of which represent
synchronous servers of four types:


Note that  derives from , not from
 — the only difference between an IP and a Unix
stream server is the address family, which is simply repeated in both Unix
server classes.


class ¶

class ¶
Forking and threading versions of each type of server can be created
using these mix-in classes.  For instance, 
is created as follows:


The mix-in class comes first, since it overrides a method defined in
.  Setting the various attributes also changes the
behavior of the underlying server mechanism.
 and the Forking classes mentioned below are
only available on POSIX platforms that support .
 waits until all child
processes complete, except if
 attribute is false.
 waits until all non-daemon
threads complete, except if
 attribute is false. Use
daemonic threads by setting
 to  to not wait until threads
complete.

Changed in version 3.7:  and
 now waits until all
child processes and non-daemonic threads complete.
Add a new  class
attribute to opt-in for the pre-3.7 behaviour.




class ¶

class ¶

class ¶

class ¶
These classes are pre-defined using the mix-in classes.

To implement a service, you must derive a class from 
and redefine its  method.
You can then run various versions of
the service by combining one of the server classes with your request handler
class.  The request handler class must be different for datagram or stream
services.  This can be hidden by using the handler subclasses
 or .
Of course, you still have to use your head!  For instance, it makes no sense to
use a forking server if the service contains state in memory that can be
modified by different requests, since the modifications in the child process
would never reach the initial state kept in the parent process and passed to
each child.  In this case, you can use a threading server, but you will probably
have to use locks to protect the integrity of the shared data.
On the other hand, if you are building an HTTP server where all data is stored
externally (for instance, in the file system), a synchronous class will
essentially render the service “deaf” while one request is being handled –
which may be for a very long time if a client is slow to receive all the data it
has requested.  Here a threading or forking server is appropriate.
In some cases, it may be appropriate to process part of a request synchronously,
but to finish processing in a forked child depending on the request data.  This
can be implemented by using a synchronous server and doing an explicit fork in
the request handler class  method.
Another approach to handling multiple simultaneous requests in an environment
that supports neither threads nor  (or where these are too
expensive or inappropriate for the service) is to maintain an explicit table of
partially finished requests and to use  to decide which
request to work on next (or whether to handle a new incoming request).  This is
particularly important for stream services where each client can potentially be
connected for a long time (if threads or subprocesses cannot be used).  See
 for another way to manage this.
