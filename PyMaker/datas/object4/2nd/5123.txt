link:
library/socket.html#notes-on-socket-timeouts

docs:

Notes on socket timeouts¶
A socket object can be in one of three modes: blocking, non-blocking, or
timeout.  Sockets are by default always created in blocking mode, but this
can be changed by calling .

In blocking mode, operations block until complete or the system returns
an error (such as connection timed out).
In non-blocking mode, operations fail (with an error that is unfortunately
system-dependent) if they cannot be completed immediately: functions from the
 can be used to know when and whether a socket is available for
reading or writing.
In timeout mode, operations fail if they cannot be completed within the
timeout specified for the socket (they raise a  exception)
or if the system returns an error.


Note
At the operating system level, sockets in timeout mode are internally set
in non-blocking mode.  Also, the blocking and timeout modes are shared between
file descriptors and socket objects that refer to the same network endpoint.
This implementation detail can have visible consequences if e.g. you decide
to use the  of a socket.


Timeouts and the  method¶
The  operation is also subject to the timeout
setting, and in general it is recommended to call 
before calling  or pass a timeout parameter to
.  However, the system network stack may also
return a connection timeout error of its own regardless of any Python socket
timeout setting.


Timeouts and the  method¶
If  is not , sockets returned by
the  method inherit that timeout.  Otherwise, the
behaviour depends on settings of the listening socket:

if the listening socket is in blocking mode or in timeout mode,
the socket returned by  is in blocking mode;
if the listening socket is in non-blocking mode, whether the socket
returned by  is in blocking or non-blocking mode
is operating system-dependent.  If you want to ensure cross-platform
behaviour, it is recommended you manually override this setting.


