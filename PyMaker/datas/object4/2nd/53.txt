link:
reference/datamodel.html#object.__hash__

docs:


(self)¶
Called by built-in function  and for operations on members of
hashed collections including , , and
.   should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:



Note
 truncates the value returned from an object’s custom
 method to the size of a .  This is
typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an
object’s    must interoperate on builds of different bit
sizes, be sure to check the width on all supported builds.  An easy way
to do this is with
.

If a class does not define an  method it should not define a
 operation either; if it defines  but not
, its instances will not be usable as items in hashable
collections.  If a class defines mutable objects and implements an
 method, it should not implement , since the
implementation of hashable collections requires that a key’s hash value is
immutable (if the object’s hash value changes, it will be in the wrong hash
bucket).
User-defined classes have  and  methods
by default; with them, all objects compare unequal (except with themselves)
and  returns an appropriate value such that 
implies both that  and .
A class that overrides  and does not define 
will have its  implicitly set to .  When the
 method of a class is , instances of the class will
raise an appropriate  when a program attempts to retrieve
their hash value, and will also be correctly identified as unhashable when
checking .
If a class that overrides  needs to retain the implementation
of  from a parent class, the interpreter must be told this
explicitly by setting .
If a class that does not override  wishes to suppress hash
support, it should include  in the class definition.
A class which defines its own  that explicitly raises
a  would be incorrectly identified as hashable by
an  call.

Note
By default, the  values of str, bytes and datetime
objects are “salted” with an unpredictable random value.  Although they
remain constant within an individual Python process, they are not
predictable between repeated invocations of Python.
This is intended to provide protection against a denial-of-service caused
by carefully-chosen inputs that exploit the worst case performance of a
dict insertion, O(n^2) complexity.  See
http://www.ocert.org/advisories/ocert-2011-003.html for details.
Changing hash values affects the iteration order of sets.
Python has never made guarantees about this ordering
(and it typically varies between 32-bit and 64-bit builds).
See also .


Changed in version 3.3: Hash randomization is enabled by default.

