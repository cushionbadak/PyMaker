link:
library/functools.html

docs:


 — Higher-order functions and operations on callable objects¶
Source code: Lib/functools.py

The  module is for higher-order functions: functions that act on
or return other functions. In general, any callable object can be treated as a
function for the purposes of this module.
The  module defines the following functions:


(func)¶
Transform an old-style comparison function to a key function.  Used
with tools that accept key functions (such as , ,
, , ,
).  This function is primarily used as a transition
tool for programs being converted from Python 2 which supported the use of
comparison functions.
A comparison function is any callable that accept two arguments, compares them,
and returns a negative number for less-than, zero for equality, or a positive
number for greater-than.  A key function is a callable that accepts one
argument and returns another value to be used as the sort key.
Example:


For sorting examples and a brief sorting tutorial, see Sorting HOW TO.

New in version 3.2.




(maxsize=128, typed=False)¶
Decorator to wrap a function with a memoizing callable that saves up to the
maxsize most recent calls.  It can save time when an expensive or I/O bound
function is periodically called with the same arguments.
Since a dictionary is used to cache results, the positional and keyword
arguments to the function must be hashable.
Distinct argument patterns may be considered to be distinct calls with
separate cache entries.  For example, f(a=1, b=2) and f(b=2, a=1)
differ in their keyword argument order and may have two separate cache
entries.
If maxsize is set to , the LRU feature is disabled and the cache can
grow without bound.  The LRU feature performs best when maxsize is a
power-of-two.
If typed is set to true, function arguments of different types will be
cached separately.  For example,  and  will be treated
as distinct calls with distinct results.
To help measure the effectiveness of the cache and tune the maxsize
parameter, the wrapped function is instrumented with a 
function that returns a named tuple showing hits, misses,
maxsize and currsize.  In a multi-threaded environment, the hits
and misses are approximate.
The decorator also provides a  function for clearing or
invalidating the cache.
The original underlying function is accessible through the
 attribute.  This is useful for introspection, for
bypassing the cache, or for rewrapping the function with a different cache.
An LRU (least recently used) cache works
best when the most recent calls are the best predictors of upcoming calls (for
example, the most popular articles on a news server tend to change each day).
The cache’s size limit assures that the cache does not grow without bound on
long-running processes such as web servers.
In general, the LRU cache should only be used when you want to reuse
previously computed values.  Accordingly, it doesn’t make sense to cache
functions with side-effects, functions that need to create distinct mutable
objects on each call, or impure functions such as time() or random().
Example of an LRU cache for static web content:


Example of efficiently computing
Fibonacci numbers
using a cache to implement a
dynamic programming
technique:



New in version 3.2.


Changed in version 3.3: Added the typed option.




¶
Given a class defining one or more rich comparison ordering methods, this
class decorator supplies the rest.  This simplifies the effort involved
in specifying all of the possible rich comparison operations:
The class must define one of , ,
, or .
In addition, the class should supply an  method.
For example:



Note
While this decorator makes it easy to create well behaved totally
ordered types, it does come at the cost of slower execution and
more complex stack traces for the derived comparison methods. If
performance benchmarking indicates this is a bottleneck for a given
application, implementing all six rich comparison methods instead is
likely to provide an easy speed boost.


New in version 3.2.


Changed in version 3.4: Returning NotImplemented from the underlying comparison function for
unrecognised types is now supported.




(func, *args, **keywords)¶
Return a new partial object which when called
will behave like func called with the positional arguments args
and keyword arguments keywords. If more arguments are supplied to the
call, they are appended to args. If additional keyword arguments are
supplied, they extend and override keywords.
Roughly equivalent to:


The  is used for partial function application which “freezes”
some portion of a function’s arguments and/or keywords resulting in a new object
with a simplified signature.  For example,  can be used to create
a callable that behaves like the  function where the base argument
defaults to two:





class (func, *args, **keywords)¶
Return a new  descriptor which behaves
like  except that it is designed to be used as a method
definition rather than being directly callable.
func must be a descriptor or a callable (objects which are both,
like normal functions, are handled as descriptors).
When func is a descriptor (such as a normal Python function,
, ,  or
another instance of ), calls to  are
delegated to the underlying descriptor, and an appropriate
partial object returned as the result.
When func is a non-descriptor callable, an appropriate bound method is
created dynamically. This behaves like a normal Python function when
used as a method: the self argument will be inserted as the first
positional argument, even before the args and keywords supplied to
the  constructor.
Example:



New in version 3.4.




(function, iterable[, initializer])¶
Apply function of two arguments cumulatively to the items of sequence, from
left to right, so as to reduce the sequence to a single value.  For example,
 calculates .
The left argument, x, is the accumulated value and the right argument, y, is
the update value from the sequence.  If the optional initializer is present,
it is placed before the items of the sequence in the calculation, and serves as
a default when the sequence is empty.  If initializer is not given and
sequence contains only one item, the first item is returned.
Roughly equivalent to:





¶
Transform a function into a single-dispatch generic function.
To define a generic function, decorate it with the 
decorator. Note that the dispatch happens on the type of the first argument,
create your function accordingly:


To add overloaded implementations to the function, use the 
attribute of the generic function.  It is a decorator.  For functions
annotated with types, the decorator will infer the type of the first
argument automatically:


For code which doesn’t use type annotations, the appropriate type
argument can be passed explicitly to the decorator itself:


To enable registering lambdas and pre-existing functions, the
 attribute can be used in a functional form:


The  attribute returns the undecorated function which
enables decorator stacking, pickling, as well as creating unit tests for
each variant independently:


When called, the generic function dispatches on the type of the first
argument:


Where there is no registered implementation for a specific type, its
method resolution order is used to find a more generic implementation.
The original function decorated with  is registered
for the base  type, which means it is used if no better
implementation is found.
To check which implementation will the generic function choose for
a given type, use the  attribute:


To access all registered implementations, use the read-only 
attribute:



New in version 3.4.


Changed in version 3.7: The  attribute supports using type annotations.




(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)¶
Update a wrapper function to look like the wrapped function. The optional
arguments are tuples to specify which attributes of the original function are
assigned directly to the matching attributes on the wrapper function and which
attributes of the wrapper function are updated with the corresponding attributes
from the original function. The default values for these arguments are the
module level constants  (which assigns to the wrapper
function’s , , , 
and , the documentation string) and  (which
updates the wrapper function’s , i.e. the instance dictionary).
To allow access to the original function for introspection and other purposes
(e.g. bypassing a caching decorator such as ), this function
automatically adds a  attribute to the wrapper that refers to
the function being wrapped.
The main intended use for this function is in decorator functions which
wrap the decorated function and return the wrapper. If the wrapper function is
not updated, the metadata of the returned function will reflect the wrapper
definition rather than the original function definition, which is typically less
than helpful.
 may be used with callables other than functions. Any
attributes named in assigned or updated that are missing from the object
being wrapped are ignored (i.e. this function will not attempt to set them
on the wrapper function).  is still raised if the
wrapper function itself is missing any attributes named in updated.

New in version 3.2: Automatic addition of the  attribute.


New in version 3.2: Copying of the  attribute by default.


Changed in version 3.2: Missing attributes no longer trigger an .


Changed in version 3.4: The  attribute now always refers to the wrapped
function, even if that function defined a  attribute.
(see bpo-17482)




(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)¶
This is a convenience function for invoking  as a
function decorator when defining a wrapper function.  It is equivalent to
.
For example:


Without the use of this decorator factory, the name of the example function
would have been , and the docstring of the original 
would have been lost.


 Objects¶
 objects are callable objects created by . They
have three read-only attributes:


¶
A callable object or function.  Calls to the  object will be
forwarded to  with new arguments and keywords.



¶
The leftmost positional arguments that will be prepended to the positional
arguments provided to a  object call.



¶
The keyword arguments that will be supplied when the  object is
called.

 objects are like  objects in that they are
callable, weak referencable, and can have attributes.  There are some important
differences.  For instance, the  and  attributes
are not created automatically.  Also,  objects defined in
classes behave like static methods and do not transform into bound methods
during instance attribute look-up.


