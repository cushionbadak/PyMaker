link:
library/difflib.html#difflib.SequenceMatcher.find_longest_match

docs:


(alo, ahi, blo, bhi)¶
Find longest matching block in  and .
If isjunk was omitted or ,  returns
 such that  is equal to , where  and . For all  meeting those conditions, the additional conditions , , and if ,  are also met. In other words, of
all maximal matching blocks, return one that starts earliest in a, and
of all those maximal matching blocks that start earliest in a, return
the one that starts earliest in b.


If isjunk was provided, first the longest matching block is determined
as above, but with the additional restriction that no junk element appears
in the block.  Then that block is extended as far as possible by matching
(only) junk elements on both sides. So the resulting block never matches
on junk except as identical junk happens to be adjacent to an interesting
match.
Here’s the same example as before, but considering blanks to be junk. That
prevents  from matching the  at the tail end of the
second sequence directly.  Instead only the  can match, and
matches the leftmost  in the second sequence:


If no blocks match, this returns .
This method returns a named tuple .
