link:
library/unittest.mock.html#autospeccing

docs:

Autospeccing¶
Autospeccing is based on the existing  feature of mock. It limits the
api of mocks to the api of an original object (the spec), but it is recursive
(implemented lazily) so that attributes of mocks only have the same api as
the attributes of the spec. In addition mocked functions / methods have the
same call signature as the original so they raise a  if they are
called incorrectly.
Before I explain how auto-speccing works, here’s why it is needed.
 is a very powerful and flexible object, but it suffers from two flaws
when used to mock out objects from a system under test. One of these flaws is
specific to the  api and the other is a more general problem with using
mock objects.
First the problem specific to .  has two assert methods that are
extremely handy:  and
.


Because mocks auto-create attributes on demand, and allow you to call them
with arbitrary arguments, if you misspell one of these assert methods then
your assertion is gone:


Your tests can pass silently and incorrectly because of the typo.
The second issue is more general to mocking. If you refactor some of your
code, rename members and so on, any tests for code that is still using the
old api but uses mocks instead of the real objects will still pass. This
means your tests can all pass even though your code is broken.
Note that this is another reason why you need integration tests as well as
unit tests. Testing everything in isolation is all fine and dandy, but if you
don’t test how your units are “wired together” there is still lots of room
for bugs that tests might have caught.
 already provides a feature to help with this, called speccing. If you
use a class or instance as the  for a mock then you can only access
attributes on the mock that exist on the real class:


The spec only applies to the mock itself, so we still have the same issue
with any methods on the mock:


Auto-speccing solves this problem. You can either pass  to
 /  or use the  function to create a
mock with a spec. If you use the  argument to  then the
object that is being replaced will be used as the spec object. Because the
speccing is done “lazily” (the spec is created as attributes on the mock are
accessed) you can use it with very complex or deeply nested objects (like
modules that import modules that import modules) without a big performance
hit.
Here’s an example of it in use:


You can see that  has a spec.  takes two
arguments in the constructor (one of which is self). Here’s what happens if
we try to call it incorrectly:


The spec also applies to instantiated classes (i.e. the return value of
specced mocks):


 objects are not callable, so the return value of instantiating our
mocked out  is a non-callable mock. With the spec in place
any typos in our asserts will raise the correct error:


In many cases you will just be able to add  to your existing
 calls and then be protected against bugs due to typos and api
changes.
As well as using autospec through  there is a
 for creating autospecced mocks directly:


This isn’t without caveats and limitations however, which is why it is not
the default behaviour. In order to know what attributes are available on the
spec object, autospec has to introspect (access attributes) the spec. As you
traverse attributes on the mock a corresponding traversal of the original
object is happening under the hood. If any of your specced objects have
properties or descriptors that can trigger code execution then you may not be
able to use autospec. On the other hand it is much better to design your
objects so that introspection is safe [4].
A more serious problem is that it is common for instance attributes to be
created in the  method and not to exist on the class at all.
autospec can’t know about any dynamically created attributes and restricts
the api to visible attributes.


There are a few different ways of resolving this problem. The easiest, but
not necessarily the least annoying, way is to simply set the required
attributes on the mock after creation. Just because autospec doesn’t allow
you to fetch attributes that don’t exist on the spec it doesn’t prevent you
setting them:


There is a more aggressive version of both spec and autospec that does
prevent you setting non-existent attributes. This is useful if you want to
ensure your code only sets valid attributes too, but obviously it prevents
this particular scenario:


Probably the best way of solving the problem is to add class attributes as
default values for instance members initialised in . Note that if
you are only setting default attributes in  then providing them via
class attributes (shared between instances of course) is faster too. e.g.


This brings up another issue. It is relatively common to provide a default
value of  for members that will later be an object of a different type.
 would be useless as a spec because it wouldn’t let you access any
attributes or methods on it. As  is never going to be useful as a
spec, and probably indicates a member that will normally of some other type,
autospec doesn’t use a spec for members that are set to . These will
just be ordinary mocks (well - MagicMocks):


If modifying your production classes to add defaults isn’t to your liking
then there are more options. One of these is simply to use an instance as the
spec rather than the class. The other is to create a subclass of the
production class and add the defaults to the subclass without affecting the
production class. Both of these require you to use an alternative object as
the spec. Thankfully  supports this - you can simply pass the
alternative object as the autospec argument:





[4]This only applies to classes or already instantiated objects. Calling
a mocked class to create a mock instance does not create a real instance.
It is only attribute lookups - along with calls to  - that are done.


