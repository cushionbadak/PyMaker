link:
library/argparse.html

docs:


 — Parser for command-line options, arguments and sub-commands¶

New in version 3.2.

Source code: Lib/argparse.py


Tutorial
This page contains the API reference information. For a more gentle
introduction to Python command-line parsing, have a look at the
argparse tutorial.

The  module makes it easy to write user-friendly command-line
interfaces. The program defines what arguments it requires, and 
will figure out how to parse those out of .  The 
module also automatically generates help and usage messages and issues errors
when users give the program invalid arguments.

Example¶
The following code is a Python program that takes a list of integers and
produces either the sum or the max:


Assuming the Python code above is saved into a file called , it can
be run at the command line and provides useful help messages:


When run with the appropriate arguments, it prints either the sum or the max of
the command-line integers:


If invalid arguments are passed in, it will issue an error:


The following sections walk you through this example.

Creating a parser¶
The first step in using the  is creating an
 object:


The  object will hold all the information necessary to
parse the command line into Python data types.


Adding arguments¶
Filling an  with information about program arguments is
done by making calls to the  method.
Generally, these calls tell the  how to take the strings
on the command line and turn them into objects.  This information is stored and
used when  is called. For example:


Later, calling  will return an object with
two attributes,  and .  The  attribute
will be a list of one or more ints, and the  attribute will be
either the  function, if  was specified at the command line,
or the  function if it was not.


Parsing arguments¶
 parses arguments through the
 method.  This will inspect the command line,
convert each argument to the appropriate type and then invoke the appropriate action.
In most cases, this means a simple  object will be built up from
attributes parsed out of the command line:


In a script,  will typically be called with no
arguments, and the  will automatically determine the
command-line arguments from .



ArgumentParser objects¶


class (prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True)¶
Create a new  object. All parameters should be passed
as keyword arguments. Each parameter has its own more detailed description
below, but in short they are:

prog - The name of the program (default: )
usage - The string describing the program usage (default: generated from
arguments added to parser)
description - Text to display before the argument help (default: none)
epilog - Text to display after the argument help (default: none)
parents - A list of  objects whose arguments should
also be included
formatter_class - A class for customizing the help output
prefix_chars - The set of characters that prefix optional arguments
(default: ‘-‘)
fromfile_prefix_chars - The set of characters that prefix files from
which additional arguments should be read (default: )
argument_default - The global default value for arguments
(default: )
conflict_handler - The strategy for resolving conflicting optionals
(usually unnecessary)
add_help - Add a  option to the parser (default: )
allow_abbrev - Allows long options to be abbreviated if the
abbreviation is unambiguous. (default: )


Changed in version 3.5: allow_abbrev parameter was added.


The following sections describe how each of these are used.

prog¶
By default,  objects use  to determine
how to display the name of the program in help messages.  This default is almost
always desirable because it will make the help messages match how the program was
invoked on the command line.  For example, consider a file named
 with the following code:


The help for this program will display  as the program name
(regardless of where the program was invoked from):


To change this default behavior, another value can be supplied using the
 argument to :


Note that the program name, whether determined from  or from the
 argument, is available to help messages using the  format
specifier.




usage¶
By default,  calculates the usage message from the
arguments it contains:


The default message can be overridden with the  keyword argument:


The  format specifier is available to fill in the program name in
your usage messages.


description¶
Most calls to the  constructor will use the
 keyword argument.  This argument gives a brief description of
what the program does and how it works.  In help messages, the description is
displayed between the command-line usage string and the help messages for the
various arguments:


By default, the description will be line-wrapped so that it fits within the
given space.  To change this behavior, see the formatter_class argument.


epilog¶
Some programs like to display additional description of the program after the
description of the arguments.  Such text can be specified using the 
argument to :


As with the description argument, the  text is by default
line-wrapped, but this behavior can be adjusted with the formatter_class
argument to .


parents¶
Sometimes, several parsers share a common set of arguments. Rather than
repeating the definitions of these arguments, a single parser with all the
shared arguments and passed to  argument to 
can be used.  The  argument takes a list of 
objects, collects all the positional and optional actions from them, and adds
these actions to the  object being constructed:


Note that most parent parsers will specify .  Otherwise, the
 will see two  options (one in the parent
and one in the child) and raise an error.

Note
You must fully initialize the parsers before passing them via .
If you change the parent parsers after the child parser, those changes will
not be reflected in the child.



formatter_class¶
 objects allow the help formatting to be customized by
specifying an alternate formatting class.  Currently, there are four such
classes:


class ¶

class ¶

class ¶

class ¶

 and  give
more control over how textual descriptions are displayed.
By default,  objects line-wrap the description and
epilog texts in command-line help messages:


Passing  as 
indicates that description and epilog are already correctly formatted and
should not be line-wrapped:


 maintains whitespace for all sorts of help text,
including argument descriptions. However, multiple new lines are replaced with
one. If you wish to preserve multiple blank lines, add spaces between the
newlines.
 automatically adds information about
default values to each of the argument help messages:


 uses the name of the type argument for each
argument as the display name for its values (rather than using the dest
as the regular formatter does):




prefix_chars¶
Most command-line options will use  as the prefix, e.g. .
Parsers that need to support different or additional prefix
characters, e.g. for options
like  or , may specify them using the  argument
to the ArgumentParser constructor:


The  argument defaults to . Supplying a set of
characters that does not include  will cause  options to be
disallowed.


fromfile_prefix_chars¶
Sometimes, for example when dealing with a particularly long argument lists, it
may make sense to keep the list of arguments in a file rather than typing it out
at the command line.  If the  argument is given to the
 constructor, then arguments that start with any of the
specified characters will be treated as files, and will be replaced by the
arguments they contain.  For example:


Arguments read from a file must by default be one per line (but see also
) and are treated as if they
were in the same place as the original file referencing argument on the command
line.  So in the example above, the expression 
is considered equivalent to the expression .
The  argument defaults to , meaning that
arguments will never be treated as file references.


argument_default¶
Generally, argument defaults are specified either by passing a default to
 or by calling the
 methods with a specific set of name-value
pairs.  Sometimes however, it may be useful to specify a single parser-wide
default for arguments.  This can be accomplished by passing the
 keyword argument to .  For example,
to globally suppress attribute creation on 
calls, we supply :




allow_abbrev¶
Normally, when you pass an argument list to the
 method of an ,
it recognizes abbreviations of long options.
This feature can be disabled by setting  to :



New in version 3.5.



conflict_handler¶
 objects do not allow two actions with the same option
string.  By default,  objects raise an exception if an
attempt is made to create an argument with an option string that is already in
use:


Sometimes (e.g. when using parents) it may be useful to simply override any
older arguments with the same option string.  To get this behavior, the value
 can be supplied to the  argument of
:


Note that  objects only remove an action if all of its
option strings are overridden.  So, in the example above, the old 
action is retained as the  action, because only the  option
string was overridden.


add_help¶
By default, ArgumentParser objects add an option which simply displays
the parser’s help message. For example, consider a file named
 containing the following code:


If  or  is supplied at the command line, the ArgumentParser
help will be printed:


Occasionally, it may be useful to disable the addition of this help option.
This can be achieved by passing  as the  argument to
:


The help option is typically . The exception to this is
if the  is specified and does not include , in
which case  and  are not valid options.  In
this case, the first character in  is used to prefix
the help options:





The add_argument() method¶


(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])¶
Define how a single command-line argument should be parsed.  Each parameter
has its own more detailed description below, but in short they are:

name or flags - Either a name or a list of option strings, e.g. 
or .
action - The basic type of action to be taken when this argument is
encountered at the command line.
nargs - The number of command-line arguments that should be consumed.
const - A constant value required by some action and nargs selections.
default - The value produced if the argument is absent from the
command line.
type - The type to which the command-line argument should be converted.
choices - A container of the allowable values for the argument.
required - Whether or not the command-line option may be omitted
(optionals only).
help - A brief description of what the argument does.
metavar - A name for the argument in usage messages.
dest - The name of the attribute to be added to the object returned by
.


The following sections describe how each of these are used.

name or flags¶
The  method must know whether an optional
argument, like  or , or a positional argument, like a list of
filenames, is expected.  The first arguments passed to
 must therefore be either a series of
flags, or a simple argument name.  For example, an optional argument could
be created like:


while a positional argument could be created like:


When  is called, optional arguments will be
identified by the  prefix, and the remaining arguments will be assumed to
be positional:




action¶
 objects associate command-line arguments with actions.  These
actions can do just about anything with the command-line arguments associated with
them, though most actions simply add an attribute to the object returned by
.  The  keyword argument specifies
how the command-line arguments should be handled. The supplied actions are:

 - This just stores the argument’s value.  This is the default
action. For example:



 - This stores the value specified by the const keyword
argument.  The  action is most commonly used with
optional arguments that specify some sort of flag.  For example:



 and  - These are special cases of
 used for storing the values  and 
respectively.  In addition, they create default values of  and
 respectively.  For example:



 - This stores a list, and appends each argument value to the
list.  This is useful to allow an option to be specified multiple times.
Example usage:



 - This stores a list, and appends the value specified by
the const keyword argument to the list.  (Note that the const keyword
argument defaults to .)  The  action is typically
useful when multiple arguments need to store constants to the same list. For
example:



 - This counts the number of times a keyword argument occurs. For
example, this is useful for increasing verbosity levels:



 - This prints a complete help message for all the options in the
current parser and then exits. By default a help action is automatically
added to the parser. See  for details of how the
output is created.

 - This expects a  keyword argument in the
 call, and prints version information
and exits when invoked:




You may also specify an arbitrary action by passing an Action subclass or
other object that implements the same interface.  The recommended way to do
this is to extend , overriding the  method
and optionally the  method.
An example of a custom action:


For more details, see .


nargs¶
ArgumentParser objects usually associate a single command-line argument with a
single action to be taken.  The  keyword argument associates a
different number of command-line arguments with a single action.  The supported
values are:

 (an integer).   arguments from the command line will be gathered
together into a list.  For example:


Note that  produces a list of one item.  This is different from
the default, in which the item is produced by itself.



. One argument will be consumed from the command line if possible, and
produced as a single item.  If no command-line argument is present, the value from
default will be produced.  Note that for optional arguments, there is an
additional case - the option string is present but not followed by a
command-line argument.  In this case the value from const will be produced.  Some
examples to illustrate this:


One of the more common uses of  is to allow optional input and
output files:





.  All command-line arguments present are gathered into a list.  Note that
it generally doesn’t make much sense to have more than one positional argument
with , but multiple optional arguments with  is
possible.  For example:





. Just like , all command-line args present are gathered into a
list.  Additionally, an error message will be generated if there wasn’t at
least one command-line argument present.  For example:





.  All the remaining command-line arguments are gathered
into a list.  This is commonly useful for command line utilities that dispatch
to other command line utilities:




If the  keyword argument is not provided, the number of arguments consumed
is determined by the action.  Generally this means a single command-line argument
will be consumed and a single item (not a list) will be produced.


const¶
The  argument of  is used to hold
constant values that are not read from the command line but are required for
the various  actions.  The two most common uses of it are:

When  is called with
 or .  These actions add the
 value to one of the attributes of the object returned by
. See the action description for examples.
When  is called with option strings
(like  or ) and .  This creates an optional
argument that can be followed by zero or one command-line arguments.
When parsing the command line, if the option string is encountered with no
command-line argument following it, the value of  will be assumed instead.
See the nargs description for examples.

With the  and  actions, the 
keyword argument must be given.  For other actions, it defaults to .


default¶
All optional arguments and some positional arguments may be omitted at the
command line.  The  keyword argument of
, whose value defaults to ,
specifies what value should be used if the command-line argument is not present.
For optional arguments, the  value is used when the option string
was not present at the command line:


If the  value is a string, the parser parses the value as if it
were a command-line argument.  In particular, the parser applies any type
conversion argument, if provided, before setting the attribute on the
 return value.  Otherwise, the parser uses the value as is:


For positional arguments with nargs equal to  or , the  value
is used when no command-line argument was present:


Providing  causes no attribute to be added if the
command-line argument was not present:




type¶
By default,  objects read command-line arguments in as simple
strings. However, quite often the command-line string should instead be
interpreted as another type, like a  or .  The
 keyword argument of  allows any
necessary type-checking and type conversions to be performed.  Common built-in
types and functions can be used directly as the value of the  argument:


See the section on the default keyword argument for information on when the
 argument is applied to default arguments.
To ease the use of various types of files, the argparse module provides the
factory FileType which takes the , ,  and
 arguments of the  function.  For example,
 can be used to create a writable file:


 can take any callable that takes a single string argument and returns
the converted value:


The choices keyword argument may be more convenient for type checkers that
simply check against a range of values:


See the choices section for more details.


choices¶
Some command-line arguments should be selected from a restricted set of values.
These can be handled by passing a container object as the choices keyword
argument to .  When the command line is
parsed, argument values will be checked, and an error message will be displayed
if the argument was not one of the acceptable values:


Note that inclusion in the choices container is checked after any type
conversions have been performed, so the type of the objects in the choices
container should match the type specified:


Any object that supports the  operator can be passed as the choices
value, so  objects,  objects, custom containers,
etc. are all supported.


required¶
In general, the  module assumes that flags like  and 
indicate optional arguments, which can always be omitted at the command line.
To make an option required,  can be specified for the 
keyword argument to :


As the example shows, if an option is marked as ,
 will report an error if that option is not
present at the command line.

Note
Required options are generally considered bad form because users expect
options to be optional, and thus they should be avoided when possible.



help¶
The  value is a string containing a brief description of the argument.
When a user requests help (usually by using  or  at the
command line), these  descriptions will be displayed with each
argument:


The  strings can include various format specifiers to avoid repetition
of things like the program name or the argument default.  The available
specifiers include the program name,  and most keyword arguments to
, e.g. , , etc.:


As the help string supports %-formatting, if you want a literal  to appear
in the help string, you must escape it as .
 supports silencing the help entry for certain options, by
setting the  value to :




metavar¶
When  generates help messages, it needs some way to refer
to each expected argument.  By default, ArgumentParser objects use the dest
value as the “name” of each object.  By default, for positional argument
actions, the dest value is used directly, and for optional argument actions,
the dest value is uppercased.  So, a single positional argument with
 will be referred to as . A single
optional argument  that should be followed by a single command-line argument
will be referred to as .  An example:


An alternative name can be specified with :


Note that  only changes the displayed name - the name of the
attribute on the  object is still determined
by the dest value.
Different values of  may cause the metavar to be used multiple times.
Providing a tuple to  specifies a different display for each of the
arguments:




dest¶
Most  actions add some value as an attribute of the
object returned by .  The name of this
attribute is determined by the  keyword argument of
.  For positional argument actions,
 is normally supplied as the first argument to
:


For optional argument actions, the value of  is normally inferred from
the option strings.   generates the value of  by
taking the first long option string and stripping away the initial 
string.  If no long option strings were supplied,  will be derived from
the first short option string by stripping the initial  character.  Any
internal  characters will be converted to  characters to make sure
the string is a valid attribute name.  The examples below illustrate this
behavior:


 allows a custom attribute name to be provided:




Action classes¶
Action classes implement the Action API, a callable which returns a callable
which processes arguments from the command-line. Any object which follows
this API may be passed as the  parameter to
.


class (option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)¶

Action objects are used by an ArgumentParser to represent the information
needed to parse a single argument from one or more strings from the
command line. The Action class must accept the two positional arguments
plus any keyword arguments passed to 
except for the  itself.
Instances of Action (or return value of any callable to the 
parameter) should have attributes “dest”, “option_strings”, “default”, “type”,
“required”, “help”, etc. defined. The easiest way to ensure these attributes
are defined is to call .
Action instances should be callable, so subclasses must override the
 method, which should accept four parameters:

 - The ArgumentParser object which contains this action.
 - The  object that will be returned by
.  Most actions add an attribute to this
object using .
 - The associated command-line arguments, with any type conversions
applied.  Type conversions are specified with the type keyword argument to
.
 - The option string that was used to invoke this action.
The  argument is optional, and will be absent if the action
is associated with a positional argument.

The  method may perform arbitrary actions, but will typically set
attributes on the  based on  and .



The parse_args() method¶


(args=None, namespace=None)¶
Convert argument strings to objects and assign them as attributes of the
namespace.  Return the populated namespace.
Previous calls to  determine exactly what objects are
created and how they are assigned. See the documentation for
 for details.

args - List of strings to parse.  The default is taken from
.
namespace - An object to take the attributes.  The default is a new empty
 object.



Option value syntax¶
The  method supports several ways of
specifying the value of an option (if it takes one).  In the simplest case, the
option and its value are passed as two separate arguments:


For long options (options with names longer than a single character), the option
and value can also be passed as a single command-line argument, using  to
separate them:


For short options (options only one character long), the option and its value
can be concatenated:


Several short options can be joined together, using only a single  prefix,
as long as only the last option (or none of them) requires a value:




Invalid arguments¶
While parsing the command line,  checks for a
variety of errors, including ambiguous options, invalid types, invalid options,
wrong number of positional arguments, etc.  When it encounters such an error,
it exits and prints the error along with a usage message:




Arguments containing ¶
The  method attempts to give errors whenever
the user has clearly made a mistake, but some situations are inherently
ambiguous.  For example, the command-line argument  could either be an
attempt to specify an option or an attempt to provide a positional argument.
The  method is cautious here: positional
arguments may only begin with  if they look like negative numbers and
there are no options in the parser that look like negative numbers:


If you have positional arguments that must begin with  and don’t look
like negative numbers, you can insert the pseudo-argument  which tells
 that everything after that is a positional
argument:




Argument abbreviations (prefix matching)¶
The  method by default
allows long options to be abbreviated to a prefix, if the abbreviation is
unambiguous (the prefix matches a unique option):


An error is produced for arguments that could produce more than one options.
This feature can be disabled by setting allow_abbrev to .


Beyond ¶
Sometimes it may be useful to have an ArgumentParser parse arguments other than those
of .  This can be accomplished by passing a list of strings to
.  This is useful for testing at the
interactive prompt:




The Namespace object¶


class ¶
Simple class used by default by  to create
an object holding attributes and return it.

This class is deliberately simple, just an  subclass with a
readable string representation. If you prefer to have dict-like view of the
attributes, you can use the standard Python idiom, :


It may also be useful to have an  assign attributes to an
already existing object, rather than a new  object.  This can
be achieved by specifying the  keyword argument:





Other utilities¶

Sub-commands¶


([title][, description][, prog][, parser_class][, action][, option_string][, dest][, required][, help][, metavar])¶
Many programs split up their functionality into a number of sub-commands,
for example, the  program can invoke sub-commands like , , and .  Splitting up functionality
this way can be a particularly good idea when a program performs several
different functions which require different kinds of command-line arguments.
 supports the creation of such sub-commands with the
 method.  The  method is normally
called with no arguments and returns a special action object.  This object
has a single method, , which takes a
command name and any  constructor arguments, and
returns an  object that can be modified as usual.
Description of parameters:

title - title for the sub-parser group in help output; by default
“subcommands” if description is provided, otherwise uses title for
positional arguments
description - description for the sub-parser group in help output, by
default 
prog - usage information that will be displayed with sub-command help,
by default the name of the program and any positional arguments before the
subparser argument
parser_class - class which will be used to create sub-parser instances, by
default the class of the current parser (e.g. ArgumentParser)
action - the basic type of action to be taken when this argument is
encountered at the command line
dest - name of the attribute under which sub-command name will be
stored; by default  and no value is stored
required - Whether or not a subcommand must be provided, by default
.
help - help for sub-parser group in help output, by default 
metavar - string presenting available sub-commands in help; by default it
is  and presents sub-commands in form {cmd1, cmd2, ..}

Some example usage:


Note that the object returned by  will only contain
attributes for the main parser and the subparser that was selected by the
command line (and not any other subparsers).  So in the example above, when
the  command is specified, only the  and  attributes are
present, and when the  command is specified, only the  and
 attributes are present.
Similarly, when a help message is requested from a subparser, only the help
for that particular parser will be printed.  The help message will not
include parent parser or sibling parser messages.  (A help message for each
subparser command, however, can be given by supplying the  argument
to  as above.)


The  method also supports  and 
keyword arguments.  When either is present, the subparser’s commands will
appear in their own group in the help output.  For example:


Furthermore,  supports an additional  argument,
which allows multiple strings to refer to the same subparser. This example,
like , aliases  as a shorthand for :


One particularly effective way of handling sub-commands is to combine the use
of the  method with calls to  so
that each subparser knows which Python function it should execute.  For
example:


This way, you can let  do the job of calling the
appropriate function after argument parsing is complete.  Associating
functions with actions like this is typically the easiest way to handle the
different actions for each of your subparsers.  However, if it is necessary
to check the name of the subparser that was invoked, the  keyword
argument to the  call will work:





FileType objects¶


class (mode='r', bufsize=-1, encoding=None, errors=None)¶
The  factory creates objects that can be passed to the type
argument of .  Arguments that have
 objects as their type will open command-line arguments as
files with the requested modes, buffer sizes, encodings and error handling
(see the  function for more details):


FileType objects understand the pseudo-argument  and automatically
convert this into  for readable  objects and
 for writable  objects:



New in version 3.4: The encodings and errors keyword arguments.




Argument groups¶


(title=None, description=None)¶
By default,  groups command-line arguments into
“positional arguments” and “optional arguments” when displaying help
messages. When there is a better conceptual grouping of arguments than this
default one, appropriate groups can be created using the
 method:


The  method returns an argument group object which
has an  method just like a regular
.  When an argument is added to the group, the parser
treats it just like a normal argument, but displays the argument in a
separate group for help messages.  The  method
accepts title and description arguments which can be used to
customize this display:


Note that any arguments not in your user-defined groups will end up back
in the usual “positional arguments” and “optional arguments” sections.



Mutual exclusion¶


(required=False)¶
Create a mutually exclusive group.  will make sure that only
one of the arguments in the mutually exclusive group was present on the
command line:


The  method also accepts a required
argument, to indicate that at least one of the mutually exclusive arguments
is required:


Note that currently mutually exclusive argument groups do not support the
title and description arguments of
.



Parser defaults¶


(**kwargs)¶
Most of the time, the attributes of the object returned by 
will be fully determined by inspecting the command-line arguments and the argument
actions.   allows some additional
attributes that are determined without any inspection of the command line to
be added:


Note that parser-level defaults always override argument-level defaults:


Parser-level defaults can be particularly useful when working with multiple
parsers.  See the  method for an
example of this type.



(dest)¶
Get the default value for a namespace attribute, as set by either
 or by
:





Printing help¶
In most typical applications,  will take
care of formatting and printing any usage or error messages.  However, several
formatting methods are available:


(file=None)¶
Print a brief description of how the  should be
invoked on the command line.  If file is ,  is
assumed.



(file=None)¶
Print a help message, including the program usage and information about the
arguments registered with the .  If file is
,  is assumed.

There are also variants of these methods that simply return a string instead of
printing it:


()¶
Return a string containing a brief description of how the
 should be invoked on the command line.



()¶
Return a string containing a help message, including the program usage and
information about the arguments registered with the .



Partial parsing¶


(args=None, namespace=None)¶

Sometimes a script may only parse a few of the command-line arguments, passing
the remaining arguments on to another script or program. In these cases, the
 method can be useful.  It works much like
 except that it does not produce an error when
extra arguments are present.  Instead, it returns a two item tuple containing
the populated namespace and the list of remaining argument strings.



Warning
Prefix matching rules apply to
. The parser may consume an option even if it’s just
a prefix of one of its known options, instead of leaving it in the remaining
arguments list.



Customizing file parsing¶


(arg_line)¶
Arguments that are read from a file (see the fromfile_prefix_chars
keyword argument to the  constructor) are read one
argument per line.  can be overridden for
fancier reading.
This method takes a single argument arg_line which is a string read from
the argument file.  It returns a list of arguments parsed from this string.
The method is called once per line read from the argument file, in order.
A useful override of this method is one that treats each space-separated word
as an argument.  The following example demonstrates how to do this:





Exiting methods¶


(status=0, message=None)¶
This method terminates the program, exiting with the specified status
and, if given, it prints a message before that.



(message)¶
This method prints a usage message including the message to the
standard error and terminates the program with a status code of 2.



Intermixed parsing¶


(args=None, namespace=None)¶



(args=None, namespace=None)¶

A number of Unix commands allow the user to intermix optional arguments with
positional arguments.  The 
and  methods
support this parsing style.
These parsers do not support all the argparse features, and will raise
exceptions if unsupported features are used.  In particular, subparsers,
, and mutually exclusive groups that include both
optionals and positionals are not supported.
The following example shows the difference between
 and
: the former returns  as unparsed arguments, while the latter collects all the positionals
into .


 returns a two item tuple
containing the populated namespace and the list of remaining argument strings.
 raises an error if there are any
remaining unparsed argument strings.

New in version 3.7.




Upgrading optparse code¶
Originally, the  module had attempted to maintain compatibility
with .  However,  was difficult to extend
transparently, particularly with the changes required to support the new
 specifiers and better usage messages.  When most everything in
 had either been copy-pasted over or monkey-patched, it no
longer seemed practical to try to maintain the backwards compatibility.
The  module improves on the standard library 
module in a number of ways including:

Handling positional arguments.
Supporting sub-commands.
Allowing alternative option prefixes like  and .
Handling zero-or-more and one-or-more style arguments.
Producing more informative usage messages.
Providing a much simpler interface for custom  and .

A partial upgrade path from  to :

Replace all  calls with
 calls.
Replace  with  and add additional 
calls for the positional arguments. Keep in mind that what was previously
called , now in the  context is called .
Replace 
by using  instead of
.
Replace callback actions and the  keyword arguments with
 or  arguments.
Replace string names for  keyword arguments with the corresponding
type objects (e.g. int, float, complex, etc).
Replace  with  and
 and  with
.
Replace strings with implicit arguments such as  or  with
the standard Python syntax to use dictionaries to format strings, that is,
 and .
Replace the OptionParser constructor  argument with a call to
.



