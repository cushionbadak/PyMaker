link:
reference/expressions.html#value-comparisons

docs:

6.10.1. Value comparisons¶
The operators , , , , , and  compare the
values of two objects.  The objects do not need to have the same type.
Chapter Objects, values and types states that objects have a value (in addition to type
and identity).  The value of an object is a rather abstract notion in Python:
For example, there is no canonical access method for an object’s value.  Also,
there is no requirement that the value of an object should be constructed in a
particular way, e.g. comprised of all its data attributes. Comparison operators
implement a particular notion of what the value of an object is.  One can think
of them as defining the value of an object indirectly, by means of their
comparison implementation.
Because all types are (direct or indirect) subtypes of , they
inherit the default comparison behavior from .  Types can
customize their comparison behavior by implementing
rich comparison methods like , described in
Basic customization.
The default behavior for equality comparison ( and ) is based on
the identity of the objects.  Hence, equality comparison of instances with the
same identity results in equality, and equality comparison of instances with
different identities results in inequality.  A motivation for this default
behavior is the desire that all objects should be reflexive (i.e. 
implies ).
A default order comparison (, , , and ) is not provided;
an attempt raises .  A motivation for this default behavior is
the lack of a similar invariant as for equality.
The behavior of the default equality comparison, that instances with different
identities are always unequal, may be in contrast to what types will need that
have a sensible definition of object value and value-based equality.  Such
types will need to customize their comparison behavior, and in fact, a number
of built-in types have done that.
The following list describes the comparison behavior of the most important
built-in types.

Numbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard
library types  and  can be
compared within and across their types, with the restriction that complex
numbers do not support order comparison.  Within the limits of the types
involved, they compare mathematically (algorithmically) correct without loss
of precision.
The not-a-number values  and  are
special.  Any ordered comparison of a number to a not-a-number value is false.
A counter-intuitive implication is that not-a-number values are not equal to
themselves.  For example, if , , , ,  are all false.  This behavior is compliant with IEEE 754.

Binary sequences (instances of  or ) can be
compared within and across their types.  They compare lexicographically using
the numeric values of their elements.

Strings (instances of ) compare lexicographically using the
numerical Unicode code points (the result of the built-in function
) of their characters. [3]
Strings and binary sequences cannot be directly compared.

Sequences (instances of , , or ) can
be compared only within each of their types, with the restriction that ranges
do not support order comparison.  Equality comparison across these types
results in inequality, and ordering comparison across these types raises
.
Sequences compare lexicographically using comparison of corresponding
elements, whereby reflexivity of the elements is enforced.
In enforcing reflexivity of elements, the comparison of collections assumes
that for a collection element ,  is always true.  Based on
that assumption, element identity is compared first, and element comparison
is performed only for distinct elements.  This approach yields the same
result as a strict element comparison would, if the compared elements are
reflexive.  For non-reflexive elements, the result is different than for
strict element comparison, and may be surprising:  The non-reflexive
not-a-number values for example result in the following comparison behavior
when used in a list:


Lexicographical comparison between built-in collections works as follows:

For two collections to compare equal, they must be of the same type, have
the same length, and each pair of corresponding elements must compare
equal (for example,  is false because the type is not the
same).
Collections that support order comparison are ordered the same as their
first unequal elements (for example,  has the same
value as ).  If a corresponding element does not exist, the
shorter collection is ordered first (for example,  is
true).


Mappings (instances of ) compare equal if and only if they have
equal (key, value) pairs. Equality comparison of the keys and values
enforces reflexivity.
Order comparisons (, , , and ) raise .

Sets (instances of  or ) can be compared within
and across their types.
They define order
comparison operators to mean subset and superset tests.  Those relations do
not define total orderings (for example, the two sets  and 
are not equal, nor subsets of one another, nor supersets of one
another).  Accordingly, sets are not appropriate arguments for functions
which depend on total ordering (for example, , , and
 produce undefined results given a list of sets as inputs).
Comparison of sets enforces reflexivity of its elements.

Most other built-in types have no comparison methods implemented, so they
inherit the default comparison behavior.


User-defined classes that customize their comparison behavior should follow
some consistency rules, if possible:

Equality comparison should be reflexive.
In other words, identical objects should compare equal:

 implies 


Comparison should be symmetric.
In other words, the following expressions should have the same result:

 and 
 and 
 and 
 and 


Comparison should be transitive.
The following (non-exhaustive) examples illustrate that:

 implies 
 implies 


Inverse comparison should result in the boolean negation.
In other words, the following expressions should have the same result:

 and 
 and  (for total ordering)
 and  (for total ordering)

The last two expressions apply to totally ordered collections (e.g. to
sequences, but not to sets or mappings). See also the
 decorator.

The  result should be consistent with equality.
Objects that are equal should either have the same hash value,
or be marked as unhashable.


Python does not enforce these consistency rules. In fact, the not-a-number
values are an example for not following these rules.
