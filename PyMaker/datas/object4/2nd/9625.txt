link:
library/importlib.html

docs:


 — The implementation of ¶

New in version 3.1.

Source code: Lib/importlib/__init__.py


Introduction¶
The purpose of the  package is two-fold. One is to provide the
implementation of the  statement (and thus, by extension, the
 function) in Python source code. This provides an
implementation of  which is portable to any Python
interpreter. This also provides an implementation which is easier to
comprehend than one implemented in a programming language other than Python.
Two, the components to implement  are exposed in this
package, making it easier for users to create their own custom objects (known
generically as an importer) to participate in the import process.

See also

The import statement
The language reference for the  statement.
Packages specification
Original specification of packages. Some semantics have changed since
the writing of this document (e.g. redirecting based on 
in ).
The  function
The  statement is syntactic sugar for this function.
PEP 235
Import on Case-Insensitive Platforms
PEP 263
Defining Python Source Code Encodings
PEP 302
New Import Hooks
PEP 328
Imports: Multi-Line and Absolute/Relative
PEP 366
Main module explicit relative imports
PEP 420
Implicit namespace packages
PEP 451
A ModuleSpec Type for the Import System
PEP 488
Elimination of PYO files
PEP 489
Multi-phase extension module initialization
PEP 552
Deterministic pycs
PEP 3120
Using UTF-8 as the Default Source Encoding
PEP 3147
PYC Repository Directories




Functions¶


(name, globals=None, locals=None, fromlist=(), level=0)¶
An implementation of the built-in  function.

Note
Programmatic importing of modules should use 
instead of this function.




(name, package=None)¶
Import a module. The name argument specifies what module to
import in absolute or relative terms
(e.g. either  or ). If the name is
specified in relative terms, then the package argument must be set to
the name of the package which is to act as the anchor for resolving the
package name (e.g.  will import
).
The  function acts as a simplifying wrapper around
. This means all semantics of the function are
derived from . The most important difference
between these two functions is that  returns the
specified package or module (e.g. ), while 
returns the top-level package or module (e.g. ).
If you are dynamically importing a module that was created since the
interpreter began execution (e.g., created a Python source file), you may
need to call  in order for the new module to be
noticed by the import system.

Changed in version 3.3: Parent packages are automatically imported.




(name, path=None)¶
Find the loader for a module, optionally within the specified path. If the
module is in , then  is
returned (unless the loader would be  or is not set, in which case
 is raised). Otherwise a search using 
is done.  is returned if no loader is found.
A dotted name does not have its parents implicitly imported as that requires
loading them and that may not be desired. To properly import a submodule you
will need to import all parent packages of the submodule and use the correct
argument to path.

New in version 3.3.


Changed in version 3.4: If  is not set, raise , just like when the
attribute is set to .


Deprecated since version 3.4: Use  instead.




()¶
Invalidate the internal caches of finders stored at
. If a finder implements  then it
will be called to perform the invalidation.  This function should be called
if any modules are created/installed while your program is running to
guarantee all finders will notice the new module’s existence.

New in version 3.3.




(module)¶
Reload a previously imported module.  The argument must be a module object,
so it must have been successfully imported before.  This is useful if you
have edited the module source file using an external editor and want to try
out the new version without leaving the Python interpreter.  The return value
is the module object (which can be different if re-importing causes a
different object to be placed in ).
When  is executed:

Python module’s code is recompiled and the module-level code re-executed,
defining a new set of objects which are bound to names in the module’s
dictionary by reusing the loader which originally loaded the
module.  The  function of extension modules is not called a second
time.
As with all other objects in Python the old objects are only reclaimed
after their reference counts drop to zero.
The names in the module namespace are updated to point to any new or
changed objects.
Other references to the old objects (such as names external to the module) are
not rebound to refer to the new objects and must be updated in each namespace
where they occur if that is desired.

There are a number of other caveats:
When a module is reloaded, its dictionary (containing the module’s global
variables) is retained.  Redefinitions of names will override the old
definitions, so this is generally not a problem.  If the new version of a
module does not define a name that was defined by the old version, the old
definition remains.  This feature can be used to the module’s advantage if it
maintains a global table or cache of objects — with a 
statement it can test for the table’s presence and skip its initialization if
desired:


It is generally not very useful to reload built-in or dynamically loaded
modules.  Reloading , ,  and other
key modules is not recommended.  In many cases extension modules are not
designed to be initialized more than once, and may fail in arbitrary ways
when reloaded.
If a module imports objects from another module using  …
 …, calling  for the other module does not
redefine the objects imported from it — one way around this is to
re-execute the  statement, another is to use 
and qualified names (module.name) instead.
If a module instantiates instances of a class, reloading the module that
defines the class does not affect the method definitions of the instances —
they continue to use the old class definition.  The same is true for derived
classes.

New in version 3.4.


Changed in version 3.7:  is raised when the module being reloaded lacks
a .




 – Abstract base classes related to import¶
Source code: Lib/importlib/abc.py

The  module contains all of the core abstract base classes
used by . Some subclasses of the core abstract base classes
are also provided to help in implementing the core ABCs.
ABC hierarchy:




class ¶
An abstract base class representing a finder.

Deprecated since version 3.3: Use  or  instead.



abstractmethod (fullname, path=None)¶
An abstract method for finding a loader for the specified
module.  Originally specified in PEP 302, this method was meant
for use in  and in the path-based import subsystem.

Changed in version 3.4: Returns  when called instead of raising
.





class ¶
An abstract base class representing a meta path finder. For
compatibility, this is a subclass of .

New in version 3.3.



(fullname, path, target=None)¶
An abstract method for finding a spec for
the specified module.  If this is a top-level import, path will
be .  Otherwise, this is a search for a subpackage or
module and path will be the value of  from the
parent package. If a spec cannot be found,  is returned.
When passed in,  is a module object that the finder may
use to make a more educated guess about what spec to return.

New in version 3.4.




(fullname, path)¶
A legacy method for finding a loader for the specified
module.  If this is a top-level import, path will be .
Otherwise, this is a search for a subpackage or module and path
will be the value of  from the parent
package. If a loader cannot be found,  is returned.
If  is defined, backwards-compatible functionality is
provided.

Changed in version 3.4: Returns  when called instead of raising
. Can use  to provide
functionality.


Deprecated since version 3.4: Use  instead.




()¶
An optional method which, when called, should invalidate any internal
cache used by the finder. Used by 
when invalidating the caches of all finders on .

Changed in version 3.4: Returns  when called instead of .





class ¶
An abstract base class representing a path entry finder.  Though
it bears some similarities to , 
is meant for use only within the path-based import subsystem provided
by . This ABC is a subclass of  for
compatibility reasons only.

New in version 3.3.



(fullname, target=None)¶
An abstract method for finding a spec for
the specified module.  The finder will search for the module only
within the path entry to which it is assigned.  If a spec
cannot be found,  is returned.  When passed in, 
is a module object that the finder may use to make a more educated
guess about what spec to return.

New in version 3.4.




(fullname)¶
A legacy method for finding a loader for the specified
module.  Returns a 2-tuple of  where 
is a sequence of file system locations contributing to part of a namespace
package. The loader may be  while specifying  to
signify the contribution of the file system locations to a namespace
package. An empty list can be used for  to signify the loader
is not part of a namespace package. If  is  and
 is the empty list then no loader or location for a namespace
package were found (i.e. failure to find anything for the module).
If  is defined then backwards-compatible functionality is
provided.

Changed in version 3.4: Returns  instead of raising .
Uses  when available to provide functionality.


Deprecated since version 3.4: Use  instead.




(fullname)¶
A concrete implementation of  which is
equivalent to .

Deprecated since version 3.4: Use  instead.




()¶
An optional method which, when called, should invalidate any internal
cache used by the finder. Used by 
when invalidating the caches of all cached finders.




class ¶
An abstract base class for a loader.
See PEP 302 for the exact definition for a loader.
Loaders that wish to support resource reading should implement a
 method as specified by
.

Changed in version 3.7: Introduced the optional  method.



(spec)¶
A method that returns the module object to use when
importing a module.  This method may return ,
indicating that default module creation semantics should take place.

New in version 3.4.


Changed in version 3.5: Starting in Python 3.6, this method will not be optional when
 is defined.




(module)¶
An abstract method that executes the module in its own namespace
when a module is imported or reloaded.  The module should already
be initialized when  is called. When this method exists,
 must be defined.

New in version 3.4.


Changed in version 3.6:  must also be defined.




(fullname)¶
A legacy method for loading a module. If the module cannot be
loaded,  is raised, otherwise the loaded module is
returned.
If the requested module already exists in , that
module should be used and reloaded.
Otherwise the loader should create a new module and insert it into
 before any loading begins, to prevent recursion
from the import. If the loader inserted a module and the load fails, it
must be removed by the loader from ; modules already
in  before the loader began execution should be left
alone (see ).
The loader should set several attributes on the module.
(Note that some of these attributes can change when a module is
reloaded):



The name of the module.




The path to where the module data is stored (not set for built-in
modules).




The path to where a compiled version of the module is/should be
stored (not set when the attribute would be inappropriate).




A list of strings specifying the search path within a
package. This attribute is not set on modules.




The parent package for the module/package. If the module is
top-level then it has a value of the empty string. The
 decorator can handle the
details for .




The loader used to load the module. The
 decorator can handle the
details for .



When  is available then backwards-compatible
functionality is provided.

Changed in version 3.4: Raise  when called instead of
. Functionality provided when
 is available.


Deprecated since version 3.4: The recommended API for loading a module is 
(and ).  Loaders should implement
it instead of load_module().  The import machinery takes care of
all the other responsibilities of load_module() when exec_module()
is implemented.




(module)¶
A legacy method which when implemented calculates and returns the
given module’s repr, as a string. The module type’s default repr() will
use the result of this method as appropriate.

New in version 3.3.


Changed in version 3.4: Made optional instead of an abstractmethod.


Deprecated since version 3.4: The import machinery now takes care of this automatically.





class ¶
An abstract base class to provide the ability to read
resources.
From the perspective of this ABC, a resource is a binary
artifact that is shipped within a package. Typically this is
something like a data file that lives next to the 
file of the package. The purpose of this class is to help abstract
out the accessing of such data files so that it does not matter if
the package and its data file(s) are stored in a e.g. zip file
versus on the file system.
For any of methods of this class, a resource argument is
expected to be a path-like object which represents
conceptually just a file name. This means that no subdirectory
paths should be included in the resource argument. This is
because the location of the package the reader is for, acts as the
“directory”. Hence the metaphor for directories and file
names is packages and resources, respectively. This is also why
instances of this class are expected to directly correlate to
a specific package (instead of potentially representing multiple
packages or a module).
Loaders that wish to support resource reading are expected to
provide a method called  which
returns an object implementing this ABC’s interface. If the module
specified by fullname is not a package, this method should return
. An object compatible with this ABC should only be
returned when the specified module is a package.

New in version 3.7.



abstractmethod (resource)¶
Returns an opened, file-like object for binary reading
of the resource.
If the resource cannot be found,  is
raised.



abstractmethod (resource)¶
Returns the file system path to the resource.
If the resource does not concretely exist on the file system,
raise .



abstractmethod (name)¶
Returns  if the named name is considered a resource.
 is raised if name does not exist.



abstractmethod ()¶
Returns an iterable of strings over the contents of
the package. Do note that it is not required that all names
returned by the iterator be actual resources, e.g. it is
acceptable to return names for which  would
be false.
Allowing non-resource names to be returned is to allow for
situations where how a package and its resources are stored
are known a priori and the non-resource names would be useful.
For instance, returning subdirectory names is allowed so that
when it is known that the package and resources are stored on
the file system then those subdirectory names can be used
directly.
The abstract method returns an iterable of no items.




class ¶
An abstract base class for a loader which implements the optional
PEP 302 protocol for loading arbitrary resources from the storage
back-end.

Deprecated since version 3.7: This ABC is deprecated in favour of supporting resource loading
through .



abstractmethod (path)¶
An abstract method to return the bytes for the data located at path.
Loaders that have a file-like storage back-end
that allows storing arbitrary data
can implement this abstract method to give direct access
to the data stored.  is to be raised if the path cannot
be found. The path is expected to be constructed using a module’s
 attribute or an item from a package’s .

Changed in version 3.4: Raises  instead of .





class ¶
An abstract base class for a loader which implements the optional
PEP 302 protocol for loaders that inspect modules.


(fullname)¶
Return the code object for a module, or  if the module does not
have a code object (as would be the case, for example, for a built-in
module).  Raise an  if loader cannot find the
requested module.

Note
While the method has a default implementation, it is suggested that
it be overridden if possible for performance.


Changed in version 3.4: No longer abstract and a concrete implementation is provided.




abstractmethod (fullname)¶
An abstract method to return the source of a module. It is returned as
a text string using universal newlines, translating all
recognized line separators into  characters.  Returns 
if no source is available (e.g. a built-in module). Raises
 if the loader cannot find the module specified.

Changed in version 3.4: Raises  instead of .




(fullname)¶
An abstract method to return a true value if the module is a package, a
false value otherwise.  is raised if the
loader cannot find the module.

Changed in version 3.4: Raises  instead of .




static (data, path='<string>')¶
Create a code object from Python source.
The data argument can be whatever the  function
supports (i.e. string or bytes). The path argument should be
the “path” to where the source code originated from, which can be an
abstract concept (e.g. location in a zip file).
With the subsequent code object one can execute it in a module by
running .

New in version 3.4.


Changed in version 3.5: Made the method static.




(module)¶
Implementation of .

New in version 3.4.




(fullname)¶
Implementation of .

Deprecated since version 3.4: use  instead.





class ¶
An abstract base class which inherits from  that,
when implemented, helps a module to be executed as a script. The ABC
represents an optional PEP 302 protocol.


abstractmethod (fullname)¶
An abstract method that is to return the value of  for
the specified module. If no path is available,  is
raised.
If source code is available, then the method should return the path to
the source file, regardless of whether a bytecode was used to load the
module.

Changed in version 3.4: Raises  instead of .





class (fullname, path)¶
An abstract base class which inherits from  and
, providing concrete implementations of
 and .
The fullname argument is a fully resolved name of the module the loader is
to handle. The path argument is the path to the file for the module.

New in version 3.3.



¶
The name of the module the loader can handle.



¶
Path to the file of the module.



(fullname)¶
Calls super’s .

Deprecated since version 3.4: Use  instead.




abstractmethod (fullname)¶
Returns .



abstractmethod (path)¶
Reads path as a binary file and returns the bytes from it.




class ¶
An abstract base class for implementing source (and optionally bytecode)
file loading. The class inherits from both  and
, requiring the implementation of:




Should only return the path to the source file; sourceless
loading is not supported.



The abstract methods defined by this class are to add optional bytecode
file support. Not implementing these optional methods (or causing them to
raise ) causes the loader to
only work with source code. Implementing the methods allows the loader to
work with source and bytecode files; it does not allow for sourceless
loading where only bytecode is provided.  Bytecode files are an
optimization to speed up loading by removing the parsing step of Python’s
compiler, and so no bytecode-specific API is exposed.


(path)¶
Optional abstract method which returns a  containing
metadata about the specified path.  Supported dictionary keys are:

 (mandatory): an integer or floating-point number
representing the modification time of the source code;
 (optional): the size in bytes of the source code.

Any other keys in the dictionary are ignored, to allow for future
extensions. If the path cannot be handled,  is raised.

New in version 3.3.


Changed in version 3.4: Raise  instead of .




(path)¶
Optional abstract method which returns the modification time for the
specified path.

Deprecated since version 3.3: This method is deprecated in favour of .  You don’t
have to implement it, but it is still available for compatibility
purposes. Raise  if the path cannot be handled.


Changed in version 3.4: Raise  instead of .




(path, data)¶
Optional abstract method which writes the specified bytes to a file
path. Any intermediate directories which do not exist are to be created
automatically.
When writing to the path fails because the path is read-only
(/), do not propagate the
exception.

Changed in version 3.4: No longer raises  when called.




(fullname)¶
Concrete implementation of .



(module)¶
Concrete implementation of .

New in version 3.4.




(fullname)¶
Concrete implementation of .

Deprecated since version 3.4: Use  instead.




(fullname)¶
Concrete implementation of .



(fullname)¶
Concrete implementation of . A module
is determined to be a package if its file path (as provided by
) is a file named
 when the file extension is removed and the module name
itself does not end in .




 – Resources¶
Source code: Lib/importlib/resources.py


New in version 3.7.

This module leverages Python’s import system to provide access to resources
within packages.  If you can import a package, you can access resources
within that package.  Resources can be opened or read, in either binary or
text mode.
Resources are roughly akin to files inside directories, though it’s important
to keep in mind that this is just a metaphor.  Resources and packages do
not have to exist as physical files and directories on the file system.

Note
This module provides functionality similar to pkg_resources Basic
Resource Access
without the performance overhead of that package.  This makes reading
resources included in packages easier, with more stable and consistent
semantics.
The standalone backport of this module provides more information
on using importlib.resources and
migrating from pkg_resources to importlib.resources.

Loaders that wish to support resource reading should implement a
 method as specified by
.
The following types are defined.


¶
The  type is defined as .  This means
that where the function describes accepting a , you can pass in
either a string or a module.  Module objects must have a resolvable
 that is not .



¶
This type describes the resource names passed into the various functions
in this package.  This is defined as .

The following functions are available.


(package, resource)¶
Open for binary reading the resource within package.
package is either a name or a module object which conforms to the
 requirements.  resource is the name of the resource to open
within package; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns a
 instance, a binary I/O stream open for reading.



(package, resource, encoding='utf-8', errors='strict')¶
Open for text reading the resource within package.  By default, the
resource is opened for reading as UTF-8.
package is either a name or a module object which conforms to the
 requirements.  resource is the name of the resource to open
within package; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  encoding and errors
have the same meaning as with built-in .
This function returns a  instance, a text I/O stream open
for reading.



(package, resource)¶
Read and return the contents of the resource within package as
.
package is either a name or a module object which conforms to the
 requirements.  resource is the name of the resource to open
within package; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  This function returns the
contents of the resource as .



(package, resource, encoding='utf-8', errors='strict')¶
Read and return the contents of resource within package as a .
By default, the contents are read as strict UTF-8.
package is either a name or a module object which conforms to the
 requirements.  resource is the name of the resource to open
within package; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).  encoding and errors
have the same meaning as with built-in .  This function
returns the contents of the resource as .



(package, resource)¶
Return the path to the resource as an actual file system path.  This
function returns a context manager for use in a  statement.
The context manager provides a  object.
Exiting the context manager cleans up any temporary file created when the
resource needs to be extracted from e.g. a zip file.
package is either a name or a module object which conforms to the
 requirements.  resource is the name of the resource to open
within package; it may not contain path separators and it may not have
sub-resources (i.e. it cannot be a directory).



(package, name)¶
Return  if there is a resource named name in the package,
otherwise .  Remember that directories are not resources!
package is either a name or a module object which conforms to the
 requirements.



(package)¶
Return an iterable over the named items within the package.  The iterable
returns  resources (e.g. files) and non-resources
(e.g. directories).  The iterable does not recurse into subdirectories.
package is either a name or a module object which conforms to the
 requirements.



 – Importers and path hooks¶
Source code: Lib/importlib/machinery.py

This module contains the various objects that help 
find and load modules.


¶
A list of strings representing the recognized file suffixes for source
modules.

New in version 3.3.




¶
A list of strings representing the file suffixes for non-optimized bytecode
modules.

New in version 3.3.


Deprecated since version 3.5: Use  instead.




¶
A list of strings representing the file suffixes for optimized bytecode
modules.

New in version 3.3.


Deprecated since version 3.5: Use  instead.




¶
A list of strings representing the recognized file suffixes for bytecode
modules (including the leading dot).

New in version 3.3.


Changed in version 3.5: The value is no longer dependent on .




¶
A list of strings representing the recognized file suffixes for
extension modules.

New in version 3.3.




()¶
Returns a combined list of strings representing all file suffixes for
modules recognized by the standard import machinery. This is a
helper for code which simply needs to know if a filesystem path
potentially refers to a module without needing any details on the kind
of module (for example, ).

New in version 3.3.




class ¶
An importer for built-in modules. All known built-in modules are
listed in . This class implements the
 and
 ABCs.
Only class methods are defined by this class to alleviate the need for
instantiation.

Changed in version 3.5: As part of PEP 489, the builtin importer now implements
 and 




class ¶
An importer for frozen modules. This class implements the
 and
 ABCs.
Only class methods are defined by this class to alleviate the need for
instantiation.



class ¶
Finder for modules declared in the Windows registry.  This class
implements the  ABC.
Only class methods are defined by this class to alleviate the need for
instantiation.

New in version 3.3.


Deprecated since version 3.6: Use  configuration instead. Future versions of Python may
not enable this finder by default.




class ¶
A Finder for  and package  attributes.
This class implements the  ABC.
Only class methods are defined by this class to alleviate the need for
instantiation.


classmethod (fullname, path=None, target=None)¶
Class method that attempts to find a spec
for the module specified by fullname on  or, if
defined, on path. For each path entry that is searched,
 is checked. If a non-false object
is found then it is used as the path entry finder to look
for the module being searched for. If no entry is found in
, then  is
searched for a finder for the path entry and, if found, is stored
in  along with being queried about
the module. If no finder is ever found then  is both
stored in the cache and returned.

New in version 3.4.


Changed in version 3.5: If the current working directory – represented by an empty string –
is no longer valid then  is returned but no value is cached
in .




classmethod (fullname, path=None)¶
A legacy wrapper around .

Deprecated since version 3.4: Use  instead.




classmethod ()¶
Calls  on all
finders stored in  that define the method.
Otherwise entries in  set to  are
deleted.

Changed in version 3.7: Entries of  in  are deleted.



Changed in version 3.4: Calls objects in  with the current working
directory for  (i.e. the empty string).




class (path, *loader_details)¶
A concrete implementation of  which
caches results from the file system.
The path argument is the directory for which the finder is in charge of
searching.
The loader_details argument is a variable number of 2-item tuples each
containing a loader and a sequence of file suffixes the loader recognizes.
The loaders are expected to be callables which accept two arguments of
the module’s name and the path to the file found.
The finder will cache the directory contents as necessary, making stat calls
for each module search to verify the cache is not outdated. Because cache
staleness relies upon the granularity of the operating system’s state
information of the file system, there is a potential race condition of
searching for a module, creating a new file, and then searching for the
module the new file represents. If the operations happen fast enough to fit
within the granularity of stat calls, then the module search will fail. To
prevent this from happening, when you create a module dynamically, make sure
to call .

New in version 3.3.



¶
The path the finder will search in.



(fullname, target=None)¶
Attempt to find the spec to handle fullname within .

New in version 3.4.




(fullname)¶
Attempt to find the loader to handle fullname within .



()¶
Clear out the internal cache.



classmethod (*loader_details)¶
A class method which returns a closure for use on .
An instance of  is returned by the closure using the
path argument given to the closure directly and loader_details
indirectly.
If the argument to the closure is not an existing directory,
 is raised.




class (fullname, path)¶
A concrete implementation of  by
subclassing  and providing some concrete
implementations of other methods.

New in version 3.3.



¶
The name of the module that this loader will handle.



¶
The path to the source file.



(fullname)¶
Return true if  appears to be for a package.



(path)¶
Concrete implementation of .



(path, data)¶
Concrete implementation of .



(name=None)¶
Concrete implementation of  where
specifying the name of the module to load is optional.

Deprecated since version 3.6: Use  instead.





class (fullname, path)¶
A concrete implementation of  which can
import bytecode files (i.e. no source code files exist).
Please note that direct use of bytecode files (and thus not source code
files) inhibits your modules from being usable by all Python
implementations or new versions of Python which change the bytecode
format.

New in version 3.3.



¶
The name of the module the loader will handle.



¶
The path to the bytecode file.



(fullname)¶
Determines if the module is a package based on .



(fullname)¶
Returns the code object for  created from .



(fullname)¶
Returns  as bytecode files have no source when this loader is
used.



(name=None)¶

Concrete implementation of  where
specifying the name of the module to load is optional.

Deprecated since version 3.6: Use  instead.




class (fullname, path)¶
A concrete implementation of  for
extension modules.
The fullname argument specifies the name of the module the loader is to
support. The path argument is the path to the extension module’s file.

New in version 3.3.



¶
Name of the module the loader supports.



¶
Path to the extension module.



(spec)¶
Creates the module object from the given specification in accordance
with PEP 489.

New in version 3.5.




(module)¶
Initializes the given module object in accordance with PEP 489.

New in version 3.5.




(fullname)¶
Returns  if the file path points to a package’s 
module based on .



(fullname)¶
Returns  as extension modules lack a code object.



(fullname)¶
Returns  as extension modules do not have source code.



(fullname)¶
Returns .

New in version 3.4.





class (name, loader, *, origin=None, loader_state=None, is_package=None)¶
A specification for a module’s import-system-related state.  This is
typically exposed as the module’s  attribute.  In the
descriptions below, the names in parentheses give the corresponding
attribute available directly on the module object.
E.g. .  Note however that
while the values are usually equivalent, they can differ since there is
no synchronization between the two objects.  Thus it is possible to update
the module’s  at runtime, and this will not be automatically
reflected in .

New in version 3.4.



¶

()
A string for the fully-qualified name of the module.


¶

()
The loader to use for loading.  For namespace packages this should be
set to .


¶

()
Name of the place from which the module is loaded, e.g. “builtin” for
built-in modules and the filename for modules loaded from source.
Normally “origin” should be set, but it may be  (the default)
which indicates it is unspecified (e.g. for namespace packages).


¶

()
List of strings for where to find submodules, if a package (
otherwise).


¶

Container of extra module-specific data for use during loading (or
).


¶

()
String for where the compiled module should be stored (or ).


¶

()
(Read-only) Fully-qualified name of the package to which the module
belongs as a submodule (or ).


¶

Boolean indicating whether or not the module’s “origin”
attribute refers to a loadable location.



 – Utility code for importers¶
Source code: Lib/importlib/util.py

This module contains the various objects that help in the construction of
an importer.


¶
The bytes which represent the bytecode version number. If you need help with
loading/writing bytecode then consider .

New in version 3.4.




(path, debug_override=None, *, optimization=None)¶
Return the PEP 3147/PEP 488 path to the byte-compiled file associated
with the source path.  For example, if path is  the return
value would be  for Python 3.2.
The  string comes from the current magic tag (see
; if  is not defined then
 will be raised).
The optimization parameter is used to specify the optimization level of the
bytecode file. An empty string represents no optimization, so
 with an optimization of  will result in a
bytecode path of .  causes
the interpter’s optimization level to be used. Any other value’s string
representation being used, so  with an optimization of
 will lead to the bytecode path of
. The string representation
of optimization can only be alphanumeric, else  is raised.
The debug_override parameter is deprecated and can be used to override
the system’s value for . A  value is the equivalent of
setting optimization to the empty string. A  value is the same as
setting optimization to . If both debug_override an optimization
are not  then  is raised.

New in version 3.4.


Changed in version 3.5: The optimization parameter was added and the debug_override parameter
was deprecated.


Changed in version 3.6: Accepts a path-like object.




(path)¶
Given the path to a PEP 3147 file name, return the associated source code
file path.  For example, if path is
 the returned path would be
.  path need not exist, however if it does not conform
to PEP 3147 or PEP 488 format, a  is raised. If
 is not defined,
 is raised.

New in version 3.4.


Changed in version 3.6: Accepts a path-like object.




(source_bytes)¶
Decode the given bytes representing source code and return it as a string
with universal newlines (as required by
).

New in version 3.4.




(name, package)¶
Resolve a relative module name to an absolute one.
If  name has no leading dots, then name is simply returned. This
allows for usage such as
 without doing a
check to see if the package argument is needed.
 is raised if name is a relative module name but
package is a false value (e.g.  or the empty string).
 is also raised a relative name would escape its containing
package (e.g. requesting  from within the  package).

New in version 3.3.




(name, package=None)¶
Find the spec for a module, optionally relative to
the specified package name. If the module is in ,
then  is returned (unless the spec would be
 or is not set, in which case  is raised).
Otherwise a search using  is done.  is
returned if no spec is found.
If name is for a submodule (contains a dot), the parent module is
automatically imported.
name and package work the same as for .

New in version 3.4.


Changed in version 3.7: Raises  instead of  if
package is in fact not a package (i.e. lacks a 
attribute).




(spec)¶
Create a new module based on spec and
.
If 
does not return , then any pre-existing attributes will not be reset.
Also, no  will be raised if triggered while accessing
spec or setting an attribute on the module.
This function is preferred over using  to create a
new module as spec is used to set as many import-controlled attributes on
the module as possible.

New in version 3.5.




¶
A decorator for 
to handle selecting the proper
module object to load with. The decorated method is expected to have a call
signature taking two positional arguments
(e.g. ) for which the second argument
will be the module object to be used by the loader.
Note that the decorator will not work on static methods because of the
assumption of two arguments.
The decorated method will take in the name of the module to be loaded
as expected for a loader. If the module is not found in
 then a new one is constructed. Regardless of where the
module came from,  set to self and 
is set based on what  returns
(if available). These attributes are set unconditionally to support
reloading.
If an exception is raised by the decorated method and a module was added to
, then the module will be removed to prevent a partially
initialized module from being in left in . If the module
was already in  then it is left alone.

Changed in version 3.3:  and  are automatically set
(when possible).


Changed in version 3.4: Set ,  
unconditionally to support reloading.


Deprecated since version 3.4: The import machinery now directly performs all the functionality
provided by this function.




¶
A decorator for 
to set the 
attribute on the returned module. If the attribute is already set the
decorator does nothing. It is assumed that the first positional argument to
the wrapped method (i.e. ) is what  should be set
to.

Changed in version 3.4: Set  if set to , as if the attribute does not
exist.


Deprecated since version 3.4: The import machinery takes care of this automatically.




¶
A decorator for  to set the
 attribute on the returned module. If 
is set and has a value other than  it will not be changed.

Deprecated since version 3.4: The import machinery takes care of this automatically.




(name, loader, *, origin=None, is_package=None)¶
A factory function for creating a  instance based
on a loader.  The parameters have the same meaning as they do for
ModuleSpec.  The function uses available loader APIs, such as
, to fill in any missing
information on the spec.

New in version 3.4.




(name, location, *, loader=None, submodule_search_locations=None)¶
A factory function for creating a  instance based
on the path to a file.  Missing information will be filled in on the
spec by making use of loader APIs and by the implication that the
module will be file-based.

New in version 3.4.


Changed in version 3.6: Accepts a path-like object.




(source_bytes)¶
Return the hash of source_bytes as bytes. A hash-based  file embeds
the  of the corresponding source file’s contents in its
header.

New in version 3.7.




class (loader)¶
A class which postpones the execution of the loader of a module until the
module has an attribute accessed.
This class only works with loaders that define
 as control over what module type
is used for the module is required. For those same reasons, the loader’s
 method must return  or a
type for which its  attribute can be mutated along with not
using slots. Finally, modules which substitute the object
placed into  will not work as there is no way to properly
replace the module references throughout the interpreter safely;
 is raised if such a substitution is detected.

Note
For projects where startup time is critical, this class allows for
potentially minimizing the cost of loading a module if it is never used.
For projects where startup time is not essential then use of this class is
heavily discouraged due to error messages created during loading being
postponed and thus occurring out of context.


New in version 3.5.


Changed in version 3.6: Began calling , removing the
compatibility warning for  and
.



classmethod (loader)¶
A static method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.






Examples¶

Importing programmatically¶
To programmatically import a module, use .




Checking if a module can be imported¶
If you need to find out if a module can be imported without actually doing the
import, then you should use .




Importing a source file directly¶
To import a Python source file directly, use the following recipe
(Python 3.5 and newer only):




Setting up an importer¶
For deep customizations of import, you typically want to implement an
importer. This means managing both the finder and loader
side of things. For finders there are two flavours to choose from depending on
your needs: a meta path finder or a path entry finder. The
former is what you would put on  while the latter is what
you create using a path entry hook on  which works
with  entries to potentially create a finder. This example will
show you how to register your own importers so that import will use them (for
creating an importer for yourself, read the documentation for the appropriate
classes defined within this package):




Approximating ¶
Import itself is implemented in Python code, making it possible to
expose most of the import machinery through importlib. The following
helps illustrate the various APIs that importlib exposes by providing an
approximate implementation of
 (Python 3.4 and newer for the importlib usage,
Python 3.6 and newer for other parts of the code).





