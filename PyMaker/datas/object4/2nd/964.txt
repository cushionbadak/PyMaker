link:
library/struct.html#byte-order-size-and-alignment

docs:

Byte Order, Size, and Alignment¶
By default, C types are represented in the machine’s native format and byte
order, and properly aligned by skipping pad bytes if necessary (according to the
rules used by the C compiler).
Alternatively, the first character of the format string can be used to indicate
the byte order, size and alignment of the packed data, according to the
following table:








Character
Byte order
Size
Alignment




native
native
native


native
standard
none


little-endian
standard
none


big-endian
standard
none


network (= big-endian)
standard
none



If the first character is not one of these,  is assumed.
Native byte order is big-endian or little-endian, depending on the host
system. For example, Intel x86 and AMD64 (x86-64) are little-endian;
Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature
switchable endianness (bi-endian). Use  to check the
endianness of your system.
Native size and alignment are determined using the C compiler’s
 expression.  This is always combined with native byte order.
Standard size depends only on the format character;  see the table in
the Format Characters section.
Note the difference between  and : both use native byte order, but
the size and alignment of the latter is standardized.
The form  is available for those poor souls who claim they can’t remember
whether network byte order is big-endian or little-endian.
There is no way to indicate non-native byte order (force byte-swapping); use the
appropriate choice of  or .
Notes:

Padding is only automatically added between successive structure members.
No padding is added at the beginning or the end of the encoded struct.
No padding is added when using non-native size and alignment, e.g.
with ‘<’, ‘>’, ‘=’, and ‘!’.
To align the end of a structure to the alignment requirement of a
particular type, end the format with the code for that type with a repeat
count of zero.  See Examples.

