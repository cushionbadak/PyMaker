link:
library/math.html#number-theoretic-and-representation-functions

docs:

Number-theoretic and representation functions¶


(x)¶
Return the ceiling of x, the smallest integer greater than or equal to x.
If x is not a float, delegates to , which should return an
 value.



(x, y)¶
Return a float with the magnitude (absolute value) of x but the sign of
y.  On platforms that support signed zeros, 
returns -1.0.



(x)¶
Return the absolute value of x.



(x)¶
Return x factorial.  Raises  if x is not integral or
is negative.



(x)¶
Return the floor of x, the largest integer less than or equal to x.
If x is not a float, delegates to , which should return an
 value.



(x, y)¶
Return , as defined by the platform C library. Note that the
Python expression  may not return the same result.  The intent of the C
standard is that  be exactly (mathematically; to infinite
precision) equal to  for some integer n such that the result has
the same sign as x and magnitude less than .  Python’s 
returns a result with the sign of y instead, and may not be exactly computable
for float arguments. For example,  is , but
the result of Python’s  is , which cannot be
represented exactly as a float, and rounds to the surprising .  For
this reason, function  is generally preferred when working with
floats, while Python’s  is preferred when working with integers.



(x)¶
Return the mantissa and exponent of x as the pair .  m is a float
and e is an integer such that  exactly. If x is zero,
returns , otherwise .  This is used to “pick
apart” the internal representation of a float in a portable way.



(iterable)¶
Return an accurate floating point sum of values in the iterable.  Avoids
loss of precision by tracking multiple intermediate partial sums:


The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the
typical case where the rounding mode is half-even.  On some non-Windows
builds, the underlying C library uses extended precision addition and may
occasionally double-round an intermediate sum causing it to be off in its
least significant bit.
For further discussion and two alternative approaches, see the ASPN cookbook
recipes for accurate floating point summation.



(a, b)¶
Return the greatest common divisor of the integers a and b.  If either
a or b is nonzero, then the value of  is the largest
positive integer that divides both a and b.   returns
.

New in version 3.5.




(a, b, *, rel_tol=1e-09, abs_tol=0.0)¶
Return  if the values a and b are close to each other and
 otherwise.
Whether or not two values are considered close is determined according to
given absolute and relative tolerances.
rel_tol is the relative tolerance – it is the maximum allowed difference
between a and b, relative to the larger absolute value of a or b.
For example, to set a tolerance of 5%, pass .  The default
tolerance is , which assures that the two values are the same
within about 9 decimal digits.  rel_tol must be greater than zero.
abs_tol is the minimum absolute tolerance – useful for comparisons near
zero. abs_tol must be at least zero.
If no errors occur, the result will be:
.
The IEEE 754 special values of , , and  will be
handled according to IEEE rules.  Specifically,  is not considered
close to any other value, including .   and  are only
considered close to themselves.

New in version 3.5.


See also
PEP 485 – A function for testing approximate equality




(x)¶
Return  if x is neither an infinity nor a NaN, and
 otherwise.  (Note that  is considered finite.)

New in version 3.2.




(x)¶
Return  if x is a positive or negative infinity, and
 otherwise.



(x)¶
Return  if x is a NaN (not a number), and  otherwise.



(x, i)¶
Return .  This is essentially the inverse of function
.



(x)¶
Return the fractional and integer parts of x.  Both results carry the sign
of x and are floats.



(x, y)¶
Return the IEEE 754-style remainder of x with respect to y.  For
finite x and finite nonzero y, this is the difference ,
where  is the closest integer to the exact value of the quotient .  If  is exactly halfway between two consecutive integers, the
nearest even integer is used for .  The remainder  thus always satisfies .
Special cases follow IEEE 754: in particular,  is
x for any finite x, and  and
 raise  for any non-NaN x.
If the result of the remainder operation is zero, that zero will have
the same sign as x.
On platforms using IEEE 754 binary floating-point, the result of this
operation is always exactly representable: no rounding error is introduced.

New in version 3.7.




(x)¶
Return the  value x truncated to an
 (usually an integer). Delegates to
.

Note that  and  have a different call/return pattern
than their C equivalents: they take a single argument and return a pair of
values, rather than returning their second return value through an ‘output
parameter’ (there is no such thing in Python).
For the , , and  functions, note that all
floating-point numbers of sufficiently large magnitude are exact integers.
Python floats typically carry no more than 53 bits of precision (the same as the
platform C double type), in which case any float x with 
necessarily has no fractional bits.
