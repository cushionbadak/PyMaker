link:
library/optparse.html#extending-optparse

docs:

Extending ¶
Since the two major controlling factors in how  interprets
command-line options are the action and type of each option, the most likely
direction of extension is to add new actions and new types.

Adding new types¶
To add new types, you need to define your own subclass of ’s
 class.  This class has a couple of attributes that define
’s types:  and .


¶
A tuple of type names; in your subclass, simply define a new tuple
 that builds on the standard one.



¶
A dictionary mapping type names to type-checking functions.  A type-checking
function has the following signature:


where  is an  instance,  is an option string
(e.g., ), and  is the string from the command line that must
be checked and converted to your desired type.   should
return an object of the hypothetical type .  The value returned by
a type-checking function will wind up in the OptionValues instance returned
by , or be passed to a callback as the
 parameter.
Your type-checking function should raise  if it
encounters any problems.   takes a single string
argument, which is passed as-is to ’s 
method, which in turn prepends the program name and the string 
and prints everything to stderr before terminating the process.

Here’s a silly example that demonstrates adding a  option type to
parse Python-style complex numbers on the command line.  (This is even sillier
than it used to be, because  1.3 added built-in support for
complex numbers, but never mind.)
First, the necessary imports:


You need to define your type-checker first, since it’s referred to later (in the
 class attribute of your Option subclass):


Finally, the Option subclass:


(If we didn’t make a  of , we would end
up modifying the  attribute of ’s
Option class.  This being Python, nothing stops you from doing that except good
manners and common sense.)
That’s it!  Now you can write a script that uses the new option type just like
any other -based script, except you have to instruct your
OptionParser to use MyOption instead of Option:


Alternately, you can build your own option list and pass it to OptionParser; if
you don’t use  in the above way, you don’t need to tell
OptionParser which option class to use:




Adding new actions¶
Adding new actions is a bit trickier, because you have to understand that
 has a couple of classifications for actions:

“store” actions
actions that result in  storing a value to an attribute of the
current OptionValues instance; these options require a 
attribute to be supplied to the Option constructor.
“typed” actions
actions that take a value from the command line and expect it to be of a
certain type; or rather, a string that can be converted to a certain type.
These options require a  attribute to the Option
constructor.

These are overlapping sets: some default “store” actions are ,
, , and , while the default “typed”
actions are , , and .
When you add an action, you need to categorize it by listing it in at least one
of the following class attributes of Option (all are lists of strings):


¶
All actions must be listed in ACTIONS.



¶
“store” actions are additionally listed here.



¶
“typed” actions are additionally listed here.



¶
Actions that always take a type (i.e. whose options always take a value) are
additionally listed here.  The only effect of this is that 
assigns the default type, , to options with no explicit type
whose action is listed in .

In order to actually implement your new action, you must override Option’s
 method and add a case that recognizes your action.
For example, let’s add an  action.  This is similar to the standard
 action, but instead of taking a single value from the command-line
and appending it to an existing list,  will take multiple values in
a single comma-delimited string, and extend an existing list with them.  That
is, if  is an  option of type , the command
line


would result in a list


Again we define a subclass of Option:


Features of note:

 both expects a value on the command-line and stores that value
somewhere, so it goes in both  and
.

to ensure that  assigns the default type of  to
 actions, we put the  action in
 as well.

 implements just this one new action, and passes
control back to  for the standard 
actions.

 is an instance of the optparse_parser.Values class, which provides
the very useful  method.  is
essentially  with a safety valve; it is called as


If the  attribute of  doesn’t exist or is , then
ensure_value() first sets it to , and then returns ‘value. This is
very handy for actions like , , and , all
of which accumulate data in a variable and expect that variable to be of a
certain type (a list for the first two, an integer for the latter).  Using
 means that scripts using your action don’t have to worry
about setting a default value for the option destinations in question; they
can just leave the default as  and  will take care of
getting it right when it’s needed.



