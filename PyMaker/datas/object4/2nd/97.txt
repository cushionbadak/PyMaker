link:
reference/datamodel.html#emulating-numeric-types

docs:

3.3.8. Emulating numeric types¶
The following methods can be defined to emulate numeric objects. Methods
corresponding to operations that are not supported by the particular kind of
number implemented (e.g., bitwise operations for non-integral numbers) should be
left undefined.


(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other[, modulo])¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the binary arithmetic operations
(, , , , , , , ,
, , , , , , ).  For instance, to
evaluate the expression , where x is an instance of a class that
has an  method,  is called.  The
 method should be the equivalent to using
 and ; it should not be related to
.  Note that  should be defined to accept
an optional third argument if the ternary version of the built-in 
function is to be supported.
If one of those methods does not support the operation with the supplied
arguments, it should return .



(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the binary arithmetic operations
(, , , , , , , ,
, , , , , , ) with reflected
(swapped) operands.  These functions are only called if the left operand does
not support the corresponding operation [3] and the operands are of different
types. [4] For instance, to evaluate the expression , where y is
an instance of a class that has an  method, 
is called if  returns NotImplemented.
Note that ternary  will not try calling  (the
coercion rules would become too complicated).

Note
If the right operand’s type is a subclass of the left operand’s type and that
subclass provides the reflected method for the operation, this method will be
called before the left operand’s non-reflected method.  This behavior allows
subclasses to override their ancestors’ operations.




(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other[, modulo])¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the augmented arithmetic assignments
(, , , , , , , , ,
, , , ).  These methods should attempt to do the
operation in-place (modifying self) and return the result (which could be,
but does not have to be, self).  If a specific method is not defined, the
augmented assignment falls back to the normal methods.  For instance, if x
is an instance of a class with an  method,  is
equivalent to  . Otherwise,  and
 are considered, as with the evaluation of . In
certain situations, augmented assignment can result in unexpected errors (see
Why does a_tuple[i] += [‘item’] raise an exception when the addition works?), but this behavior is in fact
part of the data model.



(self)¶

(self)¶

(self)¶

(self)¶
Called to implement the unary arithmetic operations (, , 
and ).



(self)¶

(self)¶

(self)¶
Called to implement the built-in functions ,
 and .  Should return a value
of the appropriate type.



(self)¶
Called to implement , and whenever Python needs to
losslessly convert the numeric object to an integer object (such as in
slicing, or in the built-in ,  and 
functions). Presence of this method indicates that the numeric object is
an integer type.  Must return an integer.

Note
In order to have a coherent integer type class, when  is
defined  should also be defined, and both should return
the same value.




(self[, ndigits])¶

(self)¶

(self)¶

(self)¶
Called to implement the built-in function  and 
functions ,  and .
Unless ndigits is passed to  all these methods should
return the value of the object truncated to an 
(typically an ).
If  is not defined then the built-in function 
falls back to .

