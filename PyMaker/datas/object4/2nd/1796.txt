link:
library/decimal.html#decimal-faq

docs:

Decimal FAQ¶
Q. It is cumbersome to type .  Is there a way to
minimize typing when using the interactive interpreter?
A. Some users abbreviate the constructor to just a single letter:


Q. In a fixed-point application with two decimal places, some inputs have many
places and need to be rounded.  Others are not supposed to have excess digits
and need to be validated.  What methods should be used?
A. The  method rounds to a fixed number of decimal places. If
the  trap is set, it is also useful for validation:








Q. Once I have valid two place inputs, how do I maintain that invariant
throughout an application?
A. Some operations like addition, subtraction, and multiplication by an integer
will automatically preserve fixed point.  Others operations, like division and
non-integer multiplication, will change the number of decimal places and need to
be followed-up with a  step:


In developing fixed-point applications, it is convenient to define functions
to handle the  step:




Q. There are many ways to express the same value.  The numbers ,
, , and  all have the same value at
various precisions. Is there a way to transform them to a single recognizable
canonical value?
A. The  method maps all equivalent values to a single
representative:


Q. Some decimal values always print with exponential notation.  Is there a way
to get a non-exponential representation?
A. For some values, exponential notation is the only way to express the number
of significant places in the coefficient.  For example, expressing
 as  keeps the value constant but cannot show the
original’s two-place significance.
If an application does not care about tracking significance, it is easy to
remove the exponent and trailing zeroes, losing significance, but keeping the
value unchanged:




Q. Is there a way to convert a regular float to a ?
A. Yes, any binary floating point number can be exactly expressed as a
Decimal though an exact conversion may take more precision than intuition would
suggest:


Q. Within a complex calculation, how can I make sure that I haven’t gotten a
spurious result because of insufficient precision or rounding anomalies.
A. The decimal module makes it easy to test results.  A best practice is to
re-run calculations using greater precision and with various rounding modes.
Widely differing results indicate insufficient precision, rounding mode issues,
ill-conditioned inputs, or a numerically unstable algorithm.
Q. I noticed that context precision is applied to the results of operations but
not to the inputs.  Is there anything to watch out for when mixing values of
different precisions?
A. Yes.  The principle is that all values are considered to be exact and so is
the arithmetic on those values.  Only the results are rounded.  The advantage
for inputs is that “what you type is what you get”.  A disadvantage is that the
results can look odd if you forget that the inputs haven’t been rounded:


The solution is either to increase precision or to force rounding of inputs
using the unary plus operation:


Alternatively, inputs can be rounded upon creation using the
 method:


Q. Is the CPython implementation fast for large numbers?
A. Yes.  In the CPython and PyPy3 implementations, the C/CFFI versions of
the decimal module integrate the high speed libmpdec library for
arbitrary precision correctly-rounded decimal floating point arithmetic.
 uses Karatsuba multiplication
for medium-sized numbers and the Number Theoretic Transform
for very large numbers.  However, to realize this performance gain, the
context needs to be set for unrounded calculations.



New in version 3.3.

