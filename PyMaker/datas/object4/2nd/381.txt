link:
library/stdtypes.html#numeric-types-int-float-complex

docs:

Numeric Types — , , ¶
There are three distinct numeric types: integers, floating
point numbers, and complex numbers.  In addition, Booleans are a
subtype of integers.  Integers have unlimited precision.  Floating point
numbers are usually implemented using  in C; information
about the precision and internal representation of floating point
numbers for the machine on which your program is running is available
in .  Complex numbers have a real and imaginary
part, which are each a floating point number.  To extract these parts
from a complex number z, use  and . (The standard
library includes additional numeric types,  that hold
rationals, and  that hold floating-point numbers with
user-definable precision.)
Numbers are created by numeric literals or as the result of built-in functions
and operators.  Unadorned integer literals (including hex, octal and binary
numbers) yield integers.  Numeric literals containing a decimal point or an
exponent sign yield floating point numbers.  Appending  or  to a
numeric literal yields an imaginary number (a complex number with a zero real
part) which you can add to an integer or float to get a complex number with real
and imaginary parts.
Python fully supports mixed arithmetic: when a binary arithmetic operator has
operands of different numeric types, the operand with the “narrower” type is
widened to that of the other, where integer is narrower than floating point,
which is narrower than complex.  Comparisons between numbers of mixed type use
the same rule. [2] The constructors , , and
 can be used to produce numbers of a specific type.
All numeric types (except complex) support the following operations, sorted by
ascending priority (all numeric operations have a higher priority than
comparison operations):








Operation
Result
Notes
Full documentation




sum of x and y
 
 


difference of x and y
 
 


product of x and y
 
 


quotient of x and y
 
 


floored quotient of x and
y
(1)
 


remainder of 
(2)
 


x negated
 
 


x unchanged
 
 


absolute value or magnitude of
x
 



x converted to integer
(3)(6)



x converted to floating point
(4)(6)



a complex number with real part
re, imaginary part im.
im defaults to zero.
(6)



conjugate of the complex number
c
 
 


the pair 
(2)



x to the power y
(5)



x to the power y
(5)
 



Notes:

Also referred to as integer division.  The resultant value is a whole
integer, though the result’s type is not necessarily int.  The result is
always rounded towards minus infinity:  is ,  is
,  is , and  is .

Not for complex numbers.  Instead convert to floats using  if
appropriate.

Conversion from floating point to integer may round or truncate
as in C; see functions  and  for
well-defined conversions.

float also accepts the strings “nan” and “inf” with an optional prefix “+”
or “-” for Not a Number (NaN) and positive or negative infinity.

Python defines  and  to be , as is common for
programming languages.

The numeric literals accepted include the digits  to  or any
Unicode equivalent (code points with the  property).
See http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt
for a complete list of code points with the  property.


All  types ( and ) also include
the following operations:






Operation
Result




x truncated to 


x rounded to n digits,
rounding half to even. If n is
omitted, it defaults to 0.


the greatest 
<= x


the least  >= x



For additional numeric operations see the  and 
modules.

Bitwise Operations on Integer Types¶
Bitwise operations only make sense for integers. The result of bitwise
operations is calculated as though carried out in two’s complement with an
infinite number of sign bits.
The priorities of the binary bitwise operations are all lower than the numeric
operations and higher than the comparisons; the unary operation  has the
same priority as the other unary numeric operations ( and ).
This table lists the bitwise operations sorted in ascending priority:







Operation
Result
Notes




bitwise or of x and
y
(4)


bitwise exclusive or of
x and y
(4)


bitwise and of x and
y
(4)


x shifted left by n bits
(1)(2)


x shifted right by n bits
(1)(3)


the bits of x inverted
 



Notes:

Negative shift counts are illegal and cause a  to be raised.
A left shift by n bits is equivalent to multiplication by 
without overflow check.
A right shift by n bits is equivalent to division by  without
overflow check.
Performing these calculations with at least one extra sign extension bit in
a finite two’s complement representation (a working bit-width of
 or more) is sufficient to get the
same result as if there were an infinite number of sign bits.



Additional Methods on Integer Types¶
The int type implements the  abstract base
class. In addition, it provides a few more methods:


()¶
Return the number of bits necessary to represent an integer in binary,
excluding the sign and leading zeros:


More precisely, if  is nonzero, then  is the
unique positive integer  such that .
Equivalently, when  is small enough to have a correctly
rounded logarithm, then .
If  is zero, then  returns .
Equivalent to:



New in version 3.1.




(length, byteorder, *, signed=False)¶
Return an array of bytes representing an integer.


The integer is represented using length bytes.  An 
is raised if the integer is not representable with the given number of
bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is , the most significant byte is at the
beginning of the byte array.  If byteorder is , the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use  as the byte order
value.
The signed argument determines whether two’s complement is used to
represent the integer.  If signed is  and a negative integer is
given, an  is raised. The default value for signed
is .

New in version 3.2.




classmethod (bytes, byteorder, *, signed=False)¶
Return the integer represented by the given array of bytes.


The argument bytes must either be a bytes-like object or an
iterable producing bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is , the most significant byte is at the
beginning of the byte array.  If byteorder is , the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use  as the byte order
value.
The signed argument indicates whether two’s complement is used to
represent the integer.

New in version 3.2.




Additional Methods on Float¶
The float type implements the  abstract base
class. float also has the following additional methods.


()¶
Return a pair of integers whose ratio is exactly equal to the
original float and with a positive denominator.  Raises
 on infinities and a  on
NaNs.



()¶
Return  if the float instance is finite with integral
value, and  otherwise:



Two methods support conversion to
and from hexadecimal strings.  Since Python’s floats are stored
internally as binary numbers, converting a float to or from a
decimal string usually involves a small rounding error.  In
contrast, hexadecimal strings allow exact representation and
specification of floating-point numbers.  This can be useful when
debugging, and in numerical work.


()¶
Return a representation of a floating-point number as a hexadecimal
string.  For finite floating-point numbers, this representation
will always include a leading  and a trailing  and
exponent.



classmethod (s)¶
Class method to return the float represented by a hexadecimal
string s.  The string s may have leading and trailing
whitespace.

Note that  is an instance method, while
 is a class method.
A hexadecimal string takes the form:


where the optional  may by either  or , 
and  are strings of hexadecimal digits, and 
is a decimal integer with an optional leading sign.  Case is not
significant, and there must be at least one hexadecimal digit in
either the integer or the fraction.  This syntax is similar to the
syntax specified in section 6.4.4.2 of the C99 standard, and also to
the syntax used in Java 1.5 onwards.  In particular, the output of
 is usable as a hexadecimal floating-point literal in
C or Java code, and hexadecimal strings produced by C’s  format
character or Java’s  are accepted by
.
Note that the exponent is written in decimal rather than hexadecimal,
and that it gives the power of 2 by which to multiply the coefficient.
For example, the hexadecimal string  represents the
floating-point number , or
:


Applying the reverse conversion to  gives a different
hexadecimal string representing the same number:




Hashing of numeric types¶
For numbers  and , possibly of different types, it’s a requirement
that  whenever  (see the 
method documentation for more details).  For ease of implementation and
efficiency across a variety of numeric types (including ,
,  and )
Python’s hash for numeric types is based on a single mathematical function
that’s defined for any rational number, and hence applies to all instances of
 and , and all finite instances of
 and .  Essentially, this function is
given by reduction modulo  for a fixed prime .  The value of  is
made available to Python as the  attribute of
.

CPython implementation detail: Currently, the prime used is  on machines with 32-bit C
longs and  on machines with 64-bit C longs.

Here are the rules in detail:

If  is a nonnegative rational number and  is not divisible
by , define  as , where  gives the inverse of  modulo .
If  is a nonnegative rational number and  is
divisible by  (but  is not) then  has no inverse
modulo  and the rule above doesn’t apply; in this case define
 to be the constant value .
If  is a negative rational number define 
as .  If the resulting hash is , replace it with
.
The particular values , 
and  are used as hash values for positive
infinity, negative infinity, or nans (respectively).  (All hashable
nans have the same hash value.)
For a  number , the hash values of the real
and imaginary parts are combined by computing , reduced modulo
 so that it lies in
.  Again, if the result is , it’s replaced with .

To clarify the above rules, here’s some example Python code,
equivalent to the built-in hash, for computing the hash of a rational
number, , or :



