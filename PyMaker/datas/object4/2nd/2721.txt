link:
library/configparser.html#customizing-parser-behaviour

docs:

Customizing Parser Behaviour¶
There are nearly as many INI format variants as there are applications using it.
 goes a long way to provide support for the largest sensible
set of INI styles available.  The default functionality is mainly dictated by
historical background and it’s very likely that you will want to customize some
of the features.
The most common way to change the way a specific config parser works is to use
the  options:

defaults, default value: 
This option accepts a dictionary of key-value pairs which will be initially
put in the  section.  This makes for an elegant way to support
concise configuration files that don’t specify values which are the same as
the documented default.
Hint: if you want to specify default values for a specific section, use
 before you read the actual file.

dict_type, default value: 
This option has a major impact on how the mapping protocol will behave and how
the written configuration files look.  With the default ordered
dictionary, every section is stored in the order they were added to the
parser.  Same goes for options within sections.
An alternative dictionary type can be used for example to sort sections and
options on write-back.  You can also use a regular dictionary for performance
reasons.
Please note: there are ways to add a set of key-value pairs in a single
operation.  When you use a regular dictionary in those operations, the order
of the keys will be ordered because dict preserves order from Python 3.7.
For example:



allow_no_value, default value: 
Some configuration files are known to include settings without values, but
which otherwise conform to the syntax supported by .  The
allow_no_value parameter to the constructor can be used to
indicate that such values should be accepted:



delimiters, default value: 
Delimiters are substrings that delimit keys from values within a section.
The first occurrence of a delimiting substring on a line is considered
a delimiter.  This means values (but not keys) can contain the delimiters.
See also the space_around_delimiters argument to
.

comment_prefixes, default value: 

inline_comment_prefixes, default value: 
Comment prefixes are strings that indicate the start of a valid comment within
a config file. comment_prefixes are used only on otherwise empty lines
(optionally indented) whereas inline_comment_prefixes can be used after
every valid value (e.g. section names, options and empty lines as well).  By
default inline comments are disabled and  and  are used as
prefixes for whole line comments.

Changed in version 3.2: In previous versions of  behaviour matched
 and .

Please note that config parsers don’t support escaping of comment prefixes so
using inline_comment_prefixes may prevent users from specifying option
values with characters used as comment prefixes.  When in doubt, avoid
setting inline_comment_prefixes.  In any circumstances, the only way of
storing comment prefix characters at the beginning of a line in multiline
values is to interpolate the prefix, for example:



strict, default value: 
When set to , the parser will not allow for any section or option
duplicates while reading from a single source (using ,
 or ).  It is recommended to use strict
parsers in new applications.

Changed in version 3.2: In previous versions of  behaviour matched
.


empty_lines_in_values, default value: 
In config parsers, values can span multiple lines as long as they are
indented more than the key that holds them.  By default parsers also let
empty lines to be parts of values.  At the same time, keys can be arbitrarily
indented themselves to improve readability.  In consequence, when
configuration files get big and complex, it is easy for the user to lose
track of the file structure.  Take for instance:


This can be especially problematic for the user to see if she’s using a
proportional font to edit the file.  That is why when your application does
not need values with empty lines, you should consider disallowing them.  This
will make empty lines split keys every time.  In the example above, it would
produce two keys,  and .

default_section, default value:  (that is:
)
The convention of allowing a special section of default values for other
sections or interpolation purposes is a powerful concept of this library,
letting users create complex declarative configurations.  This section is
normally called  but this can be customized to point to any
other valid section name.  Some typical values include:  or
.  The name provided is used for recognizing default sections
when reading from any source and is used when writing configuration back to
a file.  Its current value can be retrieved using the
 attribute and may be modified at runtime
(i.e. to convert files from one format to another).

interpolation, default value: 
Interpolation behaviour may be customized by providing a custom handler
through the interpolation argument.  can be used to turn off
interpolation completely,  provides a more
advanced variant inspired by .  More on the subject in the
dedicated documentation section.
 has a default value of .

converters, default value: not set
Config parsers provide option value getters that perform type conversion.  By
default , , and
 are implemented.  Should other getters be
desirable, users may define them in a subclass or pass a dictionary where each
key is a name of the converter and each value is a callable implementing said
conversion.  For instance, passing  would add
 on both the parser object and all section proxies.  In
other words, it will be possible to write both
 and
.
If the converter needs to access the state of the parser, it can be
implemented as a method on a config parser subclass.  If the name of this
method starts with , it will be available on all section proxies, in
the dict-compatible form (see the  example above).


More advanced customization may be achieved by overriding default values of
these parser attributes.  The defaults are defined on the classes, so they may
be overridden by subclasses or by attribute assignment.


¶
By default when using , config parsers
consider the following values : , , ,
 and the following values : , , ,
.  You can override this by specifying a custom dictionary of strings
and their Boolean outcomes. For example:


Other typical Boolean pairs include / or
/.



(option)¶
This method transforms option names on every read, get, or set
operation.  The default converts the name to lowercase.  This also
means that when a configuration file gets written, all keys will be
lowercase.  Override this method if that’s unsuitable.
For example:



Note
The optionxform function transforms option names to a canonical form.
This should be an idempotent function: if the name is already in
canonical form, it should be returned unchanged.




¶
A compiled regular expression used to parse section headers.  The default
matches  to the name .  Whitespace is considered
part of the section name, thus  will be read as a section of
name .  Override this attribute if that’s unsuitable.  For
example:



Note
While ConfigParser objects also use an  attribute for recognizing
option lines, it’s not recommended to override it because that would
interfere with constructor options allow_no_value and delimiters.


