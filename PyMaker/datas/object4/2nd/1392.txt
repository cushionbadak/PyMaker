link:
library/types.html#module-types

docs:

 — Dynamic type creation and names for built-in types¶
Source code: Lib/types.py

This module defines utility functions to assist in dynamic creation of
new types.
It also defines names for some object types that are used by the standard
Python interpreter, but not exposed as builtins like  or
 are.
Finally, it provides some additional type-related utility classes and functions
that are not fundamental enough to be builtins.

Dynamic Type Creation¶


(name, bases=(), kwds=None, exec_body=None)¶
Creates a class object dynamically using the appropriate metaclass.
The first three arguments are the components that make up a class
definition header: the class name, the base classes (in order), the
keyword arguments (such as ).
The exec_body argument is a callback that is used to populate the
freshly created class namespace. It should accept the class namespace
as its sole argument and update the namespace directly with the class
contents. If no callback is provided, it has the same effect as passing
in .

New in version 3.3.




(name, bases=(), kwds=None)¶
Calculates the appropriate metaclass and creates the class namespace.
The arguments are the components that make up a class definition header:
the class name, the base classes (in order) and the keyword arguments
(such as ).
The return value is a 3-tuple: 
metaclass is the appropriate metaclass, namespace is the
prepared class namespace and kwds is an updated copy of the passed
in kwds argument with any  entry removed. If no kwds
argument is passed in, this will be an empty dict.

New in version 3.3.


Changed in version 3.6: The default value for the  element of the returned
tuple has changed.  Now an insertion-order-preserving mapping is
used when the metaclass does not have a  method.



See also

Metaclasses
Full details of the class creation process supported by these functions
PEP 3115 - Metaclasses in Python 3000
Introduced the  namespace hook




(bases)¶
Resolve MRO entries dynamically as specified by PEP 560.
This function looks for items in bases that are not instances of
, and returns a tuple where each such object that has
an  method is replaced with an unpacked result of
calling this method.  If a bases item is an instance of ,
or it doesn’t have an  method, then it is included in
the return tuple unchanged.

New in version 3.7.



See also
PEP 560 - Core support for typing module and generic types



Standard Interpreter Types¶
This module provides names for many of the types that are required to
implement a Python interpreter. It deliberately avoids including some of
the types that arise only incidentally during processing such as the
 type.
Typical use of these names is for  or
 checks.
Standard names are defined for the following types:


¶

¶
The type of user-defined functions and functions created by
  expressions.



¶
The type of generator-iterator objects, created by
generator functions.



¶
The type of coroutine objects, created by
 functions.

New in version 3.5.




¶
The type of asynchronous generator-iterator objects, created by
asynchronous generator functions.

New in version 3.6.




¶
The type for code objects such as returned by .



¶
The type of methods of user-defined class instances.



¶

¶
The type of built-in functions like  or , and
methods of built-in classes.  (Here, the term “built-in” means “written in
C”.)



¶
The type of methods of some built-in data types and base classes such as
 or .

New in version 3.7.




¶
The type of bound methods of some built-in data types and base classes.
For example it is the type of .

New in version 3.7.




¶
The type of methods of some built-in data types such as .

New in version 3.7.




¶
The type of unbound class methods of some built-in data types such as
.

New in version 3.7.




class (name, doc=None)¶
The type of modules. Constructor takes the name of the
module to be created and optionally its docstring.

Note
Use  to create a new module if you
wish to set the various import-controlled attributes.



¶
The docstring of the module. Defaults to .



¶
The loader which loaded the module. Defaults to .

Changed in version 3.4: Defaults to . Previously the attribute was optional.




¶
The name of the module.



¶
Which package a module belongs to. If the module is top-level
(i.e. not a part of any specific package) then the attribute should be set
to , else it should be set to the name of the package (which can be
 if the module is a package itself). Defaults to .

Changed in version 3.4: Defaults to . Previously the attribute was optional.





class (tb_next, tb_frame, tb_lasti, tb_lineno)¶
The type of traceback objects such as found in .
See the language reference for details of the
available attributes and operations, and guidance on creating tracebacks
dynamically.



¶
The type of frame objects such as found in  if  is a
traceback object.
See the language reference for details of the
available attributes and operations.



¶
The type of objects defined in extension modules with , such
as  or .  This type is used as
descriptor for object attributes; it has the same purpose as the
 type, but for classes defined in extension modules.



¶
The type of objects defined in extension modules with , such
as .  This type is used as descriptor for simple C
data members which use standard conversion functions; it has the same purpose
as the  type, but for classes defined in extension modules.

CPython implementation detail: In other implementations of Python, this type may be identical to
.




class (mapping)¶
Read-only proxy of a mapping. It provides a dynamic view on the mapping’s
entries, which means that when the mapping changes, the view reflects these
changes.

New in version 3.3.




Return  if the underlying mapping has a key key, else
.




Return the item of the underlying mapping with key key.  Raises a
 if key is not in the underlying mapping.




Return an iterator over the keys of the underlying mapping.  This is a
shortcut for .




Return the number of items in the underlying mapping.



()¶
Return a shallow copy of the underlying mapping.



(key[, default])¶
Return the value for key if key is in the underlying mapping, else
default.  If default is not given, it defaults to , so that
this method never raises a .



()¶
Return a new view of the underlying mapping’s items (
pairs).



()¶
Return a new view of the underlying mapping’s keys.



()¶
Return a new view of the underlying mapping’s values.




Additional Utility Classes and Functions¶


class ¶
A simple  subclass that provides attribute access to its
namespace, as well as a meaningful repr.
Unlike , with  you can add and remove
attributes.  If a  object is initialized with keyword
arguments, those are directly added to the underlying namespace.
The type is roughly equivalent to the following code:


 may be useful as a replacement for .
However, for a structured record type use 
instead.

New in version 3.3.




(fget=None, fset=None, fdel=None, doc=None)¶
Route attribute access on a class to __getattr__.
This is a descriptor, used to define attributes that act differently when
accessed through an instance and through a class.  Instance access remains
normal, but access to an attribute through a class will be routed to the
class’s __getattr__ method; this is done by raising AttributeError.
This allows one to have properties active on an instance, and have virtual
attributes on the class with the same name (see Enum for an example).

New in version 3.4.




Coroutine Utility Functions¶


(gen_func)¶
This function transforms a generator function into a
coroutine function which returns a generator-based coroutine.
The generator-based coroutine is still a generator iterator,
but is also considered to be a coroutine object and is
awaitable.  However, it may not necessarily implement
the  method.
If gen_func is a generator function, it will be modified in-place.
If gen_func is not a generator function, it will be wrapped. If it
returns an instance of , the instance
will be wrapped in an awaitable proxy object.  All other types
of objects will be returned as is.

New in version 3.5.



