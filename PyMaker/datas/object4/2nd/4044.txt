link:
library/ctypes.html#ctypes-tutorial

docs:

ctypes tutorial¶
Note: The code samples in this tutorial use  to make sure that
they actually work.  Since some code samples behave differently under Linux,
Windows, or Mac OS X, they contain doctest directives in comments.
Note: Some code samples reference the ctypes  type.  On platforms
where  it is an alias to .
So, you should not be confused if  is printed if you would expect
 — they are actually the same type.

Loading dynamic link libraries¶
 exports the cdll, and on Windows windll and oledll
objects, for loading dynamic link libraries.
You load libraries by accessing them as attributes of these objects. cdll
loads libraries which export functions using the standard  calling
convention, while windll libraries call functions using the 
calling convention. oledll also uses the  calling convention, and
assumes the functions return a Windows  error code. The error
code is used to automatically raise an  exception when the
function call fails.

Changed in version 3.3: Windows errors used to raise , which is now an alias
of .

Here are some examples for Windows. Note that  is the MS standard C
library containing most standard C functions, and uses the cdecl calling
convention:


Windows appends the usual  file suffix automatically.

Note
Accessing the standard C library through  will use an
outdated version of the library that may be incompatible with the one
being used by Python. Where possible, use native Python functionality,
or else import and use the  module.

On Linux, it is required to specify the filename including the extension to
load a library, so attribute access can not be used to load libraries. Either the
 method of the dll loaders should be used, or you should load
the library by creating an instance of CDLL by calling the constructor:




Accessing functions from loaded dlls¶
Functions are accessed as attributes of dll objects:


Note that win32 system dlls like  and  often export ANSI
as well as UNICODE versions of a function. The UNICODE version is exported with
an  appended to the name, while the ANSI version is exported with an 
appended to the name. The win32  function, which returns a
module handle for a given module name, has the following C prototype, and a
macro is used to expose one of them as  depending on whether
UNICODE is defined or not:


windll does not try to select one of them by magic, you must access the
version you need by specifying  or 
explicitly, and then call it with bytes or string objects respectively.
Sometimes, dlls export functions with names which aren’t valid Python
identifiers, like . In this case you have to use
 to retrieve the function:


On Windows, some dlls export functions not by name but by ordinal. These
functions can be accessed by indexing the dll object with the ordinal number:




Calling functions¶
You can call these functions like any other Python callable. This example uses
the  function, which returns system time in seconds since the Unix
epoch, and the  function, which returns a win32 module
handle.
This example calls both functions with a NULL pointer ( should be used
as the NULL pointer):



Note
 may raise a  after calling the function, if
it detects that an invalid number of arguments were passed.  This behavior
should not be relied upon.  It is deprecated in 3.6.2, and will be removed
in 3.7.

 is raised when you call an  function with the
 calling convention, or vice versa:


To find out the correct calling convention you have to look into the C header
file or the documentation for the function you want to call.
On Windows,  uses win32 structured exception handling to prevent
crashes from general protection faults when functions are called with invalid
argument values:


There are, however, enough ways to crash Python with , so you
should be careful anyway.  The  module can be helpful in
debugging crashes (e.g. from segmentation faults produced by erroneous C library
calls).
, integers, bytes objects and (unicode) strings are the only native
Python objects that can directly be used as parameters in these function calls.
 is passed as a C  pointer, bytes objects and strings are passed
as pointer to the memory block that contains their data ( or
).  Python integers are passed as the platforms default C
 type, their value is masked to fit into the C type.
Before we move on calling functions with other parameter types, we have to learn
more about  data types.


Fundamental data types¶
 defines a number of primitive C compatible data types:







ctypes type
C type
Python type





bool (1)



1-character bytes object



1-character string



int



int



int



int



int



int



int



int


 or 
int


 or

int



int


 or

int



float



float



float


 (NUL terminated)
bytes object or 


 (NUL terminated)
string or 



int or 




The constructor accepts any object with a truth value.

All these types can be created by calling them with an optional initializer of
the correct type and value:


Since these types are mutable, their value can also be changed afterwards:


Assigning a new value to instances of the pointer types ,
, and  changes the memory location they
point to, not the contents of the memory block (of course not, because Python
bytes objects are immutable):


You should be careful, however, not to pass them to functions expecting pointers
to mutable memory. If you need mutable memory blocks, ctypes has a
 function which creates these in various ways.  The
current memory block contents can be accessed (or changed) with the 
property; if you want to access it as NUL terminated string, use the 
property:


The  function replaces the  function
(which is still available as an alias), as well as the  function
from earlier ctypes releases.  To create a mutable memory block containing
unicode characters of the C type  use the
 function.


Calling functions, continued¶
Note that printf prints to the real standard output channel, not to
, so these examples will only work at the console prompt, not
from within IDLE or PythonWin:


As has been mentioned before, all Python types except integers, strings, and
bytes objects have to be wrapped in their corresponding  type, so
that they can be converted to the required C data type:




Calling functions with your own custom data types¶
You can also customize  argument conversion to allow instances of
your own classes be used as function arguments.   looks for an
 attribute and uses this as the function argument.  Of
course, it must be one of integer, string, or bytes:


If you don’t want to store the instance’s data in the 
instance variable, you could define a  which makes the
attribute available on request.


Specifying the required argument types (function prototypes)¶
It is possible to specify the required argument types of functions exported from
DLLs by setting the  attribute.
 must be a sequence of C data types (the  function is
probably not a good example here, because it takes a variable number and
different types of parameters depending on the format string, on the other hand
this is quite handy to experiment with this feature):


Specifying a format protects against incompatible argument types (just as a
prototype for a C function), and tries to convert the arguments to valid types:


If you have defined your own classes which you pass to function calls, you have
to implement a  class method for them to be able to use them
in the  sequence. The  class method receives
the Python object passed to the function call, it should do a typecheck or
whatever is needed to make sure this object is acceptable, and then return the
object itself, its  attribute, or whatever you want to
pass as the C function argument in this case. Again, the result should be an
integer, string, bytes, a  instance, or an object with an
 attribute.


Return types¶
By default functions are assumed to return the C  type.  Other
return types can be specified by setting the  attribute of the
function object.
Here is a more advanced example, it uses the  function, which expects
a string pointer and a char, and returns a pointer to a string:


If you want to avoid the  calls above, you can set the
 attribute, and the second argument will be converted from a
single character Python bytes object into a C char:


You can also use a callable Python object (a function or a class for example) as
the  attribute, if the foreign function returns an integer.  The
callable will be called with the integer the C function returns, and the
result of this call will be used as the result of your function call. This is
useful to check for error return values and automatically raise an exception:


 is a function which will call Windows  api to
get the string representation of an error code, and returns an exception.
 takes an optional error code parameter, if no one is used, it calls
 to retrieve it.
Please note that a much more powerful error checking mechanism is available
through the  attribute; see the reference manual for details.


Passing pointers (or: passing parameters by reference)¶
Sometimes a C api function expects a pointer to a data type as parameter,
probably to write into the corresponding location, or if the data is too large
to be passed by value. This is also known as passing parameters by reference.
 exports the  function which is used to pass parameters
by reference.  The same effect can be achieved with the  function,
although  does a lot more work since it constructs a real pointer
object, so it is faster to use  if you don’t need the pointer
object in Python itself:




Structures and unions¶
Structures and unions must derive from the  and 
base classes which are defined in the  module. Each subclass must
define a  attribute.   must be a list of
2-tuples, containing a field name and a field type.
The field type must be a  type like , or any other
derived  type: structure, union, array, pointer.
Here is a simple example of a POINT structure, which contains two integers named
x and y, and also shows how to initialize a structure in the constructor:


You can, however, build much more complicated structures.  A structure can
itself contain other structures by using a structure as a field type.
Here is a RECT structure which contains two POINTs named upperleft and
lowerright:


Nested structures can also be initialized in the constructor in several ways:


Field descriptors can be retrieved from the class, they are useful
for debugging because they can provide useful information:



Warning
 does not support passing unions or structures with bit-fields
to functions by value.  While this may work on 32-bit x86, it’s not
guaranteed by the library to work in the general case.  Unions and
structures with bit-fields should always be passed to functions by pointer.



Structure/union alignment and byte order¶
By default, Structure and Union fields are aligned in the same way the C
compiler does it. It is possible to override this behavior be specifying a
 class attribute in the subclass definition. This must be set to a
positive integer and specifies the maximum alignment for the fields. This is
what  also does in MSVC.
 uses the native byte order for Structures and Unions.  To build
structures with non-native byte order, you can use one of the
, ,
, and  base classes.  These
classes cannot contain pointer fields.


Bit fields in structures and unions¶
It is possible to create structures and unions containing bit fields. Bit fields
are only possible for integer fields, the bit width is specified as the third
item in the  tuples:




Arrays¶
Arrays are sequences, containing a fixed number of instances of the same type.
The recommended way to create array types is by multiplying a data type with a
positive integer:


Here is an example of a somewhat artificial data type, a structure containing 4
POINTs among other stuff:


Instances are created in the usual way, by calling the class:


The above code print a series of  lines, because the array contents is
initialized to zeros.
Initializers of the correct type can also be specified:




Pointers¶
Pointer instances are created by calling the  function on a
 type:


Pointer instances have a  attribute which
returns the object to which the pointer points, the  object above:


Note that  does not have OOR (original object return), it constructs a
new, equivalent object each time you retrieve an attribute:


Assigning another  instance to the pointer’s contents attribute
would cause the pointer to point to the memory location where this is stored:


Pointer instances can also be indexed with integers:


Assigning to an integer index changes the pointed to value:


It is also possible to use indexes different from 0, but you must know what
you’re doing, just as in C: You can access or change arbitrary memory locations.
Generally you only use this feature if you receive a pointer from a C function,
and you know that the pointer actually points to an array instead of a single
item.
Behind the scenes, the  function does more than simply create
pointer instances, it has to create pointer types first. This is done with the
 function, which accepts any  type, and returns a
new type:


Calling the pointer type without an argument creates a  pointer.
 pointers have a  boolean value:


 checks for  when dereferencing pointers (but dereferencing
invalid non- pointers would crash Python):




Type conversions¶
Usually, ctypes does strict type checking.  This means, if you have
 in the  list of a function or as the type of
a member field in a structure definition, only instances of exactly the same
type are accepted.  There are some exceptions to this rule, where ctypes accepts
other objects.  For example, you can pass compatible array instances instead of
pointer types.  So, for , ctypes accepts an array of c_int:


In addition, if a function argument is explicitly declared to be a pointer type
(such as ) in , an object of the pointed
type ( in this case) can be passed to the function.  ctypes will apply
the required  conversion in this case automatically.
To set a POINTER type field to , you can assign :


Sometimes you have instances of incompatible types.  In C, you can cast one type
into another type.   provides a  function which can be
used in the same way.  The  structure defined above accepts
 pointers or  arrays for its  field,
but not instances of other types:


For these cases, the  function is handy.
The  function can be used to cast a ctypes instance into a pointer
to a different ctypes data type.   takes two parameters, a ctypes
object that is or can be converted to a pointer of some kind, and a ctypes
pointer type.  It returns an instance of the second argument, which references
the same memory block as the first argument:


So,  can be used to assign to the  field of  the
structure:




Incomplete Types¶
Incomplete Types are structures, unions or arrays whose members are not yet
specified. In C, they are specified by forward declarations, which are defined
later:


The straightforward translation into ctypes code would be this, but it does not
work:


because the new  is not available in the class statement itself.
In , we can define the  class and set the 
attribute later, after the class statement:


Lets try it. We create two instances of , and let them point to each
other, and finally follow the pointer chain a few times:




Callback functions¶
 allows creating C callable function pointers from Python callables.
These are sometimes called callback functions.
First, you must create a class for the callback function. The class knows the
calling convention, the return type, and the number and types of arguments this
function will receive.
The  factory function creates types for callback functions
using the  calling convention. On Windows, the 
factory function creates types for callback functions using the 
calling convention.
Both of these factory functions are called with the result type as first
argument, and the callback functions expected argument types as the remaining
arguments.
I will present an example here which uses the standard C library’s
 function, that is used to sort items with the help of a callback
function.   will be used to sort an array of integers:


 must be called with a pointer to the data to sort, the number of
items in the data array, the size of one item, and a pointer to the comparison
function, the callback. The callback will then be called with two pointers to
items, and it must return a negative integer if the first item is smaller than
the second, a zero if they are equal, and a positive integer otherwise.
So our callback function receives pointers to integers, and must return an
integer. First we create the  for the callback function:


To get started, here is a simple callback that shows the values it gets
passed:


The result:


Now we can actually compare the two items and return a useful result:


As we can easily check, our array is sorted now:


The function factories can be used as decorator factories, so we may as well
write:



Note
Make sure you keep references to  objects as long as they
are used from C code.  doesn’t, and if you don’t, they may be
garbage collected, crashing your program when a callback is made.
Also, note that if the callback function is called in a thread created
outside of Python’s control (e.g. by the foreign code that calls the
callback), ctypes creates a new dummy Python thread on every invocation. This
behavior is correct for most purposes, but it means that values stored with
 will not survive across different callbacks, even when
those calls are made from the same C thread.



Accessing values exported from dlls¶
Some shared libraries not only export functions, they also export variables. An
example in the Python library itself is the , an integer
set to 0, 1, or 2, depending on the  or  flag given on
startup.
 can access values like this with the  class methods of
the type.  pythonapi is a predefined symbol giving access to the Python C
api:


If the interpreter would have been started with , the sample would
have printed , or  if  would have been
specified.
An extended example which also demonstrates the use of pointers accesses the
 pointer exported by Python.
Quoting the docs for that value:

This pointer is initialized to point to an array of 
records, terminated by one whose members are all NULL or zero.  When a frozen
module is imported, it is searched in this table.  Third-party code could play
tricks with this to provide a dynamically created collection of frozen modules.
So manipulating this pointer could even prove useful. To restrict the example
size, we show only how this table can be read with :


We have defined the  data type, so we can get the pointer
to the table:


Since  is a  to the array of  records, we
can iterate over it, but we just have to make sure that our loop terminates,
because pointers have no size. Sooner or later it would probably crash with an
access violation or whatever, so it’s better to break out of the loop when we
hit the NULL entry:


The fact that standard Python has a frozen module and a frozen package
(indicated by the negative size member) is not well known, it is only used for
testing. Try it out with  for example.


Surprises¶
There are some edges in  where you might expect something other
than what actually happens.
Consider the following example:


Hm. We certainly expected the last statement to print . What
happened? Here are the steps of the  line above:


Note that  and  are objects still using the internal buffer of
the  object above. So executing  copies the buffer
contents of  into  ‘s buffer.  This, in turn, changes the
contents of . So, the last assignment , doesn’t have
the expected effect.
Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays
doesn’t copy the sub-object, instead it retrieves a wrapper object accessing
the root-object’s underlying buffer.
Another example that may behave different from what one would expect is this:


Why is it printing ?  ctypes instances are objects containing a memory
block plus some descriptors accessing the contents of the memory.
Storing a Python object in the memory block does not store the object itself,
instead the  of the object is stored.  Accessing the contents again
constructs a new Python object each time!


Variable-sized data types¶
 provides some support for variable-sized arrays and structures.
The  function can be used to resize the memory buffer of an
existing ctypes object.  The function takes the object as first argument, and
the requested size in bytes as the second argument.  The memory block cannot be
made smaller than the natural memory block specified by the objects type, a
 is raised if this is tried:


This is nice and fine, but how would one access the additional elements
contained in this array?  Since the type still only knows about 4 elements, we
get errors accessing other elements:


Another way to use variable-sized data types with  is to use the
dynamic nature of Python, and (re-)define the data type after the required size
is already known, on a case by case basis.

