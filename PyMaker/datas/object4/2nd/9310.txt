link:
library/dataclasses.html#module-level-decorators-classes-and-functions

docs:

Module-level decorators, classes, and functions¶


(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)¶
This function is a decorator that is used to add generated
special methods to classes, as described below.
The  decorator examines the class to find
s.  A  is defined as class variable that has a
type annotation.  With two
exceptions described below, nothing in 
examines the type specified in the variable annotation.
The order of the fields in all of the generated methods is the
order in which they appear in the class definition.
The  decorator will add various “dunder” methods to
the class, described below.  If any of the added methods already
exist on the class, the behavior depends on the parameter, as documented
below. The decorator returns the same class that is called on; no new
class is created.
If  is used just as a simple decorator with no parameters,
it acts as if it has the default values documented in this
signature.  That is, these three uses of  are
equivalent:


The parameters to  are:

: If true (the default), a  method will be
generated.
If the class already defines , this parameter is
ignored.

: If true (the default), a  method will be
generated.  The generated repr string will have the class name and
the name and repr of each field, in the order they are defined in
the class.  Fields that are marked as being excluded from the repr
are not included.  For example:
.
If the class already defines , this parameter is
ignored.

: If true (the default), an  method will be
generated.  This method compares the class as if it were a tuple
of its fields, in order.  Both instances in the comparison must
be of the identical type.
If the class already defines , this parameter is
ignored.

: If true (the default is ), ,
, , and  methods will be
generated.  These compare the class as if it were a tuple of its
fields, in order.  Both instances in the comparison must be of the
identical type.  If  is true and  is false, a
 is raised.
If the class already defines any of ,
, , or , then
 is raised.

: If  (the default), a  method
is generated according to how  and  are set.
 is used by built-in , and when objects are
added to hashed collections such as dictionaries and sets.  Having a
 implies that instances of the class are immutable.
Mutability is a complicated property that depends on the programmer’s
intent, the existence and behavior of , and the values of
the  and  flags in the  decorator.
By default,  will not implicitly add a 
method unless it is safe to do so.  Neither will it add or change an
existing explicitly defined  method.  Setting the class
attribute  has a specific meaning to Python, as
described in the  documentation.
If  is not explicit defined, or if it is set to ,
then  may add an implicit  method.
Although not recommended, you can force  to create a
 method with . This might be the case
if your class is logically immutable but can nonetheless be mutated.
This is a specialized use case and should be considered carefully.
Here are the rules governing implicit creation of a 
method.  Note that you cannot both have an explicit 
method in your dataclass and set ; this will result
in a .
If  and  are both true, by default  will
generate a  method for you.  If  is true and
 is false,  will be set to , marking it
unhashable (which it is, since it is mutable).  If  is false,
 will be left untouched meaning the 
method of the superclass will be used (if the superclass is
, this means it will fall back to id-based hashing).

: If true (the default is False), assigning to fields will
generate an exception.  This emulates read-only frozen instances.  If
 or  is defined in the class, then
 is raised.  See the discussion below.


s may optionally specify a default value, using normal
Python syntax:


In this example, both  and  will be included in the added
 method, which will be defined as:


 will be raised if a field without a default value
follows a field with a default value.  This is true either when this
occurs in a single class, or as a result of class inheritance.



(*, default=MISSING, default_factory=MISSING, repr=True, hash=None, init=True, compare=True, metadata=None)¶
For common and simple use cases, no other functionality is
required.  There are, however, some dataclass features that
require additional per-field information.  To satisfy this need for
additional information, you can replace the default field value
with a call to the provided  function.  For example:


As shown above, the  value is a sentinel object used to
detect if the  and  parameters are
provided.  This sentinel is used because  is a valid value
for .  No code should directly use the 
value.
The parameters to  are:

: If provided, this will be the default value for this
field.  This is needed because the  call itself
replaces the normal position of the default value.

: If provided, it must be a zero-argument
callable that will be called when a default value is needed for
this field.  Among other purposes, this can be used to specify
fields with mutable default values, as discussed below.  It is an
error to specify both  and .

: If true (the default), this field is included as a
parameter to the generated  method.

: If true (the default), this field is included in the
string returned by the generated  method.

: If true (the default), this field is included in the
generated equality and comparison methods (,
, et al.).

: This can be a bool or .  If true, this field is
included in the generated  method.  If  (the
default), use the value of : this would normally be
the expected behavior.  A field should be considered in the hash
if it’s used for comparisons.  Setting this value to anything
other than  is discouraged.
One possible reason to set  but 
would be if a field is expensive to compute a hash value for,
that field is needed for equality testing, and there are other
fields that contribute to the type’s hash value.  Even if a field
is excluded from the hash, it will still be used for comparisons.

: This can be a mapping or None. None is treated as
an empty dict.  This value is wrapped in
 to make it read-only, and exposed
on the  object. It is not used at all by Data
Classes, and is provided as a third-party extension mechanism.
Multiple third-parties can each have their own key, to use as a
namespace in the metadata.


If the default value of a field is specified by a call to
, then the class attribute for this field will be
replaced by the specified  value.  If no  is
provided, then the class attribute will be deleted.  The intent is
that after the  decorator runs, the class
attributes will all contain the default values for the fields, just
as if the default value itself were specified.  For example,
after:


The class attribute  will be , the class attribute
 will be , and the class attributes  and
 will not be set.



class ¶
 objects describe each defined field. These objects
are created internally, and are returned by the 
module-level method (see below).  Users should never instantiate a
 object directly.  Its documented attributes are:


: The name of the field.
: The type of the field.
, , , , ,
, and  have the identical meaning and
values as they do in the  declaration.


Other attributes may exist, but they are private and must not be
inspected or relied on.



(class_or_instance)¶
Returns a tuple of  objects that define the fields for this
dataclass.  Accepts either a dataclass, or an instance of a dataclass.
Raises  if not passed a dataclass or instance of one.
Does not return pseudo-fields which are  or .



(instance, *, dict_factory=dict)¶
Converts the dataclass  to a dict (by using the
factory function ).  Each dataclass is converted
to a dict of its fields, as  pairs.  dataclasses, dicts,
lists, and tuples are recursed into.  For example:


Raises  if  is not a dataclass instance.



(instance, *, tuple_factory=tuple)¶
Converts the dataclass  to a tuple (by using the
factory function ).  Each dataclass is converted
to a tuple of its field values.  dataclasses, dicts, lists, and
tuples are recursed into.
Continuing from the previous example:


Raises  if  is not a dataclass instance.



(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)¶
Creates a new dataclass with name , fields as defined
in , base classes as given in , and initialized
with a namespace as given in .   is an
iterable whose elements are each either , ,
or .  If just  is supplied,
 is used for .  The values of ,
, , , , and  have
the same meaning as they do in .
This function is not strictly required, because any Python
mechanism for creating a new class with  can
then apply the  function to convert that class to
a dataclass.  This function is provided as a convenience.  For
example:


Is equivalent to:





(instance, **changes)¶
Creates a new object of the same type of , replacing
fields with values from .  If  is not a Data
Class, raises .  If values in  do not
specify fields, raises .
The newly returned object is created by calling the 
method of the dataclass.  This ensures that
, if present, is also called.
Init-only variables without default values, if any exist, must be
specified on the call to  so that they can be passed to
 and .
It is an error for  to contain any fields that are
defined as having .  A  will be raised
in this case.
Be forewarned about how  fields work during a call to
.  They are not copied from the source object, but
rather are initialized in , if they’re
initialized at all.  It is expected that  fields will
be rarely and judiciously used.  If they are used, it might be wise
to have alternate class constructors, or perhaps a custom
 (or similarly named) method which handles instance
copying.



(class_or_instance)¶
Returns True if its parameter is a dataclass or an instance of one,
otherwise returns False.
If you need to know if a class is an instance of a dataclass (and
not a dataclass itself), then add a further check for :



