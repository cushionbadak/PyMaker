link:
reference/expressions.html#calls

docs:

6.3.4. Calls¶
A call calls a callable object (e.g., a function) with a possibly empty
series of arguments:

An optional trailing comma may be present after the positional and keyword arguments
but does not affect the semantics.
The primary must evaluate to a callable object (user-defined functions, built-in
functions, methods of built-in objects, class objects, methods of class
instances, and all objects having a  method are callable).  All
argument expressions are evaluated before the call is attempted.  Please refer
to section Function definitions for the syntax of formal parameter lists.
If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for the
formal parameters.  If there are N positional arguments, they are placed in the
first N slots.  Next, for each keyword argument, the identifier is used to
determine the corresponding slot (if the identifier is the same as the first
formal parameter name, the first slot is used, and so on).  If the slot is
already filled, a  exception is raised. Otherwise, the value of
the argument is placed in the slot, filling it (even if the expression is
, it fills the slot).  When all arguments have been processed, the slots
that are still unfilled are filled with the corresponding default value from the
function definition.  (Default values are calculated, once, when the function is
defined; thus, a mutable object such as a list or dictionary used as default
value will be shared by all calls that don’t specify an argument value for the
corresponding slot; this should usually be avoided.)  If there are any unfilled
slots for which no default value is specified, a  exception is
raised.  Otherwise, the list of filled slots is used as the argument list for
the call.

CPython implementation detail: An implementation may provide built-in functions whose positional parameters
do not have names, even if they are ‘named’ for the purpose of documentation,
and which therefore cannot be supplied by keyword.  In CPython, this is the
case for functions implemented in C that use  to
parse their arguments.

If there are more positional arguments than there are formal parameter slots, a
 exception is raised, unless a formal parameter using the syntax
 is present; in this case, that formal parameter receives a tuple
containing the excess positional arguments (or an empty tuple if there were no
excess positional arguments).
If any keyword argument does not correspond to a formal parameter name, a
 exception is raised, unless a formal parameter using the syntax
 is present; in this case, that formal parameter receives a
dictionary containing the excess keyword arguments (using the keywords as keys
and the argument values as corresponding values), or a (new) empty dictionary if
there were no excess keyword arguments.
If the syntax  appears in the function call,  must
evaluate to an iterable.  Elements from these iterables are
treated as if they were additional positional arguments.  For the call
, if y evaluates to a sequence y1, …, yM,
this is equivalent to a call with M+4 positional arguments x1, x2,
y1, …, yM, x3, x4.
A consequence of this is that although the  syntax may appear
after explicit keyword arguments, it is processed before the
keyword arguments (and any  arguments – see below).  So:


It is unusual for both keyword arguments and the  syntax to be
used in the same call, so in practice this confusion does not arise.
If the syntax  appears in the function call,  must
evaluate to a mapping, the contents of which are treated as
additional keyword arguments.  If a keyword is already present
(as an explicit keyword argument, or from another unpacking),
a  exception is raised.
Formal parameters using the syntax  or  cannot be
used as positional argument slots or as keyword argument names.

Changed in version 3.5: Function calls accept any number of  and  unpackings,
positional arguments may follow iterable unpackings (),
and keyword arguments may follow dictionary unpackings ().
Originally proposed by PEP 448.

A call always returns some value, possibly , unless it raises an
exception.  How this value is computed depends on the type of the callable
object.
If it is—

a user-defined function:
The code block for the function is executed, passing it the argument list.  The
first thing the code block will do is bind the formal parameters to the
arguments; this is described in section Function definitions.  When the code block
executes a  statement, this specifies the return value of the
function call.

a built-in function or method:
The result is up to the interpreter; see Built-in Functions for the
descriptions of built-in functions and methods.

a class object:
A new instance of that class is returned.

a class instance method:
The corresponding user-defined function is called, with an argument list that is
one longer than the argument list of the call: the instance becomes the first
argument.

a class instance:
The class must define a  method; the effect is then the same as
if that method was called.


