link:
library/socket.html#example

docs:

Example¶
Here are four minimal example programs using the TCP/IP protocol: a server that
echoes all data that it receives back (servicing only one client), and a client
using it.  Note that a server must perform the sequence ,
, ,  (possibly
repeating the  to service more than one client), while a
client only needs the sequence , .  Also
note that the server does not / on
the socket it is listening on but on the new socket returned by
.
The first two examples support IPv4 only.




The next two examples are identical to the above two, but support both IPv4 and
IPv6. The server side will listen to the first address family available (it
should listen to both instead). On most of IPv6-ready systems, IPv6 will take
precedence and the server may not accept IPv4 traffic. The client side will try
to connect to the all addresses returned as a result of the name resolution, and
sends traffic to the first one connected successfully.




The next example shows how to write a very simple network sniffer with raw
sockets on Windows. The example requires administrator privileges to modify
the interface:


The next example shows how to use the socket interface to communicate to a CAN
network using the raw socket protocol. To use CAN with the broadcast
manager protocol instead, open a socket with:


After binding () or connecting () the socket, you
can use the , and the  operations (and
their counterparts) on the socket object as usual.
This last example might require special privileges:


Running an example several times with too small delay between executions, could
lead to this error:


This is because the previous execution has left the socket in a 
state, and can’t be immediately reused.
There is a  flag to set, in order to prevent this,
:


the  flag tells the kernel to reuse a local socket in
 state, without waiting for its natural timeout to expire.

See also
For an introduction to socket programming (in C), see the following papers:

An Introductory 4.3BSD Interprocess Communication Tutorial, by Stuart Sechrest
An Advanced 4.3BSD Interprocess Communication Tutorial, by Samuel J.  Leffler et
al,

both in the UNIX Programmer’s Manual, Supplementary Documents 1 (sections
PS1:7 and PS1:8).  The platform-specific reference material for the various
socket-related system calls are also a valuable source of information on the
details of socket semantics.  For Unix, refer to the manual pages; for Windows,
see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, readers may
want to refer to RFC 3493 titled Basic Socket Interface Extensions for IPv6.

