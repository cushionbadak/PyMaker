link:
library/enum.html#derived-enumerations

docs:

Derived Enumerations¶

IntEnum¶
The first variation of  that is provided is also a subclass of
.  Members of an  can be compared to integers;
by extension, integer enumerations of different types can also be compared
to each other:


However, they still can’t be compared to standard  enumerations:


 values behave like integers in other ways you’d expect:




IntFlag¶
The next variation of  provided, , is also based
on .  The difference being  members can be combined
using the bitwise operators (&, |, ^, ~) and the result is still an
 member.  However, as the name implies, 
members also subclass  and can be used wherever an  is
used.  Any operation on an  member besides the bit-wise
operations will lose the  membership.

New in version 3.6.

Sample  class:


It is also possible to name the combinations:


Another important difference between  and  is that
if no flags are set (the value is 0), its boolean evaluation is :


Because  members are also subclasses of  they can
be combined with them:




Flag¶
The last variation is .  Like , 
members can be combined using the bitwise operators (&, |, ^, ~).  Unlike
, they cannot be combined with, nor compared against, any
other  enumeration, nor .  While it is possible to
specify the values directly it is recommended to use  as the
value and let  select an appropriate value.

New in version 3.6.

Like , if a combination of  members results in no
flags being set, the boolean evaluation is :


Individual flags should have values that are powers of two (1, 2, 4, 8, …),
while combinations of flags won’t:


Giving a name to the “no flags set” condition does not change its boolean
value:



Note
For the majority of new code,  and  are strongly
recommended, since  and  break some
semantic promises of an enumeration (by being comparable to integers, and
thus by transitivity to other unrelated enumerations).  
and  should be used only in cases where  and
 will not do; for example, when integer constants are replaced
with enumerations, or for interoperability with other systems.



Others¶
While  is part of the  module, it would be very
simple to implement independently:


This demonstrates how similar derived enumerations can be defined; for example
a  that mixes in  instead of .
Some rules:

When subclassing , mix-in types must appear before
 itself in the sequence of bases, as in the 
example above.
While  can have members of any type, once you mix in an
additional type, all the members must have values of that type, e.g.
 above.  This restriction does not apply to mix-ins which only
add methods and don’t specify another data type such as  or
.
When another data type is mixed in, the  attribute is not the
same as the enum member itself, although it is equivalent and will compare
equal.
%-style formatting:  %s and %r call the  class’s
 and  respectively; other codes (such as
%i or %h for IntEnum) treat the enum member as its mixed-in type.
Formatted string literals, ,
and  will use the mixed-in
type’s .  If the  class’s  or
 is desired, use the !s or !r format codes.


