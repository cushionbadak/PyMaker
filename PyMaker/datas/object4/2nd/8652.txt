link:
library/unittest.mock-examples.html#coping-with-mutable-arguments

docs:

Coping with mutable arguments¶
Another situation is rare, but can bite you, is when your mock is called with
mutable arguments.  and  store references to the
arguments. If the arguments are mutated by the code under test then you can no
longer make assertions about what the values were when the mock was called.
Here’s some example code that shows the problem. Imagine the following functions
defined in ‘mymodule’:


When we try to test that  calls  with the correct argument look
what happens:


One possibility would be for mock to copy the arguments you pass in. This
could then cause problems if you do assertions that rely on object identity
for equality.
Here’s one solution that uses the 
functionality. If you provide a  function for a mock then
 will be called with the same args as the mock. This gives us an
opportunity to copy the arguments and store them for later assertions. In this
example I’m using another mock to store the arguments so that I can use the
mock methods for doing the assertion. Again a helper function sets this up for
me.


 is called with the mock that will be called. It returns a new
mock that we do the assertion on. The  function makes a copy of
the args and calls our  with the copy.

Note
If your mock is only going to be used once there is an easier way of
checking arguments at the point they are called. You can simply do the
checking inside a  function.



An alternative approach is to create a subclass of  or
 that copies (using ) the arguments.
Here’s an example implementation:


When you subclass  or  all dynamically created attributes,
and the  will use your subclass automatically. That means all
children of a  will also have the type .
