link:
library/collections.html#counter-objects

docs:

 objects¶
A counter tool is provided to support convenient and rapid tallies.
For example:




class ([iterable-or-mapping])¶
A  is a  subclass for counting hashable objects.
It is a collection where elements are stored as dictionary keys
and their counts are stored as dictionary values.  Counts are allowed to be
any integer value including zero or negative counts.  The 
class is similar to bags or multisets in other languages.
Elements are counted from an iterable or initialized from another
mapping (or counter):


Counter objects have a dictionary interface except that they return a zero
count for missing items instead of raising a :


Setting a count to zero does not remove an element from a counter.
Use  to remove it entirely:



New in version 3.1.

Counter objects support three methods beyond those available for all
dictionaries:


()¶
Return an iterator over elements repeating each as many times as its
count.  Elements are returned in arbitrary order.  If an element’s count
is less than one,  will ignore it.





([n])¶
Return a list of the n most common elements and their counts from the
most common to the least.  If n is omitted or ,
 returns all elements in the counter.
Elements with equal counts are ordered arbitrarily:





([iterable-or-mapping])¶
Elements are subtracted from an iterable or from another mapping
(or counter).  Like  but subtracts counts instead
of replacing them.  Both inputs and outputs may be zero or negative.



New in version 3.2.


The usual dictionary methods are available for  objects
except for two which work differently for counters.


(iterable)¶
This class method is not implemented for  objects.



([iterable-or-mapping])¶
Elements are counted from an iterable or added-in from another
mapping (or counter).  Like  but adds counts
instead of replacing them.  Also, the iterable is expected to be a
sequence of elements, not a sequence of  pairs.


Common patterns for working with  objects:


Several mathematical operations are provided for combining 
objects to produce multisets (counters that have counts greater than zero).
Addition and subtraction combine counters by adding or subtracting the counts
of corresponding elements.  Intersection and union return the minimum and
maximum of corresponding counts.  Each operation can accept inputs with signed
counts, but the output will exclude results with counts of zero or less.


Unary addition and subtraction are shortcuts for adding an empty counter
or subtracting from an empty counter.



New in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations.


Note
Counters were primarily designed to work with positive integers to represent
running counts; however, care was taken to not unnecessarily preclude use
cases needing other types or negative values.  To help with those use cases,
this section documents the minimum range and type restrictions.

The  class itself is a dictionary subclass with no
restrictions on its keys and values.  The values are intended to be numbers
representing counts, but you could store anything in the value field.
The  method requires only that the values be orderable.
For in-place operations such as , the value type need only
support addition and subtraction.  So fractions, floats, and decimals would
work and negative values are supported.  The same is also true for
 and  which allow negative and zero values
for both inputs and outputs.
The multiset methods are designed only for use cases with positive values.
The inputs may be negative or zero, but only outputs with positive values
are created.  There are no type restrictions, but the value type needs to
support addition, subtraction, and comparison.
The  method requires integer counts.  It ignores zero and
negative counts.



See also

Bag class
in Smalltalk.

Wikipedia entry for Multisets.

C++ multisets
tutorial with examples.

For mathematical operations on multisets and their use cases, see
Knuth, Donald. The Art of Computer Programming Volume II,
Section 4.6.3, Exercise 19.

To enumerate all distinct multisets of a given size over a given set of
elements, see :





