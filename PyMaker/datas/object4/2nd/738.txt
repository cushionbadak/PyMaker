link:
library/string.html#format-string-syntax

docs:

Format String Syntax¶
The  method and the  class share the same
syntax for format strings (although in the case of ,
subclasses can define their own format string syntax).  The syntax is
related to that of formatted string literals, but
there are differences.
Format strings contain “replacement fields” surrounded by curly braces .
Anything that is not contained in braces is considered literal text, which is
copied unchanged to the output.  If you need to include a brace character in the
literal text, it can be escaped by doubling:  and .
The grammar for a replacement field is as follows:



In less formal terms, the replacement field can start with a field_name that specifies
the object whose value is to be formatted and inserted
into the output instead of the replacement field.
The field_name is optionally followed by a  conversion field, which is
preceded by an exclamation point , and a format_spec, which is preceded
by a colon .  These specify a non-default format for the replacement value.
See also the Format Specification Mini-Language section.
The field_name itself begins with an arg_name that is either a number or a
keyword.  If it’s a number, it refers to a positional argument, and if it’s a keyword,
it refers to a named keyword argument.  If the numerical arg_names in a format string
are 0, 1, 2, … in sequence, they can all be omitted (not just some)
and the numbers 0, 1, 2, … will be automatically inserted in that order.
Because arg_name is not quote-delimited, it is not possible to specify arbitrary
dictionary keys (e.g., the strings  or ) within a format string.
The arg_name can be followed by any number of index or
attribute expressions. An expression of the form  selects the named
attribute using , while an expression of the form 
does an index lookup using .

Changed in version 3.1: The positional argument specifiers can be omitted for ,
so  is equivalent to .


Changed in version 3.4: The positional argument specifiers can be omitted for .

Some simple format string examples:


The conversion field causes a type coercion before formatting.  Normally, the
job of formatting a value is done by the  method of the value
itself.  However, in some cases it is desirable to force a type to be formatted
as a string, overriding its own definition of formatting.  By converting the
value to a string before calling , the normal formatting logic
is bypassed.
Three conversion flags are currently supported:  which calls 
on the value,  which calls  and  which calls
.
Some examples:


The format_spec field contains a specification of how the value should be
presented, including such details as field width, alignment, padding, decimal
precision and so on.  Each value type can define its own “formatting
mini-language” or interpretation of the format_spec.
Most built-in types support a common formatting mini-language, which is
described in the next section.
A format_spec field can also include nested replacement fields within it.
These nested replacement fields may contain a field name, conversion flag
and format specification, but deeper nesting is
not allowed.  The replacement fields within the
format_spec are substituted before the format_spec string is interpreted.
This allows the formatting of a value to be dynamically specified.
See the Format examples section for some examples.

Format Specification Mini-Language¶
“Format specifications” are used within replacement fields contained within a
format string to define how individual values are presented (see
Format String Syntax and Formatted string literals).
They can also be passed directly to the built-in
 function.  Each formattable type may define how the format
specification is to be interpreted.
Most built-in types implement the following options for format specifications,
although some of the formatting options are only supported by the numeric types.
A general convention is that an empty format string () produces
the same result as if you had called  on the value. A
non-empty format string typically modifies the result.
The general form of a standard format specifier is:

If a valid align value is specified, it can be preceded by a fill
character that can be any character and defaults to a space if omitted.
It is not possible to use a literal curly brace (“” or “”) as
the fill character in a formatted string literal or when using the 
method.  However, it is possible to insert a curly brace
with a nested replacement field.  This limitation doesn’t
affect the  function.
The meaning of the various alignment options is as follows:







Option
Meaning




Forces the field to be left-aligned within the available
space (this is the default for most objects).


Forces the field to be right-aligned within the
available space (this is the default for numbers).


Forces the padding to be placed after the sign (if any)
but before the digits.  This is used for printing fields
in the form ‘+000000120’. This alignment option is only
valid for numeric types.  It becomes the default when ‘0’
immediately precedes the field width.


Forces the field to be centered within the available
space.




Note that unless a minimum field width is defined, the field width will always
be the same size as the data to fill it, so that the alignment option has no
meaning in this case.
The sign option is only valid for number types, and can be one of the
following:







Option
Meaning




indicates that a sign should be used for both
positive as well as negative numbers.


indicates that a sign should be used only for negative
numbers (this is the default behavior).

space
indicates that a leading space should be used on
positive numbers, and a minus sign on negative numbers.




The  option causes the “alternate form” to be used for the
conversion.  The alternate form is defined differently for different
types.  This option is only valid for integer, float, complex and
Decimal types. For integers, when binary, octal, or hexadecimal output
is used, this option adds the prefix respective , , or
 to the output value. For floats, complex and Decimal the
alternate form causes the result of the conversion to always contain a
decimal-point character, even if no digits follow it. Normally, a
decimal-point character appears in the result of these conversions
only if a digit follows it. In addition, for  and 
conversions, trailing zeros are not removed from the result.
The  option signals the use of a comma for a thousands separator.
For a locale aware separator, use the  integer presentation type
instead.

Changed in version 3.1: Added the  option (see also PEP 378).

The  option signals the use of an underscore for a thousands
separator for floating point presentation types and for integer
presentation type .  For integer presentation types ,
, , and , underscores will be inserted every 4
digits.  For other presentation types, specifying this option is an
error.

Changed in version 3.6: Added the  option (see also PEP 515).

width is a decimal integer defining the minimum field width.  If not
specified, then the field width will be determined by the content.
When no explicit alignment is given, preceding the width field by a zero
() character enables
sign-aware zero-padding for numeric types.  This is equivalent to a fill
character of  with an alignment type of .
The precision is a decimal number indicating how many digits should be
displayed after the decimal point for a floating point value formatted with
 and , or before and after the decimal point for a floating point
value formatted with  or .  For non-number types the field
indicates the maximum field size - in other words, how many characters will be
used from the field content. The precision is not allowed for integer values.
Finally, the type determines how the data should be presented.
The available string presentation types are:







Type
Meaning




String format. This is the default type for strings and
may be omitted.

None
The same as .




The available integer presentation types are:







Type
Meaning




Binary format. Outputs the number in base 2.


Character. Converts the integer to the corresponding
unicode character before printing.


Decimal Integer. Outputs the number in base 10.


Octal format. Outputs the number in base 8.


Hex format. Outputs the number in base 16, using
lower-case letters for the digits above 9.


Hex format. Outputs the number in base 16, using
upper-case letters for the digits above 9.


Number. This is the same as , except that it uses
the current locale setting to insert the appropriate
number separator characters.

None
The same as .




In addition to the above presentation types, integers can be formatted
with the floating point presentation types listed below (except
 and ). When doing so,  is used to convert the
integer to a floating point number before formatting.
The available presentation types for floating point and decimal values are:







Type
Meaning




Exponent notation. Prints the number in scientific
notation using the letter ‘e’ to indicate the exponent.
The default precision is .


Exponent notation. Same as  except it uses an
upper case ‘E’ as the separator character.


Fixed-point notation. Displays the number as a
fixed-point number.  The default precision is .


Fixed-point notation. Same as , but converts
 to   and  to .


General format.  For a given precision ,
this rounds the number to  significant digits and
then formats the result in either fixed-point format
or in scientific notation, depending on its magnitude.
The precise rules are as follows: suppose that the
result formatted with presentation type  and
precision  would have exponent .  Then
if , the number is formatted
with presentation type  and precision
.  Otherwise, the number is formatted
with presentation type  and precision .
In both cases insignificant trailing zeros are removed
from the significand, and the decimal point is also
removed if there are no remaining digits following it.
Positive and negative infinity, positive and negative
zero, and nans, are formatted as , ,
,  and  respectively, regardless of
the precision.
A precision of  is treated as equivalent to a
precision of .  The default precision is .



General format. Same as  except switches to
 if the number gets too large. The
representations of infinity and NaN are uppercased, too.


Number. This is the same as , except that it uses
the current locale setting to insert the appropriate
number separator characters.


Percentage. Multiplies the number by 100 and displays
in fixed () format, followed by a percent sign.

None
Similar to , except that fixed-point notation,
when used, has at least one digit past the decimal point.
The default precision is as high as needed to represent
the particular value. The overall effect is to match the
output of  as altered by the other format
modifiers.






Format examples¶
This section contains examples of the  syntax and
comparison with the old -formatting.
In most of the cases the syntax is similar to the old -formatting, with the
addition of the  and with  used instead of .
For example,  can be translated to .
The new format syntax also supports new and different options, shown in the
following examples.
Accessing arguments by position:


Accessing arguments by name:


Accessing arguments’ attributes:


Accessing arguments’ items:


Replacing  and :


Aligning the text and specifying a width:


Replacing , , and  and specifying a sign:


Replacing  and  and converting the value to different bases:


Using the comma as a thousands separator:


Expressing a percentage:


Using type-specific formatting:


Nesting arguments and more complex examples:



