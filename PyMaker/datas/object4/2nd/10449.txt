link:
library/fcntl.html#module-fcntl

docs:

 — The  and  system calls¶

This module performs file control and I/O control on file descriptors. It is an
interface to the  and  Unix routines.  For a
complete description of these calls, see fcntl(2) and
ioctl(2) Unix manual pages.
All functions in this module take a file descriptor fd as their first
argument.  This can be an integer file descriptor, such as returned by
, or an  object, such as 
itself, which provides a  that returns a genuine file
descriptor.

Changed in version 3.3: Operations in this module used to raise an  where they now
raise an .

The module defines the following functions:


(fd, cmd, arg=0)¶
Perform the operation cmd on file descriptor fd (file objects providing
a  method are accepted as well).  The values used
for cmd are operating system dependent, and are available as constants
in the  module, using the same names as used in the relevant C
header files. The argument arg can either be an integer value, or a
 object. With an integer value, the return value of this
function is the integer return value of the C  call.  When
the argument is bytes it represents a binary structure, e.g. created by
. The binary data is copied to a buffer whose address is
passed to the C  call.  The return value after a successful
call is the contents of the buffer, converted to a  object.
The length of the returned object will be the same as the length of the
arg argument. This is limited to 1024 bytes. If the information returned
in the buffer by the operating system is larger than 1024 bytes, this is
most likely to result in a segmentation violation or a more subtle data
corruption.
If the  fails, an  is raised.



(fd, request, arg=0, mutate_flag=True)¶
This function is identical to the  function, except
that the argument handling is even more complicated.
The request parameter is limited to values that can fit in 32-bits.
Additional constants of interest for use as the request argument can be
found in the  module, under the same names as used in
the relevant C header files.
The parameter arg can be one of an integer, an object supporting the
read-only buffer interface (like ) or an object supporting
the read-write buffer interface (like ).
In all but the last case, behaviour is as for the 
function.
If a mutable buffer is passed, then the behaviour is determined by the value of
the mutate_flag parameter.
If it is false, the buffer’s mutability is ignored and behaviour is as for a
read-only buffer, except that the 1024 byte limit mentioned above is avoided –
so long as the buffer you pass is at least as long as what the operating system
wants to put there, things should work.
If mutate_flag is true (the default), then the buffer is (in effect) passed
to the underlying  system call, the latter’s return code is
passed back to the calling Python, and the buffer’s new contents reflect the
action of the .  This is a slight simplification, because if the
supplied buffer is less than 1024 bytes long it is first copied into a static
buffer 1024 bytes long which is then passed to  and copied back
into the supplied buffer.
If the  fails, an  exception is raised.
An example:





(fd, operation)¶
Perform the lock operation operation on file descriptor fd (file objects providing
a  method are accepted as well). See the Unix manual
flock(2) for details.  (On some systems, this function is emulated
using .)
If the  fails, an  exception is raised.



(fd, cmd, len=0, start=0, whence=0)¶
This is essentially a wrapper around the  locking calls.
fd is the file descriptor of the file to lock or unlock, and cmd
is one of the following values:

 – unlock
 – acquire a shared lock
 – acquire an exclusive lock

When cmd is  or , it can also be
bitwise ORed with  to avoid blocking on lock acquisition.
If  is used and the lock cannot be acquired, an
 will be raised and the exception will have an errno
attribute set to  or  (depending on the
operating system; for portability, check for both values).  On at least some
systems,  can only be used if the file descriptor refers to a
file opened for writing.
len is the number of bytes to lock, start is the byte offset at
which the lock starts, relative to whence, and whence is as with
, specifically:

 – relative to the start of the file ()
 – relative to the current buffer position ()
 – relative to the end of the file ()

The default for start is 0, which means to start at the beginning of the file.
The default for len is 0 which means to lock to the end of the file.  The
default for whence is also 0.

Examples (all on a SVR4 compliant system):


Note that in the first example the return value variable rv will hold an
integer value; in the second example it will hold a  object.  The
structure lay-out for the lockdata variable is system dependent — therefore
using the  call may be better.

See also

Module 
If the locking flags  and  are
present in the  module (on BSD only), the 
function provides an alternative to the  and 
functions.


