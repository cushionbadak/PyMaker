link:
library/gettext.html#internationalizing-your-programs-and-modules

docs:

Internationalizing your programs and modules¶
Internationalization (I18N) refers to the operation by which a program is made
aware of multiple languages.  Localization (L10N) refers to the adaptation of
your program, once internationalized, to the local language and cultural habits.
In order to provide multilingual messages for your Python programs, you need to
take the following steps:

prepare your program or module by specially marking translatable strings
run a suite of tools over your marked files to generate raw messages catalogs
create language-specific translations of the message catalogs
use the  module so that message strings are properly translated

In order to prepare your code for I18N, you need to look at all the strings in
your files.  Any string that needs to be translated should be marked by wrapping
it in  — that is, a call to the function .  For example:


In this example, the string  is marked as a candidate
for translation, while the strings  and  are not.
There are a few tools to extract the strings meant for translation.
The original GNU gettext only supported C or C++ source
code but its extended version xgettext scans code written
in a number of languages, including Python, to find strings marked as
translatable.  Babel is a Python
internationalization library that includes a  script to
extract and compile message catalogs.  François Pinard’s program
called xpot does a similar job and is available as part of
his po-utils package.
(Python also includes pure-Python versions of these programs, called
pygettext.py and msgfmt.py; some Python distributions
will install them for you.  pygettext.py is similar to
xgettext, but only understands Python source code and
cannot handle other programming languages such as C or C++.
pygettext.py supports a command-line interface similar to
xgettext; for details on its use, run .  msgfmt.py is binary compatible with GNU
msgfmt.  With these two programs, you may not need the GNU
gettext package to internationalize your Python
applications.)
xgettext, pygettext, and similar tools generate
 files that are message catalogs.  They are structured
human-readable files that contain every marked string in the source
code, along with a placeholder for the translated versions of these
strings.
Copies of these  files are then handed over to the
individual human translators who write translations for every
supported natural language.  They send back the completed
language-specific versions as a  file that’s
compiled into a machine-readable  binary catalog file using
the msgfmt program.  The  files are used by the
 module for the actual translation processing at
run-time.
How you use the  module in your code depends on whether you are
internationalizing a single module or your entire application. The next two
sections will discuss each case.

Localizing your module¶
If you are localizing your module, you must take care not to make global
changes, e.g. to the built-in namespace. You should not use the GNU gettext
API but instead the class-based API.
Let’s say your module is called “spam” and the module’s various natural language
translation  files reside in  in GNU
gettext format.  Here’s what you would put at the top of your
module:




Localizing your application¶
If you are localizing your application, you can install the  function
globally into the built-in namespace, usually in the main driver file of your
application.  This will let all your application-specific files just use
 without having to explicitly install it in each file.
In the simple case then, you need only add the following bit of code to the main
driver file of your application:


If you need to set the locale directory, you can pass it into the
 function:




Changing languages on the fly¶
If your program needs to support many languages at the same time, you may want
to create multiple translation instances and then switch between them
explicitly, like so:




Deferred translations¶
In most coding situations, strings are translated where they are coded.
Occasionally however, you need to mark strings for translation, but defer actual
translation until later.  A classic example is:


Here, you want to mark the strings in the  list as being
translatable, but you don’t actually want to translate them until they are
printed.
Here is one way you can handle this situation:


This works because the dummy definition of  simply returns the string
unchanged.  And this dummy definition will temporarily override any definition
of  in the built-in namespace (until the  command). Take
care, though if you have a previous definition of  in the local
namespace.
Note that the second use of  will not identify “a” as being
translatable to the gettext program, because the parameter
is not a string literal.
Another way to handle this is with the following example:


In this case, you are marking translatable strings with the function
, which won’t conflict with any definition of .
However, you will need to teach your message extraction program to
look for translatable strings marked with . xgettext,
pygettext, , and xpot all
support this through the use of the  command-line switch.
The choice of  here is totally arbitrary; it could have just
as easily been .

