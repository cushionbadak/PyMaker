link:
library/collections.html#deque-objects

docs:

 objects¶


class ([iterable[, maxlen]])¶
Returns a new deque object initialized left-to-right (using ) with
data from iterable.  If iterable is not specified, the new deque is empty.
Deques are a generalization of stacks and queues (the name is pronounced “deck”
and is short for “double-ended queue”).  Deques support thread-safe, memory
efficient appends and pops from either side of the deque with approximately the
same O(1) performance in either direction.
Though  objects support similar operations, they are optimized for
fast fixed-length operations and incur O(n) memory movement costs for
 and  operations which change both the size and
position of the underlying data representation.
If maxlen is not specified or is , deques may grow to an
arbitrary length.  Otherwise, the deque is bounded to the specified maximum
length.  Once a bounded length deque is full, when new items are added, a
corresponding number of items are discarded from the opposite end.  Bounded
length deques provide functionality similar to the  filter in
Unix. They are also useful for tracking transactions and other pools of data
where only the most recent activity is of interest.
Deque objects support the following methods:


(x)¶
Add x to the right side of the deque.



(x)¶
Add x to the left side of the deque.



()¶
Remove all elements from the deque leaving it with length 0.



()¶
Create a shallow copy of the deque.

New in version 3.5.




(x)¶
Count the number of deque elements equal to x.

New in version 3.2.




(iterable)¶
Extend the right side of the deque by appending elements from the iterable
argument.



(iterable)¶
Extend the left side of the deque by appending elements from iterable.
Note, the series of left appends results in reversing the order of
elements in the iterable argument.



(x[, start[, stop]])¶
Return the position of x in the deque (at or after index start
and before index stop).  Returns the first match or raises
 if not found.

New in version 3.5.




(i, x)¶
Insert x into the deque at position i.
If the insertion would cause a bounded deque to grow beyond maxlen,
an  is raised.

New in version 3.5.




()¶
Remove and return an element from the right side of the deque. If no
elements are present, raises an .



()¶
Remove and return an element from the left side of the deque. If no
elements are present, raises an .



(value)¶
Remove the first occurrence of value.  If not found, raises a
.



()¶
Reverse the elements of the deque in-place and then return .

New in version 3.2.




(n=1)¶
Rotate the deque n steps to the right.  If n is negative, rotate
to the left.
When the deque is not empty, rotating one step to the right is equivalent
to , and rotating one step to the left is
equivalent to .

Deque objects also provide one read-only attribute:


¶
Maximum size of a deque or  if unbounded.

New in version 3.1.



In addition to the above, deques support iteration, pickling, ,
, , , membership testing with
the  operator, and subscript references such as .  Indexed
access is O(1) at both ends but slows to O(n) in the middle.  For fast random
access, use lists instead.
Starting in version 3.5, deques support , ,
and .
Example:



 Recipes¶
This section shows various approaches to working with deques.
Bounded length deques provide functionality similar to the  filter
in Unix:


Another approach to using deques is to maintain a sequence of recently
added elements by appending to the right and popping to the left:


A round-robin scheduler can be implemented with
input iterators stored in a .  Values are yielded from the active
iterator in position zero.  If that iterator is exhausted, it can be removed
with ; otherwise, it can be cycled back to the end with
the  method:


The  method provides a way to implement  slicing and
deletion.  For example, a pure Python implementation of  relies on
the  method to position elements to be popped:


To implement  slicing, use a similar approach applying
 to bring a target element to the left side of the deque. Remove
old entries with , add new entries with , and then
reverse the rotation.
With minor variations on that approach, it is easy to implement Forth style
stack manipulations such as , , , , ,
, and .

