link:
reference/import.html#import-related-module-attributes

docs:

5.4.4. Import-related module attributes¶
The import machinery fills in these attributes on each module object
during loading, based on the module’s spec, before the loader executes
the module.


¶
The  attribute must be set to the fully-qualified name of
the module.  This name is used to uniquely identify the module in
the import system.



¶
The  attribute must be set to the loader object that
the import machinery used when loading the module.  This is mostly
for introspection, but can be used for additional loader-specific
functionality, for example getting data associated with a loader.



¶
The module’s  attribute must be set.  Its value must
be a string, but it can be the same value as its .  When
the module is a package, its  value should be set to
its .  When the module is not a package, 
should be set to the empty string for top-level modules, or for
submodules, to the parent package’s name.  See PEP 366 for further
details.
This attribute is used instead of  to calculate explicit
relative imports for main modules, as defined in PEP 366. It is
expected to have the same value as .

Changed in version 3.6: The value of  is expected to be the same as
.




¶
The  attribute must be set to the module spec that was
used when importing the module. Setting 
appropriately applies equally to modules initialized during
interpreter startup.  The one exception is ,
where  is set to None in some cases.
When  is not defined,  is used as
a fallback.

New in version 3.4.


Changed in version 3.6:  is used as a fallback when  is
not defined.




¶
If the module is a package (either regular or namespace), the module
object’s  attribute must be set.  The value must be
iterable, but may be empty if  has no further significance.
If  is not empty, it must produce strings when iterated
over. More details on the semantics of  are given
below.
Non-package modules should not have a  attribute.



¶



¶
 is optional. If set, this attribute’s value must be a
string.  The import system may opt to leave  unset if it
has no semantic meaning (e.g. a module loaded from a database).
If  is set, it may also be appropriate to set the
 attribute which is the path to any compiled version of
the code (e.g. byte-compiled file). The file does not need to exist
to set this attribute; the path can simply point to where the
compiled file would exist (see PEP 3147).
It is also appropriate to set  when  is not
set.  However, that scenario is quite atypical.  Ultimately, the
loader is what makes use of  and/or .  So
if a loader can load from a cached module but otherwise does not load
from a file, that atypical scenario may be appropriate.

