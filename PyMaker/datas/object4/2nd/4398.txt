link:
library/multiprocessing.html#programming-guidelines

docs:

Programming guidelines¶
There are certain guidelines and idioms which should be adhered to when using
.

All start methods¶
The following applies to all start methods.
Avoid shared state

As far as possible one should try to avoid shifting large amounts of data
between processes.
It is probably best to stick to using queues or pipes for communication
between processes rather than using the lower level synchronization
primitives.

Picklability

Ensure that the arguments to the methods of proxies are picklable.
Thread safety of proxies

Do not use a proxy object from more than one thread unless you protect it
with a lock.
(There is never a problem with different processes using the same proxy.)

Joining zombie processes

On Unix when a process finishes but has not been joined it becomes a zombie.
There should never be very many because each time a new process starts (or
 is called) all completed processes
which have not yet been joined will be joined.  Also calling a finished
process’s  will
join the process.  Even so it is probably good
practice to explicitly join all the processes that you start.
Better to inherit than pickle/unpickle

When using the spawn or forkserver start methods many types
from  need to be picklable so that child
processes can use them.  However, one should generally avoid
sending shared objects to other processes using pipes or queues.
Instead you should arrange the program so that a process which
needs access to a shared resource created elsewhere can inherit it
from an ancestor process.
Avoid terminating processes

Using the 
method to stop a process is liable to
cause any shared resources (such as locks, semaphores, pipes and queues)
currently being used by the process to become broken or unavailable to other
processes.
Therefore it is probably best to only consider using
 on processes
which never use any shared resources.

Joining processes that use queues

Bear in mind that a process that has put items in a queue will wait before
terminating until all the buffered items are fed by the “feeder” thread to
the underlying pipe.  (The child process can call the

method of the queue to avoid this behaviour.)
This means that whenever you use a queue you need to make sure that all
items which have been put on the queue will eventually be removed before the
process is joined.  Otherwise you cannot be sure that processes which have
put items on the queue will terminate.  Remember also that non-daemonic
processes will be joined automatically.
An example which will deadlock is the following:


A fix here would be to swap the last two lines (or simply remove the
 line).

Explicitly pass resources to child processes

On Unix using the fork start method, a child process can make
use of a shared resource created in a parent process using a
global resource.  However, it is better to pass the object as an
argument to the constructor for the child process.
Apart from making the code (potentially) compatible with Windows
and the other start methods this also ensures that as long as the
child process is still alive the object will not be garbage
collected in the parent process.  This might be important if some
resource is freed when the object is garbage collected in the
parent process.
So for instance


should be rewritten as



Beware of replacing  with a “file like object”

 originally unconditionally called:


in the  method — this resulted
in issues with processes-in-processes. This has been changed to:


Which solves the fundamental issue of processes colliding with each other
resulting in a bad file descriptor error, but introduces a potential danger
to applications which replace  with a “file-like object”
with output buffering.  This danger is that if multiple processes call
 on this file-like object, it could result in the same
data being flushed to the object multiple times, resulting in corruption.
If you write a file-like object and implement your own caching, you can
make it fork-safe by storing the pid whenever you append to the cache,
and discarding the cache when the pid changes. For example:


For more information, see bpo-5155, bpo-5313 and bpo-5331



The spawn and forkserver start methods¶
There are a few extra restriction which don’t apply to the fork
start method.
More picklability

Ensure that all arguments to  are picklable.
Also, if you subclass  then make sure that
instances will be picklable when the  method is called.
Global variables

Bear in mind that if code run in a child process tries to access a global
variable, then the value it sees (if any) may not be the same as the value
in the parent process at the time that  was called.
However, global variables which are just module level constants cause no
problems.

Safe importing of main module

Make sure that the main module can be safely imported by a new Python
interpreter without causing unintended side effects (such a starting a new
process).
For example, using the spawn or forkserver start method
running the following module would fail with a
:


Instead one should protect the “entry point” of the program by using  as follows:


(The  line can be omitted if the program will be run
normally instead of frozen.)
This allows the newly spawned Python interpreter to safely import the module
and then run the module’s  function.
Similar restrictions apply if a pool or manager is created in the main
module.


