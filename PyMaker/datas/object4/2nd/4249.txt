link:
library/multiprocessing.html#reference

docs:

Reference¶
The  package mostly replicates the API of the
 module.

 and exceptions¶


class (group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)¶
Process objects represent activity that is run in a separate process. The
 class has equivalents of all the methods of
.
The constructor should always be called with keyword arguments. group
should always be ; it exists solely for compatibility with
.  target is the callable object to be invoked by
the  method.  It defaults to , meaning nothing is
called. name is the process name (see  for more details).
args is the argument tuple for the target invocation.  kwargs is a
dictionary of keyword arguments for the target invocation.  If provided,
the keyword-only daemon argument sets the process  flag
to  or .  If  (the default), this flag will be
inherited from the creating process.
By default, no arguments are passed to target.
If a subclass overrides the constructor, it must make sure it invokes the
base class constructor () before doing anything else
to the process.

Changed in version 3.3: Added the daemon argument.



()¶
Method representing the process’s activity.
You may override this method in a subclass.  The standard 
method invokes the callable object passed to the object’s constructor as
the target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.



()¶
Start the process’s activity.
This must be called at most once per process object.  It arranges for the
object’s  method to be invoked in a separate process.



([timeout])¶
If the optional argument timeout is  (the default), the method
blocks until the process whose  method is called terminates.
If timeout is a positive number, it blocks at most timeout seconds.
Note that the method returns  if its process terminates or if the
method times out.  Check the process’s  to determine if
it terminated.
A process can be joined many times.
A process cannot join itself because this would cause a deadlock.  It is
an error to attempt to join a process before it has been started.



¶
The process’s name.  The name is a string used for identification purposes
only.  It has no semantics.  Multiple processes may be given the same
name.
The initial name is set by the constructor.  If no explicit name is
provided to the constructor, a name of the form
‘Process-N1:N2:…:Nk’ is constructed, where
each Nk is the N-th child of its parent.



()¶
Return whether the process is alive.
Roughly, a process object is alive from the moment the 
method returns until the child process terminates.



¶
The process’s daemon flag, a Boolean value.  This must be set before
 is called.
The initial value is inherited from the creating process.
When a process exits, it attempts to terminate all of its daemonic child
processes.
Note that a daemonic process is not allowed to create child processes.
Otherwise a daemonic process would leave its children orphaned if it gets
terminated when its parent process exits. Additionally, these are not
Unix daemons or services, they are normal processes that will be
terminated (and not joined) if non-daemonic processes have exited.

In addition to the   API,  objects
also support the following attributes and methods:


¶
Return the process ID.  Before the process is spawned, this will be
.



¶
The child’s exit code.  This will be  if the process has not yet
terminated.  A negative value -N indicates that the child was terminated
by signal N.



¶
The process’s authentication key (a byte string).
When  is initialized the main process is assigned a
random string using .
When a  object is created, it will inherit the
authentication key of its parent process, although this may be changed by
setting  to another byte string.
See Authentication keys.



¶
A numeric handle of a system object which will become “ready” when
the process ends.
You can use this value if you want to wait on several events at
once using .  Otherwise
calling  is simpler.
On Windows, this is an OS handle usable with the 
and  family of API calls.  On Unix, this is
a file descriptor usable with primitives from the  module.

New in version 3.3.




()¶
Terminate the process.  On Unix this is done using the  signal;
on Windows  is used.  Note that exit handlers and
finally clauses, etc., will not be executed.
Note that descendant processes of the process will not be terminated –
they will simply become orphaned.

Warning
If this method is used when the associated process is using a pipe or
queue then the pipe or queue is liable to become corrupted and may
become unusable by other process.  Similarly, if the process has
acquired a lock or semaphore etc. then terminating it is liable to
cause other processes to deadlock.




()¶
Same as  but using the  signal on Unix.

New in version 3.7.




()¶
Close the  object, releasing all resources associated
with it.   is raised if the underlying process
is still running.  Once  returns successfully, most
other methods and attributes of the  object will
raise .

New in version 3.7.


Note that the , , ,
 and  methods should only be called by
the process that created the process object.
Example usage of some of the methods of :





exception ¶
The base class of all  exceptions.



exception ¶
Exception raised by  when the supplied
buffer object is too small for the message read.
If  is an instance of  then  will give
the message as a byte string.



exception ¶
Raised when there is an authentication error.



exception ¶
Raised by methods with a timeout when the timeout expires.



Pipes and Queues¶
When using multiple processes, one generally uses message passing for
communication between processes and avoids having to use any synchronization
primitives like locks.
For passing messages one can use  (for a connection between two
processes) or a queue (which allows multiple producers and consumers).
The ,  and  types
are multi-producer, multi-consumer FIFO
queues modelled on the  class in the
standard library.  They differ in that  lacks the
 and  methods introduced
into Python 2.5’s  class.
If you use  then you must call
 for each task removed from the queue or else the
semaphore used to count the number of unfinished tasks may eventually overflow,
raising an exception.
Note that one can also create a shared queue by using a manager object – see
Managers.

Note
 uses the usual  and
 exceptions to signal a timeout.  They are not available in
the  namespace so you need to import them from
.


Note
When an object is put on a queue, the object is pickled and a
background thread later flushes the pickled data to an underlying
pipe.  This has some consequences which are a little surprising,
but should not cause any practical difficulties – if they really
bother you then you can instead use a queue created with a
manager.

After putting an object on an empty queue there may be an
infinitesimal delay before the queue’s 
method returns  and  can
return without raising .
If multiple processes are enqueuing objects, it is possible for
the objects to be received at the other end out-of-order.
However, objects enqueued by the same process will always be in
the expected order with respect to each other.



Warning
If a process is killed using  or 
while it is trying to use a , then the data in the queue is
likely to become corrupted.  This may cause any other process to get an
exception when it tries to use the queue later on.


Warning
As mentioned above, if a child process has put items on a queue (and it has
not used ), then that process will
not terminate until all buffered items have been flushed to the pipe.
This means that if you try joining that process you may get a deadlock unless
you are sure that all items which have been put on the queue have been
consumed.  Similarly, if the child process is non-daemonic then the parent
process may hang on exit when it tries to join all its non-daemonic children.
Note that a queue created using a manager does not have this issue.  See
Programming guidelines.

For an example of the usage of queues for interprocess communication see
Examples.


([duplex])¶
Returns a pair  of
 objects representing the
ends of a pipe.
If duplex is  (the default) then the pipe is bidirectional.  If
duplex is  then the pipe is unidirectional:  can only be
used for receiving messages and  can only be used for sending
messages.



class ([maxsize])¶
Returns a process shared queue implemented using a pipe and a few
locks/semaphores.  When a process first puts an item on the queue a feeder
thread is started which transfers objects from a buffer into the pipe.
The usual  and  exceptions from the
standard library’s  module are raised to signal timeouts.
 implements all the methods of  except for
 and .


()¶
Return the approximate size of the queue.  Because of
multithreading/multiprocessing semantics, this number is not reliable.
Note that this may raise  on Unix platforms like
Mac OS X where  is not implemented.



()¶
Return  if the queue is empty,  otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



()¶
Return  if the queue is full,  otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



(obj[, block[, timeout]])¶
Put obj into the queue.  If the optional argument block is 
(the default) and timeout is  (the default), block if necessary until
a free slot is available.  If timeout is a positive number, it blocks at
most timeout seconds and raises the  exception if no
free slot was available within that time.  Otherwise (block is
), put an item on the queue if a free slot is immediately
available, else raise the  exception (timeout is
ignored in that case).



(obj)¶
Equivalent to .



([block[, timeout]])¶
Remove and return an item from the queue.  If optional args block is
 (the default) and timeout is  (the default), block if
necessary until an item is available.  If timeout is a positive number,
it blocks at most timeout seconds and raises the 
exception if no item was available within that time.  Otherwise (block is
), return an item if one is immediately available, else raise the
 exception (timeout is ignored in that case).



()¶
Equivalent to .

 has a few additional methods not found in
.  These methods are usually unnecessary for most
code:


()¶
Indicate that no more data will be put on this queue by the current
process.  The background thread will quit once it has flushed all buffered
data to the pipe.  This is called automatically when the queue is garbage
collected.



()¶
Join the background thread.  This can only be used after  has
been called.  It blocks until the background thread exits, ensuring that
all data in the buffer has been flushed to the pipe.
By default if a process is not the creator of the queue then on exit it
will attempt to join the queue’s background thread.  The process can call
 to make  do nothing.



()¶
Prevent  from blocking.  In particular, this prevents
the background thread from being joined automatically when the process
exits – see .
A better name for this method might be
.  It is likely to cause enqueued
data to lost, and you almost certainly will not need to use it.
It is really only there if you need the current process to exit
immediately without waiting to flush enqueued data to the
underlying pipe, and you don’t care about lost data.


Note
This class’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
functionality in this class will be disabled, and attempts to
instantiate a  will result in an . See
bpo-3770 for additional information.  The same holds true for any
of the specialized queue types listed below.




class ¶
It is a simplified  type, very close to a locked .


()¶
Return  if the queue is empty,  otherwise.



()¶
Remove and return an item from the queue.



(item)¶
Put item into the queue.




class ([maxsize])¶
, a  subclass, is a queue which
additionally has  and  methods.


()¶
Indicate that a formerly enqueued task is complete. Used by queue
consumers.  For each  used to fetch a task, a subsequent
call to  tells the queue that the processing on the task
is complete.
If a  is currently blocking, it will resume when all
items have been processed (meaning that a  call was
received for every item that had been  into the queue).
Raises a  if called more times than there were items
placed in the queue.



()¶
Block until all items in the queue have been gotten and processed.
The count of unfinished tasks goes up whenever an item is added to the
queue.  The count goes down whenever a consumer calls
 to indicate that the item was retrieved and all work on
it is complete.  When the count of unfinished tasks drops to zero,
 unblocks.




Miscellaneous¶


()¶
Return list of all live children of the current process.
Calling this has the side effect of “joining” any processes which have
already finished.



()¶
Return the number of CPUs in the system.
This number is not equivalent to the number of CPUs the current process can
use.  The number of usable CPUs can be obtained with

May raise .

See also





()¶
Return the  object corresponding to the current process.
An analogue of .



()¶
Add support for when a program which uses  has been
frozen to produce a Windows executable.  (Has been tested with py2exe,
PyInstaller and cx_Freeze.)
One needs to call this function straight after the  line of the main module.  For example:


If the  line is omitted then trying to run the frozen
executable will raise .
Calling  has no effect when invoked on any operating
system other than Windows.  In addition, if the module is being run
normally by the Python interpreter on Windows (the program has not been
frozen), then  has no effect.



()¶
Returns a list of the supported start methods, the first of which
is the default.  The possible start methods are ,
 and .  On Windows only  is
available.  On Unix  and  are always
supported, with  being the default.

New in version 3.4.




(method=None)¶
Return a context object which has the same attributes as the
 module.
If method is  then the default context is returned.
Otherwise method should be , ,
.   is raised if the specified
start method is not available.

New in version 3.4.




(allow_none=False)¶
Return the name of start method used for starting processes.
If the start method has not been fixed and allow_none is false,
then the start method is fixed to the default and the name is
returned.  If the start method has not been fixed and allow_none
is true then  is returned.
The return value can be , , 
or .   is the default on Unix, while  is
the default on Windows.

New in version 3.4.




()¶
Sets the path of the Python interpreter to use when starting a child process.
(By default  is used).  Embedders will probably need to
do some thing like


before they can create child processes.

Changed in version 3.4: Now supported on Unix when the  start method is used.




(method)¶
Set the method which should be used to start child processes.
method can be ,  or .
Note that this should be called at most once, and it should be
protected inside the  clause of the
main module.

New in version 3.4.



Note
 contains no analogues of
, ,
, ,
, or .



Connection Objects¶
Connection objects allow the sending and receiving of picklable objects or
strings.  They can be thought of as message oriented connected sockets.
Connection objects are usually created using
 – see also
Listeners and Clients.


class ¶


(obj)¶
Send an object to the other end of the connection which should be read
using .
The object must be picklable.  Very large pickles (approximately 32 MiB+,
though it depends on the OS) may raise a  exception.



()¶
Return an object sent from the other end of the connection using
.  Blocks until there is something to receive.  Raises
 if there is nothing left to receive
and the other end was closed.



()¶
Return the file descriptor or handle used by the connection.



()¶
Close the connection.
This is called automatically when the connection is garbage collected.



([timeout])¶
Return whether there is any data available to be read.
If timeout is not specified then it will return immediately.  If
timeout is a number then this specifies the maximum time in seconds to
block.  If timeout is  then an infinite timeout is used.
Note that multiple connection objects may be polled at once by
using .



(buffer[, offset[, size]])¶
Send byte data from a bytes-like object as a complete message.
If offset is given then data is read from that position in buffer.  If
size is given then that many bytes will be read from buffer.  Very large
buffers (approximately 32 MiB+, though it depends on the OS) may raise a
 exception



([maxlength])¶
Return a complete message of byte data sent from the other end of the
connection as a string.  Blocks until there is something to receive.
Raises  if there is nothing left
to receive and the other end has closed.
If maxlength is specified and the message is longer than maxlength
then  is raised and the connection will no longer be
readable.

Changed in version 3.3: This function used to raise , which is now an
alias of .




(buffer[, offset])¶
Read into buffer a complete message of byte data sent from the other end
of the connection and return the number of bytes in the message.  Blocks
until there is something to receive.  Raises
 if there is nothing left to receive and the other end was
closed.
buffer must be a writable bytes-like object.  If
offset is given then the message will be written into the buffer from
that position.  Offset must be a non-negative integer less than the
length of buffer (in bytes).
If the buffer is too short then a  exception is
raised and the complete message is available as  where 
is the exception instance.


Changed in version 3.3: Connection objects themselves can now be transferred between processes
using  and .


New in version 3.3: Connection objects now support the context management protocol – see
Context Manager Types.   returns the
connection object, and  calls .


For example:



Warning
The  method automatically unpickles the data it
receives, which can be a security risk unless you can trust the process
which sent the message.
Therefore, unless the connection object was produced using  you
should only use the  and 
methods after performing some sort of authentication.  See
Authentication keys.


Warning
If a process is killed while it is trying to read or write to a pipe then
the data in the pipe is likely to become corrupted, because it may become
impossible to be sure where the message boundaries lie.



Synchronization primitives¶
Generally synchronization primitives are not as necessary in a multiprocess
program as they are in a multithreaded program.  See the documentation for
 module.
Note that one can also create synchronization primitives by using a manager
object – see Managers.


class (parties[, action[, timeout]])¶
A barrier object: a clone of .

New in version 3.3.




class ([value])¶
A bounded semaphore object: a close analog of
.
A solitary difference from its close analog exists: its  method’s
first argument is named block, as is consistent with .

Note
On Mac OS X, this is indistinguishable from  because
 is not implemented on that platform.




class ([lock])¶
A condition variable: an alias for .
If lock is specified then it should be a  or 
object from .

Changed in version 3.3: The  method was added.




class ¶
A clone of .



class ¶
A non-recursive lock object: a close analog of .
Once a process or thread has acquired a lock, subsequent attempts to
acquire it from any process or thread will block until it is released;
any process or thread may release it.  The concepts and behaviors of
 as it applies to threads are replicated here in
 as it applies to either processes or threads,
except as noted.
Note that  is actually a factory function which returns an
instance of  initialized with a
default context.
 supports the context manager protocol and thus may be
used in  statements.


(block=True, timeout=None)¶
Acquire a lock, blocking or non-blocking.
With the block argument set to  (the default), the method call
will block until the lock is in an unlocked state, then set it to locked
and return .  Note that the name of this first argument differs
from that in .
With the block argument set to , the method call does not
block.  If the lock is currently in a locked state, return ;
otherwise set the lock to a locked state and return .
When invoked with a positive, floating-point value for timeout, block
for at most the number of seconds specified by timeout as long as
the lock can not be acquired.  Invocations with a negative value for
timeout are equivalent to a timeout of zero.  Invocations with a
timeout value of  (the default) set the timeout period to
infinite.  Note that the treatment of negative or  values for
timeout differs from the implemented behavior in
.  The timeout argument has no practical
implications if the block argument is set to  and is thus
ignored.  Returns  if the lock has been acquired or  if
the timeout period has elapsed.



()¶
Release a lock.  This can be called from any process or thread, not only
the process or thread which originally acquired the lock.
Behavior is the same as in  except that
when invoked on an unlocked lock, a  is raised.




class ¶
A recursive lock object: a close analog of .  A
recursive lock must be released by the process or thread that acquired it.
Once a process or thread has acquired a recursive lock, the same process
or thread may acquire it again without blocking; that process or thread
must release it once for each time it has been acquired.
Note that  is actually a factory function which returns an
instance of  initialized with a
default context.
 supports the context manager protocol and thus may be
used in  statements.


(block=True, timeout=None)¶
Acquire a lock, blocking or non-blocking.
When invoked with the block argument set to , block until the
lock is in an unlocked state (not owned by any process or thread) unless
the lock is already owned by the current process or thread.  The current
process or thread then takes ownership of the lock (if it does not
already have ownership) and the recursion level inside the lock increments
by one, resulting in a return value of .  Note that there are
several differences in this first argument’s behavior compared to the
implementation of , starting with the name
of the argument itself.
When invoked with the block argument set to , do not block.
If the lock has already been acquired (and thus is owned) by another
process or thread, the current process or thread does not take ownership
and the recursion level within the lock is not changed, resulting in
a return value of .  If the lock is in an unlocked state, the
current process or thread takes ownership and the recursion level is
incremented, resulting in a return value of .
Use and behaviors of the timeout argument are the same as in
.  Note that some of these behaviors of timeout
differ from the implemented behaviors in .



()¶
Release a lock, decrementing the recursion level.  If after the
decrement the recursion level is zero, reset the lock to unlocked (not
owned by any process or thread) and if any other processes or threads
are blocked waiting for the lock to become unlocked, allow exactly one
of them to proceed.  If after the decrement the recursion level is still
nonzero, the lock remains locked and owned by the calling process or
thread.
Only call this method when the calling process or thread owns the lock.
An  is raised if this method is called by a process
or thread other than the owner or if the lock is in an unlocked (unowned)
state.  Note that the type of exception raised in this situation
differs from the implemented behavior in .




class ([value])¶
A semaphore object: a close analog of .
A solitary difference from its close analog exists: its  method’s
first argument is named block, as is consistent with .


Note
On Mac OS X,  is unsupported, so calling  with
a timeout will emulate that function’s behavior using a sleeping loop.


Note
If the SIGINT signal generated by Ctrl-C arrives while the main thread is
blocked by a call to , ,
, , 
or  then the call will be immediately interrupted and
 will be raised.
This differs from the behaviour of  where SIGINT will be
ignored while the equivalent blocking calls are in progress.


Note
Some of this package’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
 module will be disabled, and attempts to
import it will result in an . See
bpo-3770 for additional information.



Shared  Objects¶
It is possible to create shared objects using shared memory which can be
inherited by child processes.


(typecode_or_type, *args, lock=True)¶
Return a  object allocated from shared memory.  By default the
return value is actually a synchronized wrapper for the object.  The object
itself can be accessed via the value attribute of a .
typecode_or_type determines the type of the returned object: it is either a
ctypes type or a one character typecode of the kind used by the 
module.  *args is passed on to the constructor for the type.
If lock is  (the default) then a new recursive lock
object is created to synchronize access to the value.  If lock is
a  or  object then that will be used to
synchronize access to the value.  If lock is  then
access to the returned object will not be automatically protected
by a lock, so it will not necessarily be “process-safe”.
Operations like  which involve a read and write are not
atomic.  So if, for instance, you want to atomically increment a
shared value it is insufficient to just do


Assuming the associated lock is recursive (which it is by default)
you can instead do


Note that lock is a keyword-only argument.



(typecode_or_type, size_or_initializer, *, lock=True)¶
Return a ctypes array allocated from shared memory.  By default the return
value is actually a synchronized wrapper for the array.
typecode_or_type determines the type of the elements of the returned array:
it is either a ctypes type or a one character typecode of the kind used by
the  module.  If size_or_initializer is an integer, then it
determines the length of the array, and the array will be initially zeroed.
Otherwise, size_or_initializer is a sequence which is used to initialize
the array and whose length determines the length of the array.
If lock is  (the default) then a new lock object is created to
synchronize access to the value.  If lock is a  or
 object then that will be used to synchronize access to the
value.  If lock is  then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.
Note that lock is a keyword only argument.
Note that an array of  has value and raw
attributes which allow one to use it to store and retrieve strings.


The  module¶
The  module provides functions for allocating
 objects from shared memory which can be inherited by child
processes.

Note
Although it is possible to store a pointer in shared memory remember that
this will refer to a location in the address space of a specific process.
However, the pointer is quite likely to be invalid in the context of a second
process and trying to dereference the pointer from the second process may
cause a crash.



(typecode_or_type, size_or_initializer)¶
Return a ctypes array allocated from shared memory.
typecode_or_type determines the type of the elements of the returned array:
it is either a ctypes type or a one character typecode of the kind used by
the  module.  If size_or_initializer is an integer then it
determines the length of the array, and the array will be initially zeroed.
Otherwise size_or_initializer is a sequence which is used to initialize the
array and whose length determines the length of the array.
Note that setting and getting an element is potentially non-atomic – use
 instead to make sure that access is automatically synchronized
using a lock.



(typecode_or_type, *args)¶
Return a ctypes object allocated from shared memory.
typecode_or_type determines the type of the returned object: it is either a
ctypes type or a one character typecode of the kind used by the 
module.  *args is passed on to the constructor for the type.
Note that setting and getting the value is potentially non-atomic – use
 instead to make sure that access is automatically synchronized
using a lock.
Note that an array of  has  and 
attributes which allow one to use it to store and retrieve strings – see
documentation for .



(typecode_or_type, size_or_initializer, *, lock=True)¶
The same as  except that depending on the value of lock a
process-safe synchronization wrapper may be returned instead of a raw ctypes
array.
If lock is  (the default) then a new lock object is created to
synchronize access to the value.  If lock is a
 or  object
then that will be used to synchronize access to the
value.  If lock is  then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.
Note that lock is a keyword-only argument.



(typecode_or_type, *args, lock=True)¶
The same as  except that depending on the value of lock a
process-safe synchronization wrapper may be returned instead of a raw ctypes
object.
If lock is  (the default) then a new lock object is created to
synchronize access to the value.  If lock is a  or
 object then that will be used to synchronize access to the
value.  If lock is  then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.
Note that lock is a keyword-only argument.



(obj)¶
Return a ctypes object allocated from shared memory which is a copy of the
ctypes object obj.



(obj[, lock])¶
Return a process-safe wrapper object for a ctypes object which uses lock to
synchronize access.  If lock is  (the default) then a
 object is created automatically.
A synchronized wrapper will have two methods in addition to those of the
object it wraps:  returns the wrapped object and
 returns the lock object used for synchronization.
Note that accessing the ctypes object through the wrapper can be a lot slower
than accessing the raw ctypes object.

Changed in version 3.5: Synchronized objects support the context manager protocol.


The table below compares the syntax for creating shared ctypes objects from
shared memory with the normal ctypes syntax.  (In the table  is some
subclass of .)







ctypes
sharedctypes using type
sharedctypes using typecode



c_double(2.4)
RawValue(c_double, 2.4)
RawValue(‘d’, 2.4)

MyStruct(4, 6)
RawValue(MyStruct, 4, 6)
 

(c_short * 7)()
RawArray(c_short, 7)
RawArray(‘h’, 7)

(c_int * 3)(9, 2, 8)
RawArray(c_int, (9, 2, 8))
RawArray(‘i’, (9, 2, 8))



Below is an example where a number of ctypes objects are modified by a child
process:


The results printed are





Managers¶
Managers provide a way to create data which can be shared between different
processes, including sharing over a network between processes running on
different machines. A manager object controls a server process which manages
shared objects.  Other processes can access the shared objects by using
proxies.


()¶
Returns a started  object which
can be used for sharing objects between processes.  The returned manager
object corresponds to a spawned child process and has methods which will
create shared objects and return corresponding proxies.

Manager processes will be shutdown as soon as they are garbage collected or
their parent process exits.  The manager classes are defined in the
 module:


class ([address[, authkey]])¶
Create a BaseManager object.
Once created one should call  or  to ensure
that the manager object refers to a started manager process.
address is the address on which the manager process listens for new
connections.  If address is  then an arbitrary one is chosen.
authkey is the authentication key which will be used to check the
validity of incoming connections to the server process.  If
authkey is  then  is used.
Otherwise authkey is used and it must be a byte string.


([initializer[, initargs]])¶
Start a subprocess to start the manager.  If initializer is not 
then the subprocess will call  when it starts.



()¶
Returns a  object which represents the actual server under
the control of the Manager. The  object supports the
 method:


 additionally has an  attribute.



()¶
Connect a local manager object to a remote manager process:





()¶
Stop the process used by the manager.  This is only available if
 has been used to start the server process.
This can be called multiple times.



(typeid[, callable[, proxytype[, exposed[, method_to_typeid[, create_method]]]]])¶
A classmethod which can be used for registering a type or callable with
the manager class.
typeid is a “type identifier” which is used to identify a particular
type of shared object.  This must be a string.
callable is a callable used for creating objects for this type
identifier.  If a manager instance will be connected to the
server using the  method, or if the
create_method argument is  then this can be left as
.
proxytype is a subclass of  which is used to create
proxies for shared objects with this typeid.  If  then a proxy
class is created automatically.
exposed is used to specify a sequence of method names which proxies for
this typeid should be allowed to access using
.  (If exposed is  then
 is used instead if it exists.)  In the case
where no exposed list is specified, all “public methods” of the shared
object will be accessible.  (Here a “public method” means any attribute
which has a  method and whose name does not begin
with .)
method_to_typeid is a mapping used to specify the return type of those
exposed methods which should return a proxy.  It maps method names to
typeid strings.  (If method_to_typeid is  then
 is used instead if it exists.)  If a
method’s name is not a key of this mapping or if the mapping is 
then the object returned by the method will be copied by value.
create_method determines whether a method should be created with name
typeid which can be used to tell the server process to create a new
shared object and return a proxy for it.  By default it is .

 instances also have one read-only property:


¶
The address used by the manager.


Changed in version 3.3: Manager objects support the context management protocol – see
Context Manager Types.   starts the
server process (if it has not already started) and then returns the
manager object.   calls .
In previous versions  did not start the
manager’s server process if it was not already started.




class ¶
A subclass of  which can be used for the synchronization
of processes.  Objects of this type are returned by
.
Its methods create and return Proxy Objects for a
number of commonly used data types to be synchronized across processes.
This notably includes shared lists and dictionaries.


(parties[, action[, timeout]])¶
Create a shared  object and return a
proxy for it.

New in version 3.3.




([value])¶
Create a shared  object and return a
proxy for it.



([lock])¶
Create a shared  object and return a proxy for
it.
If lock is supplied then it should be a proxy for a
 or  object.

Changed in version 3.3: The  method was added.




()¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



([maxsize])¶
Create a shared  object and return a proxy for it.



()¶
Create a shared  object and return a proxy for it.



([value])¶
Create a shared  object and return a proxy for
it.



(typecode, sequence)¶
Create an array and return a proxy for it.



(typecode, value)¶
Create an object with a writable  attribute and return a proxy
for it.



()¶

(mapping)

(sequence)
Create a shared  object and return a proxy for it.



()¶

(sequence)
Create a shared  object and return a proxy for it.


Changed in version 3.6: Shared objects are capable of being nested.  For example, a shared
container object such as a shared list can contain other shared objects
which will all be managed and synchronized by the .




class ¶
A type that can register with .
A namespace object has no public methods, but does have writable attributes.
Its representation shows the values of its attributes.
However, when using a proxy for a namespace object, an attribute beginning
with  will be an attribute of the proxy and not an attribute of the
referent:




Customized managers¶
To create one’s own manager, one creates a subclass of  and
uses the  classmethod to register new types or
callables with the manager class.  For example:




Using a remote manager¶
It is possible to run a manager server on one machine and have clients use it
from other machines (assuming that the firewalls involved allow it).
Running the following commands creates a server for a single shared queue which
remote clients can access:


One client can access the server as follows:


Another client can also use it:


Local processes can also access that queue, using the code from above on the
client to access it remotely:





Proxy Objects¶
A proxy is an object which refers to a shared object which lives (presumably)
in a different process.  The shared object is said to be the referent of the
proxy.  Multiple proxy objects may have the same referent.
A proxy object has methods which invoke corresponding methods of its referent
(although not every method of the referent will necessarily be available through
the proxy).  In this way, a proxy can be used just like its referent can:


Notice that applying  to a proxy will return the representation of
the referent, whereas applying  will return the representation of
the proxy.
An important feature of proxy objects is that they are picklable so they can be
passed between processes.  As such, a referent can contain
Proxy Objects.  This permits nesting of these managed
lists, dicts, and other Proxy Objects:


Similarly, dict and list proxies may be nested inside one another:


If standard (non-proxy)  or  objects are contained
in a referent, modifications to those mutable values will not be propagated
through the manager because the proxy has no way of knowing when the values
contained within are modified.  However, storing a value in a container proxy
(which triggers a  on the proxy object) does propagate through
the manager and so to effectively modify such an item, one could re-assign the
modified value to the container proxy:


This approach is perhaps less convenient than employing nested
Proxy Objects for most use cases but also
demonstrates a level of control over the synchronization.

Note
The proxy types in  do nothing to support comparisons
by value.  So, for instance, we have:


One should just use a copy of the referent instead when making comparisons.



class ¶
Proxy objects are instances of subclasses of .


(methodname[, args[, kwds]])¶
Call and return the result of a method of the proxy’s referent.
If  is a proxy whose referent is  then the expression


will evaluate the expression


in the manager’s process.
The returned value will be a copy of the result of the call or a proxy to
a new shared object – see documentation for the method_to_typeid
argument of .
If an exception is raised by the call, then is re-raised by
.  If some other exception is raised in the manager’s
process then this is converted into a  exception and is
raised by .
Note in particular that an exception will be raised if methodname has
not been exposed.
An example of the usage of :





()¶
Return a copy of the referent.
If the referent is unpicklable then this will raise an exception.



()¶
Return a representation of the proxy object.



()¶
Return the representation of the referent.



Cleanup¶
A proxy object uses a weakref callback so that when it gets garbage collected it
deregisters itself from the manager which owns its referent.
A shared object gets deleted from the manager process when there are no longer
any proxies referring to it.



Process Pools¶
One can create a pool of processes which will carry out tasks submitted to it
with the  class.


class ([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])¶
A process pool object which controls a pool of worker processes to which jobs
can be submitted.  It supports asynchronous results with timeouts and
callbacks and has a parallel map implementation.
processes is the number of worker processes to use.  If processes is
 then the number returned by  is used.
If initializer is not  then each worker process will call
 when it starts.
maxtasksperchild is the number of tasks a worker process can complete
before it will exit and be replaced with a fresh worker process, to enable
unused resources to be freed. The default maxtasksperchild is , which
means worker processes will live as long as the pool.
context can be used to specify the context used for starting
the worker processes.  Usually a pool is created using the
function  or the  method
of a context object.  In both cases context is set
appropriately.
Note that the methods of the pool object should only be called by
the process which created the pool.

New in version 3.2: maxtasksperchild


New in version 3.4: context


Note
Worker processes within a  typically live for the complete
duration of the Pool’s work queue. A frequent pattern found in other
systems (such as Apache, mod_wsgi, etc) to free resources held by
workers is to allow a worker within a pool to complete only a set
amount of work before being exiting, being cleaned up and a new
process spawned to replace the old one. The maxtasksperchild
argument to the  exposes this ability to the end user.



(func[, args[, kwds]])¶
Call func with arguments args and keyword arguments kwds.  It blocks
until the result is ready. Given this blocks,  is
better suited for performing work in parallel. Additionally, func
is only executed in one of the workers of the pool.



(func[, args[, kwds[, callback[, error_callback]]]])¶
A variant of the  method which returns a result object.
If callback is specified then it should be a callable which accepts a
single argument.  When the result becomes ready callback is applied to
it, that is unless the call failed, in which case the error_callback
is applied instead.
If error_callback is specified then it should be a callable which
accepts a single argument.  If the target function fails, then
the error_callback is called with the exception instance.
Callbacks should complete immediately since otherwise the thread which
handles the results will get blocked.



(func, iterable[, chunksize])¶
A parallel equivalent of the  built-in function (it supports only
one iterable argument though).  It blocks until the result is ready.
This method chops the iterable into a number of chunks which it submits to
the process pool as separate tasks.  The (approximate) size of these
chunks can be specified by setting chunksize to a positive integer.
Note that it may cause high memory usage for very long iterables. Consider
using  or  with explicit chunksize
option for better efficiency.



(func, iterable[, chunksize[, callback[, error_callback]]])¶
A variant of the  method which returns a result object.
If callback is specified then it should be a callable which accepts a
single argument.  When the result becomes ready callback is applied to
it, that is unless the call failed, in which case the error_callback
is applied instead.
If error_callback is specified then it should be a callable which
accepts a single argument.  If the target function fails, then
the error_callback is called with the exception instance.
Callbacks should complete immediately since otherwise the thread which
handles the results will get blocked.



(func, iterable[, chunksize])¶
A lazier version of .
The chunksize argument is the same as the one used by the 
method.  For very long iterables using a large value for chunksize can
make the job complete much faster than using the default value of
.
Also if chunksize is  then the  method of the iterator
returned by the  method has an optional timeout parameter:
 will raise  if the
result cannot be returned within timeout seconds.



(func, iterable[, chunksize])¶
The same as  except that the ordering of the results from the
returned iterator should be considered arbitrary.  (Only when there is
only one worker process is the order guaranteed to be “correct”.)



(func, iterable[, chunksize])¶
Like  except that the elements of the iterable are expected
to be iterables that are unpacked as arguments.
Hence an iterable of  results in .

New in version 3.3.




(func, iterable[, chunksize[, callback[, error_callback]]])¶
A combination of  and  that iterates over
iterable of iterables and calls func with the iterables unpacked.
Returns a result object.

New in version 3.3.




()¶
Prevents any more tasks from being submitted to the pool.  Once all the
tasks have been completed the worker processes will exit.



()¶
Stops the worker processes immediately without completing outstanding
work.  When the pool object is garbage collected  will be
called immediately.



()¶
Wait for the worker processes to exit.  One must call  or
 before using .


New in version 3.3: Pool objects now support the context management protocol – see
Context Manager Types.   returns the
pool object, and  calls .




class ¶
The class of the result returned by  and
.


([timeout])¶
Return the result when it arrives.  If timeout is not  and the
result does not arrive within timeout seconds then
 is raised.  If the remote call raised
an exception then that exception will be reraised by .



([timeout])¶
Wait until the result is available or until timeout seconds pass.



()¶
Return whether the call has completed.



()¶
Return whether the call completed without raising an exception.  Will
raise  if the result is not ready.


The following example demonstrates the use of a pool:




Listeners and Clients¶
Usually message passing between processes is done using queues or by using
 objects returned by
.
However, the  module allows some extra
flexibility.  It basically gives a high level message oriented API for dealing
with sockets or Windows named pipes.  It also has support for digest
authentication using the  module, and for polling
multiple connections at the same time.


(connection, authkey)¶
Send a randomly generated message to the other end of the connection and wait
for a reply.
If the reply matches the digest of the message using authkey as the key
then a welcome message is sent to the other end of the connection.  Otherwise
 is raised.



(connection, authkey)¶
Receive a message, calculate the digest of the message using authkey as the
key, and then send the digest back.
If a welcome message is not received, then
 is raised.



(address[, family[, authkey]])¶
Attempt to set up a connection to the listener which is using address
address, returning a .
The type of the connection is determined by family argument, but this can
generally be omitted since it can usually be inferred from the format of
address. (See Address Formats)
If authkey is given and not None, it should be a byte string and will be
used as the secret key for an HMAC-based authentication challenge. No
authentication is done if authkey is None.
 is raised if authentication fails.
See Authentication keys.



class ([address[, family[, backlog[, authkey]]]])¶
A wrapper for a bound socket or Windows named pipe which is ‘listening’ for
connections.
address is the address to be used by the bound socket or named pipe of the
listener object.

Note
If an address of ‘0.0.0.0’ is used, the address will not be a connectable
end point on Windows. If you require a connectable end-point,
you should use ‘127.0.0.1’.

family is the type of socket (or named pipe) to use.  This can be one of
the strings  (for a TCP socket),  (for a Unix
domain socket) or  (for a Windows named pipe).  Of these only
the first is guaranteed to be available.  If family is  then the
family is inferred from the format of address.  If address is also
 then a default is chosen.  This default is the family which is
assumed to be the fastest available.  See
Address Formats.  Note that if family is
 and address is  then the socket will be created in a
private temporary directory created using .
If the listener object uses a socket then backlog (1 by default) is passed
to the  method of the socket once it has been
bound.
If authkey is given and not None, it should be a byte string and will be
used as the secret key for an HMAC-based authentication challenge. No
authentication is done if authkey is None.
 is raised if authentication fails.
See Authentication keys.


()¶
Accept a connection on the bound socket or named pipe of the listener
object and return a  object.
If authentication is attempted and fails, then
 is raised.



()¶
Close the bound socket or named pipe of the listener object.  This is
called automatically when the listener is garbage collected.  However it
is advisable to call it explicitly.

Listener objects have the following read-only properties:


¶
The address which is being used by the Listener object.



¶
The address from which the last accepted connection came.  If this is
unavailable then it is .


New in version 3.3: Listener objects now support the context management protocol – see
Context Manager Types.   returns the
listener object, and  calls .




(object_list, timeout=None)¶
Wait till an object in object_list is ready.  Returns the list of
those objects in object_list which are ready.  If timeout is a
float then the call blocks for at most that many seconds.  If
timeout is  then it will block for an unlimited period.
A negative timeout is equivalent to a zero timeout.
For both Unix and Windows, an object can appear in object_list if
it is

a readable  object;
a connected and readable  object; or
the  attribute of a
 object.

A connection or socket object is ready when there is data available
to be read from it, or the other end has been closed.
Unix:  almost equivalent
.  The difference is
that, if  is interrupted by a signal, it can
raise  with an error number of , whereas
 will not.
Windows: An item in object_list must either be an integer
handle which is waitable (according to the definition used by the
documentation of the Win32 function )
or it can be an object with a  method which returns a
socket handle or pipe handle.  (Note that pipe handles and socket
handles are not waitable handles.)

New in version 3.3.


Examples
The following server code creates a listener which uses  as
an authentication key.  It then waits for a connection and sends some data to
the client:


The following code connects to the server and receives some data from the
server:


The following code uses  to
wait for messages from multiple processes at once:



Address Formats¶

An  address is a tuple of the form  where
hostname is a string and port is an integer.
An  address is a string representing a filename on the
filesystem.

An  address is a string of the form
.  To use  to connect to a named
pipe on a remote computer called ServerName one should use an address of the
form  instead.



Note that any string beginning with two backslashes is assumed by default to be
an  address rather than an  address.



Authentication keys¶
When one uses , the
data received is automatically
unpickled. Unfortunately unpickling data from an untrusted source is a security
risk. Therefore  and  use the  module
to provide digest authentication.
An authentication key is a byte string which can be thought of as a
password: once a connection is established both ends will demand proof
that the other knows the authentication key.  (Demonstrating that both
ends are using the same key does not involve sending the key over
the connection.)
If authentication is requested but no authentication key is specified then the
return value of  is used (see
).  This value will be automatically inherited by
any  object that the current process creates.
This means that (by default) all processes of a multi-process program will share
a single authentication key which can be used when setting up connections
between themselves.
Suitable authentication keys can also be generated by using .


Logging¶
Some support for logging is available.  Note, however, that the 
package does not use process shared locks so it is possible (depending on the
handler type) for messages from different processes to get mixed up.


()¶
Returns the logger used by .  If necessary, a new one
will be created.
When first created the logger has level  and no
default handler. Messages sent to this logger will not by default propagate
to the root logger.
Note that on Windows child processes will only inherit the level of the
parent process’s logger – any other customization of the logger will not be
inherited.



()¶
This function performs a call to  but in addition to
returning the logger created by get_logger, it adds a handler which sends
output to  using format
.

Below is an example session with logging turned on:


For a full table of logging levels, see the  module.


The  module¶
 replicates the API of  but is
no more than a wrapper around the  module.

