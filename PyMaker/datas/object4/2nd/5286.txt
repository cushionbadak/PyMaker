link:
library/ssl.html#notes-on-non-blocking-sockets

docs:

Notes on non-blocking sockets¶
SSL sockets behave slightly different than regular sockets in
non-blocking mode. When working with non-blocking sockets, there are
thus several things you need to be aware of:

Most  methods will raise either
 or  instead of
 if an I/O operation would
block.  will be raised if a read operation on
the underlying socket is necessary, and  for
a write operation on the underlying socket. Note that attempts to
write to an SSL socket may require reading from the underlying
socket first, and attempts to read from the SSL socket may require
a prior write to the underlying socket.

Changed in version 3.5: In earlier Python versions, the  method
returned zero instead of raising  or
.


Calling  tells you that the OS-level socket can be
read from (or written to), but it does not imply that there is sufficient
data at the upper SSL layer.  For example, only part of an SSL frame might
have arrived.  Therefore, you must be ready to handle 
and  failures, and retry after another call to
.

Conversely, since the SSL layer has its own framing, a SSL socket may
still have data available for reading without 
being aware of it.  Therefore, you should first call
 to drain any potentially available data, and then
only block on a  call if still necessary.
(of course, similar provisions apply when using other primitives such as
, or those in the  module)

The SSL handshake itself will be non-blocking: the
 method has to be retried until it returns
successfully.  Here is a synopsis using  to wait for
the socket’s readiness:





See also
The  module supports non-blocking SSL sockets and provides a
higher level API. It polls for events using the  module and
handles ,  and
 exceptions. It runs the SSL handshake asynchronously
as well.

