link:
library/multiprocessing.html#pipes-and-queues

docs:

Pipes and Queues¶
When using multiple processes, one generally uses message passing for
communication between processes and avoids having to use any synchronization
primitives like locks.
For passing messages one can use  (for a connection between two
processes) or a queue (which allows multiple producers and consumers).
The ,  and  types
are multi-producer, multi-consumer FIFO
queues modelled on the  class in the
standard library.  They differ in that  lacks the
 and  methods introduced
into Python 2.5’s  class.
If you use  then you must call
 for each task removed from the queue or else the
semaphore used to count the number of unfinished tasks may eventually overflow,
raising an exception.
Note that one can also create a shared queue by using a manager object – see
Managers.

Note
 uses the usual  and
 exceptions to signal a timeout.  They are not available in
the  namespace so you need to import them from
.


Note
When an object is put on a queue, the object is pickled and a
background thread later flushes the pickled data to an underlying
pipe.  This has some consequences which are a little surprising,
but should not cause any practical difficulties – if they really
bother you then you can instead use a queue created with a
manager.

After putting an object on an empty queue there may be an
infinitesimal delay before the queue’s 
method returns  and  can
return without raising .
If multiple processes are enqueuing objects, it is possible for
the objects to be received at the other end out-of-order.
However, objects enqueued by the same process will always be in
the expected order with respect to each other.



Warning
If a process is killed using  or 
while it is trying to use a , then the data in the queue is
likely to become corrupted.  This may cause any other process to get an
exception when it tries to use the queue later on.


Warning
As mentioned above, if a child process has put items on a queue (and it has
not used ), then that process will
not terminate until all buffered items have been flushed to the pipe.
This means that if you try joining that process you may get a deadlock unless
you are sure that all items which have been put on the queue have been
consumed.  Similarly, if the child process is non-daemonic then the parent
process may hang on exit when it tries to join all its non-daemonic children.
Note that a queue created using a manager does not have this issue.  See
Programming guidelines.

For an example of the usage of queues for interprocess communication see
Examples.


([duplex])¶
Returns a pair  of
 objects representing the
ends of a pipe.
If duplex is  (the default) then the pipe is bidirectional.  If
duplex is  then the pipe is unidirectional:  can only be
used for receiving messages and  can only be used for sending
messages.



class ([maxsize])¶
Returns a process shared queue implemented using a pipe and a few
locks/semaphores.  When a process first puts an item on the queue a feeder
thread is started which transfers objects from a buffer into the pipe.
The usual  and  exceptions from the
standard library’s  module are raised to signal timeouts.
 implements all the methods of  except for
 and .


()¶
Return the approximate size of the queue.  Because of
multithreading/multiprocessing semantics, this number is not reliable.
Note that this may raise  on Unix platforms like
Mac OS X where  is not implemented.



()¶
Return  if the queue is empty,  otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



()¶
Return  if the queue is full,  otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.



(obj[, block[, timeout]])¶
Put obj into the queue.  If the optional argument block is 
(the default) and timeout is  (the default), block if necessary until
a free slot is available.  If timeout is a positive number, it blocks at
most timeout seconds and raises the  exception if no
free slot was available within that time.  Otherwise (block is
), put an item on the queue if a free slot is immediately
available, else raise the  exception (timeout is
ignored in that case).



(obj)¶
Equivalent to .



([block[, timeout]])¶
Remove and return an item from the queue.  If optional args block is
 (the default) and timeout is  (the default), block if
necessary until an item is available.  If timeout is a positive number,
it blocks at most timeout seconds and raises the 
exception if no item was available within that time.  Otherwise (block is
), return an item if one is immediately available, else raise the
 exception (timeout is ignored in that case).



()¶
Equivalent to .

 has a few additional methods not found in
.  These methods are usually unnecessary for most
code:


()¶
Indicate that no more data will be put on this queue by the current
process.  The background thread will quit once it has flushed all buffered
data to the pipe.  This is called automatically when the queue is garbage
collected.



()¶
Join the background thread.  This can only be used after  has
been called.  It blocks until the background thread exits, ensuring that
all data in the buffer has been flushed to the pipe.
By default if a process is not the creator of the queue then on exit it
will attempt to join the queue’s background thread.  The process can call
 to make  do nothing.



()¶
Prevent  from blocking.  In particular, this prevents
the background thread from being joined automatically when the process
exits – see .
A better name for this method might be
.  It is likely to cause enqueued
data to lost, and you almost certainly will not need to use it.
It is really only there if you need the current process to exit
immediately without waiting to flush enqueued data to the
underlying pipe, and you don’t care about lost data.


Note
This class’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
functionality in this class will be disabled, and attempts to
instantiate a  will result in an . See
bpo-3770 for additional information.  The same holds true for any
of the specialized queue types listed below.




class ¶
It is a simplified  type, very close to a locked .


()¶
Return  if the queue is empty,  otherwise.



()¶
Remove and return an item from the queue.



(item)¶
Put item into the queue.




class ([maxsize])¶
, a  subclass, is a queue which
additionally has  and  methods.


()¶
Indicate that a formerly enqueued task is complete. Used by queue
consumers.  For each  used to fetch a task, a subsequent
call to  tells the queue that the processing on the task
is complete.
If a  is currently blocking, it will resume when all
items have been processed (meaning that a  call was
received for every item that had been  into the queue).
Raises a  if called more times than there were items
placed in the queue.



()¶
Block until all items in the queue have been gotten and processed.
The count of unfinished tasks goes up whenever an item is added to the
queue.  The count goes down whenever a consumer calls
 to indicate that the item was retrieved and all work on
it is complete.  When the count of unfinished tasks drops to zero,
 unblocks.


