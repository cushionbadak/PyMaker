link:
library/stdtypes.html#printf-style-string-formatting

docs:

-style String Formatting¶

Note
The formatting operations described here exhibit a variety of quirks that
lead to a number of common errors (such as failing to display tuples and
dictionaries correctly).  Using the newer formatted string literals, the  interface, or template strings may help avoid these errors.  Each of these
alternatives provides their own trade-offs and benefits of simplicity,
flexibility, and/or extensibility.

String objects have one unique built-in operation: the  operator (modulo).
This is also known as the string formatting or interpolation operator.
Given  (where format is a string),  conversion
specifications in format are replaced with zero or more elements of values.
The effect is similar to using the  in the C language.
If format requires a single argument, values may be a single non-tuple
object. [5]  Otherwise, values must be a tuple with exactly the number of
items specified by the format string, or a single mapping object (for example, a
dictionary).
A conversion specifier contains two or more characters and has the following
components, which must occur in this order:

The  character, which marks the start of the specifier.
Mapping key (optional), consisting of a parenthesised sequence of characters
(for example, ).
Conversion flags (optional), which affect the result of some conversion
types.
Minimum field width (optional).  If specified as an  (asterisk), the
actual width is read from the next element of the tuple in values, and the
object to convert comes after the minimum field width and optional precision.
Precision (optional), given as a  (dot) followed by the precision.  If
specified as  (an asterisk), the actual precision is read from the next
element of the tuple in values, and the value to convert comes after the
precision.
Length modifier (optional).
Conversion type.

When the right argument is a dictionary (or other mapping type), then the
formats in the string must include a parenthesised mapping key into that
dictionary inserted immediately after the  character. The mapping key
selects the value to be formatted from the mapping.  For example:


In this case no  specifiers may occur in a format (since they require a
sequential parameter list).
The conversion flag characters are:






Flag
Meaning




The value conversion will use the “alternate form” (where defined
below).


The conversion will be zero padded for numeric values.


The converted value is left adjusted (overrides the 
conversion if both are given).


(a space) A blank should be left before a positive number (or empty
string) produced by a signed conversion.


A sign character ( or ) will precede the conversion
(overrides a “space” flag).



A length modifier (, , or ) may be present, but is ignored as it
is not necessary for Python – so e.g.  is identical to .
The conversion types are:







Conversion
Meaning
Notes




Signed integer decimal.
 


Signed integer decimal.
 


Signed octal value.
(1)


Obsolete type – it is identical to .
(6)


Signed hexadecimal (lowercase).
(2)


Signed hexadecimal (uppercase).
(2)


Floating point exponential format (lowercase).
(3)


Floating point exponential format (uppercase).
(3)


Floating point decimal format.
(3)


Floating point decimal format.
(3)


Floating point format. Uses lowercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Floating point format. Uses uppercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Single character (accepts integer or single
character string).
 


String (converts any Python object using
).
(5)


String (converts any Python object using
).
(5)


String (converts any Python object using
).
(5)


No argument is converted, results in a 
character in the result.
 



Notes:

The alternate form causes a leading octal specifier () to be
inserted before the first digit.

The alternate form causes a leading  or  (depending on whether
the  or  format was used) to be inserted before the first digit.

The alternate form causes the result to always contain a decimal point, even if
no digits follow it.
The precision determines the number of digits after the decimal point and
defaults to 6.

The alternate form causes the result to always contain a decimal point, and
trailing zeroes are not removed as they would otherwise be.
The precision determines the number of significant digits before and after the
decimal point and defaults to 6.

If precision is , the output is truncated to  characters.

See PEP 237.


Since Python strings have an explicit length,  conversions do not assume
that  is the end of the string.

Changed in version 3.1:  conversions for numbers whose absolute value is over 1e50 are no
longer replaced by  conversions.

