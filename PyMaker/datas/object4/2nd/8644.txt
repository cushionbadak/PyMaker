link:
library/unittest.mock-examples.html#patch-decorators

docs:

Patch Decorators¶

Note
With  it matters that you patch objects in the namespace where
they are looked up. This is normally straightforward, but for a quick guide
read where to patch.

A common need in tests is to patch a class attribute or a module attribute,
for example patching a builtin or patching a class in a module to test that it
is instantiated. Modules and classes are effectively global, so patching on
them has to be undone after the test or the patch will persist into other
tests and cause hard to diagnose problems.
mock provides three convenient decorators for this: ,  and
.  takes a single string, of the form
 to specify the attribute you are patching. It
also optionally takes a value that you want the attribute (or class or
whatever) to be replaced with. ‘patch.object’ takes an object and the name of
the attribute you would like patched, plus optionally the value to patch it
with.
:




If you are patching a module (including ) then use 
instead of :


The module name can be ‘dotted’, in the form  if needed:


A nice pattern is to actually decorate test methods themselves:


If you want to patch with a Mock, you can use  with only one argument
(or  with two arguments). The mock will be created for you and
passed into the test function / method:


You can stack up multiple patch decorators using this pattern:


When you nest patch decorators the mocks are passed in to the decorated
function in the same order they applied (the normal Python order that
decorators are applied). This means from the bottom up, so in the example
above the mock for  is passed in first.
There is also  for setting values in a dictionary just
during a scope and restoring the dictionary to its original state when the test
ends:


,  and  can all be used as context managers.
Where you use  to create a mock for you, you can get a reference to the
mock using the “as” form of the with statement:


As an alternative ,  and  can be used as
class decorators. When used in this way it is the same as applying the
decorator individually to every method whose name starts with “test”.
