link:
reference/expressions.html#comparisons

docs:

6.10. Comparisons¶
Unlike C, all comparison operations in Python have the same priority, which is
lower than that of any arithmetic, shifting or bitwise operation.  Also unlike
C, expressions like  have the interpretation that is conventional
in mathematics:

Comparisons yield boolean values:  or .
Comparisons can be chained arbitrarily, e.g.,  is equivalent to
, except that  is evaluated only once (but in both
cases  is not evaluated at all when  is found to be false).
Formally, if a, b, c, …, y, z are expressions and op1, op2, …,
opN are comparison operators, then  is equivalent
to , except that each expression is
evaluated at most once.
Note that  doesn’t imply any kind of comparison between a and
c, so that, e.g.,  is perfectly legal (though perhaps not
pretty).

6.10.1. Value comparisons¶
The operators , , , , , and  compare the
values of two objects.  The objects do not need to have the same type.
Chapter Objects, values and types states that objects have a value (in addition to type
and identity).  The value of an object is a rather abstract notion in Python:
For example, there is no canonical access method for an object’s value.  Also,
there is no requirement that the value of an object should be constructed in a
particular way, e.g. comprised of all its data attributes. Comparison operators
implement a particular notion of what the value of an object is.  One can think
of them as defining the value of an object indirectly, by means of their
comparison implementation.
Because all types are (direct or indirect) subtypes of , they
inherit the default comparison behavior from .  Types can
customize their comparison behavior by implementing
rich comparison methods like , described in
Basic customization.
The default behavior for equality comparison ( and ) is based on
the identity of the objects.  Hence, equality comparison of instances with the
same identity results in equality, and equality comparison of instances with
different identities results in inequality.  A motivation for this default
behavior is the desire that all objects should be reflexive (i.e. 
implies ).
A default order comparison (, , , and ) is not provided;
an attempt raises .  A motivation for this default behavior is
the lack of a similar invariant as for equality.
The behavior of the default equality comparison, that instances with different
identities are always unequal, may be in contrast to what types will need that
have a sensible definition of object value and value-based equality.  Such
types will need to customize their comparison behavior, and in fact, a number
of built-in types have done that.
The following list describes the comparison behavior of the most important
built-in types.

Numbers of built-in numeric types (Numeric Types — int, float, complex) and of the standard
library types  and  can be
compared within and across their types, with the restriction that complex
numbers do not support order comparison.  Within the limits of the types
involved, they compare mathematically (algorithmically) correct without loss
of precision.
The not-a-number values  and  are
special.  Any ordered comparison of a number to a not-a-number value is false.
A counter-intuitive implication is that not-a-number values are not equal to
themselves.  For example, if , , , ,  are all false.  This behavior is compliant with IEEE 754.

Binary sequences (instances of  or ) can be
compared within and across their types.  They compare lexicographically using
the numeric values of their elements.

Strings (instances of ) compare lexicographically using the
numerical Unicode code points (the result of the built-in function
) of their characters. [3]
Strings and binary sequences cannot be directly compared.

Sequences (instances of , , or ) can
be compared only within each of their types, with the restriction that ranges
do not support order comparison.  Equality comparison across these types
results in inequality, and ordering comparison across these types raises
.
Sequences compare lexicographically using comparison of corresponding
elements, whereby reflexivity of the elements is enforced.
In enforcing reflexivity of elements, the comparison of collections assumes
that for a collection element ,  is always true.  Based on
that assumption, element identity is compared first, and element comparison
is performed only for distinct elements.  This approach yields the same
result as a strict element comparison would, if the compared elements are
reflexive.  For non-reflexive elements, the result is different than for
strict element comparison, and may be surprising:  The non-reflexive
not-a-number values for example result in the following comparison behavior
when used in a list:


Lexicographical comparison between built-in collections works as follows:

For two collections to compare equal, they must be of the same type, have
the same length, and each pair of corresponding elements must compare
equal (for example,  is false because the type is not the
same).
Collections that support order comparison are ordered the same as their
first unequal elements (for example,  has the same
value as ).  If a corresponding element does not exist, the
shorter collection is ordered first (for example,  is
true).


Mappings (instances of ) compare equal if and only if they have
equal (key, value) pairs. Equality comparison of the keys and values
enforces reflexivity.
Order comparisons (, , , and ) raise .

Sets (instances of  or ) can be compared within
and across their types.
They define order
comparison operators to mean subset and superset tests.  Those relations do
not define total orderings (for example, the two sets  and 
are not equal, nor subsets of one another, nor supersets of one
another).  Accordingly, sets are not appropriate arguments for functions
which depend on total ordering (for example, , , and
 produce undefined results given a list of sets as inputs).
Comparison of sets enforces reflexivity of its elements.

Most other built-in types have no comparison methods implemented, so they
inherit the default comparison behavior.


User-defined classes that customize their comparison behavior should follow
some consistency rules, if possible:

Equality comparison should be reflexive.
In other words, identical objects should compare equal:

 implies 


Comparison should be symmetric.
In other words, the following expressions should have the same result:

 and 
 and 
 and 
 and 


Comparison should be transitive.
The following (non-exhaustive) examples illustrate that:

 implies 
 implies 


Inverse comparison should result in the boolean negation.
In other words, the following expressions should have the same result:

 and 
 and  (for total ordering)
 and  (for total ordering)

The last two expressions apply to totally ordered collections (e.g. to
sequences, but not to sets or mappings). See also the
 decorator.

The  result should be consistent with equality.
Objects that are equal should either have the same hash value,
or be marked as unhashable.


Python does not enforce these consistency rules. In fact, the not-a-number
values are an example for not following these rules.


6.10.2. Membership test operations¶
The operators  and  test for membership.   evaluates to  if x is a member of s, and  otherwise.
 returns the negation of .  All built-in sequences and
set types support this as well as dictionary, for which  tests
whether the dictionary has a given key. For container types such as list, tuple,
set, frozenset, dict, or collections.deque, the expression  is equivalent
to .
For the string and bytes types,  is  if and only if x is a
substring of y.  An equivalent test is .  Empty strings are
always considered to be a substring of any other string, so  will
return .
For user-defined classes which define the  method,  returns  if  returns a true value, and
 otherwise.
For user-defined classes which do not define  but do define
,  is  if some value  with  is
produced while iterating over .  If an exception is raised during the
iteration, it is as if  raised that exception.
Lastly, the old-style iteration protocol is tried: if a class defines
,  is  if and only if there is a non-negative
integer index i such that , and all lower integer indices do not
raise  exception.  (If any other exception is raised, it is as
if  raised that exception).
The operator  is defined to have the inverse truth value of
.


6.10.3. Identity comparisons¶
The operators  and  test for an object’s identity:  is true if and only if x and y are the same object.  An Object’s identity
is determined using the  function.   yields the inverse
truth value. [4]

