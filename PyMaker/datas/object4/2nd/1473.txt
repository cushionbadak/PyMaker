link:
library/enum.html#module-enum

docs:

 — Support for enumerations¶

New in version 3.4.

Source code: Lib/enum.py

An enumeration is a set of symbolic names (members) bound to unique,
constant values.  Within an enumeration, the members can be compared
by identity, and the enumeration itself can be iterated over.

Module Contents¶
This module defines four enumeration classes that can be used to define unique
sets of names and values: , , , and
.  It also defines one decorator, , and one
helper, .


class ¶
Base class for creating enumerated constants.  See section
Functional API for an alternate construction syntax.



class ¶
Base class for creating enumerated constants that are also
subclasses of .



class ¶
Base class for creating enumerated constants that can be combined using
the bitwise operators without losing their  membership.
 members are also subclasses of .



class ¶
Base class for creating enumerated constants that can be combined using
the bitwise operations without losing their  membership.



()¶
Enum class decorator that ensures only one name is bound to any one value.



class ¶
Instances are replaced with an appropriate value for Enum members.


New in version 3.6: , , 



Creating an Enum¶
Enumerations are created using the  syntax, which makes them
easy to read and write.  An alternative creation method is described in
Functional API.  To define an enumeration, subclass  as
follows:



Note
Enum member values
Member values can be anything: , , etc..  If
the exact value is unimportant you may use  instances and an
appropriate value will be chosen for you.  Care must be taken if you mix
 with other values.


Note
Nomenclature

The class  is an enumeration (or enum)
The attributes , , etc., are
enumeration members (or enum members) and are functionally constants.
The enum members have names and values (the name of
 is , the value of  is
, etc.)



Note
Even though we use the  syntax to create Enums, Enums
are not normal Python classes.  See How are Enums different? for
more details.

Enumeration members have human readable string representations:


…while their  has more information:


The type of an enumeration member is the enumeration it belongs to:


Enum members also have a property that contains just their item name:


Enumerations support iteration, in definition order:


Enumeration members are hashable, so they can be used in dictionaries and sets:




Programmatic access to enumeration members and their attributes¶
Sometimes it’s useful to access members in enumerations programmatically (i.e.
situations where  won’t do because the exact color is not known
at program-writing time).   allows such access:


If you want to access enum members by name, use item access:


If you have an enum member and need its  or :




Duplicating enum members and values¶
Having two enum members with the same name is invalid:


However, two enum members are allowed to have the same value.  Given two members
A and B with the same value (and A defined first), B is an alias to A.  By-value
lookup of the value of A and B will return A.  By-name lookup of B will also
return A:



Note
Attempting to create a member with the same name as an already
defined attribute (another member, a method, etc.) or attempting to create
an attribute with the same name as a member is not allowed.



Ensuring unique enumeration values¶
By default, enumerations allow multiple names as aliases for the same value.
When this behavior isn’t desired, the following decorator can be used to
ensure each value is used only once in the enumeration:




A  decorator specifically for enumerations.  It searches an
enumeration’s  gathering any aliases it finds; if any are
found  is raised with the details:




Using automatic values¶
If the exact value is unimportant you can use :


The values are chosen by , which can be
overridden:



Note
The goal of the default  methods is to provide
the next  in sequence with the last  provided, but
the way it does this is an implementation detail and may change.



Iteration¶
Iterating over the members of an enum does not provide the aliases:


The special attribute  is an ordered dictionary mapping names
to members.  It includes all names defined in the enumeration, including the
aliases:


The  attribute can be used for detailed programmatic access to
the enumeration members.  For example, finding all the aliases:




Comparisons¶
Enumeration members are compared by identity:


Ordered comparisons between enumeration values are not supported.  Enum
members are not integers (but see IntEnum below):


Equality comparisons are defined though:


Comparisons against non-enumeration values will always compare not equal
(again,  was explicitly designed to behave differently, see
below):




Allowed members and attributes of enumerations¶
The examples above use integers for enumeration values.  Using integers is
short and handy (and provided by default by the Functional API), but not
strictly enforced.  In the vast majority of use-cases, one doesn’t care what
the actual value of an enumeration is.  But if the value is important,
enumerations can have arbitrary values.
Enumerations are Python classes, and can have methods and special methods as
usual.  If we have this enumeration:


Then:


The rules for what is allowed are as follows: names that start and end with
a single underscore are reserved by enum and cannot be used; all other
attributes defined within an enumeration will become members of this
enumeration, with the exception of special methods (,
, etc.), descriptors (methods are also descriptors), and
variable names listed in .
Note:  if your enumeration defines  and/or  then
whatever value(s) were given to the enum member will be passed into those
methods.  See Planet for an example.


Restricted Enum subclassing¶
A new  class must have one base Enum class, up to one concrete
data type, and as many -based mixin classes as needed.  The
order of these base classes is:


Also, subclassing an enumeration is allowed only if the enumeration does not define
any members.  So this is forbidden:


But this is allowed:


Allowing subclassing of enums that define members would lead to a violation of
some important invariants of types and instances.  On the other hand, it makes
sense to allow sharing some common behavior between a group of enumerations.
(See OrderedEnum for an example.)


Pickling¶
Enumerations can be pickled and unpickled:


The usual restrictions for pickling apply: picklable enums must be defined in
the top level of a module, since unpickling requires them to be importable
from that module.

Note
With pickle protocol version 4 it is possible to easily pickle enums
nested in other classes.

It is possible to modify how Enum members are pickled/unpickled by defining
 in the enumeration class.


Functional API¶
The  class is callable, providing the following functional API:


The semantics of this API resemble . The first
argument of the call to  is the name of the enumeration.
The second argument is the source of enumeration member names.  It can be a
whitespace-separated string of names, a sequence of names, a sequence of
2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to
values.  The last two options enable assigning arbitrary values to
enumerations; the others auto-assign increasing integers starting with 1 (use
the  parameter to specify a different starting value).  A
new class derived from  is returned.  In other words, the above
assignment to  is equivalent to:


The reason for defaulting to  as the starting number and not  is
that  is  in a boolean sense, but enum members all evaluate
to .
Pickling enums created with the functional API can be tricky as frame stack
implementation details are used to try and figure out which module the
enumeration is being created in (e.g. it will fail if you use a utility
function in separate module, and also may not work on IronPython or Jython).
The solution is to specify the module name explicitly as follows:



Warning
If  is not supplied, and Enum cannot determine what it is,
the new Enum members will not be unpicklable; to keep errors closer to
the source, pickling will be disabled.

The new pickle protocol 4 also, in some circumstances, relies on
 being set to the location where pickle will be able
to find the class.  For example, if the class was made available in class
SomeData in the global scope:


The complete signature is:






value:What the new Enum class will record as its name.


names:The Enum members.  This can be a whitespace or comma separated string
(values will start at 1 unless otherwise specified):


or an iterator of names:


or an iterator of (name, value) pairs:


or a mapping:




module:name of module where new Enum class can be found.


qualname:where in module new Enum class can be found.


type:type to mix in to new Enum class.


start:number to start counting at if only names are passed in.





Changed in version 3.5: The start parameter was added.



Derived Enumerations¶

IntEnum¶
The first variation of  that is provided is also a subclass of
.  Members of an  can be compared to integers;
by extension, integer enumerations of different types can also be compared
to each other:


However, they still can’t be compared to standard  enumerations:


 values behave like integers in other ways you’d expect:




IntFlag¶
The next variation of  provided, , is also based
on .  The difference being  members can be combined
using the bitwise operators (&, |, ^, ~) and the result is still an
 member.  However, as the name implies, 
members also subclass  and can be used wherever an  is
used.  Any operation on an  member besides the bit-wise
operations will lose the  membership.

New in version 3.6.

Sample  class:


It is also possible to name the combinations:


Another important difference between  and  is that
if no flags are set (the value is 0), its boolean evaluation is :


Because  members are also subclasses of  they can
be combined with them:




Flag¶
The last variation is .  Like , 
members can be combined using the bitwise operators (&, |, ^, ~).  Unlike
, they cannot be combined with, nor compared against, any
other  enumeration, nor .  While it is possible to
specify the values directly it is recommended to use  as the
value and let  select an appropriate value.

New in version 3.6.

Like , if a combination of  members results in no
flags being set, the boolean evaluation is :


Individual flags should have values that are powers of two (1, 2, 4, 8, …),
while combinations of flags won’t:


Giving a name to the “no flags set” condition does not change its boolean
value:



Note
For the majority of new code,  and  are strongly
recommended, since  and  break some
semantic promises of an enumeration (by being comparable to integers, and
thus by transitivity to other unrelated enumerations).  
and  should be used only in cases where  and
 will not do; for example, when integer constants are replaced
with enumerations, or for interoperability with other systems.



Others¶
While  is part of the  module, it would be very
simple to implement independently:


This demonstrates how similar derived enumerations can be defined; for example
a  that mixes in  instead of .
Some rules:

When subclassing , mix-in types must appear before
 itself in the sequence of bases, as in the 
example above.
While  can have members of any type, once you mix in an
additional type, all the members must have values of that type, e.g.
 above.  This restriction does not apply to mix-ins which only
add methods and don’t specify another data type such as  or
.
When another data type is mixed in, the  attribute is not the
same as the enum member itself, although it is equivalent and will compare
equal.
%-style formatting:  %s and %r call the  class’s
 and  respectively; other codes (such as
%i or %h for IntEnum) treat the enum member as its mixed-in type.
Formatted string literals, ,
and  will use the mixed-in
type’s .  If the  class’s  or
 is desired, use the !s or !r format codes.




Interesting examples¶
While , , , and  are
expected to cover the majority of use-cases, they cannot cover them all.  Here
are recipes for some different types of enumerations that can be used directly,
or as examples for creating one’s own.

Omitting values¶
In many use-cases one doesn’t care what the actual value of an enumeration
is. There are several ways to define this type of simple enumeration:

use instances of  for the value
use instances of  as the value
use a descriptive string as the value
use a tuple as the value and a custom  to replace the
tuple with an  value

Using any of these methods signifies to the user that these values are not
important, and also enables one to add, remove, or reorder members without
having to renumber the remaining members.
Whichever method you choose, you should provide a  that also hides
the (unimportant) value:



Using ¶
Using  would look like:




Using ¶
Using  would look like:




Using a descriptive string¶
Using a string as the value would look like:




Using a custom ¶
Using an auto-numbering  would look like:



Note
The  method, if defined, is used during creation of the Enum
members; it is then replaced by Enum’s  which is used after
class creation for lookup of existing members.




OrderedEnum¶
An ordered enumeration that is not based on  and so maintains
the normal  invariants (such as not being comparable to other
enumerations):




DuplicateFreeEnum¶
Raises an error if a duplicate member name is found instead of creating an
alias:



Note
This is a useful example for subclassing Enum to add or change other
behaviors as well as disallowing aliases.  If the only desired change is
disallowing aliases, the  decorator can be used instead.



Planet¶
If  or  is defined the value of the enum member
will be passed to those methods:




TimePeriod¶
An example to show the  attribute in use:





How are Enums different?¶
Enums have a custom metaclass that affects many aspects of both derived Enum
classes and their instances (members).

Enum Classes¶
The  metaclass is responsible for providing the
, ,  and other methods that
allow one to do things with an  class that fail on a typical
class, such as list(Color) or some_enum_var in Color.   is
responsible for ensuring that various other methods on the final 
class are correct (such as , ,
 and ).


Enum Members (aka instances)¶
The most interesting thing about Enum members is that they are singletons.
 creates them all while it is creating the 
class itself, and then puts a custom  in place to ensure
that no new ones are ever instantiated by returning only the existing
member instances.


Finer Points¶

Supported  names¶
 is an  of :
items.  It is only available on the class.
, if specified, must create and return the enum members; it is
also a very good idea to set the member’s  appropriately.  Once
all the members are created it is no longer used.


Supported  names¶

 – name of the member
 – value of the member; can be set / modified in 
 – a lookup function used when a value is not found; may be
overridden
 – a list of names, either as a  or a ,
that will not be transformed into members, and will be removed from the final
class
 – used in Python 2/3 code to ensure member order is consistent
(class attribute, removed during class creation)
 – used by the Functional API and by
 to get an appropriate value for an enum member; may be
overridden


New in version 3.6: , , 


New in version 3.7: 

To help keep Python 2 / Python 3 code in sync an  attribute can
be provided.  It will be checked against the actual order of the enumeration
and raise an error if the two do not match:



Note
In Python 2 code the  attribute is necessary as definition
order is lost before it can be recorded.



 member type¶
 members are instances of their  class, and are
normally accessed as .  Under certain circumstances they
can also be accessed as , but you should never do
this as that lookup may fail or, worse, return something besides the
 member you are looking for (this is another good reason to use
all-uppercase names for members):



Changed in version 3.5.



Boolean value of  classes and members¶
 members that are mixed with non- types (such as
, , etc.) are evaluated according to the mixed-in
type’s rules; otherwise, all members evaluate as .  To make your
own Enum’s boolean evaluation depend on the member’s value add the following to
your class:


 classes always evaluate as .


 classes with methods¶
If you give your  subclass extra methods, like the Planet
class above, those methods will show up in a  of the member,
but not of the class:




Combining members of ¶
If a combination of Flag members is not named, the  will include
all named flags and all named combinations of flags that are in the value:





