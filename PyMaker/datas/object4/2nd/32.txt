link:
reference/datamodel.html

docs:


3. Data model¶

3.1. Objects, values and types¶
Objects are Python’s abstraction for data.  All data in a Python program
is represented by objects or by relations between objects. (In a sense, and in
conformance to Von Neumann’s model of a “stored program computer,” code is also
represented by objects.)
Every object has an identity, a type and a value.  An object’s identity never
changes once it has been created; you may think of it as the object’s address in
memory.  The ‘’ operator compares the identity of two objects; the
 function returns an integer representing its identity.

CPython implementation detail: For CPython,  is the memory address where  is stored.

An object’s type determines the operations that the object supports (e.g., “does
it have a length?”) and also defines the possible values for objects of that
type.  The  function returns an object’s type (which is an object
itself).  Like its identity, an object’s type is also unchangeable.
[1]
The value of some objects can change.  Objects whose value can
change are said to be mutable; objects whose value is unchangeable once they
are created are called immutable. (The value of an immutable container object
that contains a reference to a mutable object can change when the latter’s value
is changed; however the container is still considered immutable, because the
collection of objects it contains cannot be changed.  So, immutability is not
strictly the same as having an unchangeable value, it is more subtle.) An
object’s mutability is determined by its type; for instance, numbers, strings
and tuples are immutable, while dictionaries and lists are mutable.
Objects are never explicitly destroyed; however, when they become unreachable
they may be garbage-collected.  An implementation is allowed to postpone garbage
collection or omit it altogether — it is a matter of implementation quality
how garbage collection is implemented, as long as no objects are collected that
are still reachable.

CPython implementation detail: CPython currently uses a reference-counting scheme with (optional) delayed
detection of cyclically linked garbage, which collects most objects as soon
as they become unreachable, but is not guaranteed to collect garbage
containing circular references.  See the documentation of the 
module for information on controlling the collection of cyclic garbage.
Other implementations act differently and CPython may change.
Do not depend on immediate finalization of objects when they become
unreachable (so you should always close files explicitly).

Note that the use of the implementation’s tracing or debugging facilities may
keep objects alive that would normally be collectable. Also note that catching
an exception with a ‘…’ statement may keep
objects alive.
Some objects contain references to “external” resources such as open files or
windows.  It is understood that these resources are freed when the object is
garbage-collected, but since garbage collection is not guaranteed to happen,
such objects also provide an explicit way to release the external resource,
usually a  method. Programs are strongly recommended to explicitly
close such objects.  The ‘…’ statement
and the ‘’ statement provide convenient ways to do this.
Some objects contain references to other objects; these are called containers.
Examples of containers are tuples, lists and dictionaries.  The references are
part of a container’s value.  In most cases, when we talk about the value of a
container, we imply the values, not the identities of the contained objects;
however, when we talk about the mutability of a container, only the identities
of the immediately contained objects are implied.  So, if an immutable container
(like a tuple) contains a reference to a mutable object, its value changes if
that mutable object is changed.
Types affect almost all aspects of object behavior.  Even the importance of
object identity is affected in some sense: for immutable types, operations that
compute new values may actually return a reference to any existing object with
the same type and value, while for mutable objects this is not allowed.  E.g.,
after ,  and  may or may not refer to the same object
with the value one, depending on the implementation, but after ,  and  are guaranteed to refer to two different, unique, newly
created empty lists. (Note that  assigns the same object to both
 and .)


3.2. The standard type hierarchy¶
Below is a list of the types that are built into Python.  Extension modules
(written in C, Java, or other languages, depending on the implementation) can
define additional types.  Future versions of Python may add types to the type
hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.),
although such additions will often be provided via the standard library instead.
Some of the type descriptions below contain a paragraph listing ‘special
attributes.’  These are attributes that provide access to the implementation and
are not intended for general use.  Their definition may change in the future.

None
This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name . It is used to signify the
absence of a value in many situations, e.g., it is returned from functions that
don’t explicitly return anything. Its truth value is false.

NotImplemented
This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name . Numeric methods
and rich comparison methods should return this value if they do not implement the
operation for the operands provided.  (The interpreter will then try the
reflected operation, or some other fallback, depending on the operator.)  Its
truth value is true.
See
Implementing the arithmetic operations
for more details.

Ellipsis
This type has a single value.  There is a single object with this value. This
object is accessed through the literal  or the built-in name
.  Its truth value is true.


These are created by numeric literals and returned as results by arithmetic
operators and arithmetic built-in functions.  Numeric objects are immutable;
once created their value never changes.  Python numbers are of course strongly
related to mathematical numbers, but subject to the limitations of numerical
representation in computers.
Python distinguishes between integers, floating point numbers, and complex
numbers:


These represent elements from the mathematical set of integers (positive and
negative).
There are two types of integers:
Integers ()

These represent numbers in an unlimited range, subject to available (virtual)
memory only.  For the purpose of shift and mask operations, a binary
representation is assumed, and negative numbers are represented in a variant of
2’s complement which gives the illusion of an infinite string of sign bits
extending to the left.

Booleans ()
These represent the truth values False and True.  The two objects representing
the values  and  are the only Boolean objects. The Boolean type is a
subtype of the integer type, and Boolean values behave like the values 0 and 1,
respectively, in almost all contexts, the exception being that when converted to
a string, the strings  or  are returned, respectively.


The rules for integer representation are intended to give the most meaningful
interpretation of shift and mask operations involving negative integers.

 ()
These represent machine-level double precision floating point numbers. You are
at the mercy of the underlying machine architecture (and C or Java
implementation) for the accepted range and handling of overflow. Python does not
support single-precision floating point numbers; the savings in processor and
memory usage that are usually the reason for using these are dwarfed by the
overhead of using objects in Python, so there is no reason to complicate the
language with two kinds of floating point numbers.

 ()
These represent complex numbers as a pair of machine-level double precision
floating point numbers.  The same caveats apply as for floating point numbers.
The real and imaginary parts of a complex number  can be retrieved through
the read-only attributes  and .



Sequences
These represent finite ordered sets indexed by non-negative numbers. The
built-in function  returns the number of items of a sequence. When
the length of a sequence is n, the index set contains the numbers 0, 1,
…, n-1.  Item i of sequence a is selected by .
Sequences also support slicing:  selects all items with index k such
that i  k  j.  When used as an expression, a slice is a
sequence of the same type.  This implies that the index set is renumbered so
that it starts at 0.
Some sequences also support “extended slicing” with a third “step” parameter:
 selects all items of a with index x where , n
  and i  x  j.
Sequences are distinguished according to their mutability:

Immutable sequences
An object of an immutable sequence type cannot change once it is created.  (If
the object contains references to other objects, these other objects may be
mutable and may be changed; however, the collection of objects directly
referenced by an immutable object cannot change.)
The following types are immutable sequences:

Strings
A string is a sequence of values that represent Unicode code points.
All the code points in the range  can be
represented in a string.  Python doesn’t have a  type;
instead, every code point in the string is represented as a string
object with length .  The built-in function 
converts a code point from its string form to an integer in the
range ;  converts an integer in the range
 to the corresponding length  string object.
 can be used to convert a  to
 using the given text encoding, and
 can be used to achieve the opposite.

Tuples
The items of a tuple are arbitrary Python objects. Tuples of two or
more items are formed by comma-separated lists of expressions.  A tuple
of one item (a ‘singleton’) can be formed by affixing a comma to an
expression (an expression by itself does not create a tuple, since
parentheses must be usable for grouping of expressions).  An empty
tuple can be formed by an empty pair of parentheses.

Bytes
A bytes object is an immutable array.  The items are 8-bit bytes,
represented by integers in the range 0 <= x < 256.  Bytes literals
(like ) and the built-in  constructor
can be used to create bytes objects.  Also, bytes objects can be
decoded to strings via the  method.



Mutable sequences
Mutable sequences can be changed after they are created.  The subscription and
slicing notations can be used as the target of assignment and 
(delete) statements.
There are currently two intrinsic mutable sequence types:

Lists
The items of a list are arbitrary Python objects.  Lists are formed by
placing a comma-separated list of expressions in square brackets. (Note
that there are no special cases needed to form lists of length 0 or 1.)

Byte Arrays
A bytearray object is a mutable array. They are created by the built-in
 constructor.  Aside from being mutable
(and hence unhashable), byte arrays otherwise provide the same interface
and functionality as immutable  objects.


The extension module  provides an additional example of a
mutable sequence type, as does the  module.



Set types
These represent unordered, finite sets of unique, immutable objects. As such,
they cannot be indexed by any subscript. However, they can be iterated over, and
the built-in function  returns the number of items in a set. Common
uses for sets are fast membership testing, removing duplicates from a sequence,
and computing mathematical operations such as intersection, union, difference,
and symmetric difference.
For set elements, the same immutability rules apply as for dictionary keys. Note
that numeric types obey the normal rules for numeric comparison: if two numbers
compare equal (e.g.,  and ), only one of them can be contained in a
set.
There are currently two intrinsic set types:

Sets
These represent a mutable set. They are created by the built-in 
constructor and can be modified afterwards by several methods, such as
.

Frozen sets
These represent an immutable set.  They are created by the built-in
 constructor.  As a frozenset is immutable and
hashable, it can be used again as an element of another set, or as
a dictionary key.



Mappings
These represent finite sets of objects indexed by arbitrary index sets. The
subscript notation  selects the item indexed by  from the mapping
; this can be used in expressions and as the target of assignments or
 statements. The built-in function  returns the number
of items in a mapping.
There is currently a single intrinsic mapping type:

Dictionaries
These represent finite sets of objects indexed by nearly arbitrary values.  The
only types of values not acceptable as keys are values containing lists or
dictionaries or other mutable types that are compared by value rather than by
object identity, the reason being that the efficient implementation of
dictionaries requires a key’s hash value to remain constant. Numeric types used
for keys obey the normal rules for numeric comparison: if two numbers compare
equal (e.g.,  and ) then they can be used interchangeably to index
the same dictionary entry.
Dictionaries are mutable; they can be created by the  notation (see
section Dictionary displays).
The extension modules  and  provide
additional examples of mapping types, as does the 
module.



Callable types
These are the types to which the function call operation (see section
Calls) can be applied:

User-defined functions
A user-defined function object is created by a function definition (see
section Function definitions).  It should be called with an argument list
containing the same number of items as the function’s formal parameter
list.
Special attributes:







Attribute
Meaning
 




The function’s documentation
string, or  if
unavailable; not inherited by
subclasses.
Writable


The function’s name.
Writable


The function’s
qualified name.

New in version 3.3.


Writable


The name of the module the
function was defined in, or
 if unavailable.
Writable


A tuple containing default
argument values for those
arguments that have defaults,
or  if no arguments
have a default value.
Writable


The code object representing
the compiled function body.
Writable


A reference to the dictionary
that holds the function’s
global variables — the
global namespace of the
module in which the function
was defined.
Read-only


The namespace supporting
arbitrary function
attributes.
Writable


 or a tuple of cells
that contain bindings for the
function’s free variables.
See below for information on
the 
attribute.
Read-only


A dict containing annotations
of parameters.  The keys of
the dict are the parameter
names, and  for
the return annotation, if
provided.
Writable


A dict containing defaults
for keyword-only parameters.
Writable



Most of the attributes labelled “Writable” check the type of the assigned value.
Function objects also support getting and setting arbitrary attributes, which
can be used, for example, to attach metadata to functions.  Regular attribute
dot-notation is used to get and set such attributes. Note that the current
implementation only supports function attributes on user-defined functions.
Function attributes on built-in functions may be supported in the future.
A cell object has the attribute . This can be used to get
the value of the cell, as well as set the value.
Additional information about a function’s definition can be retrieved from its
code object; see the description of internal types below.

Instance methods
An instance method object combines a class, a class instance and any
callable object (normally a user-defined function).
Special read-only attributes:  is the class instance object,
 is the function object;  is the method’s
documentation (same as );  is the
method name (same as );  is the
name of the module the method was defined in, or  if unavailable.
Methods also support accessing (but not setting) the arbitrary function
attributes on the underlying function object.
User-defined method objects may be created when getting an attribute of a
class (perhaps via an instance of that class), if that attribute is a
user-defined function object or a class method object.
When an instance method object is created by retrieving a user-defined
function object from a class via one of its instances, its
 attribute is the instance, and the method object is said
to be bound.  The new method’s  attribute is the original
function object.
When a user-defined method object is created by retrieving another method
object from a class or instance, the behaviour is the same as for a
function object, except that the  attribute of the new
instance is not the original method object but its 
attribute.
When an instance method object is created by retrieving a class method
object from a class or instance, its  attribute is the
class itself, and its  attribute is the function object
underlying the class method.
When an instance method object is called, the underlying function
() is called, inserting the class instance
() in front of the argument list.  For instance, when
 is a class which contains a definition for a function
, and  is an instance of , calling  is
equivalent to calling .
When an instance method object is derived from a class method object, the
“class instance” stored in  will actually be the class
itself, so that calling either  or  is equivalent to
calling  where  is the underlying function.
Note that the transformation from function object to instance method
object happens each time the attribute is retrieved from the instance.  In
some cases, a fruitful optimization is to assign the attribute to a local
variable and call that local variable. Also notice that this
transformation only happens for user-defined functions; other callable
objects (and all non-callable objects) are retrieved without
transformation.  It is also important to note that user-defined functions
which are attributes of a class instance are not converted to bound
methods; this only happens when the function is an attribute of the
class.

Generator functions
A function or method which uses the  statement (see section
The yield statement) is called a generator function.  Such a function, when
called, always returns an iterator object which can be used to execute the
body of the function:  calling the iterator’s 
method will cause the function to execute until it provides a value
using the  statement.  When the function executes a
 statement or falls off the end, a 
exception is raised and the iterator will have reached the end of the set of
values to be returned.

Coroutine functions
A function or method which is defined using  is called
a coroutine function.  Such a function, when called, returns a
coroutine object.  It may contain  expressions,
as well as  and  statements. See
also the Coroutine Objects section.

Asynchronous generator functions
A function or method which is defined using  and
which uses the  statement is called a
asynchronous generator function.  Such a function, when called,
returns an asynchronous iterator object which can be used in an
 statement to execute the body of the function.
Calling the asynchronous iterator’s  method
will return an awaitable which when awaited
will execute until it provides a value using the 
expression.  When the function executes an empty 
statement or falls off the end, a  exception
is raised and the asynchronous iterator will have reached the end of
the set of values to be yielded.

Built-in functions
A built-in function object is a wrapper around a C function.  Examples of
built-in functions are  and  ( is a
standard built-in module). The number and type of the arguments are
determined by the C function. Special read-only attributes:
 is the function’s documentation string, or  if
unavailable;  is the function’s name;  is
set to  (but see the next item);  is the name of
the module the function was defined in or  if unavailable.

Built-in methods
This is really a different disguise of a built-in function, this time containing
an object passed to the C function as an implicit extra argument.  An example of
a built-in method is , assuming alist is a list object. In
this case, the special read-only attribute  is set to the object
denoted by alist.

Classes
Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override .  The arguments of the call are passed to
 and, in the typical case, to  to
initialize the new instance.
Class Instances
Instances of arbitrary classes can be made callable by defining a
 method in their class.


Modules
Modules are a basic organizational unit of Python code, and are created by
the import system as invoked either by the
 statement, or by calling
functions such as  and built-in
.  A module object has a namespace implemented by a
dictionary object (this is the dictionary referenced by the 
attribute of functions defined in the module).  Attribute references are
translated to lookups in this dictionary, e.g.,  is equivalent to
. A module object does not contain the code object used
to initialize the module (since it isn’t needed once the initialization is
done).
Attribute assignment updates the module’s namespace dictionary, e.g.,
 is equivalent to .
Predefined (writable) attributes:  is the module’s name;
 is the module’s documentation string, or  if
unavailable;  (optional) is a dictionary containing
variable annotations collected during module
body execution;  is the pathname of the file from which the
module was loaded, if it was loaded from a file. The 
attribute may be missing for certain types of modules, such as C modules
that are statically linked into the interpreter; for extension modules
loaded dynamically from a shared library, it is the pathname of the shared
library file.
Special read-only attribute:  is the module’s
namespace as a dictionary object.

CPython implementation detail: Because of the way CPython clears module dictionaries, the module
dictionary will be cleared when the module falls out of scope even if the
dictionary still has live references.  To avoid this, copy the dictionary
or keep the module around while using its dictionary directly.


Custom classes
Custom class types are typically created by class definitions (see section
Class definitions).  A class has a namespace implemented by a dictionary object.
Class attribute references are translated to lookups in this dictionary, e.g.,
 is translated to  (although there are a number of
hooks which allow for other means of locating attributes). When the attribute
name is not found there, the attribute search continues in the base classes.
This search of the base classes uses the C3 method resolution order which
behaves correctly even in the presence of ‘diamond’ inheritance structures
where there are multiple inheritance paths leading back to a common ancestor.
Additional details on the C3 MRO used by Python can be found in the
documentation accompanying the 2.3 release at
https://www.python.org/download/releases/2.3/mro/.
When a class attribute reference (for class , say) would yield a
class method object, it is transformed into an instance method object whose
 attribute is .  When it would yield a static
method object, it is transformed into the object wrapped by the static method
object. See section Implementing Descriptors for another way in which attributes
retrieved from a class may differ from those actually contained in its
.
Class attribute assignments update the class’s dictionary, never the dictionary
of a base class.
A class object can be called (see above) to yield a class instance (see below).
Special attributes:  is the class name;  is
the module name in which the class was defined;  is the
dictionary containing the class’s namespace;  is a
tuple containing the base classes, in the order of their occurrence in the
base class list;  is the class’s documentation string,
or  if undefined;  (optional) is a dictionary
containing variable annotations collected during
class body execution.

Class instances
A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose  attribute is the instance.  Static method and
class method objects are also transformed; see above under “Classes”.  See
section Implementing Descriptors for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s .  If no class attribute is found, and the
object’s class has a  method, that is called to satisfy
the lookup.
Attribute assignments and deletions update the instance’s dictionary, never a
class’s dictionary.  If the class has a  or
 method, this is called instead of updating the instance
dictionary directly.
Class instances can pretend to be numbers, sequences, or mappings if they have
methods with certain special names.  See section Special method names.
Special attributes:  is the attribute dictionary;
 is the instance’s class.

I/O objects (also known as file objects)
A file object represents an open file.  Various shortcuts are
available to create file objects: the  built-in function, and
also , , and the
 method of socket objects (and perhaps by
other functions or methods provided by extension modules).
The objects ,  and  are
initialized to file objects corresponding to the interpreter’s standard
input, output and error streams; they are all open in text mode and
therefore follow the interface defined by the 
abstract class.

Internal types
A few types used internally by the interpreter are exposed to the user. Their
definitions may change with future versions of the interpreter, but they are
mentioned here for completeness.

Code objects
Code objects represent byte-compiled executable Python code, or bytecode.
The difference between a code object and a function object is that the function
object contains an explicit reference to the function’s globals (the module in
which it was defined), while a code object contains no context; also the default
argument values are stored in the function object, not in the code object
(because they represent values calculated at run-time).  Unlike function
objects, code objects are immutable and contain no references (directly or
indirectly) to mutable objects.
Special read-only attributes:  gives the function name;
 is the number of positional arguments (including arguments
with default values);  is the number of local variables used
by the function (including arguments);  is a tuple containing
the names of the local variables (starting with the argument names);
 is a tuple containing the names of local variables that are
referenced by nested functions;  is a tuple containing the
names of free variables;  is a string representing the sequence
of bytecode instructions;  is a tuple containing the literals
used by the bytecode;  is a tuple containing the names used by
the bytecode;  is the filename from which the code was
compiled;  is the first line number of the function;
 is a string encoding the mapping from bytecode offsets to
line numbers (for details see the source code of the interpreter);
 is the required stack size (including local variables);
 is an integer encoding a number of flags for the interpreter.
The following flag bits are defined for : bit  is set if
the function uses the  syntax to accept an arbitrary number of
positional arguments; bit  is set if the function uses the
 syntax to accept arbitrary keyword arguments; bit  is set
if the function is a generator.
Future feature declarations () also use bits
in  to indicate whether a code object was compiled with a
particular feature enabled: bit  is set if the function was compiled
with future division enabled; bits  and  were used in earlier
versions of Python.
Other bits in  are reserved for internal use.
If a code object represents a function, the first item in  is
the documentation string of the function, or  if undefined.



Frame objects
Frame objects represent execution frames.  They may occur in traceback objects
(see below), and are also passed to registered trace functions.
Special read-only attributes:  is to the previous stack frame
(towards the caller), or  if this is the bottom stack frame;
 is the code object being executed in this frame; 
is the dictionary used to look up local variables;  is used for
global variables;  is used for built-in (intrinsic) names;
 gives the precise instruction (this is an index into the
bytecode string of the code object).
Special writable attributes: , if not , is a function
called for various events during code execution (this is used by the debugger).
Normally an event is triggered for each new source line - this can be
disabled by setting  to .
Implementations may allow per-opcode events to be requested by setting
 to . Note that this may lead to
undefined interpreter behaviour if exceptions raised by the trace
function escape to the function being traced.
 is the current line number of the frame — writing to this
from within a trace function jumps to the given line (only for the bottom-most
frame).  A debugger can implement a Jump command (aka Set Next Statement)
by writing to f_lineno.
Frame objects support one method:


()¶
This method clears all references to local variables held by the
frame.  Also, if the frame belonged to a generator, the generator
is finalized.  This helps break reference cycles involving frame
objects (for example when catching an exception and storing its
traceback for later use).
 is raised if the frame is currently executing.

New in version 3.4.





Traceback objects
Traceback objects represent a stack trace of an exception.  A traceback object
is implicitly created when an exception occurs, and may also be explicitly
created by calling .
For implicitly created tracebacks, when the search for an exception handler
unwinds the execution stack, at each unwound level a traceback object is
inserted in front of the current traceback.  When an exception handler is
entered, the stack trace is made available to the program. (See section
The try statement.) It is accessible as the third item of the
tuple returned by , and as the  attribute
of the caught exception.
When the program contains no suitable
handler, the stack trace is written (nicely formatted) to the standard error
stream; if the interpreter is interactive, it is also made available to the user
as .
For explicitly created tracebacks, it is up to the creator of the traceback
to determine how the  attributes should be linked to form a
full stack trace.
Special read-only attributes:
 points to the execution frame of the current level;
 gives the line number where the exception occurred;
 indicates the precise instruction.
The line number and last instruction in the traceback may differ from the
line number of its frame object if the exception occurred in a
 statement with no matching except clause or with a
finally clause.
Special writable attribute:  is the next level in the stack
trace (towards the frame where the exception occurred), or  if
there is no next level.

Changed in version 3.7: Traceback objects can now be explicitly instantiated from Python code,
and the  attribute of existing instances can be updated.


Slice objects
Slice objects are used to represent slices for 
methods.  They are also created by the built-in  function.
Special read-only attributes:  is the lower bound;
 is the upper bound;  is the step
value; each is  if omitted.  These attributes can have any type.
Slice objects support one method:


(self, length)¶
This method takes a single integer argument length and computes
information about the slice that the slice object would describe if
applied to a sequence of length items.  It returns a tuple of three
integers; respectively these are the start and stop indices and the
step or stride length of the slice. Missing or out-of-bounds indices
are handled in a manner consistent with regular slices.


Static method objects
Static method objects provide a way of defeating the transformation of function
objects to method objects described above. A static method object is a wrapper
around any other object, usually a user-defined method object. When a static
method object is retrieved from a class or a class instance, the object actually
returned is the wrapped object, which is not subject to any further
transformation. Static method objects are not themselves callable, although the
objects they wrap usually are. Static method objects are created by the built-in
 constructor.
Class method objects
A class method object, like a static method object, is a wrapper around another
object that alters the way in which that object is retrieved from classes and
class instances. The behaviour of class method objects upon such retrieval is
described above, under “User-defined methods”. Class method objects are created
by the built-in  constructor.





3.3. Special method names¶
A class can implement certain operations that are invoked by special syntax
(such as arithmetic operations or subscripting and slicing) by defining methods
with special names. This is Python’s approach to operator overloading,
allowing classes to define their own behavior with respect to language
operators.  For instance, if a class defines a method named ,
and  is an instance of this class, then  is roughly equivalent
to .  Except where mentioned, attempts to execute an
operation raise an exception when no appropriate method is defined (typically
 or ).
Setting a special method to  indicates that the corresponding
operation is not available.  For example, if a class sets
 to , the class is not iterable, so calling
 on its instances will raise a  (without
falling back to ). [2]
When implementing a class that emulates any built-in type, it is important that
the emulation only be implemented to the degree that it makes sense for the
object being modelled.  For example, some sequences may work well with retrieval
of individual elements, but extracting a slice may not make sense.  (One example
of this is the  interface in the W3C’s Document
Object Model.)

3.3.1. Basic customization¶


(cls[, ...])¶
Called to create a new instance of class cls.   is a static
method (special-cased so you need not declare it as such) that takes the class
of which an instance was requested as its first argument.  The remaining
arguments are those passed to the object constructor expression (the call to the
class).  The return value of  should be the new object instance
(usually an instance of cls).
Typical implementations create a new instance of the class by invoking the
superclass’s  method using 
with appropriate arguments and then modifying the newly-created instance
as necessary before returning it.
If  returns an instance of cls, then the new instance’s
 method will be invoked like , where
self is the new instance and the remaining arguments are the same as were
passed to .
If  does not return an instance of cls, then the new instance’s
 method will not be invoked.
 is intended mainly to allow subclasses of immutable types (like
int, str, or tuple) to customize instance creation.  It is also commonly
overridden in custom metaclasses in order to customize class creation.



(self[, ...])¶
Called after the instance has been created (by ), but before
it is returned to the caller.  The arguments are those passed to the
class constructor expression.  If a base class has an 
method, the derived class’s  method, if any, must explicitly
call it to ensure proper initialization of the base class part of the
instance; for example: .
Because  and  work together in constructing
objects ( to create it, and  to customize it),
no non- value may be returned by ; doing so will
cause a  to be raised at runtime.



(self)¶
Called when the instance is about to be destroyed.  This is also called a
finalizer or (improperly) a destructor.  If a base class has a
 method, the derived class’s  method,
if any, must explicitly call it to ensure proper deletion of the base
class part of the instance.
It is possible (though not recommended!) for the  method
to postpone destruction of the instance by creating a new reference to
it.  This is called object resurrection.  It is implementation-dependent
whether  is called a second time when a resurrected object
is about to be destroyed; the current CPython implementation
only calls it once.
It is not guaranteed that  methods are called for objects
that still exist when the interpreter exits.

Note
 doesn’t directly call  — the former decrements
the reference count for  by one, and the latter is only called when
’s reference count reaches zero.


CPython implementation detail: It is possible for a reference cycle to prevent the reference count
of an object from going to zero.  In this case, the cycle will be
later detected and deleted by the cyclic garbage collector.  A common cause of reference cycles is when
an exception has been caught in a local variable.  The frame’s
locals then reference the exception, which references its own
traceback, which references the locals of all frames caught in the
traceback.

See also
Documentation for the  module.



Warning
Due to the precarious circumstances under which  methods are
invoked, exceptions that occur during their execution are ignored, and a warning
is printed to  instead.  In particular:

 can be invoked when arbitrary code is being executed,
including from any arbitrary thread.  If  needs to take
a lock or invoke any other blocking resource, it may deadlock as
the resource may already be taken by the code that gets interrupted
to execute .
 can be executed during interpreter shutdown.  As a
consequence, the global variables it needs to access (including other
modules) may already have been deleted or set to . Python
guarantees that globals whose name begins with a single underscore
are deleted from their module before other globals are deleted; if
no other references to such globals exist, this may help in assuring
that imported modules are still available at the time when the
 method is called.





(self)¶
Called by the  built-in function to compute the “official” string
representation of an object.  If at all possible, this should look like a
valid Python expression that could be used to recreate an object with the
same value (given an appropriate environment).  If this is not possible, a
string of the form  should be returned.
The return value must be a string object. If a class defines 
but not , then  is also used when an
“informal” string representation of instances of that class is required.
This is typically used for debugging, so it is important that the representation
is information-rich and unambiguous.



(self)¶
Called by  and the built-in functions
 and  to compute the “informal” or nicely
printable string representation of an object.  The return value must be a
string object.
This method differs from  in that there is no
expectation that  return a valid Python expression: a more
convenient or concise representation can be used.
The default implementation defined by the built-in type 
calls .



(self)¶
Called by bytes to compute a byte-string representation
of an object. This should return a  object.



(self, format_spec)¶
Called by the  built-in function,
and by extension, evaluation of formatted string literals and the  method, to produce a “formatted”
string representation of an object. The format_spec argument is
a string that contains a description of the formatting options desired.
The interpretation of the format_spec argument is up to the type
implementing , however most classes will either
delegate formatting to one of the built-in types, or use a similar
formatting option syntax.
See Format Specification Mini-Language for a description of the standard formatting syntax.
The return value must be a string object.

Changed in version 3.4: The __format__ method of  itself raises a 
if passed any non-empty string.


Changed in version 3.7:  is now equivalent to  rather
than .




(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These are the so-called “rich comparison” methods. The correspondence between
operator symbols and method names is as follows:  calls ,
 calls ,  calls ,  calls
,  calls , and  calls
.
A rich comparison method may return the singleton  if it does
not implement the operation for a given pair of arguments. By convention,
 and  are returned for a successful comparison. However, these
methods can return any value, so if the comparison operator is used in a Boolean
context (e.g., in the condition of an  statement), Python will call
 on the value to determine if the result is true or false.
By default,  delegates to  and
inverts the result unless it is .  There are no other
implied relationships among the comparison operators, for example,
the truth of  does not imply .
To automatically generate ordering operations from a single root operation,
see .
See the paragraph on  for
some important notes on creating hashable objects which support
custom comparison operations and are usable as dictionary keys.
There are no swapped-argument versions of these methods (to be used when the
left argument does not support the operation but the right argument does);
rather,  and  are each other’s reflection,
 and  are each other’s reflection, and
 and  are their own reflection.
If the operands are of different types, and right operand’s type is
a direct or indirect subclass of the left operand’s type,
the reflected method of the right operand has priority, otherwise
the left operand’s method has priority.  Virtual subclassing is
not considered.



(self)¶
Called by built-in function  and for operations on members of
hashed collections including , , and
.   should return an integer. The only required
property is that objects which compare equal have the same hash value; it is
advised to mix together the hash values of the components of the object that
also play a part in comparison of objects by packing them into a tuple and
hashing the tuple. Example:



Note
 truncates the value returned from an object’s custom
 method to the size of a .  This is
typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an
object’s    must interoperate on builds of different bit
sizes, be sure to check the width on all supported builds.  An easy way
to do this is with
.

If a class does not define an  method it should not define a
 operation either; if it defines  but not
, its instances will not be usable as items in hashable
collections.  If a class defines mutable objects and implements an
 method, it should not implement , since the
implementation of hashable collections requires that a key’s hash value is
immutable (if the object’s hash value changes, it will be in the wrong hash
bucket).
User-defined classes have  and  methods
by default; with them, all objects compare unequal (except with themselves)
and  returns an appropriate value such that 
implies both that  and .
A class that overrides  and does not define 
will have its  implicitly set to .  When the
 method of a class is , instances of the class will
raise an appropriate  when a program attempts to retrieve
their hash value, and will also be correctly identified as unhashable when
checking .
If a class that overrides  needs to retain the implementation
of  from a parent class, the interpreter must be told this
explicitly by setting .
If a class that does not override  wishes to suppress hash
support, it should include  in the class definition.
A class which defines its own  that explicitly raises
a  would be incorrectly identified as hashable by
an  call.

Note
By default, the  values of str, bytes and datetime
objects are “salted” with an unpredictable random value.  Although they
remain constant within an individual Python process, they are not
predictable between repeated invocations of Python.
This is intended to provide protection against a denial-of-service caused
by carefully-chosen inputs that exploit the worst case performance of a
dict insertion, O(n^2) complexity.  See
http://www.ocert.org/advisories/ocert-2011-003.html for details.
Changing hash values affects the iteration order of sets.
Python has never made guarantees about this ordering
(and it typically varies between 32-bit and 64-bit builds).
See also .


Changed in version 3.3: Hash randomization is enabled by default.




(self)¶
Called to implement truth value testing and the built-in operation
; should return  or .  When this method is not
defined,  is called, if it is defined, and the object is
considered true if its result is nonzero.  If a class defines neither
 nor , all its instances are considered
true.



3.3.2. Customizing attribute access¶
The following methods can be defined to customize the meaning of attribute
access (use of, assignment to, or deletion of ) for class instances.


(self, name)¶
Called when the default attribute access fails with an 
(either  raises an  because
name is not an instance attribute or an attribute in the class tree
for ; or  of a name property raises
).  This method should either return the (computed)
attribute value or raise an  exception.
Note that if the attribute is found through the normal mechanism,
 is not called.  (This is an intentional asymmetry between
 and .) This is done both for efficiency
reasons and because otherwise  would have no way to access
other attributes of the instance.  Note that at least for instance variables,
you can fake total control by not inserting any values in the instance attribute
dictionary (but instead inserting them in another object).  See the
 method below for a way to actually get total control
over attribute access.



(self, name)¶
Called unconditionally to implement attribute accesses for instances of the
class. If the class also defines , the latter will not be
called unless  either calls it explicitly or raises an
. This method should return the (computed) attribute value
or raise an  exception. In order to avoid infinite
recursion in this method, its implementation should always call the base class
method with the same name to access any attributes it needs, for example,
.

Note
This method may still be bypassed when looking up special methods as the
result of implicit invocation via language syntax or built-in functions.
See Special method lookup.




(self, name, value)¶
Called when an attribute assignment is attempted.  This is called instead of
the normal mechanism (i.e. store the value in the instance dictionary).
name is the attribute name, value is the value to be assigned to it.
If  wants to assign to an instance attribute, it should
call the base class method with the same name, for example,
.



(self, name)¶
Like  but for attribute deletion instead of assignment.  This
should only be implemented if  is meaningful for the object.



(self)¶
Called when  is called on the object. A sequence must be
returned.  converts the returned sequence to a list and sorts it.


3.3.2.1. Customizing module attribute access¶
Special names  and  can be also used to customize
access to module attributes. The  function at the module level
should accept one argument which is the name of an attribute and return the
computed value or raise an . If an attribute is
not found on a module object through the normal lookup, i.e.
, then  is searched in
the module  before raising an . If found,
it is called with the attribute name and the result is returned.
The  function should accept no arguments, and return a list of
strings that represents the names accessible on module. If present, this
function overrides the standard  search on a module.
For a more fine grained customization of the module behavior (setting
attributes, properties, etc.), one can set the  attribute of
a module object to a subclass of . For example:



Note
Defining module  and setting module  only
affect lookups made using the attribute access syntax – directly accessing
the module globals (whether by code within the module, or via a reference
to the module’s globals dictionary) is unaffected.


Changed in version 3.5:  module attribute is now writable.


New in version 3.7:  and  module attributes.


See also

PEP 562 - Module __getattr__ and __dir__
Describes the  and  functions on modules.




3.3.2.2. Implementing Descriptors¶
The following methods only apply when an instance of the class containing the
method (a so-called descriptor class) appears in an owner class (the
descriptor must be in either the owner’s class dictionary or in the class
dictionary for one of its parents).  In the examples below, “the attribute”
refers to the attribute whose name is the key of the property in the owner
class’ .


(self, instance, owner)¶
Called to get the attribute of the owner class (class attribute access) or of an
instance of that class (instance attribute access). owner is always the owner
class, while instance is the instance that the attribute was accessed through,
or  when the attribute is accessed through the owner.  This method
should return the (computed) attribute value or raise an 
exception.



(self, instance, value)¶
Called to set the attribute on an instance instance of the owner class to a
new value, value.



(self, instance)¶
Called to delete the attribute on an instance instance of the owner class.



(self, owner, name)¶
Called at the time the owning class owner is created. The
descriptor has been assigned to name.

New in version 3.6.


The attribute  is interpreted by the  module
as specifying the class where this object was defined (setting this
appropriately can assist in runtime introspection of dynamic class attributes).
For callables, it may indicate that an instance of the given type (or a
subclass) is expected or required as the first positional argument (for example,
CPython sets this attribute for unbound methods that are implemented in C).


3.3.2.3. Invoking Descriptors¶
In general, a descriptor is an object attribute with “binding behavior”, one
whose attribute access has been overridden by methods in the descriptor
protocol:  , , and . If any of
those methods are defined for an object, it is said to be a descriptor.
The default behavior for attribute access is to get, set, or delete the
attribute from an object’s dictionary. For instance,  has a lookup chain
starting with , then , and
continuing through the base classes of  excluding metaclasses.
However, if the looked-up value is an object defining one of the descriptor
methods, then Python may override the default behavior and invoke the descriptor
method instead.  Where this occurs in the precedence chain depends on which
descriptor methods were defined and how they were called.
The starting point for descriptor invocation is a binding, . How the
arguments are assembled depends on :

Direct Call
The simplest and least common call is when user code directly invokes a
descriptor method:    .
Instance Binding
If binding to an object instance,  is transformed into the call:
.
Class Binding
If binding to a class,  is transformed into the call:
.
Super Binding
If  is an instance of , then the binding 
searches  for the base class 
immediately preceding  and then invokes the descriptor with the call:
.

For instance bindings, the precedence of descriptor invocation depends on the
which descriptor methods are defined.  A descriptor can define any combination
of ,  and .  If it does not
define , then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines  and/or , it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both  and , while non-data
descriptors have just the  method.  Data descriptors with
 and  defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.
Python methods (including  and ) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.
The  function is implemented as a data descriptor. Accordingly,
instances cannot override the behavior of a property.


3.3.2.4. __slots__¶
__slots__ allow us to explicitly declare data members (like
properties) and deny the creation of __dict__ and __weakref__
(unless explicitly declared in __slots__ or available in a parent.)
The space saved over using __dict__ can be significant.
Attribute lookup speed can be significantly improved as well.


¶
This class variable can be assigned a string, iterable, or sequence of
strings with variable names used by instances.  __slots__ reserves space
for the declared variables and prevents the automatic creation of __dict__
and __weakref__ for each instance.


3.3.2.4.1. Notes on using __slots__¶

When inheriting from a class without __slots__, the __dict__ and
__weakref__ attribute of the instances will always be accessible.
Without a __dict__ variable, instances cannot be assigned new variables not
listed in the __slots__ definition.  Attempts to assign to an unlisted
variable name raises . If dynamic assignment of new
variables is desired, then add  to the sequence of strings in
the __slots__ declaration.
Without a __weakref__ variable for each instance, classes defining
__slots__ do not support weak references to its instances. If weak reference
support is needed, then add  to the sequence of strings in the
__slots__ declaration.
__slots__ are implemented at the class level by creating descriptors
(Implementing Descriptors) for each variable name.  As a result, class attributes
cannot be used to set default values for instance variables defined by
__slots__; otherwise, the class attribute would overwrite the descriptor
assignment.
The action of a __slots__ declaration is not limited to the class
where it is defined.  __slots__ declared in parents are available in
child classes. However, child subclasses will get a __dict__  and
__weakref__ unless they also define __slots__ (which should only
contain names of any additional slots).
If a class defines a slot also defined in a base class, the instance variable
defined by the base class slot is inaccessible (except by retrieving its
descriptor directly from the base class). This renders the meaning of the
program undefined.  In the future, a check may be added to prevent this.
Nonempty __slots__ does not work for classes derived from “variable-length”
built-in types such as ,  and .
Any non-string iterable may be assigned to __slots__. Mappings may also be
used; however, in the future, special meaning may be assigned to the values
corresponding to each key.
__class__ assignment works only if both classes have the same __slots__.
Multiple inheritance with multiple slotted parent classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
.





3.3.3. Customizing class creation¶
Whenever a class inherits from another class, __init_subclass__ is
called on that class. This way, it is possible to write classes which
change the behavior of subclasses. This is closely related to class
decorators, but where class decorators only affect the specific class they’re
applied to,  solely applies to future subclasses of the
class defining the method.


classmethod (cls)¶
This method is called whenever the containing class is subclassed.
cls is then the new subclass. If defined as a normal instance method,
this method is implicitly converted to a class method.
Keyword arguments which are given to a new class are passed to
the parent’s class . For compatibility with
other classes using , one should take out the
needed keyword arguments and pass the others over to the base
class, as in:


The default implementation  does
nothing, but raises an error if it is called with any arguments.

Note
The metaclass hint  is consumed by the rest of the type
machinery, and is never passed to  implementations.
The actual metaclass (rather than the explicit hint) can be accessed as
.


New in version 3.6.



3.3.3.1. Metaclasses¶
By default, classes are constructed using . The class body is
executed in a new namespace and the class name is bound locally to the
result of .
The class creation process can be customized by passing the 
keyword argument in the class definition line, or by inheriting from an
existing class that included such an argument. In the following example,
both  and  are instances of :


Any other keyword arguments that are specified in the class definition are
passed through to all metaclass operations described below.
When a class definition is executed, the following steps occur:

MRO entries are resolved;
the appropriate metaclass is determined;
the class namespace is prepared;
the class body is executed;
the class object is created.



3.3.3.2. Resolving MRO entries¶
If a base that appears in class definition is not an instance of ,
then an  method is searched on it. If found, it is called
with the original bases tuple. This method must return a tuple of classes that
will be used instead of this base. The tuple may be empty, in such case
the original base is ignored.

See also
PEP 560 - Core support for typing module and generic types



3.3.3.3. Determining the appropriate metaclass¶
The appropriate metaclass for a class definition is determined as follows:

if no bases and no explicit metaclass are given, then  is used;
if an explicit metaclass is given and it is not an instance of
, then it is used directly as the metaclass;
if an instance of  is given as the explicit metaclass, or
bases are defined, then the most derived metaclass is used.

The most derived metaclass is selected from the explicitly specified
metaclass (if any) and the metaclasses (i.e. ) of all specified
base classes. The most derived metaclass is one which is a subtype of all
of these candidate metaclasses. If none of the candidate metaclasses meets
that criterion, then the class definition will fail with .


3.3.3.4. Preparing the class namespace¶
Once the appropriate metaclass has been identified, then the class namespace
is prepared. If the metaclass has a  attribute, it is called
as  (where the
additional keyword arguments, if any, come from the class definition).
If the metaclass has no  attribute, then the class namespace
is initialised as an empty ordered mapping.

See also

PEP 3115 - Metaclasses in Python 3000
Introduced the  namespace hook




3.3.3.5. Executing the class body¶
The class body is executed (approximately) as
. The key difference from a normal
call to  is that lexical scoping allows the class body (including
any methods) to reference names from the current and outer scopes when the
class definition occurs inside a function.
However, even when the class definition occurs inside the function, methods
defined inside the class still cannot see names defined at the class scope.
Class variables must be accessed through the first parameter of instance or
class methods, or through the implicit lexically scoped  reference
described in the next section.


3.3.3.6. Creating the class object¶
Once the class namespace has been populated by executing the class body,
the class object is created by calling
 (the additional keywords
passed here are the same as those passed to ).
This class object is the one that will be referenced by the zero-argument
form of .  is an implicit closure reference
created by the compiler if any methods in a class body refer to either
 or . This allows the zero argument form of
 to correctly identify the class being defined based on
lexical scoping, while the class or instance that was used to make the
current call is identified based on the first argument passed to the method.

CPython implementation detail: In CPython 3.6 and later, the  cell is passed to the metaclass
as a  entry in the class namespace. If present, this must
be propagated up to the  call in order for the class to be
initialised correctly.
Failing to do so will result in a  in Python 3.6,
and a  in Python 3.8.

When using the default metaclass , or any metaclass that ultimately
calls , the following additional customisation steps are
invoked after creating the class object:

first,  collects all of the descriptors in the class
namespace that define a  method;
second, all of these  methods are called with the class
being defined and the assigned name of that particular descriptor;
finally, the  hook is called on the
immediate parent of the new class in its method resolution order.

After the class object is created, it is passed to the class decorators
included in the class definition (if any) and the resulting object is bound
in the local namespace as the defined class.
When a new class is created by , the object provided as the
namespace parameter is copied to a new ordered mapping and the original
object is discarded. The new copy is wrapped in a read-only proxy, which
becomes the  attribute of the class object.

See also

PEP 3135 - New super
Describes the implicit  closure reference




3.3.3.7. Uses for metaclasses¶
The potential uses for metaclasses are boundless. Some ideas that have been
explored include enum, logging, interface checking, automatic delegation,
automatic property creation, proxies, frameworks, and automatic resource
locking/synchronization.



3.3.4. Customizing instance and subclass checks¶
The following methods are used to override the default behavior of the
 and  built-in functions.
In particular, the metaclass  implements these methods in
order to allow the addition of Abstract Base Classes (ABCs) as “virtual base
classes” to any class or type (including built-in types), including other
ABCs.


(self, instance)¶
Return true if instance should be considered a (direct or indirect)
instance of class. If defined, called to implement .



(self, subclass)¶
Return true if subclass should be considered a (direct or indirect)
subclass of class.  If defined, called to implement .

Note that these methods are looked up on the type (metaclass) of a class.  They
cannot be defined as class methods in the actual class.  This is consistent with
the lookup of special methods that are called on instances, only in this
case the instance is itself a class.

See also

PEP 3119 - Introducing Abstract Base Classes
Includes the specification for customizing  and
 behavior through  and
, with motivation for this functionality
in the context of adding Abstract Base Classes (see the 
module) to the language.




3.3.5. Emulating generic types¶
One can implement the generic class syntax as specified by PEP 484
(for example ) by defining a special method:


classmethod (cls, key)¶
Return an object representing the specialization of a generic class
by type arguments found in key.

This method is looked up on the class object itself, and when defined in
the class body, this method is implicitly a class method.  Note, this
mechanism is primarily reserved for use with static type hints, other usage
is discouraged.

See also
PEP 560 - Core support for typing module and generic types



3.3.6. Emulating callable objects¶


(self[, args...])¶
Called when the instance is “called” as a function; if this method is defined,
 is a shorthand for .



3.3.7. Emulating container types¶
The following methods can be defined to implement container objects.  Containers
usually are sequences (such as lists or tuples) or mappings (like dictionaries),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers k for which  where N is the length of the sequence, or slice objects, which define a
range of items.  It is also recommended that mappings provide the methods
, , , , ,
, , , , and
 behaving similar to those for Python’s standard dictionary
objects.  The  module provides a

abstract base class to help create those methods from a base set of
, , , and .
Mutable sequences should provide methods , ,
, , , , ,
 and , like Python standard list objects.  Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods ,
, , ,  and
 described below; they should not define other numerical
operators.  It is recommended that both mappings and sequences implement the
 method to allow efficient use of the  operator; for
mappings,  should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the  method to allow efficient iteration
through the container; for mappings,  should be the same as
; for sequences, it should iterate through the values.


(self)¶
Called to implement the built-in function .  Should return the length
of the object, an integer  0.  Also, an object that doesn’t define a
 method and whose  method returns zero is
considered to be false in a Boolean context.

CPython implementation detail: In CPython, the length is required to be at most .
If the length is larger than  some features (such as
) may raise .  To prevent raising
 by truth value testing, an object must define a
 method.




(self)¶
Called to implement . Should return an estimated
length for the object (which may be greater or less than the actual length).
The length must be an integer  0. This method is purely an
optimization and is never required for correctness.

New in version 3.4.



Note
Slicing is done exclusively with the following three methods.  A call like


is translated to


and so forth.  Missing slice items are always filled in with .



(self, key)¶
Called to implement evaluation of . For sequence types, the
accepted keys should be integers and slice objects.  Note that the special
interpretation of negative indexes (if the class wishes to emulate a sequence
type) is up to the  method. If key is of an inappropriate
type,  may be raised; if of a value outside the set of indexes
for the sequence (after any special interpretation of negative values),
 should be raised. For mapping types, if key is missing (not
in the container),  should be raised.

Note
 loops expect that an  will be raised for illegal
indexes to allow proper detection of the end of the sequence.




(self, key, value)¶
Called to implement assignment to .  Same note as for
.  This should only be implemented for mappings if the
objects support changes to the values for keys, or if new keys can be added, or
for sequences if elements can be replaced.  The same exceptions should be raised
for improper key values as for the  method.



(self, key)¶
Called to implement deletion of .  Same note as for
.  This should only be implemented for mappings if the
objects support removal of keys, or for sequences if elements can be removed
from the sequence.  The same exceptions should be raised for improper key
values as for the  method.



(self, key)¶
Called by . to implement  for dict subclasses
when key is not in the dictionary.



(self)¶
This method is called when an iterator is required for a container. This method
should return a new iterator object that can iterate over all the objects in the
container.  For mappings, it should iterate over the keys of the container.
Iterator objects also need to implement this method; they are required to return
themselves.  For more information on iterator objects, see Iterator Types.



(self)¶
Called (if present) by the  built-in to implement
reverse iteration.  It should return a new iterator object that iterates
over all the objects in the container in reverse order.
If the  method is not provided, the 
built-in will fall back to using the sequence protocol ( and
).  Objects that support the sequence protocol should
only provide  if they can provide an implementation
that is more efficient than the one provided by .

The membership test operators ( and ) are normally
implemented as an iteration through a sequence.  However, container objects can
supply the following special method with a more efficient implementation, which
also does not require the object be a sequence.


(self, item)¶
Called to implement membership test operators.  Should return true if item
is in self, false otherwise.  For mapping objects, this should consider the
keys of the mapping rather than the values or the key-item pairs.
For objects that don’t define , the membership test first
tries iteration via , then the old sequence iteration
protocol via , see this section in the language
reference.



3.3.8. Emulating numeric types¶
The following methods can be defined to emulate numeric objects. Methods
corresponding to operations that are not supported by the particular kind of
number implemented (e.g., bitwise operations for non-integral numbers) should be
left undefined.


(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other[, modulo])¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the binary arithmetic operations
(, , , , , , , ,
, , , , , , ).  For instance, to
evaluate the expression , where x is an instance of a class that
has an  method,  is called.  The
 method should be the equivalent to using
 and ; it should not be related to
.  Note that  should be defined to accept
an optional third argument if the ternary version of the built-in 
function is to be supported.
If one of those methods does not support the operation with the supplied
arguments, it should return .



(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the binary arithmetic operations
(, , , , , , , ,
, , , , , , ) with reflected
(swapped) operands.  These functions are only called if the left operand does
not support the corresponding operation [3] and the operands are of different
types. [4] For instance, to evaluate the expression , where y is
an instance of a class that has an  method, 
is called if  returns NotImplemented.
Note that ternary  will not try calling  (the
coercion rules would become too complicated).

Note
If the right operand’s type is a subclass of the left operand’s type and that
subclass provides the reflected method for the operation, this method will be
called before the left operand’s non-reflected method.  This behavior allows
subclasses to override their ancestors’ operations.




(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other[, modulo])¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶

(self, other)¶
These methods are called to implement the augmented arithmetic assignments
(, , , , , , , , ,
, , , ).  These methods should attempt to do the
operation in-place (modifying self) and return the result (which could be,
but does not have to be, self).  If a specific method is not defined, the
augmented assignment falls back to the normal methods.  For instance, if x
is an instance of a class with an  method,  is
equivalent to  . Otherwise,  and
 are considered, as with the evaluation of . In
certain situations, augmented assignment can result in unexpected errors (see
Why does a_tuple[i] += [‘item’] raise an exception when the addition works?), but this behavior is in fact
part of the data model.



(self)¶

(self)¶

(self)¶

(self)¶
Called to implement the unary arithmetic operations (, , 
and ).



(self)¶

(self)¶

(self)¶
Called to implement the built-in functions ,
 and .  Should return a value
of the appropriate type.



(self)¶
Called to implement , and whenever Python needs to
losslessly convert the numeric object to an integer object (such as in
slicing, or in the built-in ,  and 
functions). Presence of this method indicates that the numeric object is
an integer type.  Must return an integer.

Note
In order to have a coherent integer type class, when  is
defined  should also be defined, and both should return
the same value.




(self[, ndigits])¶

(self)¶

(self)¶

(self)¶
Called to implement the built-in function  and 
functions ,  and .
Unless ndigits is passed to  all these methods should
return the value of the object truncated to an 
(typically an ).
If  is not defined then the built-in function 
falls back to .



3.3.9. With Statement Context Managers¶
A context manager is an object that defines the runtime context to be
established when executing a  statement. The context manager
handles the entry into, and the exit from, the desired runtime context for the
execution of the block of code.  Context managers are normally invoked using the
 statement (described in section The with statement), but can also be
used by directly invoking their methods.
Typical uses of context managers include saving and restoring various kinds of
global state, locking and unlocking resources, closing opened files, etc.
For more information on context managers, see Context Manager Types.


(self)¶
Enter the runtime context related to this object. The  statement
will bind this method’s return value to the target(s) specified in the
 clause of the statement, if any.



(self, exc_type, exc_value, traceback)¶
Exit the runtime context related to this object. The parameters describe the
exception that caused the context to be exited. If the context was exited
without an exception, all three arguments will be .
If an exception is supplied, and the method wishes to suppress the exception
(i.e., prevent it from being propagated), it should return a true value.
Otherwise, the exception will be processed normally upon exit from this method.
Note that  methods should not reraise the passed-in exception;
this is the caller’s responsibility.


See also

PEP 343 - The “with” statement
The specification, background, and examples for the Python 
statement.




3.3.10. Special method lookup¶
For custom classes, implicit invocations of special methods are only guaranteed
to work correctly if defined on an object’s type, not in the object’s instance
dictionary.  That behaviour is the reason why the following code raises an
exception:


The rationale behind this behaviour lies with a number of special methods such
as  and  that are implemented by all objects,
including type objects. If the implicit lookup of these methods used the
conventional lookup process, they would fail when invoked on the type object
itself:


Incorrectly attempting to invoke an unbound method of a class in this way is
sometimes referred to as ‘metaclass confusion’, and is avoided by bypassing
the instance when looking up special methods:


In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
 method even of the object’s metaclass:


Bypassing the  machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of
special methods (the special method must be set on the class
object itself in order to be consistently invoked by the interpreter).



3.4. Coroutines¶

3.4.1. Awaitable Objects¶
An awaitable object generally implements an  method.
Coroutine objects returned from  functions
are awaitable.

Note
The generator iterator objects returned from generators
decorated with  or 
are also awaitable, but they do not implement .



(self)¶
Must return an iterator.  Should be used to implement
awaitable objects.  For instance,  implements
this method to be compatible with the  expression.


New in version 3.5.


See also
PEP 492 for additional information about awaitable objects.



3.4.2. Coroutine Objects¶
Coroutine objects are awaitable objects.
A coroutine’s execution can be controlled by calling  and
iterating over the result.  When the coroutine has finished executing and
returns, the iterator raises , and the exception’s
 attribute holds the return value.  If the
coroutine raises an exception, it is propagated by the iterator.  Coroutines
should not directly raise unhandled  exceptions.
Coroutines also have the methods listed below, which are analogous to
those of generators (see Generator-iterator methods).  However, unlike
generators, coroutines do not directly support iteration.

Changed in version 3.5.2: It is a  to await on a coroutine more than once.



(value)¶
Starts or resumes execution of the coroutine.  If value is ,
this is equivalent to advancing the iterator returned by
.  If value is not , this method delegates
to the  method of the iterator that caused
the coroutine to suspend.  The result (return value,
, or other exception) is the same as when
iterating over the  return value, described above.



(type[, value[, traceback]])¶
Raises the specified exception in the coroutine.  This method delegates
to the  method of the iterator that caused
the coroutine to suspend, if it has such a method.  Otherwise,
the exception is raised at the suspension point.  The result
(return value, , or other exception) is the same as
when iterating over the  return value, described
above.  If the exception is not caught in the coroutine, it propagates
back to the caller.



()¶
Causes the coroutine to clean itself up and exit.  If the coroutine
is suspended, this method first delegates to the 
method of the iterator that caused the coroutine to suspend, if it
has such a method.  Then it raises  at the
suspension point, causing the coroutine to immediately clean itself up.
Finally, the coroutine is marked as having finished executing, even if
it was never started.
Coroutine objects are automatically closed using the above process when
they are about to be destroyed.



3.4.3. Asynchronous Iterators¶
An asynchronous iterator can call asynchronous code in
its  method.
Asynchronous iterators can be used in an  statement.


(self)¶
Must return an asynchronous iterator object.



(self)¶
Must return an awaitable resulting in a next value of the iterator.  Should
raise a  error when the iteration is over.

An example of an asynchronous iterable object:



New in version 3.5.


Changed in version 3.7: Prior to Python 3.7,  could return an awaitable
that would resolve to an
asynchronous iterator.
Starting with Python 3.7,  must return an
asynchronous iterator object.  Returning anything else
will result in a  error.



3.4.4. Asynchronous Context Managers¶
An asynchronous context manager is a context manager that is able to
suspend execution in its  and  methods.
Asynchronous context managers can be used in an  statement.


(self)¶
This method is semantically similar to the , with only
difference that it must return an awaitable.



(self, exc_type, exc_value, traceback)¶
This method is semantically similar to the , with only
difference that it must return an awaitable.

An example of an asynchronous context manager class:



New in version 3.5.

Footnotes



[1]It is possible in some cases to change an object’s type, under certain
controlled conditions. It generally isn’t a good idea though, since it can
lead to some very strange behaviour if it is handled incorrectly.





[2]The , , , and
 methods have special handling for this; others
will still raise a , but may do so by relying on
the behavior that  is not callable.





[3]“Does not support” here means that the class has no such method, or
the method returns .  Do not set the method to
 if you want to force fallback to the right operand’s reflected
method—that will instead have the opposite effect of explicitly
blocking such fallback.





[4]For operands of the same type, it is assumed that if the non-reflected method
(such as ) fails the operation is not supported, which is why the
reflected method is not called.





