link:
library/sqlite3.html

docs:


 — DB-API 2.0 interface for SQLite databases¶
Source code: Lib/sqlite3/

SQLite is a C library that provides a lightweight disk-based database that
doesn’t require a separate server process and allows accessing the database
using a nonstandard variant of the SQL query language. Some applications can use
SQLite for internal data storage.  It’s also possible to prototype an
application using SQLite and then port the code to a larger database such as
PostgreSQL or Oracle.
The sqlite3 module was written by Gerhard Häring.  It provides a SQL interface
compliant with the DB-API 2.0 specification described by PEP 249.
To use the module, you must first create a  object that
represents the database.  Here the data will be stored in the
 file:


You can also supply the special name  to create a database in RAM.
Once you have a , you can create a   object
and call its  method to perform SQL commands:


The data you’ve saved is persistent and is available in subsequent sessions:


Usually your SQL operations will need to use values from Python variables.  You
shouldn’t assemble your query using Python’s string operations because doing so
is insecure; it makes your program vulnerable to an SQL injection attack
(see https://xkcd.com/327/ for humorous example of what can go wrong).
Instead, use the DB-API’s parameter substitution.  Put  as a placeholder
wherever you want to use a value, and then provide a tuple of values as the
second argument to the cursor’s  method.  (Other database
modules may use a different placeholder, such as  or .) For
example:


To retrieve data after executing a SELECT statement, you can either treat the
cursor as an iterator, call the cursor’s  method to
retrieve a single matching row, or call  to get a list of the
matching rows.
This example uses the iterator form:



See also

https://github.com/ghaering/pysqlite
The pysqlite web page – sqlite3 is developed externally under the name
“pysqlite”.
https://www.sqlite.org
The SQLite web page; the documentation describes the syntax and the
available data types for the supported SQL dialect.
https://www.w3schools.com/sql/
Tutorial, reference and examples for learning SQL syntax.
PEP 249 - Database API Specification 2.0
PEP written by Marc-André Lemburg.



Module functions and constants¶


¶
The version number of this module, as a string. This is not the version of
the SQLite library.



¶
The version number of this module, as a tuple of integers. This is not the
version of the SQLite library.



¶
The version number of the run-time SQLite library, as a string.



¶
The version number of the run-time SQLite library, as a tuple of integers.



¶
This constant is meant to be used with the detect_types parameter of the
 function.
Setting it makes the  module parse the declared type for each
column it returns.  It will parse out the first word of the declared type,
i. e.  for “integer primary key”, it will parse out “integer”, or for
“number(10)” it will parse out “number”. Then for that column, it will look
into the converters dictionary and use the converter function registered for
that type there.



¶
This constant is meant to be used with the detect_types parameter of the
 function.
Setting this makes the SQLite interface parse the column name for each column it
returns.  It will look for a string formed [mytype] in there, and then decide
that ‘mytype’ is the type of the column. It will try to find an entry of
‘mytype’ in the converters dictionary and then use the converter function found
there to return the value. The column name found in 
is only the first word of the column name, i.  e. if you use something like
 in your SQL, then we will parse out everything until the
first blank for the column name: the column name would simply be “x”.



(database[, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements, uri])¶
Opens a connection to the SQLite database file database. By default returns a
 object, unless a custom factory is given.
database is a path-like object giving the pathname (absolute or
relative to the current  working directory) of the database file to be opened.
You can use  to open a database connection to a database that
resides in RAM instead of on disk.
When a database is accessed by multiple connections, and one of the processes
modifies the database, the SQLite database is locked until that transaction is
committed. The timeout parameter specifies how long the connection should wait
for the lock to go away until raising an exception. The default for the timeout
parameter is 5.0 (five seconds).
For the isolation_level parameter, please see the
 property of  objects.
SQLite natively supports only the types TEXT, INTEGER, REAL, BLOB and NULL. If
you want to use other types you must add support for them yourself. The
detect_types parameter and the using custom converters registered with the
module-level  function allow you to easily do that.
detect_types defaults to 0 (i. e. off, no type detection), you can set it to
any combination of  and  to turn
type detection on.
By default, check_same_thread is  and only the creating thread may
use the connection. If set , the returned connection may be shared
across multiple threads. When using multiple threads with the same connection
writing operations should be serialized by the user to avoid data corruption.
By default, the  module uses its  class for the
connect call.  You can, however, subclass the  class and make
 use your class instead by providing your class for the factory
parameter.
Consult the section SQLite and Python types of this manual for details.
The  module internally uses a statement cache to avoid SQL parsing
overhead. If you want to explicitly set the number of statements that are cached
for the connection, you can set the cached_statements parameter. The currently
implemented default is to cache 100 statements.
If uri is true, database is interpreted as a URI. This allows you
to specify options. For example, to open a database in read-only mode
you can use:


More information about this feature, including a list of recognized options, can
be found in the SQLite URI documentation.

Changed in version 3.4: Added the uri parameter.


Changed in version 3.7: database can now also be a path-like object, not only a string.




(typename, callable)¶
Registers a callable to convert a bytestring from the database into a custom
Python type. The callable will be invoked for all database values that are of
the type typename. Confer the parameter detect_types of the 
function for how the type detection works. Note that typename and the name of
the type in your query are matched in case-insensitive manner.



(type, callable)¶
Registers a callable to convert the custom Python type type into one of
SQLite’s supported types. The callable callable accepts as single parameter
the Python value, and must return a value of the following types: int,
float, str or bytes.



(sql)¶
Returns  if the string sql contains one or more complete SQL
statements terminated by semicolons. It does not verify that the SQL is
syntactically correct, only that there are no unclosed string literals and the
statement is terminated by a semicolon.
This can be used to build a shell for SQLite, as in the following example:





(flag)¶
By default you will not get any tracebacks in user-defined functions,
aggregates, converters, authorizer callbacks etc. If you want to debug them,
you can call this function with flag set to . Afterwards, you will
get tracebacks from callbacks on . Use  to
disable the feature again.



Connection Objects¶


class ¶
A SQLite database connection has the following attributes and methods:


¶
Get or set the current default isolation level.  for autocommit mode or
one of “DEFERRED”, “IMMEDIATE” or “EXCLUSIVE”. See section
Controlling Transactions for a more detailed explanation.



¶
 if a transaction is active (there are uncommitted changes),
 otherwise.  Read-only attribute.

New in version 3.2.




(factory=Cursor)¶
The cursor method accepts a single optional parameter factory. If
supplied, this must be a callable returning an instance of 
or its subclasses.



()¶
This method commits the current transaction. If you don’t call this method,
anything you did since the last call to  is not visible from
other database connections. If you wonder why you don’t see the data you’ve
written to the database, please check you didn’t forget to call this method.



()¶
This method rolls back any changes to the database since the last call to
.



()¶
This closes the database connection. Note that this does not automatically
call . If you just close your database connection without
calling  first, your changes will be lost!



(sql[, parameters])¶
This is a nonstandard shortcut that creates a cursor object by calling
the  method, calls the cursor’s
 method with the parameters given, and returns
the cursor.



(sql[, parameters])¶
This is a nonstandard shortcut that creates a cursor object by
calling the  method, calls the cursor’s
 method with the parameters given, and
returns the cursor.



(sql_script)¶
This is a nonstandard shortcut that creates a cursor object by
calling the  method, calls the cursor’s
 method with the given sql_script, and
returns the cursor.



(name, num_params, func)¶
Creates a user-defined function that you can later use from within SQL
statements under the function name name. num_params is the number of
parameters the function accepts (if num_params is -1, the function may
take any number of arguments), and func is a Python callable that is
called as the SQL function.
The function can return any of the types supported by SQLite: bytes, str, int,
float and .
Example:





(name, num_params, aggregate_class)¶
Creates a user-defined aggregate function.
The aggregate class must implement a  method, which accepts the number
of parameters num_params (if num_params is -1, the function may take
any number of arguments), and a  method which will return the
final result of the aggregate.
The  method can return any of the types supported by SQLite:
bytes, str, int, float and .
Example:





(name, callable)¶
Creates a collation with the specified name and callable. The callable will
be passed two string arguments. It should return -1 if the first is ordered
lower than the second, 0 if they are ordered equal and 1 if the first is ordered
higher than the second.  Note that this controls sorting (ORDER BY in SQL) so
your comparisons don’t affect other SQL operations.
Note that the callable will get its parameters as Python bytestrings, which will
normally be encoded in UTF-8.
The following example shows a custom collation that sorts “the wrong way”:


To remove a collation, call  with  as callable:





()¶
You can call this method from a different thread to abort any queries that might
be executing on the connection. The query will then abort and the caller will
get an exception.



(authorizer_callback)¶
This routine registers a callback. The callback is invoked for each attempt to
access a column of a table in the database. The callback should return
 if access is allowed,  if the entire SQL
statement should be aborted with an error and  if the
column should be treated as a NULL value. These constants are available in the
 module.
The first argument to the callback signifies what kind of operation is to be
authorized. The second and third argument will be arguments or 
depending on the first argument. The 4th argument is the name of the database
(“main”, “temp”, etc.) if applicable. The 5th argument is the name of the
inner-most trigger or view that is responsible for the access attempt or
 if this access attempt is directly from input SQL code.
Please consult the SQLite documentation about the possible values for the first
argument and the meaning of the second and third argument depending on the first
one. All necessary constants are available in the  module.



(handler, n)¶
This routine registers a callback. The callback is invoked for every n
instructions of the SQLite virtual machine. This is useful if you want to
get called from SQLite during long-running operations, for example to update
a GUI.
If you want to clear any previously installed progress handler, call the
method with  for handler.
Returning a non-zero value from the handler function will terminate the
currently executing query and cause it to raise an 
exception.



(trace_callback)¶
Registers trace_callback to be called for each SQL statement that is
actually executed by the SQLite backend.
The only argument passed to the callback is the statement (as string) that
is being executed. The return value of the callback is ignored. Note that
the backend does not only run statements passed to the 
methods.  Other sources include the transaction management of the Python
module and the execution of triggers defined in the current database.
Passing  as trace_callback will disable the trace callback.

New in version 3.3.




(enabled)¶
This routine allows/disallows the SQLite engine to load SQLite extensions
from shared libraries.  SQLite extensions can define new functions,
aggregates or whole new virtual table implementations.  One well-known
extension is the fulltext-search extension distributed with SQLite.
Loadable extensions are disabled by default. See [1].

New in version 3.2.






(path)¶
This routine loads a SQLite extension from a shared library.  You have to
enable extension loading with  before you can
use this routine.
Loadable extensions are disabled by default. See [1].

New in version 3.2.




¶
You can change this attribute to a callable that accepts the cursor and the
original row as a tuple and will return the real result row.  This way, you can
implement more advanced ways of returning results, such  as returning an object
that can also access columns by name.
Example:


If returning a tuple doesn’t suffice and you want name-based access to
columns, you should consider setting  to the
highly-optimized  type.  provides both
index-based and case-insensitive name-based access to columns with almost no
memory overhead. It will probably be better than your own custom
dictionary-based approach or even a db_row based solution.



¶
Using this attribute you can control what objects are returned for the 
data type. By default, this attribute is set to  and the
 module will return Unicode objects for . If you want to
return bytestrings instead, you can set it to .
You can also set it to any other callable that accepts a single bytestring
parameter and returns the resulting object.
See the following example code for illustration:





¶
Returns the total number of database rows that have been modified, inserted, or
deleted since the database connection was opened.



()¶
Returns an iterator to dump the database in an SQL text format.  Useful when
saving an in-memory database for later restoration.  This function provides
the same capabilities as the .dump command in the sqlite3
shell.
Example:





(target, *, pages=0, progress=None, name="main", sleep=0.250)¶
This method makes a backup of a SQLite database even while it’s being accessed
by other clients, or concurrently by the same connection.  The copy will be
written into the mandatory argument target, that must be another
 instance.
By default, or when pages is either  or a negative integer, the entire
database is copied in a single step; otherwise the method performs a loop
copying up to pages pages at a time.
If progress is specified, it must either be  or a callable object that
will be executed at each iteration with three integer arguments, respectively
the status of the last iteration, the remaining number of pages still to be
copied and the total number of pages.
The name argument specifies the database name that will be copied: it must be
a string containing either , the default, to indicate the main
database,  to indicate the temporary database or the name specified
after the  keyword in an  statement for an attached
database.
The sleep argument specifies the number of seconds to sleep by between
successive attempts to backup remaining pages, can be specified either as an
integer or a floating point value.
Example 1, copy an existing database into another:


Example 2, copy an existing database into a transient copy:


Availability: SQLite 3.6.11 or higher

New in version 3.7.





Cursor Objects¶


class ¶
A  instance has the following attributes and methods.


(sql[, parameters])¶
Executes an SQL statement. The SQL statement may be parameterized (i. e.
placeholders instead of SQL literals). The  module supports two
kinds of placeholders: question marks (qmark style) and named placeholders
(named style).
Here’s an example of both styles:


 will only execute a single SQL statement. If you try to execute
more than one statement with it, it will raise a . Use
 if you want to execute multiple SQL statements with one
call.



(sql, seq_of_parameters)¶
Executes an SQL command against all parameter sequences or mappings found in
the sequence seq_of_parameters.  The  module also allows
using an iterator yielding parameters instead of a sequence.


Here’s a shorter example using a generator:





(sql_script)¶
This is a nonstandard convenience method for executing multiple SQL statements
at once. It issues a  statement first, then executes the SQL script it
gets as a parameter.
sql_script can be an instance of .
Example:





()¶
Fetches the next row of a query result set, returning a single sequence,
or  when no more data is available.



(size=cursor.arraysize)¶
Fetches the next set of rows of a query result, returning a list.  An empty
list is returned when no more rows are available.
The number of rows to fetch per call is specified by the size parameter.
If it is not given, the cursor’s arraysize determines the number of rows
to be fetched. The method should try to fetch as many rows as indicated by
the size parameter. If this is not possible due to the specified number of
rows not being available, fewer rows may be returned.
Note there are performance considerations involved with the size parameter.
For optimal performance, it is usually best to use the arraysize attribute.
If the size parameter is used, then it is best for it to retain the same
value from one  call to the next.



()¶
Fetches all (remaining) rows of a query result, returning a list.  Note that
the cursor’s arraysize attribute can affect the performance of this operation.
An empty list is returned when no rows are available.



()¶
Close the cursor now (rather than whenever  is called).
The cursor will be unusable from this point forward; a 
exception will be raised if any operation is attempted with the cursor.



¶
Although the  class of the  module implements this
attribute, the database engine’s own support for the determination of “rows
affected”/”rows selected” is quirky.
For  statements, the number of modifications are summed up
into .
As required by the Python DB API Spec, the  attribute “is -1 in
case no  has been performed on the cursor or the rowcount of the
last operation is not determinable by the interface”. This includes 
statements because we cannot determine the number of rows a query produced
until all rows were fetched.
With SQLite versions before 3.6.5,  is set to 0 if
you make a  without any condition.



¶
This read-only attribute provides the rowid of the last modified row. It is
only set if you issued an  or a  statement using the
 method.  For operations other than  or
 or when  is called,  is
set to .
If the  or  statement failed to insert the previous
successful rowid is returned.

Changed in version 3.6: Added support for the  statement.




¶
Read/write attribute that controls the number of rows returned by .
The default value is 1 which means a single row would be fetched per call.



¶
This read-only attribute provides the column names of the last query. To
remain compatible with the Python DB API, it returns a 7-tuple for each
column where the last six items of each tuple are .
It is set for  statements without any matching rows as well.



¶
This read-only attribute provides the SQLite database 
used by the  object.  A  object created by
calling  will have a
 attribute that refers to con:






Row Objects¶


class ¶
A  instance serves as a highly optimized
 for  objects.
It tries to mimic a tuple in most of its features.
It supports mapping access by column name and index, iteration,
representation, equality testing and .
If two  objects have exactly the same columns and their
members are equal, they compare equal.


()¶
This method returns a list of column names. Immediately after a query,
it is the first member of each tuple in .


Changed in version 3.5: Added support of slicing.


Let’s assume we initialize a table as in the example given above:


Now we plug  in:




Exceptions¶


exception ¶
A subclass of .



exception ¶
The base class of the other exceptions in this module.  It is a subclass
of .



exception ¶
Exception raised for errors that are related to the database.



exception ¶
Exception raised when the relational integrity of the database is affected,
e.g. a foreign key check fails.  It is a subclass of .



exception ¶
Exception raised for programming errors, e.g. table not found or already
exists, syntax error in the SQL statement, wrong number of parameters
specified, etc.  It is a subclass of .



exception ¶
Exception raised for errors that are related to the database’s operation
and not necessarily under the control of the programmer, e.g. an unexpected
disconnect occurs, the data source name is not found, a transaction could
not be processed, etc.  It is a subclass of .



exception ¶
Exception raised in case a method or database API was used which is not
supported by the database, e.g. calling the 
method on a connection that does not support transaction or has
transactions turned off.  It is a subclass of .



SQLite and Python types¶

Introduction¶
SQLite natively supports the following types: , ,
, , .
The following Python types can thus be sent to SQLite without any problem:






Python type
SQLite type




















This is how SQLite types are converted to Python types by default:






SQLite type
Python type













depends on ,
 by default






The type system of the  module is extensible in two ways: you can
store additional Python types in a SQLite database via object adaptation, and
you can let the  module convert SQLite types to different Python
types via converters.


Using adapters to store additional Python types in SQLite databases¶
As described before, SQLite supports only a limited set of types natively. To
use other Python types with SQLite, you must adapt them to one of the
sqlite3 module’s supported types for SQLite: one of NoneType, int, float,
str, bytes.
There are two ways to enable the  module to adapt a custom Python
type to one of the supported ones.

Letting your object adapt itself¶
This is a good approach if you write the class yourself. Let’s suppose you have
a class like this:


Now you want to store the point in a single SQLite column.  First you’ll have to
choose one of the supported types first to be used for representing the point.
Let’s just use str and separate the coordinates using a semicolon. Then you need
to give your class a method  which must return
the converted value. The parameter protocol will be .




Registering an adapter callable¶
The other possibility is to create a function that converts the type to the
string representation and register the function with .


The  module has two default adapters for Python’s built-in
 and  types.  Now let’s suppose
we want to store  objects not in ISO representation,
but as a Unix timestamp.





Converting SQLite values to custom Python types¶
Writing an adapter lets you send custom Python types to SQLite. But to make it
really useful we need to make the Python to SQLite to Python roundtrip work.
Enter converters.
Let’s go back to the  class. We stored the x and y coordinates
separated via semicolons as strings in SQLite.
First, we’ll define a converter function that accepts the string as a parameter
and constructs a  object from it.

Note
Converter functions always get called with a  object, no
matter under which data type you sent the value to SQLite.



Now you need to make the  module know that what you select from
the database is actually a point. There are two ways of doing this:

Implicitly via the declared type
Explicitly via the column name

Both ways are described in section Module functions and constants, in the entries
for the constants  and .
The following example illustrates both approaches.




Default adapters and converters¶
There are default adapters for the date and datetime types in the datetime
module. They will be sent as ISO dates/ISO timestamps to SQLite.
The default converters are registered under the name “date” for
 and under the name “timestamp” for
.
This way, you can use date/timestamps from Python without any additional
fiddling in most cases. The format of the adapters is also compatible with the
experimental SQLite date/time functions.
The following example demonstrates this.


If a timestamp stored in SQLite has a fractional part longer than 6
numbers, its value will be truncated to microsecond precision by the
timestamp converter.



Controlling Transactions¶
The underlying  library operates in  mode by default,
but the Python  module by default does not.
 mode means that statements that modify the database take effect
immediately.  A  or  statement disables 
mode, and a , a , or a  that ends the
outermost transaction, turns  mode back on.
The Python  module by default issues a  statement
implicitly before a Data Modification Language (DML) statement (i.e.
///).
You can control which kind of  statements  implicitly
executes via the isolation_level parameter to the 
call, or via the  property of connections.
If you specify no isolation_level, a plain  is used, which is
equivalent to specifying .  Other possible values are 
and .
You can disable the  module’s implicit transaction management by
setting  to .  This will leave the underlying
 library operating in  mode.  You can then completely
control the transaction state by explicitly issuing , ,
, and  statements in your code.

Changed in version 3.6:  used to implicitly commit an open transaction before DDL
statements.  This is no longer the case.



Using  efficiently¶

Using shortcut methods¶
Using the nonstandard ,  and
 methods of the  object, your code can
be written more concisely because you don’t have to create the (often
superfluous)  objects explicitly. Instead, the 
objects are created implicitly and these shortcut methods return the cursor
objects. This way, you can execute a  statement and iterate over it
directly using only a single call on the  object.




Accessing columns by name instead of by index¶
One useful feature of the  module is the built-in
 class designed to be used as a row factory.
Rows wrapped with this class can be accessed both by index (like tuples) and
case-insensitively by name:




Using the connection as a context manager¶
Connection objects can be used as context managers
that automatically commit or rollback transactions.  In the event of an
exception, the transaction is rolled back; otherwise, the transaction is
committed:





Common issues¶

Multithreading¶
Older SQLite versions had issues with sharing connections between threads.
That’s why the Python module disallows sharing connections and cursors between
threads. If you still try to do so, you will get an exception at runtime.
The only exception is calling the  method, which
only makes sense to call from a different thread.
Footnotes



[1](1, 2) The sqlite3 module is not built with loadable extension support by
default, because some platforms (notably Mac OS X) have SQLite
libraries which are compiled without this feature. To get loadable
extension support, you must pass –enable-loadable-sqlite-extensions to
configure.





