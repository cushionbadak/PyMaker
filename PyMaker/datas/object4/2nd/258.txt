link:
reference/simple_stmts.html#simple-statements

docs:

7. Simple statements¶
A simple statement is comprised within a single logical line. Several simple
statements may occur on a single line separated by semicolons.  The syntax for
simple statements is:


7.1. Expression statements¶
Expression statements are used (mostly interactively) to compute and write a
value, or (usually) to call a procedure (a function that returns no meaningful
result; in Python, procedures return the value ).  Other uses of
expression statements are allowed and occasionally useful.  The syntax for an
expression statement is:

An expression statement evaluates the expression list (which may be a single
expression).
In interactive mode, if the value is not , it is converted to a string
using the built-in  function and the resulting string is written to
standard output on a line by itself (except if the result is , so that
procedure calls do not cause any output.)


7.2. Assignment statements¶
Assignment statements are used to (re)bind names to values and to modify
attributes or items of mutable objects:

(See section Primaries for the syntax definitions for attributeref,
subscription, and slicing.)
An assignment statement evaluates the expression list (remember that this can be
a single expression or a comma-separated list, the latter yielding a tuple) and
assigns the single resulting object to each of the target lists, from left to
right.
Assignment is defined recursively depending on the form of the target (list).
When a target is part of a mutable object (an attribute reference, subscription
or slicing), the mutable object must ultimately perform the assignment and
decide about its validity, and may raise an exception if the assignment is
unacceptable.  The rules observed by various types and the exceptions raised are
given with the definition of the object types (see section The standard type hierarchy).
Assignment of an object to a target list, optionally enclosed in parentheses or
square brackets, is recursively defined as follows.

If the target list is a single target with no trailing comma,
optionally in parentheses, the object is assigned to that target.
Else: The object must be an iterable with the same number of
items as there are targets in the target list, and the items are assigned,
from left to right, to the corresponding targets.
If the target list contains one target prefixed with an asterisk, called a
“starred” target: The object must be an iterable with at least as many items
as there are targets in the target list, minus one.  The first items of the
iterable are assigned, from left to right, to the targets before the starred
target.  The final items of the iterable are assigned to the targets after
the starred target.  A list of the remaining items in the iterable is then
assigned to the starred target (the list can be empty).
Else: The object must be an iterable with the same number of items as there
are targets in the target list, and the items are assigned, from left to
right, to the corresponding targets.



Assignment of an object to a single target is recursively defined as follows.

If the target is an identifier (name):

If the name does not occur in a  or 
statement in the current code block: the name is bound to the object in the
current local namespace.
Otherwise: the name is bound to the object in the global namespace or the
outer namespace determined by , respectively.

The name is rebound if it was already bound.  This may cause the reference
count for the object previously bound to the name to reach zero, causing the
object to be deallocated and its destructor (if it has one) to be called.

If the target is an attribute reference: The primary expression in the
reference is evaluated.  It should yield an object with assignable attributes;
if this is not the case,  is raised.  That object is then
asked to assign the assigned object to the given attribute; if it cannot
perform the assignment, it raises an exception (usually but not necessarily
).
Note: If the object is a class instance and the attribute reference occurs on
both sides of the assignment operator, the RHS expression,  can access
either an instance attribute or (if no instance attribute exists) a class
attribute.  The LHS target  is always set as an instance attribute,
creating it if necessary.  Thus, the two occurrences of  do not
necessarily refer to the same attribute: if the RHS expression refers to a
class attribute, the LHS creates a new instance attribute as the target of the
assignment:


This description does not necessarily apply to descriptor attributes, such as
properties created with .

If the target is a subscription: The primary expression in the reference is
evaluated.  It should yield either a mutable sequence object (such as a list)
or a mapping object (such as a dictionary).  Next, the subscript expression is
evaluated.
If the primary is a mutable sequence object (such as a list), the subscript
must yield an integer.  If it is negative, the sequence’s length is added to
it.  The resulting value must be a nonnegative integer less than the
sequence’s length, and the sequence is asked to assign the assigned object to
its item with that index.  If the index is out of range,  is
raised (assignment to a subscripted sequence cannot add new items to a list).
If the primary is a mapping object (such as a dictionary), the subscript must
have a type compatible with the mapping’s key type, and the mapping is then
asked to create a key/datum pair which maps the subscript to the assigned
object.  This can either replace an existing key/value pair with the same key
value, or insert a new key/value pair (if no key with the same value existed).
For user-defined objects, the  method is called with
appropriate arguments.

If the target is a slicing: The primary expression in the reference is
evaluated.  It should yield a mutable sequence object (such as a list).  The
assigned object should be a sequence object of the same type.  Next, the lower
and upper bound expressions are evaluated, insofar they are present; defaults
are zero and the sequence’s length.  The bounds should evaluate to integers.
If either bound is negative, the sequence’s length is added to it.  The
resulting bounds are clipped to lie between zero and the sequence’s length,
inclusive.  Finally, the sequence object is asked to replace the slice with
the items of the assigned sequence.  The length of the slice may be different
from the length of the assigned sequence, thus changing the length of the
target sequence, if the target sequence allows it.



CPython implementation detail: In the current implementation, the syntax for targets is taken to be the same
as for expressions, and invalid syntax is rejected during the code generation
phase, causing less detailed error messages.

Although the definition of assignment implies that overlaps between the
left-hand side and the right-hand side are ‘simultaneous’ (for example  swaps two variables), overlaps within the collection of assigned-to
variables occur left-to-right, sometimes resulting in confusion.  For instance,
the following program prints :



See also

PEP 3132 - Extended Iterable Unpacking
The specification for the  feature.



7.2.1. Augmented assignment statements¶
Augmented assignment is the combination, in a single statement, of a binary
operation and an assignment statement:

(See section Primaries for the syntax definitions of the last three
symbols.)
An augmented assignment evaluates the target (which, unlike normal assignment
statements, cannot be an unpacking) and the expression list, performs the binary
operation specific to the type of assignment on the two operands, and assigns
the result to the original target.  The target is only evaluated once.
An augmented assignment expression like  can be rewritten as  to achieve a similar, but not exactly equal effect. In the augmented
version,  is only evaluated once. Also, when possible, the actual operation
is performed in-place, meaning that rather than creating a new object and
assigning that to the target, the old object is modified instead.
Unlike normal assignments, augmented assignments evaluate the left-hand side
before evaluating the right-hand side.  For example,  first
looks-up , then it evaluates  and performs the addition, and
lastly, it writes the result back to .
With the exception of assigning to tuples and multiple targets in a single
statement, the assignment done by augmented assignment statements is handled the
same way as normal assignments. Similarly, with the exception of the possible
in-place behavior, the binary operation performed by augmented assignment is
the same as the normal binary operations.
For targets which are attribute references, the same caveat about class
and instance attributes applies as for regular assignments.


7.2.2. Annotated assignment statements¶
Annotation assignment is the combination, in a single
statement, of a variable or attribute annotation and an optional assignment statement:

The difference from normal Assignment statements is that only single target and
only single right hand side value is allowed.
For simple names as assignment targets, if in class or module scope,
the annotations are evaluated and stored in a special class or module
attribute 
that is a dictionary mapping from variable names (mangled if private) to
evaluated annotations. This attribute is writable and is automatically
created at the start of class or module body execution, if annotations
are found statically.
For expressions as assignment targets, the annotations are evaluated if
in class or module scope, but not stored.
If a name is annotated in a function scope, then this name is local for
that scope. Annotations are never evaluated and stored in function scopes.
If the right hand side is present, an annotated
assignment performs the actual assignment before evaluating annotations
(where applicable). If the right hand side is not present for an expression
target, then the interpreter evaluates the target except for the last
 or  call.

See also

PEP 526 - Syntax for Variable Annotations
The proposal that added syntax for annotating the types of variables
(including class variables and instance variables), instead of expressing
them through comments.
PEP 484 - Type hints
The proposal that added the  module to provide a standard
syntax for type annotations that can be used in static analysis tools and
IDEs.





7.3. The  statement¶
Assert statements are a convenient way to insert debugging assertions into a
program:

The simple form, , is equivalent to


The extended form, , is equivalent to


These equivalences assume that  and  refer to
the built-in variables with those names.  In the current implementation, the
built-in variable  is  under normal circumstances,
 when optimization is requested (command line option ).  The current
code generator emits no code for an assert statement when optimization is
requested at compile time.  Note that it is unnecessary to include the source
code for the expression that failed in the error message; it will be displayed
as part of the stack trace.
Assignments to  are illegal.  The value for the built-in variable
is determined when the interpreter starts.


7.4. The  statement¶

 is a null operation — when it is executed, nothing happens.
It is useful as a placeholder when a statement is required syntactically, but no
code needs to be executed, for example:




7.5. The  statement¶

Deletion is recursively defined very similar to the way assignment is defined.
Rather than spelling it out in full details, here are some hints.
Deletion of a target list recursively deletes each target, from left to right.
Deletion of a name removes the binding of that name from the local or global
namespace, depending on whether the name occurs in a  statement
in the same code block.  If the name is unbound, a  exception
will be raised.
Deletion of attribute references, subscriptions and slicings is passed to the
primary object involved; deletion of a slicing is in general equivalent to
assignment of an empty slice of the right type (but even this is determined by
the sliced object).

Changed in version 3.2: Previously it was illegal to delete a name from the local namespace if it
occurs as a free variable in a nested block.



7.6. The  statement¶

 may only occur syntactically nested in a function definition,
not within a nested class definition.
If an expression list is present, it is evaluated, else  is substituted.
 leaves the current function call with the expression list (or
) as return value.
When  passes control out of a  statement with a
 clause, that  clause is executed before
really leaving the function.
In a generator function, the  statement indicates that the
generator is done and will cause  to be raised. The returned
value (if any) is used as an argument to construct  and
becomes the  attribute.
In an asynchronous generator function, an empty  statement
indicates that the asynchronous generator is done and will cause
 to be raised.  A non-empty 
statement is a syntax error in an asynchronous generator function.


7.7. The  statement¶

A  statement is semantically equivalent to a yield
expression. The yield statement can be used to omit the parentheses
that would otherwise be required in the equivalent yield expression
statement. For example, the yield statements


are equivalent to the yield expression statements


Yield expressions and statements are only used when defining a generator
function, and are only used in the body of the generator function.  Using yield
in a function definition is sufficient to cause that definition to create a
generator function instead of a normal function.
For full details of  semantics, refer to the
Yield expressions section.


7.8. The  statement¶

If no expressions are present,  re-raises the last exception
that was active in the current scope.  If no exception is active in the current
scope, a  exception is raised indicating that this is an
error.
Otherwise,  evaluates the first expression as the exception
object.  It must be either a subclass or an instance of .
If it is a class, the exception instance will be obtained when needed by
instantiating the class with no arguments.
The type of the exception is the exception instance’s class, the
value is the instance itself.
A traceback object is normally created automatically when an exception is raised
and attached to it as the  attribute, which is writable.
You can create an exception and set your own traceback in one step using the
 exception method (which returns the same exception
instance, with its traceback set to its argument), like so:


The  clause is used for exception chaining: if given, the second
expression must be another exception class or instance, which will then be
attached to the raised exception as the  attribute (which is
writable).  If the raised exception is not handled, both exceptions will be
printed:


A similar mechanism works implicitly if an exception is raised inside an
exception handler or a  clause: the previous exception is then
attached as the new exception’s  attribute:


Exception chaining can be explicitly suppressed by specifying  in
the  clause:


Additional information on exceptions can be found in section Exceptions,
and information about handling exceptions is in section The try statement.

Changed in version 3.3:  is now permitted as  in .


New in version 3.3: The  attribute to suppress automatic display of the
exception context.



7.9. The  statement¶

 may only occur syntactically nested in a  or
 loop, but not nested in a function or class definition within
that loop.
It terminates the nearest enclosing loop, skipping the optional 
clause if the loop has one.
If a  loop is terminated by , the loop control
target keeps its current value.
When  passes control out of a  statement with a
 clause, that  clause is executed before
really leaving the loop.


7.10. The  statement¶

 may only occur syntactically nested in a  or
 loop, but not nested in a function or class definition or
 clause within that loop.  It continues with the next
cycle of the nearest enclosing loop.
When  passes control out of a  statement with a
 clause, that  clause is executed before
really starting the next loop cycle.


7.11. The  statement¶

The basic import statement (no  clause) is executed in two
steps:

find a module, loading and initializing it if necessary
define a name or names in the local namespace for the scope where
the  statement occurs.

When the statement contains multiple clauses (separated by
commas) the two steps are carried out separately for each clause, just
as though the clauses had been separated out into individual import
statements.
The details of the first step, finding and loading modules are described in
greater detail in the section on the import system,
which also describes the various types of packages and modules that can
be imported, as well as all the hooks that can be used to customize
the import system. Note that failures in this step may indicate either
that the module could not be located, or that an error occurred while
initializing the module, which includes execution of the module’s code.
If the requested module is retrieved successfully, it will be made
available in the local namespace in one of three ways:

If the module name is followed by , then the name
following  is bound directly to the imported module.
If no other name is specified, and the module being imported is a top
level module, the module’s name is bound in the local namespace as a
reference to the imported module
If the module being imported is not a top level module, then the name
of the top level package that contains the module is bound in the local
namespace as a reference to the top level package. The imported module
must be accessed using its full qualified name rather than directly

The  form uses a slightly more complex process:

find the module specified in the  clause, loading and
initializing it if necessary;
for each of the identifiers specified in the  clauses:
check if the imported module has an attribute by that name
if not, attempt to import a submodule with that name and then
check the imported module again for that attribute
if the attribute is not found,  is raised.
otherwise, a reference to that value is stored in the local namespace,
using the name in the  clause if it is present,
otherwise using the attribute name



Examples:


If the list of identifiers is replaced by a star (), all public
names defined in the module are bound in the local namespace for the scope
where the  statement occurs.
The public names defined by a module are determined by checking the module’s
namespace for a variable named ; if defined, it must be a sequence
of strings which are names defined or imported by that module.  The names
given in  are all considered public and are required to exist.  If
 is not defined, the set of public names includes all names found
in the module’s namespace which do not begin with an underscore character
().   should contain the entire public API. It is intended
to avoid accidentally exporting items that are not part of the API (such as
library modules which were imported and used within the module).
The wild card form of import —  — is only allowed at
the module level.  Attempting to use it in class or function definitions will
raise a .
When specifying what module to import you do not have to specify the absolute
name of the module. When a module or package is contained within another
package it is possible to make a relative import within the same top package
without having to mention the package name. By using leading dots in the
specified module or package after  you can specify how high to
traverse up the current package hierarchy without specifying exact names. One
leading dot means the current package where the module making the import
exists. Two dots means up one package level. Three dots is up two levels, etc.
So if you execute  from a module in the  package
then you will end up importing . If you execute  from within  you will import .
The specification for relative imports is contained in
the Package Relative Imports section.
 is provided to support applications that
determine dynamically the modules to be loaded.

7.11.1. Future statements¶
A future statement is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be available in a
specified future release of Python where the feature becomes standard.
The future statement is intended to ease migration to future versions of Python
that introduce incompatible changes to the language.  It allows use of the new
features on a per-module basis before the release in which the feature becomes
standard.

A future statement must appear near the top of the module.  The only lines that
can appear before a future statement are:

the module docstring (if any),
comments,
blank lines, and
other future statements.

The only feature in Python 3.7 that requires using the future statement is
.
All historical features enabled by the future statement are still recognized
by Python 3.  The list includes , ,
, , ,
,  and .  They are
all redundant because they are always enabled, and only kept for
backwards compatibility.
A future statement is recognized and treated specially at compile time: Changes
to the semantics of core constructs are often implemented by generating
different code.  It may even be the case that a new feature introduces new
incompatible syntax (such as a new reserved word), in which case the compiler
may need to parse the module differently.  Such decisions cannot be pushed off
until runtime.
For any given release, the compiler knows which feature names have been defined,
and raises a compile-time error if a future statement contains a feature not
known to it.
The direct runtime semantics are the same as for any import statement: there is
a standard module , described later, and it will be imported in
the usual way at the time the future statement is executed.
The interesting runtime semantics depend on the specific feature enabled by the
future statement.
Note that there is nothing special about the statement:


That is not a future statement; it’s an ordinary import statement with no
special semantics or syntax restrictions.
Code compiled by calls to the built-in functions  and 
that occur in a module  containing a future statement will, by default,
use the new syntax or semantics associated with the future statement.  This can
be controlled by optional arguments to  — see the documentation
of that function for details.
A future statement typed at an interactive interpreter prompt will take effect
for the rest of the interpreter session.  If an interpreter is started with the
 option, is passed a script name to execute, and the script includes
a future statement, it will be in effect in the interactive session started
after the script is executed.

See also

PEP 236 - Back to the __future__
The original proposal for the __future__ mechanism.





7.12. The  statement¶

The  statement is a declaration which holds for the entire
current code block.  It means that the listed identifiers are to be interpreted
as globals.  It would be impossible to assign to a global variable without
, although free variables may refer to globals without being
declared global.
Names listed in a  statement must not be used in the same code
block textually preceding that  statement.
Names listed in a  statement must not be defined as formal
parameters or in a  loop control target, 
definition, function definition,  statement, or variable
annotation.

CPython implementation detail: The current implementation does not enforce some of these restrictions, but
programs should not abuse this freedom, as future implementations may enforce
them or silently change the meaning of the program.

Programmer’s note:  is a directive to the parser.  It
applies only to code parsed at the same time as the  statement.
In particular, a  statement contained in a string or code
object supplied to the built-in  function does not affect the code
block containing the function call, and code contained in such a string is
unaffected by  statements in the code containing the function
call.  The same applies to the  and  functions.


7.13. The  statement¶

The  statement causes the listed identifiers to refer to
previously bound variables in the nearest enclosing scope excluding globals.
This is important because the default behavior for binding is to search the
local namespace first.  The statement allows encapsulated code to rebind
variables outside of the local scope besides the global (module) scope.
Names listed in a  statement, unlike those listed in a
 statement, must refer to pre-existing bindings in an
enclosing scope (the scope in which a new binding should be created cannot
be determined unambiguously).
Names listed in a  statement must not collide with
pre-existing bindings in the local scope.

See also

PEP 3104 - Access to Names in Outer Scopes
The specification for the  statement.



