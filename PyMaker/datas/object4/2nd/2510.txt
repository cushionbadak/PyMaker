link:
library/lzma.html

docs:


 — Compression using the LZMA algorithm¶

New in version 3.3.

Source code: Lib/lzma.py

This module provides classes and convenience functions for compressing and
decompressing data using the LZMA compression algorithm. Also included is a file
interface supporting the  and legacy  file formats used by the
xz utility, as well as raw compressed streams.
The interface provided by this module is very similar to that of the 
module. However, note that  is not thread-safe, unlike
, so if you need to use a single  instance
from multiple threads, it is necessary to protect it with a lock.


exception ¶
This exception is raised when an error occurs during compression or
decompression, or while initializing the compressor/decompressor state.


Reading and writing compressed files¶


(filename, mode="rb", *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)¶
Open an LZMA-compressed file in binary or text mode, returning a file
object.
The filename argument can be either an actual file name (given as a
,  or path-like object), in
which case the named file is opened, or it can be an existing file object
to read from or write to.
The mode argument can be any of , , , ,
, ,  or  for binary mode, or ,
, , or  for text mode. The default is .
When opening a file for reading, the format and filters arguments have
the same meanings as for . In this case, the check
and preset arguments should not be used.
When opening a file for writing, the format, check, preset and
filters arguments have the same meanings as for .
For binary mode, this function is equivalent to the 
constructor: . In this case, the encoding,
errors and newline arguments must not be provided.
For text mode, a  object is created, and wrapped in an
 instance with the specified encoding, error
handling behavior, and line ending(s).

Changed in version 3.4: Added support for the ,  and  modes.


Changed in version 3.6: Accepts a path-like object.




class (filename=None, mode="r", *, format=None, check=-1, preset=None, filters=None)¶
Open an LZMA-compressed file in binary mode.
An  can wrap an already-open file object, or operate
directly on a named file. The filename argument specifies either the file
object to wrap, or the name of the file to open (as a ,
 or path-like object). When wrapping an
existing file object, the wrapped file will not be closed when the
 is closed.
The mode argument can be either  for reading (default),  for
overwriting,  for exclusive creation, or  for appending. These
can equivalently be given as , ,  and 
respectively.
If filename is a file object (rather than an actual file name), a mode of
 does not truncate the file, and is instead equivalent to .
When opening a file for reading, the input file may be the concatenation of
multiple separate compressed streams. These are transparently decoded as a
single logical stream.
When opening a file for reading, the format and filters arguments have
the same meanings as for . In this case, the check
and preset arguments should not be used.
When opening a file for writing, the format, check, preset and
filters arguments have the same meanings as for .
 supports all the members specified by
, except for  and .
Iteration and the  statement are supported.
The following method is also provided:


(size=-1)¶
Return buffered data without advancing the file position. At least one
byte of data will be returned, unless EOF has been reached. The exact
number of bytes returned is unspecified (the size argument is ignored).

Note
While calling  does not change the file position of
the , it may change the position of the underlying
file object (e.g. if the  was constructed by passing a
file object for filename).



Changed in version 3.4: Added support for the  and  modes.


Changed in version 3.5: The  method now accepts an argument of
.


Changed in version 3.6: Accepts a path-like object.




Compressing and decompressing data in memory¶


class (format=FORMAT_XZ, check=-1, preset=None, filters=None)¶
Create a compressor object, which can be used to compress data incrementally.
For a more convenient way of compressing a single chunk of data, see
.
The format argument specifies what container format should be used.
Possible values are:


: The  container format.
This is the default format.



: The legacy  container format.
This format is more limited than  – it does not support integrity
checks or multiple filters.



: A raw data stream, not using any container format.
This format specifier does not support integrity checks, and requires that
you always specify a custom filter chain (for both compression and
decompression). Additionally, data compressed in this manner cannot be
decompressed using  (see ).



The check argument specifies the type of integrity check to include in the
compressed data. This check is used when decompressing, to ensure that the
data has not been corrupted. Possible values are:

: No integrity check.
This is the default (and the only acceptable value) for
 and .
: 32-bit Cyclic Redundancy Check.
: 64-bit Cyclic Redundancy Check.
This is the default for .
: 256-bit Secure Hash Algorithm.

If the specified check is not supported, an  is raised.
The compression settings can be specified either as a preset compression
level (with the preset argument), or in detail as a custom filter chain
(with the filters argument).
The preset argument (if provided) should be an integer between  and
 (inclusive), optionally OR-ed with the constant
. If neither preset nor filters are given, the
default behavior is to use  (preset level ).
Higher presets produce smaller output, but make the compression process
slower.

Note
In addition to being more CPU-intensive, compression with higher presets
also requires much more memory (and produces output that needs more memory
to decompress). With preset  for example, the overhead for an
 object can be as high as 800 MiB. For this reason,
it is generally best to stick with the default preset.

The filters argument (if provided) should be a filter chain specifier.
See Specifying custom filter chains for details.


(data)¶
Compress data (a  object), returning a 
object containing compressed data for at least part of the input. Some of
data may be buffered internally, for use in later calls to
 and . The returned data should be
concatenated with the output of any previous calls to .



()¶
Finish the compression process, returning a  object
containing any data stored in the compressor’s internal buffers.
The compressor cannot be used after this method has been called.




class (format=FORMAT_AUTO, memlimit=None, filters=None)¶
Create a decompressor object, which can be used to decompress data
incrementally.
For a more convenient way of decompressing an entire compressed stream at
once, see .
The format argument specifies the container format that should be used. The
default is , which can decompress both  and
 files. Other possible values are ,
, and .
The memlimit argument specifies a limit (in bytes) on the amount of memory
that the decompressor can use. When this argument is used, decompression will
fail with an  if it is not possible to decompress the input
within the given memory limit.
The filters argument specifies the filter chain that was used to create
the stream being decompressed. This argument is required if format is
, but should not be used for other formats.
See Specifying custom filter chains for more information about filter chains.

Note
This class does not transparently handle inputs containing multiple
compressed streams, unlike  and . To
decompress a multi-stream input with , you must
create a new decompressor for each stream.



(data, max_length=-1)¶
Decompress data (a bytes-like object), returning
uncompressed data as bytes. Some of data may be buffered
internally, for use in later calls to . The
returned data should be concatenated with the output of any
previous calls to .
If max_length is nonnegative, returns at most max_length
bytes of decompressed data. If this limit is reached and further
output can be produced, the  attribute will
be set to . In this case, the next call to
 may provide data as  to obtain
more of the output.
If all of the input data was decompressed and returned (either
because this was less than max_length bytes, or because
max_length was negative), the  attribute
will be set to .
Attempting to decompress data after the end of stream is reached
raises an EOFError.  Any data found after the end of the
stream is ignored and saved in the  attribute.

Changed in version 3.5: Added the max_length parameter.




¶
The ID of the integrity check used by the input stream. This may be
 until enough of the input has been decoded to
determine what integrity check it uses.



¶
 if the end-of-stream marker has been reached.



¶
Data found after the end of the compressed stream.
Before the end of the stream is reached, this will be .



¶
 if the  method can provide more
decompressed data before requiring new uncompressed input.

New in version 3.5.





(data, format=FORMAT_XZ, check=-1, preset=None, filters=None)¶
Compress data (a  object), returning the compressed data as a
 object.
See  above for a description of the format, check,
preset and filters arguments.



(data, format=FORMAT_AUTO, memlimit=None, filters=None)¶
Decompress data (a  object), returning the uncompressed data
as a  object.
If data is the concatenation of multiple distinct compressed streams,
decompress all of these streams, and return the concatenation of the results.
See  above for a description of the format,
memlimit and filters arguments.



Miscellaneous¶


(check)¶
Returns true if the given integrity check is supported on this system.
 and  are always supported.
 and  may be unavailable if you are
using a version of liblzma that was compiled with a limited
feature set.



Specifying custom filter chains¶
A filter chain specifier is a sequence of dictionaries, where each dictionary
contains the ID and options for a single filter. Each dictionary must contain
the key , and may contain additional keys to specify filter-dependent
options. Valid filter IDs are as follows:


Compression filters:

 (for use with )
 (for use with  and )





Delta filter:







Branch-Call-Jump (BCJ) filters:












A filter chain can consist of up to 4 filters, and cannot be empty. The last
filter in the chain must be a compression filter, and any other filters must be
delta or BCJ filters.
Compression filters support the following options (specified as additional
entries in the dictionary representing the filter):


: A compression preset to use as a source of default values for
options that are not specified explicitly.
: Dictionary size in bytes. This should be between 4 KiB and
1.5 GiB (inclusive).
: Number of literal context bits.
: Number of literal position bits. The sum  must be at
most 4.
: Number of position bits; must be at most 4.
:  or .
: What should be considered a “nice length” for a match.
This should be 273 or less.
: What match finder to use – , ,
, , or .
: Maximum search depth used by match finder. 0 (default) means to
select automatically based on other filter options.


The delta filter stores the differences between bytes, producing more repetitive
input for the compressor in certain circumstances. It supports one option,
. This indicates the distance between bytes to be subtracted. The
default is 1, i.e. take the differences between adjacent bytes.
The BCJ filters are intended to be applied to machine code. They convert
relative branches, calls and jumps in the code to use absolute addressing, with
the aim of increasing the redundancy that can be exploited by the compressor.
These filters support one option, . This specifies the address
that should be mapped to the beginning of the input data. The default is 0.


Examples¶
Reading in a compressed file:


Creating a compressed file:


Compressing data in memory:


Incremental compression:


Writing compressed data to an already-open file:


Creating a compressed file using a custom filter chain:




