link:
library/multiprocessing.html#all-start-methods

docs:

All start methods¶
The following applies to all start methods.
Avoid shared state

As far as possible one should try to avoid shifting large amounts of data
between processes.
It is probably best to stick to using queues or pipes for communication
between processes rather than using the lower level synchronization
primitives.

Picklability

Ensure that the arguments to the methods of proxies are picklable.
Thread safety of proxies

Do not use a proxy object from more than one thread unless you protect it
with a lock.
(There is never a problem with different processes using the same proxy.)

Joining zombie processes

On Unix when a process finishes but has not been joined it becomes a zombie.
There should never be very many because each time a new process starts (or
 is called) all completed processes
which have not yet been joined will be joined.  Also calling a finished
process’s  will
join the process.  Even so it is probably good
practice to explicitly join all the processes that you start.
Better to inherit than pickle/unpickle

When using the spawn or forkserver start methods many types
from  need to be picklable so that child
processes can use them.  However, one should generally avoid
sending shared objects to other processes using pipes or queues.
Instead you should arrange the program so that a process which
needs access to a shared resource created elsewhere can inherit it
from an ancestor process.
Avoid terminating processes

Using the 
method to stop a process is liable to
cause any shared resources (such as locks, semaphores, pipes and queues)
currently being used by the process to become broken or unavailable to other
processes.
Therefore it is probably best to only consider using
 on processes
which never use any shared resources.

Joining processes that use queues

Bear in mind that a process that has put items in a queue will wait before
terminating until all the buffered items are fed by the “feeder” thread to
the underlying pipe.  (The child process can call the

method of the queue to avoid this behaviour.)
This means that whenever you use a queue you need to make sure that all
items which have been put on the queue will eventually be removed before the
process is joined.  Otherwise you cannot be sure that processes which have
put items on the queue will terminate.  Remember also that non-daemonic
processes will be joined automatically.
An example which will deadlock is the following:


A fix here would be to swap the last two lines (or simply remove the
 line).

Explicitly pass resources to child processes

On Unix using the fork start method, a child process can make
use of a shared resource created in a parent process using a
global resource.  However, it is better to pass the object as an
argument to the constructor for the child process.
Apart from making the code (potentially) compatible with Windows
and the other start methods this also ensures that as long as the
child process is still alive the object will not be garbage
collected in the parent process.  This might be important if some
resource is freed when the object is garbage collected in the
parent process.
So for instance


should be rewritten as



Beware of replacing  with a “file like object”

 originally unconditionally called:


in the  method — this resulted
in issues with processes-in-processes. This has been changed to:


Which solves the fundamental issue of processes colliding with each other
resulting in a bad file descriptor error, but introduces a potential danger
to applications which replace  with a “file-like object”
with output buffering.  This danger is that if multiple processes call
 on this file-like object, it could result in the same
data being flushed to the object multiple times, resulting in corruption.
If you write a file-like object and implement your own caching, you can
make it fork-safe by storing the pid whenever you append to the cache,
and discarding the cache when the pid changes. For example:


For more information, see bpo-5155, bpo-5313 and bpo-5331

