link:
library/socket.html#socket-families

docs:

Socket families¶
Depending on the system and the build options, various socket families
are supported by this module.
The address format required by a particular socket object is automatically
selected based on the address family specified when the socket object was
created.  Socket addresses are represented as follows:

The address of an  socket bound to a file system node
is represented as a string, using the file system encoding and the
 error handler (see PEP 383).  An address in
Linux’s abstract namespace is returned as a bytes-like object with
an initial null byte; note that sockets in this namespace can
communicate with normal file system sockets, so programs intended to
run on Linux may need to deal with both types of address.  A string or
bytes-like object can be used for either type of address when
passing it as an argument.


Changed in version 3.3: Previously,  socket paths were assumed to use UTF-8
encoding.


Changed in version 3.5: Writable bytes-like object is now accepted.





A pair  is used for the  address family,
where host is a string representing either a hostname in Internet domain
notation like  or an IPv4 address like ,
and port is an integer.

For IPv4 addresses, two special forms are accepted instead of a host
address:  represents , which is used to bind to all
interfaces, and the string  represents
.  This behavior is not compatible with IPv6,
therefore, you may want to avoid these if you intend to support IPv6 with your
Python programs.


For  address family, a four-tuple  is used, where flowinfo and scopeid represent the 
and  members in  in C.  For
 module methods, flowinfo and scopeid can be omitted just for
backward compatibility.  Note, however, omission of scopeid can cause problems
in manipulating scoped IPv6 addresses.

Changed in version 3.7: For multicast addresses (with scopeid meaningful) address may not contain
 (or ) part. This information is superfluous and may
be safely omitted (recommended).


 sockets are represented as pairs .

Linux-only support for TIPC is available using the 
address family.  TIPC is an open, non-IP based networked protocol designed
for use in clustered computer environments.  Addresses are represented by a
tuple, and the fields depend on the address type. The general tuple form is
, where:

addr_type is one of , ,
or .

scope is one of , , and
.

If addr_type is , then v1 is the server type, v2 is
the port identifier, and v3 should be 0.
If addr_type is , then v1 is the server type, v2
is the lower port number, and v3 is the upper port number.
If addr_type is , then v1 is the node, v2 is the
reference, and v3 should be set to 0.



A tuple  is used for the  address family,
where interface is a string representing a network interface name like
. The network interface name  can be used to receive packets
from all network interfaces of this family.

 protocol require a tuple 
where both additional parameters are unsigned long integer that represent a
CAN identifier (standard or extended).


A string or a tuple  is used for the 
protocol of the  family. The string is the name of a
kernel control using a dynamically-assigned ID. The tuple can be used if ID
and unit number of the kernel control are known or if a registered ID is
used.

New in version 3.3.


 supports the following protocols and address
formats:

 accepts  where  is
the Bluetooth address as a string and  is an integer.

 accepts  where 
is the Bluetooth address as a string and  is an integer.

 accepts  where  is
either an integer or a string with the Bluetooth address of the
interface. (This depends on your OS; NetBSD and DragonFlyBSD expect
a Bluetooth address while everything else expects an integer.)

Changed in version 3.2: NetBSD and DragonFlyBSD support added.


 accepts  where  is a
 object containing the Bluetooth address in a
string format. (ex. ) This protocol is not
supported under FreeBSD.



 is a Linux-only socket based interface to Kernel
cryptography. An algorithm socket is configured with a tuple of two to four
elements , where:

type is the algorithm type as string, e.g. , ,
 or .
name is the algorithm name and operation mode as string, e.g.
, ,  or .
feat and mask are unsigned 32bit integers.

Availability: Linux 2.6.38, some algorithm types require more recent Kernels.

New in version 3.6.


 allows communication between virtual machines and
their hosts. The sockets are represented as a  tuple
where the context ID or CID and port are integers.
Availability: Linux >= 4.8 QEMU >= 2.8 ESX >= 4.0 ESX Workstation >= 6.5.

New in version 3.7.


 is a low-level interface directly to network devices.
The packets are represented by the tuple
 where:

ifname - String specifying the device name.
proto - An in network-byte-order integer specifying the Ethernet
protocol number.
pkttype - Optional integer specifying the packet type:
 (the default) - Packet addressed to the local host.
 - Physical-layer broadcast packet.
 - Packet sent to a physical-layer multicast address.
 - Packet to some other host that has been caught by
a device driver in promiscuous mode.
 - Packet originating from the local host that is
looped back to a packet socket.


hatype - Optional integer specifying the ARP hardware address type.
addr - Optional bytes-like object specifying the hardware physical
address, whose interpretation depends on the device.



If you use a hostname in the host portion of IPv4/v6 socket address, the
program may show a nondeterministic behavior, as Python uses the first address
returned from the DNS resolution.  The socket address will be resolved
differently into an actual IPv4/v6 address, depending on the results from DNS
resolution and/or the host configuration.  For deterministic behavior use a
numeric address in host portion.
All errors raise exceptions.  The normal exceptions for invalid argument types
and out-of-memory conditions can be raised; starting from Python 3.3, errors
related to socket or address semantics raise  or one of its
subclasses (they used to raise ).
Non-blocking mode is supported through .  A
generalization of this based on timeouts is supported through
.
