link:
library/threading.html#rlock-objects

docs:

RLock Objects¶
A reentrant lock is a synchronization primitive that may be acquired multiple
times by the same thread.  Internally, it uses the concepts of “owning thread”
and “recursion level” in addition to the locked/unlocked state used by primitive
locks.  In the locked state, some thread owns the lock; in the unlocked state,
no thread owns it.
To lock the lock, a thread calls its  method; this
returns once the thread owns the lock.  To unlock the lock, a thread calls
its  method. /
call pairs may be nested; only the final  (the
 of the outermost pair) resets the lock to unlocked and
allows another thread blocked in  to proceed.
Reentrant locks also support the context management protocol.


class ¶
This class implements reentrant lock objects.  A reentrant lock must be
released by the thread that acquired it.  Once a thread has acquired a
reentrant lock, the same thread may acquire it again without blocking; the
thread must release it once for each time it has acquired it.
Note that  is actually a factory function which returns an instance
of the most efficient version of the concrete RLock class that is supported
by the platform.


(blocking=True, timeout=-1)¶
Acquire a lock, blocking or non-blocking.
When invoked without arguments: if this thread already owns the lock, increment
the recursion level by one, and return immediately.  Otherwise, if another
thread owns the lock, block until the lock is unlocked.  Once the lock is
unlocked (not owned by any thread), then grab ownership, set the recursion level
to one, and return.  If more than one thread is blocked waiting until the lock
is unlocked, only one at a time will be able to grab ownership of the lock.
There is no return value in this case.
When invoked with the blocking argument set to true, do the same thing as when
called without arguments, and return true.
When invoked with the blocking argument set to false, do not block.  If a call
without an argument would block, return false immediately; otherwise, do the
same thing as when called without arguments, and return true.
When invoked with the floating-point timeout argument set to a positive
value, block for at most the number of seconds specified by timeout
and as long as the lock cannot be acquired.  Return true if the lock has
been acquired, false if the timeout has elapsed.

Changed in version 3.2: The timeout parameter is new.




()¶
Release a lock, decrementing the recursion level.  If after the decrement it is
zero, reset the lock to unlocked (not owned by any thread), and if any other
threads are blocked waiting for the lock to become unlocked, allow exactly one
of them to proceed.  If after the decrement the recursion level is still
nonzero, the lock remains locked and owned by the calling thread.
Only call this method when the calling thread owns the lock. A
 is raised if this method is called when the lock is
unlocked.
There is no return value.


