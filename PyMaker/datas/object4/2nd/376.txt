link:
library/stdtypes.html

docs:


Built-in Types¶
The following sections describe the standard types that are built into the
interpreter.
The principal built-in types are numerics, sequences, mappings, classes,
instances and exceptions.
Some collection classes are mutable.  The methods that add, subtract, or
rearrange their members in place, and don’t return a specific item, never return
the collection instance itself but .
Some operations are supported by several object types; in particular,
practically all objects can be compared, tested for truth value, and converted
to a string (with the  function or the slightly different
 function).  The latter function is implicitly used when an object is
written by the  function.

Truth Value Testing¶
Any object can be tested for truth value, for use in an  or
 condition or as operand of the Boolean operations below.
By default, an object is considered true unless its class defines either a
 method that returns  or a  method that
returns zero, when called with the object. [1]  Here are most of the built-in
objects considered false:



constants defined to be false:  and .
zero of any numeric type: , , , ,

empty sequences and collections: , , , , ,


Operations and built-in functions that have a Boolean result always return 
or  for false and  or  for true, unless otherwise stated.
(Important exception: the Boolean operations  and  always return
one of their operands.)


Boolean Operations — , , ¶
These are the Boolean operations, ordered by ascending priority:







Operation
Result
Notes




if x is false, then y, else
x
(1)


if x is false, then x, else
y
(2)


if x is false, then ,
else 
(3)



Notes:

This is a short-circuit operator, so it only evaluates the second
argument if the first one is false.
This is a short-circuit operator, so it only evaluates the second
argument if the first one is true.
 has a lower priority than non-Boolean operators, so  is
interpreted as , and  is a syntax error.



Comparisons¶
There are eight comparison operations in Python.  They all have the same
priority (which is higher than that of the Boolean operations).  Comparisons can
be chained arbitrarily; for example,  is equivalent to , except that y is evaluated only once (but in both cases z is not
evaluated at all when  is found to be false).
This table summarizes the comparison operations:






Operation
Meaning




strictly less than


less than or equal


strictly greater than


greater than or equal


equal


not equal


object identity


negated object identity



Objects of different types, except different numeric types, never compare equal.
Furthermore, some types (for example, function objects) support only a degenerate
notion of comparison where any two objects of that type are unequal.  The ,
,  and  operators will raise a  exception when
comparing a complex number with another built-in numeric type, when the objects
are of different types that cannot be compared, or in other cases where there is
no defined ordering.
Non-identical instances of a class normally compare as non-equal unless the
class defines the  method.
Instances of a class cannot be ordered with respect to other instances of the
same class, or other types of object, unless the class defines enough of the
methods , , , and  (in
general,  and  are sufficient, if you want the
conventional meanings of the comparison operators).
The behavior of the  and  operators cannot be
customized; also they can be applied to any two objects and never raise an
exception.
Two more operations with the same syntactic priority,  and
, are supported by types that are iterable or
implement the  method.


Numeric Types — , , ¶
There are three distinct numeric types: integers, floating
point numbers, and complex numbers.  In addition, Booleans are a
subtype of integers.  Integers have unlimited precision.  Floating point
numbers are usually implemented using  in C; information
about the precision and internal representation of floating point
numbers for the machine on which your program is running is available
in .  Complex numbers have a real and imaginary
part, which are each a floating point number.  To extract these parts
from a complex number z, use  and . (The standard
library includes additional numeric types,  that hold
rationals, and  that hold floating-point numbers with
user-definable precision.)
Numbers are created by numeric literals or as the result of built-in functions
and operators.  Unadorned integer literals (including hex, octal and binary
numbers) yield integers.  Numeric literals containing a decimal point or an
exponent sign yield floating point numbers.  Appending  or  to a
numeric literal yields an imaginary number (a complex number with a zero real
part) which you can add to an integer or float to get a complex number with real
and imaginary parts.
Python fully supports mixed arithmetic: when a binary arithmetic operator has
operands of different numeric types, the operand with the “narrower” type is
widened to that of the other, where integer is narrower than floating point,
which is narrower than complex.  Comparisons between numbers of mixed type use
the same rule. [2] The constructors , , and
 can be used to produce numbers of a specific type.
All numeric types (except complex) support the following operations, sorted by
ascending priority (all numeric operations have a higher priority than
comparison operations):








Operation
Result
Notes
Full documentation




sum of x and y
 
 


difference of x and y
 
 


product of x and y
 
 


quotient of x and y
 
 


floored quotient of x and
y
(1)
 


remainder of 
(2)
 


x negated
 
 


x unchanged
 
 


absolute value or magnitude of
x
 



x converted to integer
(3)(6)



x converted to floating point
(4)(6)



a complex number with real part
re, imaginary part im.
im defaults to zero.
(6)



conjugate of the complex number
c
 
 


the pair 
(2)



x to the power y
(5)



x to the power y
(5)
 



Notes:

Also referred to as integer division.  The resultant value is a whole
integer, though the result’s type is not necessarily int.  The result is
always rounded towards minus infinity:  is ,  is
,  is , and  is .

Not for complex numbers.  Instead convert to floats using  if
appropriate.

Conversion from floating point to integer may round or truncate
as in C; see functions  and  for
well-defined conversions.

float also accepts the strings “nan” and “inf” with an optional prefix “+”
or “-” for Not a Number (NaN) and positive or negative infinity.

Python defines  and  to be , as is common for
programming languages.

The numeric literals accepted include the digits  to  or any
Unicode equivalent (code points with the  property).
See http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt
for a complete list of code points with the  property.


All  types ( and ) also include
the following operations:






Operation
Result




x truncated to 


x rounded to n digits,
rounding half to even. If n is
omitted, it defaults to 0.


the greatest 
<= x


the least  >= x



For additional numeric operations see the  and 
modules.

Bitwise Operations on Integer Types¶
Bitwise operations only make sense for integers. The result of bitwise
operations is calculated as though carried out in two’s complement with an
infinite number of sign bits.
The priorities of the binary bitwise operations are all lower than the numeric
operations and higher than the comparisons; the unary operation  has the
same priority as the other unary numeric operations ( and ).
This table lists the bitwise operations sorted in ascending priority:







Operation
Result
Notes




bitwise or of x and
y
(4)


bitwise exclusive or of
x and y
(4)


bitwise and of x and
y
(4)


x shifted left by n bits
(1)(2)


x shifted right by n bits
(1)(3)


the bits of x inverted
 



Notes:

Negative shift counts are illegal and cause a  to be raised.
A left shift by n bits is equivalent to multiplication by 
without overflow check.
A right shift by n bits is equivalent to division by  without
overflow check.
Performing these calculations with at least one extra sign extension bit in
a finite two’s complement representation (a working bit-width of
 or more) is sufficient to get the
same result as if there were an infinite number of sign bits.



Additional Methods on Integer Types¶
The int type implements the  abstract base
class. In addition, it provides a few more methods:


()¶
Return the number of bits necessary to represent an integer in binary,
excluding the sign and leading zeros:


More precisely, if  is nonzero, then  is the
unique positive integer  such that .
Equivalently, when  is small enough to have a correctly
rounded logarithm, then .
If  is zero, then  returns .
Equivalent to:



New in version 3.1.




(length, byteorder, *, signed=False)¶
Return an array of bytes representing an integer.


The integer is represented using length bytes.  An 
is raised if the integer is not representable with the given number of
bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is , the most significant byte is at the
beginning of the byte array.  If byteorder is , the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use  as the byte order
value.
The signed argument determines whether two’s complement is used to
represent the integer.  If signed is  and a negative integer is
given, an  is raised. The default value for signed
is .

New in version 3.2.




classmethod (bytes, byteorder, *, signed=False)¶
Return the integer represented by the given array of bytes.


The argument bytes must either be a bytes-like object or an
iterable producing bytes.
The byteorder argument determines the byte order used to represent the
integer.  If byteorder is , the most significant byte is at the
beginning of the byte array.  If byteorder is , the most
significant byte is at the end of the byte array.  To request the native
byte order of the host system, use  as the byte order
value.
The signed argument indicates whether two’s complement is used to
represent the integer.

New in version 3.2.




Additional Methods on Float¶
The float type implements the  abstract base
class. float also has the following additional methods.


()¶
Return a pair of integers whose ratio is exactly equal to the
original float and with a positive denominator.  Raises
 on infinities and a  on
NaNs.



()¶
Return  if the float instance is finite with integral
value, and  otherwise:



Two methods support conversion to
and from hexadecimal strings.  Since Python’s floats are stored
internally as binary numbers, converting a float to or from a
decimal string usually involves a small rounding error.  In
contrast, hexadecimal strings allow exact representation and
specification of floating-point numbers.  This can be useful when
debugging, and in numerical work.


()¶
Return a representation of a floating-point number as a hexadecimal
string.  For finite floating-point numbers, this representation
will always include a leading  and a trailing  and
exponent.



classmethod (s)¶
Class method to return the float represented by a hexadecimal
string s.  The string s may have leading and trailing
whitespace.

Note that  is an instance method, while
 is a class method.
A hexadecimal string takes the form:


where the optional  may by either  or , 
and  are strings of hexadecimal digits, and 
is a decimal integer with an optional leading sign.  Case is not
significant, and there must be at least one hexadecimal digit in
either the integer or the fraction.  This syntax is similar to the
syntax specified in section 6.4.4.2 of the C99 standard, and also to
the syntax used in Java 1.5 onwards.  In particular, the output of
 is usable as a hexadecimal floating-point literal in
C or Java code, and hexadecimal strings produced by C’s  format
character or Java’s  are accepted by
.
Note that the exponent is written in decimal rather than hexadecimal,
and that it gives the power of 2 by which to multiply the coefficient.
For example, the hexadecimal string  represents the
floating-point number , or
:


Applying the reverse conversion to  gives a different
hexadecimal string representing the same number:




Hashing of numeric types¶
For numbers  and , possibly of different types, it’s a requirement
that  whenever  (see the 
method documentation for more details).  For ease of implementation and
efficiency across a variety of numeric types (including ,
,  and )
Python’s hash for numeric types is based on a single mathematical function
that’s defined for any rational number, and hence applies to all instances of
 and , and all finite instances of
 and .  Essentially, this function is
given by reduction modulo  for a fixed prime .  The value of  is
made available to Python as the  attribute of
.

CPython implementation detail: Currently, the prime used is  on machines with 32-bit C
longs and  on machines with 64-bit C longs.

Here are the rules in detail:

If  is a nonnegative rational number and  is not divisible
by , define  as , where  gives the inverse of  modulo .
If  is a nonnegative rational number and  is
divisible by  (but  is not) then  has no inverse
modulo  and the rule above doesn’t apply; in this case define
 to be the constant value .
If  is a negative rational number define 
as .  If the resulting hash is , replace it with
.
The particular values , 
and  are used as hash values for positive
infinity, negative infinity, or nans (respectively).  (All hashable
nans have the same hash value.)
For a  number , the hash values of the real
and imaginary parts are combined by computing , reduced modulo
 so that it lies in
.  Again, if the result is , it’s replaced with .

To clarify the above rules, here’s some example Python code,
equivalent to the built-in hash, for computing the hash of a rational
number, , or :





Iterator Types¶
Python supports a concept of iteration over containers.  This is implemented
using two distinct methods; these are used to allow user-defined classes to
support iteration.  Sequences, described below in more detail, always support
the iteration methods.
One method needs to be defined for container objects to provide iteration
support:


()¶
Return an iterator object.  The object is required to support the iterator
protocol described below.  If a container supports different types of
iteration, additional methods can be provided to specifically request
iterators for those iteration types.  (An example of an object supporting
multiple forms of iteration would be a tree structure which supports both
breadth-first and depth-first traversal.)  This method corresponds to the
 slot of the type structure for Python objects in the Python/C
API.

The iterator objects themselves are required to support the following two
methods, which together form the iterator protocol:


()¶
Return the iterator object itself.  This is required to allow both containers
and iterators to be used with the  and  statements.
This method corresponds to the  slot of the type structure for
Python objects in the Python/C API.



()¶
Return the next item from the container.  If there are no further items, raise
the  exception.  This method corresponds to the
 slot of the type structure for Python objects in the
Python/C API.

Python defines several iterator objects to support iteration over general and
specific sequence types, dictionaries, and other more specialized forms.  The
specific types are not important beyond their implementation of the iterator
protocol.
Once an iterator’s  method raises
, it must continue to do so on subsequent calls.
Implementations that do not obey this property are deemed broken.

Generator Types¶
Python’s generators provide a convenient way to implement the iterator
protocol.  If a container object’s  method is implemented as a
generator, it will automatically return an iterator object (technically, a
generator object) supplying the  and 
methods.
More information about generators can be found in the documentation for
the yield expression.



Sequence Types — , , ¶
There are three basic sequence types: lists, tuples, and range objects.
Additional sequence types tailored for processing of
binary data and text strings are
described in dedicated sections.

Common Sequence Operations¶
The operations in the following table are supported by most sequence types,
both mutable and immutable. The  ABC is
provided to make it easier to correctly implement these operations on
custom sequence types.
This table lists the sequence operations sorted in ascending priority.  In the
table, s and t are sequences of the same type, n, i, j and k are
integers and x is an arbitrary object that meets any type and value
restrictions imposed by s.
The  and  operations have the same priorities as the
comparison operations. The  (concatenation) and  (repetition)
operations have the same priority as the corresponding numeric operations. [3]







Operation
Result
Notes




 if an item of s is
equal to x, else 
(1)


 if an item of s is
equal to x, else 
(1)


the concatenation of s and
t
(6)(7)

 or

equivalent to adding s to
itself n times
(2)(7)


ith item of s, origin 0
(3)


slice of s from i to j
(3)(4)


slice of s from i to j
with step k
(3)(5)


length of s
 


smallest item of s
 


largest item of s
 


index of the first occurrence
of x in s (at or after
index i and before index j)
(8)


total number of occurrences of
x in s
 



Sequences of the same type also support comparisons.  In particular, tuples
and lists are compared lexicographically by comparing corresponding elements.
This means that to compare equal, every element must compare equal and the
two sequences must be of the same type and have the same length.  (For full
details see Comparisons in the language reference.)
Notes:

While the  and  operations are used only for simple
containment testing in the general case, some specialised sequences
(such as ,  and ) also use
them for subsequence testing:



Values of n less than  are treated as  (which yields an empty
sequence of the same type as s).  Note that items in the sequence s
are not copied; they are referenced multiple times.  This often haunts
new Python programmers; consider:


What has happened is that  is a one-element list containing an empty
list, so all three elements of  are references to this single empty
list.  Modifying any of the elements of  modifies this single list.
You can create a list of different lists this way:


Further explanation is available in the FAQ entry
How do I create a multidimensional list?.

If i or j is negative, the index is relative to the end of sequence s:
 or  is substituted.  But note that  is
still .

The slice of s from i to j is defined as the sequence of items with index
k such that .  If i or j is greater than , use
.  If i is omitted or , use .  If j is omitted or
, use .  If i is greater than or equal to j, the slice is
empty.

The slice of s from i to j with step k is defined as the sequence of
items with index   such that .  In other words,
the indices are , , ,  and so on, stopping when
j is reached (but never including j).  When k is positive,
i and j are reduced to  if they are greater.
When k is negative, i and j are reduced to  if
they are greater.  If i or j are omitted or , they become
“end” values (which end depends on the sign of k).  Note, k cannot be zero.
If k is , it is treated like .

Concatenating immutable sequences always results in a new object.  This
means that building up a sequence by repeated concatenation will have a
quadratic runtime cost in the total sequence length.  To get a linear
runtime cost, you must switch to one of the alternatives below:

if concatenating  objects, you can build a list and use
 at the end or else write to an 
instance and retrieve its value when complete
if concatenating  objects, you can similarly use
 or , or you can do in-place
concatenation with a  object.  
objects are mutable and have an efficient overallocation mechanism
if concatenating  objects, extend a  instead
for other types, investigate the relevant class documentation


Some sequence types (such as ) only support item sequences
that follow specific patterns, and hence don’t support sequence
concatenation or repetition.

 raises  when x is not found in s.
Not all implementations support passing the additional arguments i and j.
These arguments allow efficient searching of subsections of the sequence. Passing
the extra arguments is roughly equivalent to using , only
without copying any data and with the returned index being relative to
the start of the sequence rather than the start of the slice.




Immutable Sequence Types¶
The only operation that immutable sequence types generally implement that is
not also implemented by mutable sequence types is support for the 
built-in.
This support allows immutable sequences, such as  instances, to
be used as  keys and stored in  and 
instances.
Attempting to hash an immutable sequence that contains unhashable values will
result in .


Mutable Sequence Types¶
The operations in the following table are defined on mutable sequence types.
The  ABC is provided to make it
easier to correctly implement these operations on custom sequence types.
In the table s is an instance of a mutable sequence type, t is any
iterable object and x is an arbitrary object that meets any type
and value restrictions imposed by s (for example,  only
accepts integers that meet the value restriction ).







Operation
Result
Notes




item i of s is replaced by
x
 


slice of s from i to j
is replaced by the contents of
the iterable t
 


same as 
 


the elements of 
are replaced by those of t
(1)


removes the elements of
 from the list
 


appends x to the end of the
sequence (same as
)
 


removes all items from s
(same as )
(5)


creates a shallow copy of s
(same as )
(5)

 or

extends s with the
contents of t (for the
most part the same as
)
 


updates s with its contents
repeated n times
(6)


inserts x into s at the
index given by i
(same as )
 


retrieves the item at i and
also removes it from s
(2)


remove the first item from s
where  is equal to x
(3)


reverses the items of s in
place
(4)



Notes:

t must have the same length as the slice it is replacing.

The optional argument i defaults to , so that by default the last
item is removed and returned.

 raises  when x is not found in s.

The  method modifies the sequence in place for economy of
space when reversing a large sequence.  To remind users that it operates by
side effect, it does not return the reversed sequence.

 and  are included for consistency with the
interfaces of mutable containers that don’t support slicing operations
(such as  and )

New in version 3.3:  and  methods.


The value n is an integer, or an object implementing
.  Zero and negative values of n clear
the sequence.  Items in the sequence are not copied; they are referenced
multiple times, as explained for  under Common Sequence Operations.




Lists¶
Lists are mutable sequences, typically used to store collections of
homogeneous items (where the precise degree of similarity will vary by
application).


class ([iterable])¶
Lists may be constructed in several ways:

Using a pair of square brackets to denote the empty list: 
Using square brackets, separating items with commas: , 
Using a list comprehension: 
Using the type constructor:  or 

The constructor builds a list whose items are the same and in the same
order as iterable’s items.  iterable may be either a sequence, a
container that supports iteration, or an iterator object.  If iterable
is already a list, a copy is made and returned, similar to .
For example,  returns  and
 returns .
If no argument is given, the constructor creates a new empty list, .
Many other operations also produce lists, including the 
built-in.
Lists implement all of the common and
mutable sequence operations. Lists also provide the
following additional method:


(*, key=None, reverse=False)¶
This method sorts the list in place, using only  comparisons
between items. Exceptions are not suppressed - if any comparison operations
fail, the entire sort operation will fail (and the list will likely be left
in a partially modified state).
 accepts two arguments that can only be passed by keyword
(keyword-only arguments):
key specifies a function of one argument that is used to extract a
comparison key from each list element (for example, ).
The key corresponding to each item in the list is calculated once and
then used for the entire sorting process. The default value of 
means that list items are sorted directly without calculating a separate
key value.
The  utility is available to convert a 2.x
style cmp function to a key function.
reverse is a boolean value.  If set to , then the list elements
are sorted as if each comparison were reversed.
This method modifies the sequence in place for economy of space when
sorting a large sequence.  To remind users that it operates by side
effect, it does not return the sorted sequence (use  to
explicitly request a new sorted list instance).
The  method is guaranteed to be stable.  A sort is stable if it
guarantees not to change the relative order of elements that compare equal
— this is helpful for sorting in multiple passes (for example, sort by
department, then by salary grade).

CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even
inspect, the list is undefined.  The C implementation of Python makes the
list appear empty for the duration, and raises  if it can
detect that the list has been mutated during a sort.





Tuples¶
Tuples are immutable sequences, typically used to store collections of
heterogeneous data (such as the 2-tuples produced by the 
built-in). Tuples are also used for cases where an immutable sequence of
homogeneous data is needed (such as allowing storage in a  or
 instance).


class ([iterable])¶
Tuples may be constructed in a number of ways:

Using a pair of parentheses to denote the empty tuple: 
Using a trailing comma for a singleton tuple:  or 
Separating items with commas:  or 
Using the  built-in:  or 

The constructor builds a tuple whose items are the same and in the same
order as iterable’s items.  iterable may be either a sequence, a
container that supports iteration, or an iterator object.  If iterable
is already a tuple, it is returned unchanged. For example,
 returns  and
 returns .
If no argument is given, the constructor creates a new empty tuple, .
Note that it is actually the comma which makes a tuple, not the parentheses.
The parentheses are optional, except in the empty tuple case, or
when they are needed to avoid syntactic ambiguity. For example,
 is a function call with three arguments, while
 is a function call with a 3-tuple as the sole argument.
Tuples implement all of the common sequence
operations.

For heterogeneous collections of data where access by name is clearer than
access by index,  may be a more appropriate
choice than a simple tuple object.


Ranges¶
The  type represents an immutable sequence of numbers and is
commonly used for looping a specific number of times in 
loops.


class (stop)¶

class (start, stop[, step])
The arguments to the range constructor must be integers (either built-in
 or any object that implements the  special
method).  If the step argument is omitted, it defaults to .
If the start argument is omitted, it defaults to .
If step is zero,  is raised.
For a positive step, the contents of a range  are determined by the
formula  where  and
.
For a negative step, the contents of the range are still determined by
the formula , but the constraints are 
and .
A range object will be empty if  does not meet the value
constraint. Ranges do support negative indices, but these are interpreted
as indexing from the end of the sequence determined by the positive
indices.
Ranges containing absolute values larger than  are
permitted but some features (such as ) may raise
.
Range examples:


Ranges implement all of the common sequence operations
except concatenation and repetition (due to the fact that range objects can
only represent sequences that follow a strict pattern and repetition and
concatenation will usually violate that pattern).


¶
The value of the start parameter (or  if the parameter was
not supplied)



¶
The value of the stop parameter



¶
The value of the step parameter (or  if the parameter was
not supplied)


The advantage of the  type over a regular  or
 is that a  object will always take the same
(small) amount of memory, no matter the size of the range it represents (as it
only stores the ,  and  values, calculating individual
items and subranges as needed).
Range objects implement the  ABC, and provide
features such as containment tests, element index lookup, slicing and
support for negative indices (see Sequence Types — list, tuple, range):


Testing range objects for equality with  and  compares
them as sequences.  That is, two range objects are considered equal if
they represent the same sequence of values.  (Note that two range
objects that compare equal might have different ,
 and  attributes, for example
 or .)

Changed in version 3.2: Implement the Sequence ABC.
Support slicing and negative indices.
Test  objects for membership in constant time instead of
iterating through all items.


Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the
sequence of values they define (instead of comparing based on
object identity).


New in version 3.3: The ,  and 
attributes.


See also

The linspace recipe
shows how to implement a lazy version of range suitable for floating
point applications.





Text Sequence Type — ¶
Textual data in Python is handled with  objects, or strings.
Strings are immutable
sequences of Unicode code points.  String literals are
written in a variety of ways:

Single quotes: 
Double quotes: .
Triple quoted: , 

Triple quoted strings may span multiple lines - all associated whitespace will
be included in the string literal.
String literals that are part of a single expression and have only whitespace
between them will be implicitly converted to a single string literal. That
is, .
See String and Bytes literals for more about the various forms of string literal,
including supported escape sequences, and the  (“raw”) prefix that
disables most escape sequence processing.
Strings may also be created from other objects using the 
constructor.
Since there is no separate “character” type, indexing a string produces
strings of length 1. That is, for a non-empty string s, .
There is also no mutable string type, but  or
 can be used to efficiently construct strings from
multiple fragments.

Changed in version 3.3: For backwards compatibility with the Python 2 series, the  prefix is
once again permitted on string literals. It has no effect on the meaning
of string literals and cannot be combined with the  prefix.



class (object='')¶

class (object=b'', encoding='utf-8', errors='strict')
Return a string version of object.  If object is not
provided, returns the empty string.  Otherwise, the behavior of 
depends on whether encoding or errors is given, as follows.
If neither encoding nor errors is given,  returns
, which is the “informal” or nicely
printable string representation of object.  For string objects, this is
the string itself.  If object does not have a 
method, then  falls back to returning
.
If at least one of encoding or errors is given, object should be a
bytes-like object (e.g.  or ).  In
this case, if object is a  (or ) object,
then  is equivalent to
.  Otherwise, the bytes
object underlying the buffer object is obtained before calling
.  See Binary Sequence Types — bytes, bytearray, memoryview and
Buffer Protocol for information on buffer objects.
Passing a  object to  without the encoding
or errors arguments falls under the first case of returning the informal
string representation (see also the  command-line option to
Python).  For example:


For more information on the  class and its methods, see
Text Sequence Type — str and the String Methods section below.  To output
formatted strings, see the Formatted string literals and Format String Syntax
sections.  In addition, see the Text Processing Services section.


String Methods¶
Strings implement all of the common sequence
operations, along with the additional methods described below.
Strings also support two styles of string formatting, one providing a large
degree of flexibility and customization (see ,
Format String Syntax and Custom String Formatting) and the other based on C
 style formatting that handles a narrower range of types and is
slightly harder to use correctly, but is often faster for the cases it can
handle (printf-style String Formatting).
The Text Processing Services section of the standard library covers a number of
other modules that provide various text related utilities (including regular
expression support in the  module).


()¶
Return a copy of the string with its first character capitalized and the
rest lowercased.



()¶
Return a casefolded copy of the string. Casefolded strings may be used for
caseless matching.
Casefolding is similar to lowercasing but more aggressive because it is
intended to remove all case distinctions in a string. For example, the German
lowercase letter  is equivalent to . Since it is already
lowercase,  would do nothing to ; 
converts it to .
The casefolding algorithm is described in section 3.13 of the Unicode
Standard.

New in version 3.3.




(width[, fillchar])¶
Return centered in a string of length width. Padding is done using the
specified fillchar (default is an ASCII space). The original string is
returned if width is less than or equal to .



(sub[, start[, end]])¶
Return the number of non-overlapping occurrences of substring sub in the
range [start, end].  Optional arguments start and end are
interpreted as in slice notation.



(encoding="utf-8", errors="strict")¶
Return an encoded version of the string as a bytes object. Default encoding
is . errors may be given to set a different error handling scheme.
The default for errors is , meaning that encoding errors raise
a . Other possible
values are , , ,
 and any other name registered via
, see section Error Handlers. For a
list of possible encodings, see section Standard Encodings.

Changed in version 3.1: Support for keyword arguments added.




(suffix[, start[, end]])¶
Return  if the string ends with the specified suffix, otherwise return
.  suffix can also be a tuple of suffixes to look for.  With optional
start, test beginning at that position.  With optional end, stop comparing
at that position.



(tabsize=8)¶
Return a copy of the string where all tab characters are replaced by one or
more spaces, depending on the current column and the given tab size.  Tab
positions occur every tabsize characters (default is 8, giving tab
positions at columns 0, 8, 16 and so on).  To expand the string, the current
column is set to zero and the string is examined character by character.  If
the character is a tab (), one or more space characters are inserted
in the result until the current column is equal to the next tab position.
(The tab character itself is not copied.)  If the character is a newline
() or return (), it is copied and the current column is reset to
zero.  Any other character is copied unchanged and the current column is
incremented by one regardless of how the character is represented when
printed.





(sub[, start[, end]])¶
Return the lowest index in the string where substring sub is found within
the slice .  Optional arguments start and end are
interpreted as in slice notation.  Return  if sub is not found.

Note
The  method should be used only if you need to know the
position of sub.  To check if sub is a substring or not, use the
 operator:






(*args, **kwargs)¶
Perform a string formatting operation.  The string on which this method is
called can contain literal text or replacement fields delimited by braces
.  Each replacement field contains either the numeric index of a
positional argument, or the name of a keyword argument.  Returns a copy of
the string where each replacement field is replaced with the string value of
the corresponding argument.


See Format String Syntax for a description of the various formatting options
that can be specified in format strings.

Note
When formatting a number (, , ,
 and subclasses) with the  type
(ex: ), the function temporarily sets the
 locale to the  locale to decode
 and  fields of  if
they are non-ASCII or longer than 1 byte, and the  locale is
different than the  locale.  This temporary change affects
other threads.


Changed in version 3.7: When formatting a number with the  type, the function sets
temporarily the  locale to the  locale in some
cases.




(mapping)¶
Similar to , except that  is
used directly and not copied to a .  This is useful
if for example  is a dict subclass:



New in version 3.2.




(sub[, start[, end]])¶
Like , but raise  when the substring is
not found.



()¶
Return true if all characters in the string are alphanumeric and there is at
least one character, false otherwise.  A character  is alphanumeric if one
of the following returns : , ,
, or .



()¶
Return true if all characters in the string are alphabetic and there is at least
one character, false otherwise.  Alphabetic characters are those characters defined
in the Unicode character database as “Letter”, i.e., those with general category
property being one of “Lm”, “Lt”, “Lu”, “Ll”, or “Lo”.  Note that this is different
from the “Alphabetic” property defined in the Unicode Standard.



()¶
Return true if the string is empty or all characters in the string are ASCII,
false otherwise.
ASCII characters have code points in the range U+0000-U+007F.

New in version 3.7.




()¶
Return true if all characters in the string are decimal
characters and there is at least one character, false
otherwise. Decimal characters are those that can be used to form
numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT
ZERO.  Formally a decimal character is a character in the Unicode
General Category “Nd”.



()¶
Return true if all characters in the string are digits and there is at least one
character, false otherwise.  Digits include decimal characters and digits that need
special handling, such as the compatibility superscript digits.
This covers digits which cannot be used to form numbers in base 10,
like the Kharosthi numbers.  Formally, a digit is a character that has the
property value Numeric_Type=Digit or Numeric_Type=Decimal.



()¶
Return true if the string is a valid identifier according to the language
definition, section Identifiers and keywords.
Use  to test for reserved identifiers such as
 and .



()¶
Return true if all cased characters [4] in the string are lowercase and
there is at least one cased character, false otherwise.



()¶
Return true if all characters in the string are numeric
characters, and there is at least one character, false
otherwise. Numeric characters include digit characters, and all characters
that have the Unicode numeric value property, e.g. U+2155,
VULGAR FRACTION ONE FIFTH.  Formally, numeric characters are those with the property
value Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric.



()¶
Return true if all characters in the string are printable or the string is
empty, false otherwise.  Nonprintable characters are those characters defined
in the Unicode character database as “Other” or “Separator”, excepting the
ASCII space (0x20) which is considered printable.  (Note that printable
characters in this context are those which should not be escaped when
 is invoked on a string.  It has no bearing on the handling of
strings written to  or .)



()¶
Return true if there are only whitespace characters in the string and there is
at least one character, false otherwise.  Whitespace characters  are those
characters defined in the Unicode character database as “Other” or “Separator”
and those with bidirectional property being one of “WS”, “B”, or “S”.



()¶
Return true if the string is a titlecased string and there is at least one
character, for example uppercase characters may only follow uncased characters
and lowercase characters only cased ones.  Return false otherwise.



()¶
Return true if all cased characters [4] in the string are uppercase and
there is at least one cased character, false otherwise.



(iterable)¶
Return a string which is the concatenation of the strings in iterable.
A  will be raised if there are any non-string values in
iterable, including  objects.  The separator between
elements is the string providing this method.



(width[, fillchar])¶
Return the string left justified in a string of length width. Padding is
done using the specified fillchar (default is an ASCII space). The
original string is returned if width is less than or equal to .



()¶
Return a copy of the string with all the cased characters [4] converted to
lowercase.
The lowercasing algorithm used is described in section 3.13 of the Unicode
Standard.



([chars])¶
Return a copy of the string with leading characters removed.  The chars
argument is a string specifying the set of characters to be removed.  If omitted
or , the chars argument defaults to removing whitespace.  The chars
argument is not a prefix; rather, all combinations of its values are stripped:





static (x[, y[, z]])¶
This static method returns a translation table usable for .
If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters (strings of length 1) to Unicode ordinals,
strings (of arbitrary lengths) or .  Character keys will then be
converted to ordinals.
If there are two arguments, they must be strings of equal length, and in the
resulting dictionary, each character in x will be mapped to the character at
the same position in y.  If there is a third argument, it must be a string,
whose characters will be mapped to  in the result.



(sep)¶
Split the string at the first occurrence of sep, and return a 3-tuple
containing the part before the separator, the separator itself, and the part
after the separator.  If the separator is not found, return a 3-tuple containing
the string itself, followed by two empty strings.



(old, new[, count])¶
Return a copy of the string with all occurrences of substring old replaced by
new.  If the optional argument count is given, only the first count
occurrences are replaced.



(sub[, start[, end]])¶
Return the highest index in the string where substring sub is found, such
that sub is contained within .  Optional arguments start
and end are interpreted as in slice notation.  Return  on failure.



(sub[, start[, end]])¶
Like  but raises  when the substring sub is not
found.



(width[, fillchar])¶
Return the string right justified in a string of length width. Padding is
done using the specified fillchar (default is an ASCII space). The
original string is returned if width is less than or equal to .



(sep)¶
Split the string at the last occurrence of sep, and return a 3-tuple
containing the part before the separator, the separator itself, and the part
after the separator.  If the separator is not found, return a 3-tuple containing
two empty strings, followed by the string itself.



(sep=None, maxsplit=-1)¶
Return a list of the words in the string, using sep as the delimiter string.
If maxsplit is given, at most maxsplit splits are done, the rightmost
ones.  If sep is not specified or , any whitespace string is a
separator.  Except for splitting from the right,  behaves like
 which is described in detail below.



([chars])¶
Return a copy of the string with trailing characters removed.  The chars
argument is a string specifying the set of characters to be removed.  If omitted
or , the chars argument defaults to removing whitespace.  The chars
argument is not a suffix; rather, all combinations of its values are stripped:





(sep=None, maxsplit=-1)¶
Return a list of the words in the string, using sep as the delimiter
string.  If maxsplit is given, at most maxsplit splits are done (thus,
the list will have at most  elements).  If maxsplit is not
specified or , then there is no limit on the number of splits
(all possible splits are made).
If sep is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings (for example,  returns
).  The sep argument may consist of multiple characters
(for example,  returns ).
Splitting an empty string with a specified separator returns .
For example:


If sep is not specified or is , a different splitting algorithm is
applied: runs of consecutive whitespace are regarded as a single separator,
and the result will contain no empty strings at the start or end if the
string has leading or trailing whitespace.  Consequently, splitting an empty
string or a string consisting of just whitespace with a  separator
returns .
For example:





([keepends])¶
Return a list of the lines in the string, breaking at line boundaries.  Line
breaks are not included in the resulting list unless keepends is given and
true.
This method splits on the following line boundaries.  In particular, the
boundaries are a superset of universal newlines.






Representation
Description




Line Feed


Carriage Return


Carriage Return + Line Feed

 or 
Line Tabulation

 or 
Form Feed


File Separator


Group Separator


Record Separator


Next Line (C1 Control Code)


Line Separator


Paragraph Separator




Changed in version 3.2:  and  added to list of line boundaries.

For example:


Unlike  when a delimiter string sep is given, this
method returns an empty list for the empty string, and a terminal line
break does not result in an extra line:


For comparison,  gives:





(prefix[, start[, end]])¶
Return  if string starts with the prefix, otherwise return .
prefix can also be a tuple of prefixes to look for.  With optional start,
test string beginning at that position.  With optional end, stop comparing
string at that position.



([chars])¶
Return a copy of the string with the leading and trailing characters removed.
The chars argument is a string specifying the set of characters to be removed.
If omitted or , the chars argument defaults to removing whitespace.
The chars argument is not a prefix or suffix; rather, all combinations of its
values are stripped:


The outermost leading and trailing chars argument values are stripped
from the string. Characters are removed from the leading end until
reaching a string character that is not contained in the set of
characters in chars. A similar action takes place on the trailing end.
For example:





()¶
Return a copy of the string with uppercase characters converted to lowercase and
vice versa. Note that it is not necessarily true that
.



()¶
Return a titlecased version of the string where words start with an uppercase
character and the remaining characters are lowercase.
For example:


The algorithm uses a simple language-independent definition of a word as
groups of consecutive letters.  The definition works in many contexts but
it means that apostrophes in contractions and possessives form word
boundaries, which may not be the desired result:


A workaround for apostrophes can be constructed using regular expressions:





(table)¶
Return a copy of the string in which each character has been mapped through
the given translation table.  The table must be an object that implements
indexing via , typically a mapping or
sequence.  When indexed by a Unicode ordinal (an integer), the
table object can do any of the following: return a Unicode ordinal or a
string, to map the character to one or more other characters; return
, to delete the character from the return string; or raise a
 exception, to map the character to itself.
You can use  to create a translation map from
character-to-character mappings in different formats.
See also the  module for a more flexible approach to custom
character mappings.



()¶
Return a copy of the string with all the cased characters [4] converted to
uppercase.  Note that  might be  if 
contains uncased characters or if the Unicode category of the resulting
character(s) is not “Lu” (Letter, uppercase), but e.g. “Lt” (Letter,
titlecase).
The uppercasing algorithm used is described in section 3.13 of the Unicode
Standard.



(width)¶
Return a copy of the string left filled with ASCII  digits to
make a string of length width. A leading sign prefix (/)
is handled by inserting the padding after the sign character rather
than before. The original string is returned if width is less than
or equal to .
For example:





-style String Formatting¶

Note
The formatting operations described here exhibit a variety of quirks that
lead to a number of common errors (such as failing to display tuples and
dictionaries correctly).  Using the newer formatted string literals, the  interface, or template strings may help avoid these errors.  Each of these
alternatives provides their own trade-offs and benefits of simplicity,
flexibility, and/or extensibility.

String objects have one unique built-in operation: the  operator (modulo).
This is also known as the string formatting or interpolation operator.
Given  (where format is a string),  conversion
specifications in format are replaced with zero or more elements of values.
The effect is similar to using the  in the C language.
If format requires a single argument, values may be a single non-tuple
object. [5]  Otherwise, values must be a tuple with exactly the number of
items specified by the format string, or a single mapping object (for example, a
dictionary).
A conversion specifier contains two or more characters and has the following
components, which must occur in this order:

The  character, which marks the start of the specifier.
Mapping key (optional), consisting of a parenthesised sequence of characters
(for example, ).
Conversion flags (optional), which affect the result of some conversion
types.
Minimum field width (optional).  If specified as an  (asterisk), the
actual width is read from the next element of the tuple in values, and the
object to convert comes after the minimum field width and optional precision.
Precision (optional), given as a  (dot) followed by the precision.  If
specified as  (an asterisk), the actual precision is read from the next
element of the tuple in values, and the value to convert comes after the
precision.
Length modifier (optional).
Conversion type.

When the right argument is a dictionary (or other mapping type), then the
formats in the string must include a parenthesised mapping key into that
dictionary inserted immediately after the  character. The mapping key
selects the value to be formatted from the mapping.  For example:


In this case no  specifiers may occur in a format (since they require a
sequential parameter list).
The conversion flag characters are:






Flag
Meaning




The value conversion will use the “alternate form” (where defined
below).


The conversion will be zero padded for numeric values.


The converted value is left adjusted (overrides the 
conversion if both are given).


(a space) A blank should be left before a positive number (or empty
string) produced by a signed conversion.


A sign character ( or ) will precede the conversion
(overrides a “space” flag).



A length modifier (, , or ) may be present, but is ignored as it
is not necessary for Python – so e.g.  is identical to .
The conversion types are:







Conversion
Meaning
Notes




Signed integer decimal.
 


Signed integer decimal.
 


Signed octal value.
(1)


Obsolete type – it is identical to .
(6)


Signed hexadecimal (lowercase).
(2)


Signed hexadecimal (uppercase).
(2)


Floating point exponential format (lowercase).
(3)


Floating point exponential format (uppercase).
(3)


Floating point decimal format.
(3)


Floating point decimal format.
(3)


Floating point format. Uses lowercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Floating point format. Uses uppercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Single character (accepts integer or single
character string).
 


String (converts any Python object using
).
(5)


String (converts any Python object using
).
(5)


String (converts any Python object using
).
(5)


No argument is converted, results in a 
character in the result.
 



Notes:

The alternate form causes a leading octal specifier () to be
inserted before the first digit.

The alternate form causes a leading  or  (depending on whether
the  or  format was used) to be inserted before the first digit.

The alternate form causes the result to always contain a decimal point, even if
no digits follow it.
The precision determines the number of digits after the decimal point and
defaults to 6.

The alternate form causes the result to always contain a decimal point, and
trailing zeroes are not removed as they would otherwise be.
The precision determines the number of significant digits before and after the
decimal point and defaults to 6.

If precision is , the output is truncated to  characters.

See PEP 237.


Since Python strings have an explicit length,  conversions do not assume
that  is the end of the string.

Changed in version 3.1:  conversions for numbers whose absolute value is over 1e50 are no
longer replaced by  conversions.




Binary Sequence Types — , , ¶
The core built-in types for manipulating binary data are  and
. They are supported by  which uses
the buffer protocol to access the memory of other
binary objects without needing to make a copy.
The  module supports efficient storage of basic data types like
32-bit integers and IEEE754 double-precision floating values.

Bytes Objects¶
Bytes objects are immutable sequences of single bytes. Since many major
binary protocols are based on the ASCII text encoding, bytes objects offer
several methods that are only valid when working with ASCII compatible
data and are closely related to string objects in a variety of other ways.


class ([source[, encoding[, errors]]])¶
Firstly, the syntax for bytes literals is largely the same as that for string
literals, except that a  prefix is added:

Single quotes: 
Double quotes: .
Triple quoted: , 

Only ASCII characters are permitted in bytes literals (regardless of the
declared source code encoding). Any binary values over 127 must be entered
into bytes literals using the appropriate escape sequence.
As with string literals, bytes literals may also use a  prefix to disable
processing of escape sequences. See String and Bytes literals for more about the various
forms of bytes literal, including supported escape sequences.
While bytes literals and representations are based on ASCII text, bytes
objects actually behave like immutable sequences of integers, with each
value in the sequence restricted such that  (attempts to
violate this restriction will trigger ). This is done
deliberately to emphasise that while many binary formats include ASCII based
elements and can be usefully manipulated with some text-oriented algorithms,
this is not generally the case for arbitrary binary data (blindly applying
text processing algorithms to binary data formats that are not ASCII
compatible will usually lead to data corruption).
In addition to the literal forms, bytes objects can be created in a number of
other ways:

A zero-filled bytes object of a specified length: 
From an iterable of integers: 
Copying existing binary data via the buffer protocol:  

Also see the bytes built-in.
Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal
numbers are a commonly used format for describing binary data. Accordingly,
the bytes type has an additional class method to read data in that format:


classmethod (string)¶
This  class method returns a bytes object, decoding the
given string object.  The string must contain two hexadecimal digits per
byte, with ASCII whitespace being ignored.



Changed in version 3.7:  now skips all ASCII whitespace in the string,
not just spaces.


A reverse conversion function exists to transform a bytes object into its
hexadecimal representation.


()¶
Return a string object containing two hexadecimal digits for each
byte in the instance.



New in version 3.5.



Since bytes objects are sequences of integers (akin to a tuple), for a bytes
object b,  will be an integer, while  will be a bytes
object of length 1.  (This contrasts with text strings, where both indexing
and slicing will produce a string of length 1)
The representation of bytes objects uses the literal format ()
since it is often more useful than e.g. .  You can
always convert a bytes object into a list of integers using .

Note
For Python 2.x users: In the Python 2.x series, a variety of implicit
conversions between 8-bit strings (the closest thing 2.x offers to a
built-in binary data type) and Unicode strings were permitted. This was a
backwards compatibility workaround to account for the fact that Python
originally only supported 8-bit text, and Unicode text was a later
addition. In Python 3.x, those implicit conversions are gone - conversions
between 8-bit binary data and Unicode text must be explicit, and bytes and
string objects will always compare unequal.



Bytearray Objects¶
 objects are a mutable counterpart to 
objects.


class ([source[, encoding[, errors]]])¶
There is no dedicated literal syntax for bytearray objects, instead
they are always created by calling the constructor:

Creating an empty instance: 
Creating a zero-filled instance with a given length: 
From an iterable of integers: 
Copying existing binary data via the buffer protocol:  

As bytearray objects are mutable, they support the
mutable sequence operations in addition to the
common bytes and bytearray operations described in Bytes and Bytearray Operations.
Also see the bytearray built-in.
Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal
numbers are a commonly used format for describing binary data. Accordingly,
the bytearray type has an additional class method to read data in that format:


classmethod (string)¶
This  class method returns bytearray object, decoding
the given string object.  The string must contain two hexadecimal digits
per byte, with ASCII whitespace being ignored.



Changed in version 3.7:  now skips all ASCII whitespace in the string,
not just spaces.


A reverse conversion function exists to transform a bytearray object into its
hexadecimal representation.


()¶
Return a string object containing two hexadecimal digits for each
byte in the instance.



New in version 3.5.



Since bytearray objects are sequences of integers (akin to a list), for a
bytearray object b,  will be an integer, while  will be
a bytearray object of length 1.  (This contrasts with text strings, where
both indexing and slicing will produce a string of length 1)
The representation of bytearray objects uses the bytes literal format
() since it is often more useful than e.g.
.  You can always convert a bytearray object into
a list of integers using .


Bytes and Bytearray Operations¶
Both bytes and bytearray objects support the common
sequence operations. They interoperate not just with operands of the same
type, but with any bytes-like object. Due to this flexibility, they can be
freely mixed in operations without causing errors. However, the return type
of the result may depend on the order of operands.

Note
The methods on bytes and bytearray objects don’t accept strings as their
arguments, just as the methods on strings don’t accept bytes as their
arguments.  For example, you have to write:


and:



Some bytes and bytearray operations assume the use of ASCII compatible
binary formats, and hence should be avoided when working with arbitrary
binary data. These restrictions are covered below.

Note
Using these ASCII based operations to manipulate binary data that is not
stored in an ASCII based format may lead to data corruption.

The following methods on bytes and bytearray objects can be used with
arbitrary binary data.


(sub[, start[, end]])¶

(sub[, start[, end]])¶
Return the number of non-overlapping occurrences of subsequence sub in
the range [start, end].  Optional arguments start and end are
interpreted as in slice notation.
The subsequence to search for may be any bytes-like object or an
integer in the range 0 to 255.

Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.




(encoding="utf-8", errors="strict")¶

(encoding="utf-8", errors="strict")¶
Return a string decoded from the given bytes.  Default encoding is
. errors may be given to set a different
error handling scheme.  The default for errors is , meaning
that encoding errors raise a .  Other possible values are
,  and any other name registered via
, see section Error Handlers. For a
list of possible encodings, see section Standard Encodings.

Note
Passing the encoding argument to  allows decoding any
bytes-like object directly, without needing to make a temporary
bytes or bytearray object.


Changed in version 3.1: Added support for keyword arguments.




(suffix[, start[, end]])¶

(suffix[, start[, end]])¶
Return  if the binary data ends with the specified suffix,
otherwise return .  suffix can also be a tuple of suffixes to
look for.  With optional start, test beginning at that position.  With
optional end, stop comparing at that position.
The suffix(es) to search for may be any bytes-like object.



(sub[, start[, end]])¶

(sub[, start[, end]])¶
Return the lowest index in the data where the subsequence sub is found,
such that sub is contained in the slice .  Optional
arguments start and end are interpreted as in slice notation.  Return
 if sub is not found.
The subsequence to search for may be any bytes-like object or an
integer in the range 0 to 255.

Note
The  method should be used only if you need to know the
position of sub.  To check if sub is a substring or not, use the
 operator:




Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.




(sub[, start[, end]])¶

(sub[, start[, end]])¶
Like , but raise  when the
subsequence is not found.
The subsequence to search for may be any bytes-like object or an
integer in the range 0 to 255.

Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.




(iterable)¶

(iterable)¶
Return a bytes or bytearray object which is the concatenation of the
binary data sequences in iterable.  A  will be raised
if there are any values in iterable that are not bytes-like
objects, including  objects.  The
separator between elements is the contents of the bytes or
bytearray object providing this method.



static (from, to)¶

static (from, to)¶
This static method returns a translation table usable for
 that will map each character in from into the
character at the same position in to; from and to must both be
bytes-like objects and have the same length.

New in version 3.1.




(sep)¶

(sep)¶
Split the sequence at the first occurrence of sep, and return a 3-tuple
containing the part before the separator, the separator itself or its
bytearray copy, and the part after the separator.
If the separator is not found, return a 3-tuple
containing a copy of the original sequence, followed by two empty bytes or
bytearray objects.
The separator to search for may be any bytes-like object.



(old, new[, count])¶

(old, new[, count])¶
Return a copy of the sequence with all occurrences of subsequence old
replaced by new.  If the optional argument count is given, only the
first count occurrences are replaced.
The subsequence to search for and its replacement may be any
bytes-like object.

Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




(sub[, start[, end]])¶

(sub[, start[, end]])¶
Return the highest index in the sequence where the subsequence sub is
found, such that sub is contained within .  Optional
arguments start and end are interpreted as in slice notation. Return
 on failure.
The subsequence to search for may be any bytes-like object or an
integer in the range 0 to 255.

Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.




(sub[, start[, end]])¶

(sub[, start[, end]])¶
Like  but raises  when the
subsequence sub is not found.
The subsequence to search for may be any bytes-like object or an
integer in the range 0 to 255.

Changed in version 3.3: Also accept an integer in the range 0 to 255 as the subsequence.




(sep)¶

(sep)¶
Split the sequence at the last occurrence of sep, and return a 3-tuple
containing the part before the separator, the separator itself or its
bytearray copy, and the part after the separator.
If the separator is not found, return a 3-tuple
containing two empty bytes or bytearray objects, followed by a copy of the
original sequence.
The separator to search for may be any bytes-like object.



(prefix[, start[, end]])¶

(prefix[, start[, end]])¶
Return  if the binary data starts with the specified prefix,
otherwise return .  prefix can also be a tuple of prefixes to
look for.  With optional start, test beginning at that position.  With
optional end, stop comparing at that position.
The prefix(es) to search for may be any bytes-like object.



(table, delete=b'')¶

(table, delete=b'')¶
Return a copy of the bytes or bytearray object where all bytes occurring in
the optional argument delete are removed, and the remaining bytes have
been mapped through the given translation table, which must be a bytes
object of length 256.
You can use the  method to create a translation
table.
Set the table argument to  for translations that only delete
characters:



Changed in version 3.6: delete is now supported as a keyword argument.


The following methods on bytes and bytearray objects have default behaviours
that assume the use of ASCII compatible binary formats, but can still be used
with arbitrary binary data by passing appropriate arguments. Note that all of
the bytearray methods in this section do not operate in place, and instead
produce new objects.


(width[, fillbyte])¶

(width[, fillbyte])¶
Return a copy of the object centered in a sequence of length width.
Padding is done using the specified fillbyte (default is an ASCII
space). For  objects, the original sequence is returned if
width is less than or equal to .

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.




(width[, fillbyte])¶

(width[, fillbyte])¶
Return a copy of the object left justified in a sequence of length width.
Padding is done using the specified fillbyte (default is an ASCII
space). For  objects, the original sequence is returned if
width is less than or equal to .

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.




([chars])¶

([chars])¶
Return a copy of the sequence with specified leading bytes removed.  The
chars argument is a binary sequence specifying the set of byte values to
be removed - the name refers to the fact this method is usually used with
ASCII characters.  If omitted or , the chars argument defaults
to removing ASCII whitespace.  The chars argument is not a prefix;
rather, all combinations of its values are stripped:


The binary sequence of byte values to remove may be any
bytes-like object.

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.




(width[, fillbyte])¶

(width[, fillbyte])¶
Return a copy of the object right justified in a sequence of length width.
Padding is done using the specified fillbyte (default is an ASCII
space). For  objects, the original sequence is returned if
width is less than or equal to .

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.




(sep=None, maxsplit=-1)¶

(sep=None, maxsplit=-1)¶
Split the binary sequence into subsequences of the same type, using sep
as the delimiter string. If maxsplit is given, at most maxsplit splits
are done, the rightmost ones.  If sep is not specified or ,
any subsequence consisting solely of ASCII whitespace is a separator.
Except for splitting from the right,  behaves like
 which is described in detail below.



([chars])¶

([chars])¶
Return a copy of the sequence with specified trailing bytes removed.  The
chars argument is a binary sequence specifying the set of byte values to
be removed - the name refers to the fact this method is usually used with
ASCII characters.  If omitted or , the chars argument defaults to
removing ASCII whitespace.  The chars argument is not a suffix; rather,
all combinations of its values are stripped:


The binary sequence of byte values to remove may be any
bytes-like object.

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.




(sep=None, maxsplit=-1)¶

(sep=None, maxsplit=-1)¶
Split the binary sequence into subsequences of the same type, using sep
as the delimiter string. If maxsplit is given and non-negative, at most
maxsplit splits are done (thus, the list will have at most 
elements).  If maxsplit is not specified or is , then there is no
limit on the number of splits (all possible splits are made).
If sep is given, consecutive delimiters are not grouped together and are
deemed to delimit empty subsequences (for example, 
returns ).  The sep argument may consist of a
multibyte sequence (for example,  returns
). Splitting an empty sequence with a specified
separator returns  or  depending on the type
of object being split.  The sep argument may be any
bytes-like object.
For example:


If sep is not specified or is , a different splitting algorithm
is applied: runs of consecutive ASCII whitespace are regarded as a single
separator, and the result will contain no empty strings at the start or
end if the sequence has leading or trailing whitespace.  Consequently,
splitting an empty sequence or a sequence consisting solely of ASCII
whitespace without a specified separator returns .
For example:





([chars])¶

([chars])¶
Return a copy of the sequence with specified leading and trailing bytes
removed. The chars argument is a binary sequence specifying the set of
byte values to be removed - the name refers to the fact this method is
usually used with ASCII characters.  If omitted or , the chars
argument defaults to removing ASCII whitespace. The chars argument is
not a prefix or suffix; rather, all combinations of its values are
stripped:


The binary sequence of byte values to remove may be any
bytes-like object.

Note
The bytearray version of this method does not operate in place -
it always produces a new object, even if no changes were made.


The following methods on bytes and bytearray objects assume the use of ASCII
compatible binary formats and should not be applied to arbitrary binary data.
Note that all of the bytearray methods in this section do not operate in
place, and instead produce new objects.


()¶

()¶
Return a copy of the sequence with each byte interpreted as an ASCII
character, and the first byte capitalized and the rest lowercased.
Non-ASCII byte values are passed through unchanged.

Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




(tabsize=8)¶

(tabsize=8)¶
Return a copy of the sequence where all ASCII tab characters are replaced
by one or more ASCII spaces, depending on the current column and the given
tab size.  Tab positions occur every tabsize bytes (default is 8,
giving tab positions at columns 0, 8, 16 and so on).  To expand the
sequence, the current column is set to zero and the sequence is examined
byte by byte.  If the byte is an ASCII tab character (), one or
more space characters are inserted in the result until the current column
is equal to the next tab position. (The tab character itself is not
copied.)  If the current byte is an ASCII newline () or
carriage return (), it is copied and the current column is reset
to zero.  Any other byte value is copied unchanged and the current column
is incremented by one regardless of how the byte value is represented when
printed:



Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




()¶

()¶
Return true if all bytes in the sequence are alphabetical ASCII characters
or ASCII decimal digits and the sequence is not empty, false otherwise.
Alphabetic ASCII characters are those byte values in the sequence
. ASCII decimal
digits are those byte values in the sequence .
For example:





()¶

()¶
Return true if all bytes in the sequence are alphabetic ASCII characters
and the sequence is not empty, false otherwise.  Alphabetic ASCII
characters are those byte values in the sequence
.
For example:





()¶

()¶
Return true if the sequence is empty or all bytes in the sequence are ASCII,
false otherwise.
ASCII bytes are in the range 0-0x7F.

New in version 3.7.




()¶

()¶
Return true if all bytes in the sequence are ASCII decimal digits
and the sequence is not empty, false otherwise. ASCII decimal digits are
those byte values in the sequence .
For example:





()¶

()¶
Return true if there is at least one lowercase ASCII character
in the sequence and no uppercase ASCII characters, false otherwise.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .



()¶

()¶
Return true if all bytes in the sequence are ASCII whitespace and the
sequence is not empty, false otherwise.  ASCII whitespace characters are
those byte values in the sequence  (space, tab, newline,
carriage return, vertical tab, form feed).



()¶

()¶
Return true if the sequence is ASCII titlecase and the sequence is not
empty, false otherwise. See  for more details on the
definition of “titlecase”.
For example:





()¶

()¶
Return true if there is at least one uppercase alphabetic ASCII character
in the sequence and no lowercase ASCII characters, false otherwise.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .



()¶

()¶
Return a copy of the sequence with all the uppercase ASCII characters
converted to their corresponding lowercase counterpart.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .

Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




(keepends=False)¶

(keepends=False)¶
Return a list of the lines in the binary sequence, breaking at ASCII
line boundaries. This method uses the universal newlines approach
to splitting lines. Line breaks are not included in the resulting list
unless keepends is given and true.
For example:


Unlike  when a delimiter string sep is given, this
method returns an empty list for the empty string, and a terminal line
break does not result in an extra line:





()¶

()¶
Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart and vice-versa.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .
Unlike , it is always the case that
 for the binary versions. Case
conversions are symmetrical in ASCII, even though that is not generally
true for arbitrary Unicode code points.

Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




()¶

()¶
Return a titlecased version of the binary sequence where words start with
an uppercase ASCII character and the remaining characters are lowercase.
Uncased byte values are left unmodified.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .
All other byte values are uncased.
The algorithm uses a simple language-independent definition of a word as
groups of consecutive letters.  The definition works in many contexts but
it means that apostrophes in contractions and possessives form word
boundaries, which may not be the desired result:


A workaround for apostrophes can be constructed using regular expressions:



Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




()¶

()¶
Return a copy of the sequence with all the lowercase ASCII characters
converted to their corresponding uppercase counterpart.
For example:


Lowercase ASCII characters are those byte values in the sequence
. Uppercase ASCII characters
are those byte values in the sequence .

Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




(width)¶

(width)¶
Return a copy of the sequence left filled with ASCII  digits to
make a sequence of length width. A leading sign prefix (/
) is handled by inserting the padding after the sign character
rather than before. For  objects, the original sequence is
returned if width is less than or equal to .
For example:



Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.




-style Bytes Formatting¶

Note
The formatting operations described here exhibit a variety of quirks that
lead to a number of common errors (such as failing to display tuples and
dictionaries correctly).  If the value being printed may be a tuple or
dictionary, wrap it in a tuple.

Bytes objects (/) have one unique built-in operation:
the  operator (modulo).
This is also known as the bytes formatting or interpolation operator.
Given  (where format is a bytes object),  conversion
specifications in format are replaced with zero or more elements of values.
The effect is similar to using the  in the C language.
If format requires a single argument, values may be a single non-tuple
object. [5]  Otherwise, values must be a tuple with exactly the number of
items specified by the format bytes object, or a single mapping object (for
example, a dictionary).
A conversion specifier contains two or more characters and has the following
components, which must occur in this order:

The  character, which marks the start of the specifier.
Mapping key (optional), consisting of a parenthesised sequence of characters
(for example, ).
Conversion flags (optional), which affect the result of some conversion
types.
Minimum field width (optional).  If specified as an  (asterisk), the
actual width is read from the next element of the tuple in values, and the
object to convert comes after the minimum field width and optional precision.
Precision (optional), given as a  (dot) followed by the precision.  If
specified as  (an asterisk), the actual precision is read from the next
element of the tuple in values, and the value to convert comes after the
precision.
Length modifier (optional).
Conversion type.

When the right argument is a dictionary (or other mapping type), then the
formats in the bytes object must include a parenthesised mapping key into that
dictionary inserted immediately after the  character. The mapping key
selects the value to be formatted from the mapping.  For example:


In this case no  specifiers may occur in a format (since they require a
sequential parameter list).
The conversion flag characters are:






Flag
Meaning




The value conversion will use the “alternate form” (where defined
below).


The conversion will be zero padded for numeric values.


The converted value is left adjusted (overrides the 
conversion if both are given).


(a space) A blank should be left before a positive number (or empty
string) produced by a signed conversion.


A sign character ( or ) will precede the conversion
(overrides a “space” flag).



A length modifier (, , or ) may be present, but is ignored as it
is not necessary for Python – so e.g.  is identical to .
The conversion types are:







Conversion
Meaning
Notes




Signed integer decimal.
 


Signed integer decimal.
 


Signed octal value.
(1)


Obsolete type – it is identical to .
(8)


Signed hexadecimal (lowercase).
(2)


Signed hexadecimal (uppercase).
(2)


Floating point exponential format (lowercase).
(3)


Floating point exponential format (uppercase).
(3)


Floating point decimal format.
(3)


Floating point decimal format.
(3)


Floating point format. Uses lowercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Floating point format. Uses uppercase exponential
format if exponent is less than -4 or not less than
precision, decimal format otherwise.
(4)


Single byte (accepts integer or single
byte objects).
 


Bytes (any object that follows the
buffer protocol or has
).
(5)


 is an alias for  and should only
be used for Python2/3 code bases.
(6)


Bytes (converts any Python object using
).
(5)


 is an alias for  and should only
be used for Python2/3 code bases.
(7)


No argument is converted, results in a 
character in the result.
 



Notes:

The alternate form causes a leading octal specifier () to be
inserted before the first digit.

The alternate form causes a leading  or  (depending on whether
the  or  format was used) to be inserted before the first digit.

The alternate form causes the result to always contain a decimal point, even if
no digits follow it.
The precision determines the number of digits after the decimal point and
defaults to 6.

The alternate form causes the result to always contain a decimal point, and
trailing zeroes are not removed as they would otherwise be.
The precision determines the number of significant digits before and after the
decimal point and defaults to 6.

If precision is , the output is truncated to  characters.

 is deprecated, but will not be removed during the 3.x series.

 is deprecated, but will not be removed during the 3.x series.

See PEP 237.



Note
The bytearray version of this method does not operate in place - it
always produces a new object, even if no changes were made.


See also
PEP 461 - Adding % formatting to bytes and bytearray


New in version 3.5.



Memory Views¶
 objects allow Python code to access the internal data
of an object that supports the buffer protocol without
copying.


class (obj)¶
Create a  that references obj.  obj must support the
buffer protocol.  Built-in objects that support the buffer protocol include
 and .
A  has the notion of an element, which is the
atomic memory unit handled by the originating object obj.  For many
simple types such as  and , an element
is a single byte, but other types such as  may have
bigger elements.
 is equal to the length of .
If , the length is 1. If , the length
is equal to the number of elements in the view. For higher dimensions,
the length is equal to the length of the nested list representation of
the view. The  attribute will give you the
number of bytes in a single element.
A  supports slicing and indexing to expose its data.
One-dimensional slicing will result in a subview:


If  is one of the native format specifiers
from the  module, indexing with an integer or a tuple of
integers is also supported and returns a single element with
the correct type.  One-dimensional memoryviews can be indexed
with an integer or a one-integer tuple.  Multi-dimensional memoryviews
can be indexed with tuples of exactly ndim integers where ndim is
the number of dimensions.  Zero-dimensional memoryviews can be indexed
with the empty tuple.
Here is an example with a non-byte format:


If the underlying object is writable, the memoryview supports
one-dimensional slice assignment. Resizing is not allowed:


One-dimensional memoryviews of hashable (read-only) types with formats
‘B’, ‘b’ or ‘c’ are also hashable. The hash is defined as
:



Changed in version 3.3: One-dimensional memoryviews can now be sliced.
One-dimensional memoryviews with formats ‘B’, ‘b’ or ‘c’ are now hashable.


Changed in version 3.4: memoryview is now registered automatically with



Changed in version 3.5: memoryviews can now be indexed with tuple of integers.

 has several methods:


(exporter)¶
A memoryview and a PEP 3118 exporter are equal if their shapes are
equivalent and if all corresponding values are equal when the operands’
respective format codes are interpreted using  syntax.
For the subset of  format strings currently supported by
,  and  are equal if :


If either format string is not supported by the  module,
then the objects will always compare as unequal (even if the format
strings and buffer contents are identical):


Note that, as with floating point numbers,  does not imply
 for memoryview objects.

Changed in version 3.3: Previous versions compared the raw memory disregarding the item format
and the logical array structure.




()¶
Return the data in the buffer as a bytestring.  This is equivalent to
calling the  constructor on the memoryview.


For non-contiguous arrays the result is equal to the flattened list
representation with all elements converted to bytes. 
supports all format strings, including those that are not in
 module syntax.



()¶
Return a string object containing two hexadecimal digits for each
byte in the buffer.



New in version 3.5.




()¶
Return the data in the buffer as a list of elements.



Changed in version 3.3:  now supports all single character native formats in
 module syntax as well as multi-dimensional
representations.




()¶
Release the underlying buffer exposed by the memoryview object.  Many
objects take special actions when a view is held on them (for example,
a  would temporarily forbid resizing); therefore,
calling release() is handy to remove these restrictions (and free any
dangling resources) as soon as possible.
After this method has been called, any further operation on the view
raises a  (except  itself which can
be called multiple times):


The context management protocol can be used for a similar effect,
using the  statement:



New in version 3.2.




(format[, shape])¶
Cast a memoryview to a new format or shape. shape defaults to
, which means that the result view
will be one-dimensional. The return value is a new memoryview, but
the buffer itself is not copied. Supported casts are 1D -> C-contiguous
and C-contiguous -> 1D.
The destination format is restricted to a single element native format in
 syntax. One of the formats must be a byte format
(‘B’, ‘b’ or ‘c’). The byte length of the result must be the same
as the original length.
Cast 1D/long to 1D/unsigned bytes:


Cast 1D/unsigned bytes to 1D/char:


Cast 1D/bytes to 3D/ints to 1D/signed char:


Cast 1D/unsigned char to 2D/unsigned long:



New in version 3.3.


Changed in version 3.5: The source format is no longer restricted when casting to a byte view.


There are also several readonly attributes available:


¶
The underlying object of the memoryview:



New in version 3.3.




¶
. This is
the amount of space in bytes that the array would use in a contiguous
representation. It is not necessarily equal to :


Multi-dimensional arrays:



New in version 3.3.




¶
A bool indicating whether the memory is read only.



¶
A string containing the format (in  module style) for each
element in the view. A memoryview can be created from exporters with
arbitrary format strings, but some methods (e.g. ) are
restricted to native single element formats.

Changed in version 3.3: format  is now handled according to the struct module syntax.
This means that .




¶
The size in bytes of each element of the memoryview:





¶
An integer indicating how many dimensions of a multi-dimensional array the
memory represents.



¶
A tuple of integers the length of  giving the shape of the
memory as an N-dimensional array.

Changed in version 3.3: An empty tuple instead of  when ndim = 0.




¶
A tuple of integers the length of  giving the size in bytes to
access each element for each dimension of the array.

Changed in version 3.3: An empty tuple instead of  when ndim = 0.




¶
Used internally for PIL-style arrays. The value is informational only.



¶
A bool indicating whether the memory is C-contiguous.

New in version 3.3.




¶
A bool indicating whether the memory is Fortran contiguous.

New in version 3.3.




¶
A bool indicating whether the memory is contiguous.

New in version 3.3.






Set Types — , ¶
A set object is an unordered collection of distinct hashable objects.
Common uses include membership testing, removing duplicates from a sequence, and
computing mathematical operations such as intersection, union, difference, and
symmetric difference.
(For other containers see the built-in , ,
and  classes, and the  module.)
Like other collections, sets support , , and .  Being an unordered collection, sets do not record element position or
order of insertion.  Accordingly, sets do not support indexing, slicing, or
other sequence-like behavior.
There are currently two built-in set types,  and .
The  type is mutable — the contents can be changed using methods
like  and .  Since it is mutable, it has no
hash value and cannot be used as either a dictionary key or as an element of
another set.  The  type is immutable and hashable —
its contents cannot be altered after it is created; it can therefore be used as
a dictionary key or as an element of another set.
Non-empty sets (not frozensets) can be created by placing a comma-separated list
of elements within braces, for example: , in addition to the
 constructor.
The constructors for both classes work the same:


class ([iterable])¶

class ([iterable])¶
Return a new set or frozenset object whose elements are taken from
iterable.  The elements of a set must be hashable.  To
represent sets of sets, the inner sets must be 
objects.  If iterable is not specified, a new empty set is
returned.
Instances of  and  provide the following
operations:



Return the number of elements in set s (cardinality of s).




Test x for membership in s.




Test x for non-membership in s.



(other)¶
Return  if the set has no elements in common with other.  Sets are
disjoint if and only if their intersection is the empty set.



(other)¶


Test whether every element in the set is in other.




Test whether the set is a proper subset of other, that is,
.



(other)¶


Test whether every element in other is in the set.




Test whether the set is a proper superset of other, that is, .



(*others)¶


Return a new set with elements from the set and all others.



(*others)¶


Return a new set with elements common to the set and all others.



(*others)¶


Return a new set with elements in the set that are not in the others.



(other)¶


Return a new set with elements in either the set or other but not both.



()¶
Return a shallow copy of the set.

Note, the non-operator versions of , ,
, and , , and
 methods will accept any iterable as an argument.  In
contrast, their operator based counterparts require their arguments to be
sets.  This precludes error-prone constructions like 
in favor of the more readable .
Both  and  support set to set comparisons. Two
sets are equal if and only if every element of each set is contained in the
other (each is a subset of the other). A set is less than another set if and
only if the first set is a proper subset of the second set (is a subset, but
is not equal). A set is greater than another set if and only if the first set
is a proper superset of the second set (is a superset, but is not equal).
Instances of  are compared to instances of 
based on their members.  For example, 
returns  and so does .
The subset and equality comparisons do not generalize to a total ordering
function.  For example, any two nonempty disjoint sets are not equal and are not
subsets of each other, so all of the following return : ,
, or .
Since sets only define partial ordering (subset relationships), the output of
the  method is undefined for lists of sets.
Set elements, like dictionary keys, must be hashable.
Binary operations that mix  instances with 
return the type of the first operand.  For example:  returns an instance of .
The following table lists operations available for  that do not
apply to immutable instances of :


(*others)¶


Update the set, adding elements from all others.



(*others)¶


Update the set, keeping only elements found in it and all others.



(*others)¶


Update the set, removing elements found in others.



(other)¶


Update the set, keeping only elements found in either set, but not in both.



(elem)¶
Add element elem to the set.



(elem)¶
Remove element elem from the set.  Raises  if elem is
not contained in the set.



(elem)¶
Remove element elem from the set if it is present.



()¶
Remove and return an arbitrary element from the set.  Raises
 if the set is empty.



()¶
Remove all elements from the set.

Note, the non-operator versions of the ,
, , and
 methods will accept any iterable as an
argument.
Note, the elem argument to the , , and
 methods may be a set.  To support searching for an equivalent
frozenset, a temporary one is created from elem.



Mapping Types — ¶
A mapping object maps hashable values to arbitrary objects.
Mappings are mutable objects.  There is currently only one standard mapping
type, the dictionary.  (For other containers see the built-in
, , and  classes, and the
 module.)
A dictionary’s keys are almost arbitrary values.  Values that are not
hashable, that is, values containing lists, dictionaries or other
mutable types (that are compared by value rather than by object identity) may
not be used as keys.  Numeric types used for keys obey the normal rules for
numeric comparison: if two numbers compare equal (such as  and )
then they can be used interchangeably to index the same dictionary entry.  (Note
however, that since computers store floating-point numbers as approximations it
is usually unwise to use them as dictionary keys.)
Dictionaries can be created by placing a comma-separated list of 
pairs within braces, for example:  or , or by the  constructor.


class (**kwarg)¶

class (mapping, **kwarg)

class (iterable, **kwarg)
Return a new dictionary initialized from an optional positional argument
and a possibly empty set of keyword arguments.
If no positional argument is given, an empty dictionary is created.
If a positional argument is given and it is a mapping object, a dictionary
is created with the same key-value pairs as the mapping object.  Otherwise,
the positional argument must be an iterable object.  Each item in
the iterable must itself be an iterable with exactly two objects.  The
first object of each item becomes a key in the new dictionary, and the
second object the corresponding value.  If a key occurs more than once, the
last value for that key becomes the corresponding value in the new
dictionary.
If keyword arguments are given, the keyword arguments and their values are
added to the dictionary created from the positional argument.  If a key
being added is already present, the value from the keyword argument
replaces the value from the positional argument.
To illustrate, the following examples all return a dictionary equal to
:


Providing keyword arguments as in the first example only works for keys that
are valid Python identifiers.  Otherwise, any valid keys can be used.
These are the operations that dictionaries support (and therefore, custom
mapping types should support too):



Return the number of items in the dictionary d.




Return the item of d with key key.  Raises a  if key is
not in the map.
If a subclass of dict defines a method  and key
is not present, the  operation calls that method with the key key
as argument.  The  operation then returns or raises whatever is
returned or raised by the  call.
No other operations or methods invoke . If
 is not defined,  is raised.
 must be a method; it cannot be an instance variable:


The example above shows part of the implementation of
.  A different  method is used
by .




Set  to value.




Remove  from d.  Raises a  if key is not in the
map.




Return  if d has a key key, else .




Equivalent to .




Return an iterator over the keys of the dictionary.  This is a shortcut
for .



()¶
Remove all items from the dictionary.



()¶
Return a shallow copy of the dictionary.



classmethod (iterable[, value])¶
Create a new dictionary with keys from iterable and values set to value.
 is a class method that returns a new dictionary. value
defaults to .



(key[, default])¶
Return the value for key if key is in the dictionary, else default.
If default is not given, it defaults to , so that this method
never raises a .



()¶
Return a new view of the dictionary’s items ( pairs).
See the documentation of view objects.



()¶
Return a new view of the dictionary’s keys.  See the documentation
of view objects.



(key[, default])¶
If key is in the dictionary, remove it and return its value, else return
default.  If default is not given and key is not in the dictionary,
a  is raised.



()¶
Remove and return a  pair from the dictionary.
Pairs are returned in LIFO order.
 is useful to destructively iterate over a dictionary, as
often used in set algorithms.  If the dictionary is empty, calling
 raises a .

Changed in version 3.7: LIFO order is now guaranteed. In prior versions,  would
return an arbitrary key/value pair.




(key[, default])¶
If key is in the dictionary, return its value.  If not, insert key
with a value of default and return default.  default defaults to
.



([other])¶
Update the dictionary with the key/value pairs from other, overwriting
existing keys.  Return .
 accepts either another dictionary object or an iterable of
key/value pairs (as tuples or other iterables of length two).  If keyword
arguments are specified, the dictionary is then updated with those
key/value pairs: .



()¶
Return a new view of the dictionary’s values.  See the
documentation of view objects.

Dictionaries compare equal if and only if they have the same  pairs. Order comparisons (‘<’, ‘<=’, ‘>=’, ‘>’) raise
.
Dictionaries preserve insertion order.  Note that updating a key does not
affect the order.  Keys added after deletion are inserted at the end.



Changed in version 3.7: Dictionary order is guaranteed to be insertion order.  This behavior was
an implementation detail of CPython from 3.6.



See also
 can be used to create a read-only view
of a .


Dictionary view objects¶
The objects returned by ,  and
 are view objects.  They provide a dynamic view on the
dictionary’s entries, which means that when the dictionary changes, the view
reflects these changes.
Dictionary views can be iterated over to yield their respective data, and
support membership tests:



Return the number of entries in the dictionary.




Return an iterator over the keys, values or items (represented as tuples of
) in the dictionary.
Keys and values are iterated over in insertion order.
This allows the creation of  pairs
using : .  Another way to
create the same list is .
Iterating views while adding or deleting entries in the dictionary may raise
a  or fail to iterate over all entries.

Changed in version 3.7: Dictionary order is guaranteed to be insertion order.





Return  if x is in the underlying dictionary’s keys, values or
items (in the latter case, x should be a  tuple).

Keys views are set-like since their entries are unique and hashable.  If all
values are hashable, so that  pairs are unique and hashable,
then the items view is also set-like.  (Values views are not treated as set-like
since the entries are generally not unique.)  For set-like views, all of the
operations defined for the abstract base class  are
available (for example, , , or ).
An example of dictionary view usage:





Context Manager Types¶
Python’s  statement supports the concept of a runtime context
defined by a context manager.  This is implemented using a pair of methods
that allow user-defined classes to define a runtime context that is entered
before the statement body is executed and exited when the statement ends:


()¶
Enter the runtime context and return either this object or another object
related to the runtime context. The value returned by this method is bound to
the identifier in the  clause of  statements using
this context manager.
An example of a context manager that returns itself is a file object.
File objects return themselves from __enter__() to allow  to be
used as the context expression in a  statement.
An example of a context manager that returns a related object is the one
returned by . These managers set the active
decimal context to a copy of the original decimal context and then return the
copy. This allows changes to be made to the current decimal context in the body
of the  statement without affecting code outside the
 statement.



(exc_type, exc_val, exc_tb)¶
Exit the runtime context and return a Boolean flag indicating if any exception
that occurred should be suppressed. If an exception occurred while executing the
body of the  statement, the arguments contain the exception type,
value and traceback information. Otherwise, all three arguments are .
Returning a true value from this method will cause the  statement
to suppress the exception and continue execution with the statement immediately
following the  statement. Otherwise the exception continues
propagating after this method has finished executing. Exceptions that occur
during execution of this method will replace any exception that occurred in the
body of the  statement.
The exception passed in should never be reraised explicitly - instead, this
method should return a false value to indicate that the method completed
successfully and does not want to suppress the raised exception. This allows
context management code to easily detect whether or not an 
method has actually failed.

Python defines several context managers to support easy thread synchronisation,
prompt closure of files or other objects, and simpler manipulation of the active
decimal arithmetic context. The specific types are not treated specially beyond
their implementation of the context management protocol. See the
 module for some examples.
Python’s generators and the  decorator
provide a convenient way to implement these protocols.  If a generator function is
decorated with the  decorator, it will return a
context manager implementing the necessary  and
 methods, rather than the iterator produced by an undecorated
generator function.
Note that there is no specific slot for any of these methods in the type
structure for Python objects in the Python/C API. Extension types wanting to
define these methods must provide them as a normal Python accessible method.
Compared to the overhead of setting up the runtime context, the overhead of a
single class dictionary lookup is negligible.


Other Built-in Types¶
The interpreter supports several other kinds of objects. Most of these support
only one or two operations.

Modules¶
The only special operation on a module is attribute access: , where
m is a module and name accesses a name defined in m’s symbol table.
Module attributes can be assigned to.  (Note that the 
statement is not, strictly speaking, an operation on a module object;  does not require a module object named foo to exist, rather it requires
an (external) definition for a module named foo somewhere.)
A special attribute of every module is . This is the
dictionary containing the module’s symbol table. Modifying this dictionary will
actually change the module’s symbol table, but direct assignment to the
 attribute is not possible (you can write
, which defines  to be , but you can’t write
).  Modifying  directly is
not recommended.
Modules built into the interpreter are written like this: .  If loaded from a file, they are written as .


Classes and Class Instances¶
See Objects, values and types and Class definitions for these.


Functions¶
Function objects are created by function definitions.  The only operation on a
function object is to call it: .
There are really two flavors of function objects: built-in functions and
user-defined functions.  Both support the same operation (to call the function),
but the implementation is different, hence the different object types.
See Function definitions for more information.


Methods¶
Methods are functions that are called using the attribute notation. There are
two flavors: built-in methods (such as  on lists) and class
instance methods.  Built-in methods are described with the types that support
them.
If you access a method (a function defined in a class namespace) through an
instance, you get a special object: a bound method (also called
instance method) object. When called, it will add the  argument
to the argument list.  Bound methods have two special read-only attributes:
 is the object on which the method operates, and  is
the function implementing the method.  Calling 
is completely equivalent to calling .
Like function objects, bound method objects support getting arbitrary
attributes.  However, since method attributes are actually stored on the
underlying function object (), setting method attributes on
bound methods is disallowed.  Attempting to set an attribute on a method
results in an  being raised.  In order to set a method
attribute, you need to explicitly set it on the underlying function object:


See The standard type hierarchy for more information.


Code Objects¶
Code objects are used by the implementation to represent “pseudo-compiled”
executable Python code such as a function body. They differ from function
objects because they don’t contain a reference to their global execution
environment.  Code objects are returned by the built-in  function
and can be extracted from function objects through their 
attribute. See also the  module.
A code object can be executed or evaluated by passing it (instead of a source
string) to the  or   built-in functions.
See The standard type hierarchy for more information.


Type Objects¶
Type objects represent the various object types.  An object’s type is accessed
by the built-in function .  There are no special operations on
types.  The standard module  defines names for all standard built-in
types.
Types are written like this: .


The Null Object¶
This object is returned by functions that don’t explicitly return a value.  It
supports no special operations.  There is exactly one null object, named
 (a built-in name).   produces the same singleton.
It is written as .


The Ellipsis Object¶
This object is commonly used by slicing (see Slicings).  It supports no
special operations.  There is exactly one ellipsis object, named
 (a built-in name).   produces the
 singleton.
It is written as  or .


The NotImplemented Object¶
This object is returned from comparisons and binary operations when they are
asked to operate on types they don’t support. See Comparisons for more
information.  There is exactly one  object.
 produces the singleton instance.
It is written as .


Boolean Values¶
Boolean values are the two constant objects  and .  They are
used to represent truth values (although other values can also be considered
false or true).  In numeric contexts (for example when used as the argument to
an arithmetic operator), they behave like the integers 0 and 1, respectively.
The built-in function  can be used to convert any value to a
Boolean, if the value can be interpreted as a truth value (see section
Truth Value Testing above).
They are written as  and , respectively.


Internal Objects¶
See The standard type hierarchy for this information.  It describes stack frame objects,
traceback objects, and slice objects.



Special Attributes¶
The implementation adds a few special read-only attributes to several object
types, where they are relevant.  Some of these are not reported by the
 built-in function.


¶
A dictionary or other mapping object used to store an object’s (writable)
attributes.



¶
The class to which a class instance belongs.



¶
The tuple of base classes of a class object.



¶
The name of the class, function, method, descriptor, or
generator instance.



¶
The qualified name of the class, function, method, descriptor,
or generator instance.

New in version 3.3.




¶
This attribute is a tuple of classes that are considered when looking for
base classes during method resolution.



()¶
This method can be overridden by a metaclass to customize the method
resolution order for its instances.  It is called at class instantiation, and
its result is stored in .



()¶
Each class keeps a list of weak references to its immediate subclasses.  This
method returns a list of all those references still alive.
Example:



Footnotes



[1]Additional information on these special methods may be found in the Python
Reference Manual (Basic customization).





[2]As a consequence, the list  is considered equal to , and
similarly for tuples.





[3]They must have since the parser can’t tell the type of the operands.





[4](1, 2, 3, 4) Cased characters are those with general category property being one of
“Lu” (Letter, uppercase), “Ll” (Letter, lowercase), or “Lt” (Letter, titlecase).





[5](1, 2) To format only a tuple you should therefore provide a singleton tuple whose only
element is the tuple to be formatted.




