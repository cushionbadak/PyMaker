link:
library/decimal.html#floating-point-notes

docs:

Floating Point Notes¶

Mitigating round-off error with increased precision¶
The use of decimal floating point eliminates decimal representation error
(making it possible to represent  exactly); however, some operations
can still incur round-off error when non-zero digits exceed the fixed precision.
The effects of round-off error can be amplified by the addition or subtraction
of nearly offsetting quantities resulting in loss of significance.  Knuth
provides two instructive examples where rounded floating point arithmetic with
insufficient precision causes the breakdown of the associative and distributive
properties of addition:


The  module makes it possible to restore the identities by
expanding the precision sufficiently to avoid loss of significance:




Special values¶
The number system for the  module provides special values
including , , , ,
and two zeros,  and .
Infinities can be constructed directly with:  . Also,
they can arise from dividing by zero when the  signal is
not trapped.  Likewise, when the  signal is not trapped, infinity
can result from rounding beyond the limits of the largest representable number.
The infinities are signed (affine) and can be used in arithmetic operations
where they get treated as very large, indeterminate numbers.  For instance,
adding a constant to infinity gives another infinite result.
Some operations are indeterminate and return , or if the
 signal is trapped, raise an exception.  For example,
 returns  which means “not a number”.  This variety of
 is quiet and, once created, will flow through other computations
always resulting in another .  This behavior can be useful for a
series of computations that occasionally have missing inputs — it allows the
calculation to proceed while flagging specific results as invalid.
A variant is  which signals rather than remaining quiet after every
operation.  This is a useful return value when an invalid result needs to
interrupt a calculation for special handling.
The behavior of Python’s comparison operators can be a little surprising where a
 is involved.  A test for equality where one of the operands is a
quiet or signaling  always returns  (even when doing
), while a test for inequality always returns
.  An attempt to compare two Decimals using any of the ,
,  or  operators will raise the  signal
if either operand is a , and return  if this signal is
not trapped.  Note that the General Decimal Arithmetic specification does not
specify the behavior of direct comparisons; these rules for comparisons
involving a  were taken from the IEEE 854 standard (see Table 3 in
section 5.7).  To ensure strict standards-compliance, use the 
and  methods instead.
The signed zeros can result from calculations that underflow. They keep the sign
that would have resulted if the calculation had been carried out to greater
precision.  Since their magnitude is zero, both positive and negative zeros are
treated as equal and their sign is informational.
In addition to the two signed zeros which are distinct yet equal, there are
various representations of zero with differing precisions yet equivalent in
value.  This takes a bit of getting used to.  For an eye accustomed to
normalized floating point representations, it is not immediately obvious that
the following calculation returns a value equal to zero:



