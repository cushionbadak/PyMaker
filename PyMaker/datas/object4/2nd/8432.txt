link:
library/unittest.html#organizing-test-code

docs:

Organizing test code¶
The basic building blocks of unit testing are test cases — single
scenarios that must be set up and checked for correctness.  In ,
test cases are represented by  instances.
To make your own test cases you must write subclasses of
 or use .
The testing code of a  instance should be entirely self
contained, such that it can be run either in isolation or in arbitrary
combination with any number of other test cases.
The simplest  subclass will simply implement a test method
(i.e. a method whose name starts with ) in order to perform specific
testing code:


Note that in order to test something, we use one of the 
methods provided by the  base class.  If the test fails, an
exception will be raised with an explanatory message, and 
will identify the test case as a failure.  Any other exceptions will be
treated as errors.
Tests can be numerous, and their set-up can be repetitive.  Luckily, we
can factor out set-up code by implementing a method called
, which the testing framework will automatically
call for every single test we run:



Note
The order in which the various tests will be run is determined
by sorting the test method names with respect to the built-in
ordering for strings.

If the  method raises an exception while the test is
running, the framework will consider the test to have suffered an error, and
the test method will not be executed.
Similarly, we can provide a  method that tidies up
after the test method has been run:


If  succeeded,  will be
run whether the test method succeeded or not.
Such a working environment for the testing code is called a
test fixture.  A new TestCase instance is created as a unique
test fixture used to execute each individual test method.  Thus
, , and 
will be called once per test.
It is recommended that you use TestCase implementations to group tests together
according to the features they test.   provides a mechanism for
this: the test suite, represented by ’s
 class.  In most cases, calling  will do
the right thing and collect all the module’s test cases for you and execute
them.
However, should you want to customize the building of your test suite,
you can do it yourself:


You can place the definitions of test cases and test suites in the same modules
as the code they are to test (such as ), but there are several
advantages to placing the test code in a separate module, such as
:

The test module can be run standalone from the command line.
The test code can more easily be separated from shipped code.
There is less temptation to change test code to fit the code it tests without
a good reason.
Test code should be modified much less frequently than the code it tests.
Tested code can be refactored more easily.
Tests for modules written in C must be in separate modules anyway, so why not
be consistent?
If the testing strategy changes, there is no need to change the source code.

