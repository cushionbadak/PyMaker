link:
library/logging.config.html#configuration-file-format

docs:

Configuration file format¶
The configuration file format understood by  is based on
 functionality. The file must contain sections called
,  and  which identify by name the
entities of each type which are defined in the file. For each such entity, there
is a separate section which identifies how that entity is configured.  Thus, for
a logger named  in the  section, the relevant
configuration details are held in a section . Similarly, a
handler called  in the  section will have its
configuration held in a section called , while a formatter
called  in the  section will have its configuration
specified in a section called . The root logger
configuration must be specified in a section called .

Note
The  API is older than the  API and does
not provide functionality to cover certain aspects of logging. For example,
you cannot configure  objects, which provide for
filtering of messages beyond simple integer levels, using .
If you need to have instances of  in your logging
configuration, you will need to use . Note that future
enhancements to configuration functionality will be added to
, so it’s worth considering transitioning to this newer
API when it’s convenient to do so.

Examples of these sections in the file are given below.


The root logger must specify a level and a list of handlers. An example of a
root logger section is given below.


The  entry can be one of  or
. For the root logger only,  means that all messages will be
logged. Level values are uated in the context of the 
package’s namespace.
The  entry is a comma-separated list of handler names, which must
appear in the  section. These names must appear in the
 section and have corresponding sections in the configuration
file.
For loggers other than the root logger, some additional information is required.
This is illustrated by the following example.


The  and  entries are interpreted as for the root logger,
except that if a non-root logger’s level is specified as , the system
consults loggers higher up the hierarchy to determine the effective level of the
logger. The  entry is set to 1 to indicate that messages must
propagate to handlers higher up the logger hierarchy from this logger, or 0 to
indicate that messages are not propagated to handlers up the hierarchy. The
 entry is the hierarchical channel name of the logger, that is to
say the name used by the application to get the logger.
Sections which specify handler configuration are exemplified by the following.


The  entry indicates the handler’s class (as determined by 
in the  package’s namespace). The  is interpreted as for
loggers, and  is taken to mean ‘log everything’.
The  entry indicates the key name of the formatter for this
handler. If blank, a default formatter () is used.
If a name is specified, it must appear in the  section and have
a corresponding section in the configuration file.
The  entry, when uated in the context of the 
package’s namespace, is the list of arguments to the constructor for the handler
class. Refer to the constructors for the relevant handlers, or to the examples
below, to see how typical entries are constructed. If not provided, it defaults
to .
The optional  entry, when uated in the context of the
 package’s namespace, is the keyword argument dict to the constructor
for the handler class. If not provided, it defaults to .


Sections which specify formatter configuration are typified by the following.


The  entry is the overall format string, and the  entry is
the -compatible date/time format string.  If empty, the
package substitutes something which is almost equivalent to specifying the date
format string .  This format also specifies milliseconds,
which are appended to the result of using the above format string, with a comma
separator.  An example time in this format is .
The  entry is optional.  It indicates the name of the formatter’s class
(as a dotted module and class name.)  This option is useful for instantiating a
 subclass.  Subclasses of
 can present exception tracebacks in an expanded or
condensed format.

Note
Due to the use of  as described above, there are
potential security risks which result from using the  to send
and receive configurations via sockets. The risks are limited to where
multiple users with no mutual trust run code on the same machine; see the
 documentation for more information.


See also

Module 
API reference for the logging module.
Module 
Useful handlers included with the logging module.


