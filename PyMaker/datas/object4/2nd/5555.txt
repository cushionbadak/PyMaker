link:
library/email.generator.html

docs:


: Generating MIME documents¶
Source code: Lib/email/generator.py

One of the most common tasks is to generate the flat (serialized) version of
the email message represented by a message object structure.  You will need to
do this if you want to send your message via  or
the  module, or print the message on the console.  Taking a
message object structure and producing a serialized representation is the job
of the generator classes.
As with the  module, you aren’t limited to the functionality
of the bundled generator; you could write one from scratch yourself.  However
the bundled generator knows how to generate most email in a standards-compliant
way, should handle MIME and non-MIME email messages just fine, and is designed
so that the bytes-oriented parsing and generation operations are inverses,
assuming the same non-transforming  is used for both.  That
is, parsing the serialized byte stream via the
 class and then regenerating the serialized
byte stream using  should produce output identical to
the input [1].  (On the other hand, using the generator on an
 constructed by program may result in
changes to the  object as defaults are
filled in.)
The  class can be used to flatten a message into a text (as
opposed to binary) serialized representation, but since Unicode cannot
represent binary data directly, the message is of necessity transformed into
something that contains only ASCII characters, using the standard email RFC
Content Transfer Encoding techniques for encoding email messages for transport
over channels that are not “8 bit clean”.


class (outfp, mangle_from_=None, maxheaderlen=None, *, policy=None)¶
Return a  object that will write any message provided
to the  method, or any surrogateescape encoded text provided
to the  method, to the file-like object outfp.
outfp must support a  method that accepts binary data.
If optional mangle_from_ is , put a  character in front of
any line in the body that starts with the exact string , that is
 followed by a space at the beginning of a line.  mangle_from_
defaults to the value of the 
setting of the policy (which is  for the
 policy and  for all others).
mangle_from_ is intended for use when messages are stored in unix mbox
format (see  and WHY THE CONTENT-LENGTH FORMAT IS BAD).
If maxheaderlen is not , refold any header lines that are longer
than maxheaderlen, or if , do not rewrap any headers.  If
manheaderlen is  (the default), wrap headers and other message
lines according to the policy settings.
If policy is specified, use that policy to control message generation.  If
policy is  (the default), use the policy associated with the
 or 
object passed to  to control the message generation.  See
 for details on what policy controls.

New in version 3.2.


Changed in version 3.3: Added the policy keyword.


Changed in version 3.6: The default behavior of the mangle_from_
and maxheaderlen parameters is to follow the policy.



(msg, unixfrom=False, linesep=None)¶
Print the textual representation of the message object structure rooted
at msg to the output file specified when the 
instance was created.
If the  option 
is  (the default), copy any headers in the original parsed
message that have not been modified to the output with any bytes with the
high bit set reproduced as in the original, and preserve the non-ASCII
Content-Transfer-Encoding of any body parts that have them.
If  is , convert the bytes with the high bit set as
needed using an ASCII-compatible Content-Transfer-Encoding.
That is, transform parts with non-ASCII
Content-Transfer-Encoding
(Content-Transfer-Encoding: 8bit) to an ASCII compatible
Content-Transfer-Encoding, and encode RFC-invalid non-ASCII
bytes in headers using the MIME  character set, thus
rendering them RFC-compliant.
If unixfrom is , print the envelope header delimiter used by
the Unix mailbox format (see ) before the first of the
RFC 5322 headers of the root message object.  If the root object has
no envelope header, craft a standard one.  The default is .
Note that for subparts, no envelope header is ever printed.
If linesep is not , use it as the separator character between
all the lines of the flattened message.  If linesep is  (the
default), use the value specified in the policy.



(fp)¶
Return an independent clone of this  instance with
the exact same option settings, and fp as the new outfp.



(s)¶
Encode s using the  codec and the  error
handler, and pass it to the write method of the outfp passed to the
’s constructor.


As a convenience,  provides the methods
 and  (a.k.a.
), which simplify the generation of
a serialized binary representation of a message object.  For more detail, see
.
Because strings cannot represent binary data, the  class must
convert any binary data in any message it flattens to an ASCII compatible
format, by converting them to an ASCII compatible
Content-Transfer_Encoding.  Using the terminology of the email
RFCs, you can think of this as  serializing to an I/O stream
that is not “8 bit clean”.  In other words, most applications will want
to be using , and not .


class (outfp, mangle_from_=None, maxheaderlen=None, *, policy=None)¶
Return a  object that will write any message provided
to the  method, or any text provided to the 
method, to the file-like object outfp.  outfp must support a
 method that accepts string data.
If optional mangle_from_ is , put a  character in front of
any line in the body that starts with the exact string , that is
 followed by a space at the beginning of a line.  mangle_from_
defaults to the value of the 
setting of the policy (which is  for the
 policy and  for all others).
mangle_from_ is intended for use when messages are stored in unix mbox
format (see  and WHY THE CONTENT-LENGTH FORMAT IS BAD).
If maxheaderlen is not , refold any header lines that are longer
than maxheaderlen, or if , do not rewrap any headers.  If
manheaderlen is  (the default), wrap headers and other message
lines according to the policy settings.
If policy is specified, use that policy to control message generation.  If
policy is  (the default), use the policy associated with the
 or 
object passed to  to control the message generation.  See
 for details on what policy controls.

Changed in version 3.3: Added the policy keyword.


Changed in version 3.6: The default behavior of the mangle_from_
and maxheaderlen parameters is to follow the policy.



(msg, unixfrom=False, linesep=None)¶
Print the textual representation of the message object structure rooted
at msg to the output file specified when the 
instance was created.
If the  option 
is , generate the message as if the option were set to .
(This is required because strings cannot represent non-ASCII bytes.)
Convert any bytes with the high bit set as needed using an
ASCII-compatible Content-Transfer-Encoding.  That is,
transform parts with non-ASCII Content-Transfer-Encoding
(Content-Transfer-Encoding: 8bit) to an ASCII compatible
Content-Transfer-Encoding, and encode RFC-invalid non-ASCII
bytes in headers using the MIME  character set, thus
rendering them RFC-compliant.
If unixfrom is , print the envelope header delimiter used by
the Unix mailbox format (see ) before the first of the
RFC 5322 headers of the root message object.  If the root object has
no envelope header, craft a standard one.  The default is .
Note that for subparts, no envelope header is ever printed.
If linesep is not , use it as the separator character between
all the lines of the flattened message.  If linesep is  (the
default), use the value specified in the policy.

Changed in version 3.2: Added support for re-encoding  message bodies, and the
linesep argument.




(fp)¶
Return an independent clone of this  instance with the
exact same options, and fp as the new outfp.



(s)¶
Write s to the write method of the outfp passed to the
’s constructor.  This provides just enough file-like
API for  instances to be used in the 
function.


As a convenience,  provides the methods
 and  (a.k.a.
), which simplify the generation of
a formatted string representation of a message object.  For more detail, see
.
The  module also provides a derived class,
, which is like the  base class,
except that non-text parts are not serialized, but are instead
represented in the output stream by a string derived from a template filled
in with information about the part.


class (outfp, mangle_from_=None, maxheaderlen=None, fmt=None, *, policy=None)¶
Act like , except that for any subpart of the message
passed to , if the subpart is of main type
text, print the decoded payload of the subpart, and if the main
type is not text, instead of printing it fill in the string
fmt using information from the part and print the resulting
filled-in string.
To fill in fmt, execute , where 
is a dictionary composed of the following keys and values:

 – Full MIME type of the non-text part
 – Main MIME type of the non-text part
 – Sub-MIME type of the non-text part
 – Filename of the non-text part
 – Description associated with the non-text part
 – Content transfer encoding of the non-text part

If fmt is , use the following default fmt:

“[Non-text (%(type)s) part of message omitted, filename %(filename)s]”
Optional _mangle_from_ and maxheaderlen are as with the
 base class.

Footnotes



[1]This statement assumes that you use the appropriate setting for
, and that there are no  settings calling for
automatic adjustments (for example,
 must be , which is
not the default).  It is also not 100% true, since if the message
does not conform to the RFC standards occasionally information about the
exact original text is lost during parsing error recovery.  It is a goal
to fix these latter edge cases when possible.



