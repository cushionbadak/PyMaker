link:
library/logging.html#logging.Logger

docs:


class ¶


¶
If this attribute evaluates to true, events logged to this logger will be
passed to the handlers of higher level (ancestor) loggers, in addition to
any handlers attached to this logger. Messages are passed directly to the
ancestor loggers’ handlers - neither the level nor filters of the ancestor
loggers in question are considered.
If this evaluates to false, logging messages are not passed to the handlers
of ancestor loggers.
The constructor sets this attribute to .

Note
If you attach a handler to a logger and one or more of its
ancestors, it may emit the same record multiple times. In general, you
should not need to attach a handler to more than one logger - if you just
attach it to the appropriate logger which is highest in the logger
hierarchy, then it will see all events logged by all descendant loggers,
provided that their propagate setting is left set to . A common
scenario is to attach handlers only to the root logger, and to let
propagation take care of the rest.




(level)¶
Sets the threshold for this logger to level. Logging messages which are less
severe than level will be ignored; logging messages which have severity level
or higher will be emitted by whichever handler or handlers service this logger,
unless a handler’s level has been set to a higher severity level than level.
When a logger is created, the level is set to  (which causes
all messages to be processed when the logger is the root logger, or delegation
to the parent when the logger is a non-root logger). Note that the root logger
is created with level .
The term ‘delegation to the parent’ means that if a logger has a level of
NOTSET, its chain of ancestor loggers is traversed until either an ancestor with
a level other than NOTSET is found, or the root is reached.
If an ancestor is found with a level other than NOTSET, then that ancestor’s
level is treated as the effective level of the logger where the ancestor search
began, and is used to determine how a logging event is handled.
If the root is reached, and it has a level of NOTSET, then all messages will be
processed. Otherwise, the root’s level will be used as the effective level.
See Logging Levels for a list of levels.

Changed in version 3.2: The level parameter now accepts a string representation of the
level such as ‘INFO’ as an alternative to the integer constants
such as . Note, however, that levels are internally stored
as integers, and methods such as e.g.  and
 will return/expect to be passed integers.




(lvl)¶
Indicates if a message of severity lvl would be processed by this logger.
This method checks first the module-level level set by
 and then the logger’s effective level as determined
by .



()¶
Indicates the effective level for this logger. If a value other than
 has been set using , it is returned. Otherwise,
the hierarchy is traversed towards the root until a value other than
 is found, and that value is returned. The value returned is
an integer, typically one of , 
etc.



(suffix)¶
Returns a logger which is a descendant to this logger, as determined by the suffix.
Thus,  would return the same
logger as would be returned by . This is a
convenience method, useful when the parent logger is named using e.g. 
rather than a literal string.

New in version 3.2.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The msg is the
message format string, and the args are the arguments which are merged into
msg using the string formatting operator. (Note that this means that you can
use keywords in the format string, together with a single dictionary argument.)
There are three keyword arguments in kwargs which are inspected:
exc_info, stack_info, and extra.
If exc_info does not evaluate as false, it causes exception information to be
added to the logging message. If an exception tuple (in the format returned by
) or an exception instance is provided, it is used;
otherwise,  is called to get the exception information.
The second optional keyword argument is stack_info, which defaults to
. If true, stack information is added to the logging
message, including the actual logging call. Note that this is not the same
stack information as that displayed through specifying exc_info: The
former is stack frames from the bottom of the stack up to the logging call
in the current thread, whereas the latter is information about stack frames
which have been unwound, following an exception, while searching for
exception handlers.
You can specify stack_info independently of exc_info, e.g. to just show
how you got to a certain point in your code, even when no exceptions were
raised. The stack frames are printed following a header line which says:


This mimics the  which is used when
displaying exception frames.
The third keyword argument is extra which can be used to pass a
dictionary which is used to populate the __dict__ of the LogRecord created for
the logging event with user-defined attributes. These custom attributes can then
be used as you like. For example, they could be incorporated into logged
messages. For example:


would print something like


The keys in the dictionary passed in extra should not clash with the keys used
by the logging system. (See the  documentation for more
information on which keys are used by the logging system.)
If you choose to use these attributes in logged messages, you need to exercise
some care. In the above example, for instance, the  has been
set up with a format string which expects ‘clientip’ and ‘user’ in the attribute
dictionary of the LogRecord. If these are missing, the message will not be
logged because a string formatting exception will occur. So in this case, you
always need to pass the extra dictionary with these keys.
While this might be annoying, this feature is intended for use in specialized
circumstances, such as multi-threaded servers where the same code executes in
many contexts, and interesting conditions which arise are dependent on this
context (such as remote client IP address and authenticated user name, in the
above example). In such circumstances, it is likely that specialized
s would be used with particular s.

New in version 3.2: The stack_info parameter was added.


Changed in version 3.5: The exc_info parameter can now accept exception instances.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .

Note
There is an obsolete method  which is functionally
identical to . As  is deprecated, please do not use
it - use  instead.




(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for .



(lvl, msg, *args, **kwargs)¶
Logs a message with integer level lvl on this logger. The other arguments are
interpreted as for .



(msg, *args, **kwargs)¶
Logs a message with level  on this logger. The arguments are
interpreted as for . Exception info is added to the logging
message. This method should only be called from an exception handler.



(filter)¶
Adds the specified filter filter to this logger.



(filter)¶
Removes the specified filter filter from this logger.



(record)¶
Applies this logger’s filters to the record and returns a true value if the
record is to be processed. The filters are consulted in turn, until one of
them returns a false value. If none of them return a false value, the record
will be processed (passed to handlers). If one returns a false value, no
further processing of the record occurs.



(hdlr)¶
Adds the specified handler hdlr to this logger.



(hdlr)¶
Removes the specified handler hdlr from this logger.



(stack_info=False)¶
Finds the caller’s source filename and line number. Returns the filename, line
number, function name and stack information as a 4-element tuple. The stack
information is returned as  unless stack_info is .



(record)¶
Handles a record by passing it to all handlers associated with this logger and
its ancestors (until a false value of propagate is found). This method is used
for unpickled records received from a socket, as well as those created locally.
Logger-level filtering is applied using .



(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)¶
This is a factory method which can be overridden in subclasses to create
specialized  instances.



()¶
Checks to see if this logger has any handlers configured. This is done by
looking for handlers in this logger and its parents in the logger hierarchy.
Returns  if a handler was found, else . The method stops searching
up the hierarchy whenever a logger with the ‘propagate’ attribute set to
false is found - that will be the last logger which is checked for the
existence of handlers.

New in version 3.2.



Changed in version 3.7: Loggers can now be pickled and unpickled.

