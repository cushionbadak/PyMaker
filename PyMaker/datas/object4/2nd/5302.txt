link:
library/ssl.html#security-considerations

docs:

Security considerations¶

Best defaults¶
For client use, if you don’t have any special requirements for your
security policy, it is highly recommended that you use the
 function to create your SSL context.
It will load the system’s trusted CA certificates, enable certificate
validation and hostname checking, and try to choose reasonably secure
protocol and cipher settings.
For example, here is how you would use the  class to
create a trusted, secure connection to a SMTP server:


If a client certificate is needed for the connection, it can be added with
.
By contrast, if you create the SSL context by calling the 
constructor yourself, it will not have certificate validation nor hostname
checking enabled by default.  If you do so, please read the paragraphs below
to achieve a good security level.


Manual settings¶

Verifying certificates¶
When calling the  constructor directly,
 is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you’re talking to.
Therefore, when in client mode, it is highly recommended to use
.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
, matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the  function can be used.  This common
check is automatically performed when  is
enabled.

Changed in version 3.7: Hostname matchings is now performed by OpenSSL. Python no longer uses
.

In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you’ll also have
to specify  and similarly check the client certificate.


Protocol versions¶
SSL versions 2 and 3 are considered insecure and are therefore dangerous to
use.  If you want maximum compatibility between clients and servers, it is
recommended to use  or
 as the protocol version. SSLv2 and SSLv3 are
disabled by default.


The SSL context created above will only allow TLSv1.2 and later (if
supported by your system) connections to a server. 
implies certificate validation and hostname checks by default. You have to
load certificates into the context.


Cipher selection¶
If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
 method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL’s documentation
about the cipher list format.
If you want to check which ciphers are enabled by a given cipher list, use
 or the  command on your
system.



Multi-processing¶
If using this module as part of a multi-processed application (using,
for example the  or  modules),
be aware that OpenSSL’s internal random number generator does not properly
handle forked processes.  Applications must change the PRNG state of the
parent process if they use any SSL feature with .  Any
successful call of ,  or
 is sufficient.

