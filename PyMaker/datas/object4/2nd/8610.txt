link:
library/unittest.mock.html#magic-mock

docs:

Magic Mock¶
There are two  variants:  and .


class (*args, **kw)¶
 is a subclass of  with default implementations
of most of the magic methods. You can use  without having to
configure the magic methods yourself.
The constructor parameters have the same meaning as for .
If you use the spec or spec_set arguments then only magic methods
that exist in the spec will be created.



class (*args, **kw)¶
A non-callable version of .
The constructor parameters have the same meaning as for
, with the exception of return_value and
side_effect which have no meaning on a non-callable mock.

The magic methods are setup with  objects, so you can configure them
and use them in the usual way:


By default many of the protocol methods are required to return objects of a
specific type. These methods are preconfigured with a default return value, so
that they can be used without you having to do anything if you aren’t interested
in the return value. You can still set the return value manually if you want
to change the default.
Methods and their defaults:

: NotImplemented
: NotImplemented
: NotImplemented
: NotImplemented
: 1
: False
: 0
: iter([])
: False
: 1j
: 1.0
: True
: 1
: default hash for the mock
: default str for the mock
: default sizeof for the mock

For example:


The two equality methods,  and , are special.
They do the default equality comparison on identity, using the
 attribute, unless you change their return value to
return something else:


The return value of  can be any iterable object and isn’t
required to be an iterator:


If the return value is an iterator, then iterating over it once will consume
it and subsequent iterations will result in an empty list:


 has all of the supported magic methods configured except for some
of the obscure and obsolete ones. You can still set these up if you want.
Magic methods that are supported but not setup by default in  are:




,  and 
 and 
, , , ,
 and 
 and 




[2]Magic methods should be looked up on the class rather than the
instance. Different versions of Python are inconsistent about applying this
rule. The supported protocol methods should work with all supported versions
of Python.





[3]The function is basically hooked up to the class, but each 
instance is kept isolated from the others.


