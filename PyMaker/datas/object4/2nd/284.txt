link:
reference/compound_stmts.html#coroutines

docs:

8.8. Coroutines¶

New in version 3.5.


8.8.1. Coroutine function definition¶

Execution of Python coroutines can be suspended and resumed at many points
(see coroutine).  Inside the body of a coroutine function,  and
 identifiers become reserved keywords;  expressions,
 and  can only be used in
coroutine function bodies.
Functions defined with  syntax are always coroutine functions,
even if they do not contain  or  keywords.
It is a  to use a  expression inside the body
of a coroutine function.
An example of a coroutine function:




8.8.2. The  statement¶

An asynchronous iterable is able to call asynchronous code in its
iter implementation, and asynchronous iterator can call asynchronous
code in its next method.
The  statement allows convenient iteration over asynchronous
iterators.
The following code:


Is semantically equivalent to:


See also  and  for details.
It is a  to use an  statement outside the
body of a coroutine function.


8.8.3. The  statement¶

An asynchronous context manager is a context manager that is
able to suspend execution in its enter and exit methods.
The following code:


Is semantically equivalent to:


See also  and  for details.
It is a  to use an  statement outside the
body of a coroutine function.

See also

PEP 492 - Coroutines with async and await syntax
The proposal that made coroutines a proper standalone concept in Python,
and added supporting syntax.


Footnotes



[1]The exception is propagated to the invocation stack unless
there is a  clause which happens to raise another
exception. That new exception causes the old one to be lost.





[2]A string literal appearing as the first statement in the function body is
transformed into the function’s  attribute and therefore the
function’s docstring.





[3]A string literal appearing as the first statement in the class body is
transformed into the namespace’s  item and therefore the class’s
docstring.



