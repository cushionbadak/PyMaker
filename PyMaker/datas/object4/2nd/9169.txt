link:
library/zipapp.html#creating-standalone-applications-with-zipapp

docs:

Creating Standalone Applications with zipapp¶
Using the  module, it is possible to create self-contained Python
programs, which can be distributed to end users who only need to have a
suitable version of Python installed on their system.  The key to doing this
is to bundle all of the application’s dependencies into the archive, along
with the application code.
The steps to create a standalone archive are as follows:

Create your application in a directory as normal, so you have a 
directory containing a  file, and any supporting application
code.

Install all of your application’s dependencies into the  directory,
using pip:


(this assumes you have your project requirements in a 
file - if not, you can just list the dependencies manually on the pip command
line).

Optionally, delete the  directories created by pip in the
 directory. These hold metadata for pip to manage the packages, and
as you won’t be making any further use of pip they aren’t required -
although it won’t do any harm if you leave them.

Package the application using:




This will produce a standalone executable, which can be run on any machine with
the appropriate interpreter available. See Specifying the Interpreter
for details. It can be shipped to users as a single file.
On Unix, the  file is executable as it stands.  You can rename the
file to remove the  extension if you prefer a “plain” command name.  On
Windows, the  file is executable by virtue of the fact that
the Python interpreter registers the  and  file extensions
when installed.

Making a Windows executable¶
On Windows, registration of the  extension is optional, and
furthermore, there are certain places that don’t recognise registered
extensions “transparently” (the simplest example is that
 won’t find your application - you need to
explicitly specify the extension).
On Windows, therefore, it is often preferable to create an executable from the
zipapp.  This is relatively easy, although it does require a C compiler.  The
basic approach relies on the fact that zipfiles can have arbitrary data
prepended, and Windows exe files can have arbitrary data appended.  So by
creating a suitable launcher and tacking the  file onto the end of it,
you end up with a single-file executable that runs your application.
A suitable launcher can be as simple as the following:


If you define the  preprocessor symbol, this will generate a
GUI executable, and without it, a console executable.
To compile the executable, you can either just use the standard MSVC
command line tools, or you can take advantage of the fact that distutils
knows how to compile Python source:


The resulting launcher uses the “Limited ABI”, so it will run unchanged with
any version of Python 3.x.  All it needs is for Python () to be
on the user’s .
For a fully standalone distribution, you can distribute the launcher with your
application appended, bundled with the Python “embedded” distribution.  This
will run on any PC with the appropriate architecture (32 bit or 64 bit).


Caveats¶
There are some limitations to the process of bundling your application into
a single file.  In most, if not all, cases they can be addressed without
needing major changes to your application.

If your application depends on a package that includes a C extension, that
package cannot be run from a zip file (this is an OS limitation, as executable
code must be present in the filesystem for the OS loader to load it). In this
case, you can exclude that dependency from the zipfile, and either require
your users to have it installed, or ship it alongside your zipfile and add code
to your  to include the directory containing the unzipped
module in . In this case, you will need to make sure to ship
appropriate binaries for your target architecture(s) (and potentially pick the
correct version to add to  at runtime, based on the user’s machine).
If you are shipping a Windows executable as described above, you either need to
ensure that your users have  on their PATH (which is not the
default behaviour of the installer) or you should bundle your application with
the embedded distribution.
The suggested launcher above uses the Python embedding API.  This means that in
your application,  will be your application, and not a
conventional Python interpreter.  Your code and its dependencies need to be
prepared for this possibility.  For example, if your application uses the
 module, it will need to call
 to let the module know where to find the
standard Python interpreter.


